function _mergeNamespaces(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const a in s)if(a!=="default"&&!(a in n)){const c=Object.getOwnPropertyDescriptor(s,a);c&&Object.defineProperty(n,a,c.get?c:{enumerable:!0,get:()=>s[a]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const c of a)if(c.type==="childList")for(const l of c.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&s(l)}).observe(document,{childList:!0,subtree:!0});function t(a){const c={};return a.integrity&&(c.integrity=a.integrity),a.referrerPolicy&&(c.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?c.credentials="include":a.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function s(a){if(a.ep)return;a.ep=!0;const c=t(a);fetch(a.href,c)}})();function getDefaultExportFromCjs(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function getAugmentedNamespace(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var a=!1;try{a=this instanceof s}catch{}return a?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var a=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,a.get?a:{enumerable:!0,get:function(){return n[s]}})}),t}var jsxRuntime={exports:{}},reactJsxRuntime_production={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactJsxRuntime_production;function requireReactJsxRuntime_production(){if(hasRequiredReactJsxRuntime_production)return reactJsxRuntime_production;hasRequiredReactJsxRuntime_production=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,a,c){var l=null;if(c!==void 0&&(l=""+c),a.key!==void 0&&(l=""+a.key),"key"in a){c={};for(var _ in a)_!=="key"&&(c[_]=a[_])}else c=a;return a=c.ref,{$$typeof:n,type:s,key:l,ref:a!==void 0?a:null,props:c}}return reactJsxRuntime_production.Fragment=e,reactJsxRuntime_production.jsx=t,reactJsxRuntime_production.jsxs=t,reactJsxRuntime_production}var hasRequiredJsxRuntime;function requireJsxRuntime(){return hasRequiredJsxRuntime||(hasRequiredJsxRuntime=1,jsxRuntime.exports=requireReactJsxRuntime_production()),jsxRuntime.exports}var jsxRuntimeExports=requireJsxRuntime(),react={exports:{}},react_production={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReact_production;function requireReact_production(){if(hasRequiredReact_production)return react_production;hasRequiredReact_production=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),a=Symbol.for("react.profiler"),c=Symbol.for("react.consumer"),l=Symbol.for("react.context"),_=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),i=Symbol.iterator;function r(oe){return oe===null||typeof oe!="object"?null:(oe=i&&oe[i]||oe["@@iterator"],typeof oe=="function"?oe:null)}var u={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},f=Object.assign,g={};function w(oe,K,Q){this.props=oe,this.context=K,this.refs=g,this.updater=Q||u}w.prototype.isReactComponent={},w.prototype.setState=function(oe,K){if(typeof oe!="object"&&typeof oe!="function"&&oe!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,oe,K,"setState")},w.prototype.forceUpdate=function(oe){this.updater.enqueueForceUpdate(this,oe,"forceUpdate")};function y(){}y.prototype=w.prototype;function x(oe,K,Q){this.props=oe,this.context=K,this.refs=g,this.updater=Q||u}var S=x.prototype=new y;S.constructor=x,f(S,w.prototype),S.isPureReactComponent=!0;var T=Array.isArray,E={H:null,A:null,T:null,S:null,V:null},A=Object.prototype.hasOwnProperty;function C(oe,K,Q,de,ue,Ze){return Q=Ze.ref,{$$typeof:n,type:oe,key:K,ref:Q!==void 0?Q:null,props:Ze}}function I(oe,K){return C(oe.type,K,void 0,void 0,void 0,oe.props)}function D(oe){return typeof oe=="object"&&oe!==null&&oe.$$typeof===n}function R(oe){var K={"=":"=0",":":"=2"};return"$"+oe.replace(/[=:]/g,function(Q){return K[Q]})}var Y=/\/+/g;function re(oe,K){return typeof oe=="object"&&oe!==null&&oe.key!=null?R(""+oe.key):K.toString(36)}function G(){}function te(oe){switch(oe.status){case"fulfilled":return oe.value;case"rejected":throw oe.reason;default:switch(typeof oe.status=="string"?oe.then(G,G):(oe.status="pending",oe.then(function(K){oe.status==="pending"&&(oe.status="fulfilled",oe.value=K)},function(K){oe.status==="pending"&&(oe.status="rejected",oe.reason=K)})),oe.status){case"fulfilled":return oe.value;case"rejected":throw oe.reason}}throw oe}function q(oe,K,Q,de,ue){var Ze=typeof oe;(Ze==="undefined"||Ze==="boolean")&&(oe=null);var Pt=!1;if(oe===null)Pt=!0;else switch(Ze){case"bigint":case"string":case"number":Pt=!0;break;case"object":switch(oe.$$typeof){case n:case e:Pt=!0;break;case h:return Pt=oe._init,q(Pt(oe._payload),K,Q,de,ue)}}if(Pt)return ue=ue(oe),Pt=de===""?"."+re(oe,0):de,T(ue)?(Q="",Pt!=null&&(Q=Pt.replace(Y,"$&/")+"/"),q(ue,K,Q,"",function(ri){return ri})):ue!=null&&(D(ue)&&(ue=I(ue,Q+(ue.key==null||oe&&oe.key===ue.key?"":(""+ue.key).replace(Y,"$&/")+"/")+Pt)),K.push(ue)),1;Pt=0;var Gt=de===""?".":de+":";if(T(oe))for(var bn=0;bn<oe.length;bn++)de=oe[bn],Ze=Gt+re(de,bn),Pt+=q(de,K,Q,Ze,ue);else if(bn=r(oe),typeof bn=="function")for(oe=bn.call(oe),bn=0;!(de=oe.next()).done;)de=de.value,Ze=Gt+re(de,bn++),Pt+=q(de,K,Q,Ze,ue);else if(Ze==="object"){if(typeof oe.then=="function")return q(te(oe),K,Q,de,ue);throw K=String(oe),Error("Objects are not valid as a React child (found: "+(K==="[object Object]"?"object with keys {"+Object.keys(oe).join(", ")+"}":K)+"). If you meant to render a collection of children, use an array instead.")}return Pt}function z(oe,K,Q){if(oe==null)return oe;var de=[],ue=0;return q(oe,de,"","",function(Ze){return K.call(Q,Ze,ue++)}),de}function H(oe){if(oe._status===-1){var K=oe._result;K=K(),K.then(function(Q){(oe._status===0||oe._status===-1)&&(oe._status=1,oe._result=Q)},function(Q){(oe._status===0||oe._status===-1)&&(oe._status=2,oe._result=Q)}),oe._status===-1&&(oe._status=0,oe._result=K)}if(oe._status===1)return oe._result.default;throw oe._result}var he=typeof reportError=="function"?reportError:function(oe){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var K=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof oe=="object"&&oe!==null&&typeof oe.message=="string"?String(oe.message):String(oe),error:oe});if(!window.dispatchEvent(K))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",oe);return}console.error(oe)};function Ce(){}return react_production.Children={map:z,forEach:function(oe,K,Q){z(oe,function(){K.apply(this,arguments)},Q)},count:function(oe){var K=0;return z(oe,function(){K++}),K},toArray:function(oe){return z(oe,function(K){return K})||[]},only:function(oe){if(!D(oe))throw Error("React.Children.only expected to receive a single React element child.");return oe}},react_production.Component=w,react_production.Fragment=t,react_production.Profiler=a,react_production.PureComponent=x,react_production.StrictMode=s,react_production.Suspense=m,react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=E,react_production.__COMPILER_RUNTIME={__proto__:null,c:function(oe){return E.H.useMemoCache(oe)}},react_production.cache=function(oe){return function(){return oe.apply(null,arguments)}},react_production.cloneElement=function(oe,K,Q){if(oe==null)throw Error("The argument must be a React element, but you passed "+oe+".");var de=f({},oe.props),ue=oe.key,Ze=void 0;if(K!=null)for(Pt in K.ref!==void 0&&(Ze=void 0),K.key!==void 0&&(ue=""+K.key),K)!A.call(K,Pt)||Pt==="key"||Pt==="__self"||Pt==="__source"||Pt==="ref"&&K.ref===void 0||(de[Pt]=K[Pt]);var Pt=arguments.length-2;if(Pt===1)de.children=Q;else if(1<Pt){for(var Gt=Array(Pt),bn=0;bn<Pt;bn++)Gt[bn]=arguments[bn+2];de.children=Gt}return C(oe.type,ue,void 0,void 0,Ze,de)},react_production.createContext=function(oe){return oe={$$typeof:l,_currentValue:oe,_currentValue2:oe,_threadCount:0,Provider:null,Consumer:null},oe.Provider=oe,oe.Consumer={$$typeof:c,_context:oe},oe},react_production.createElement=function(oe,K,Q){var de,ue={},Ze=null;if(K!=null)for(de in K.key!==void 0&&(Ze=""+K.key),K)A.call(K,de)&&de!=="key"&&de!=="__self"&&de!=="__source"&&(ue[de]=K[de]);var Pt=arguments.length-2;if(Pt===1)ue.children=Q;else if(1<Pt){for(var Gt=Array(Pt),bn=0;bn<Pt;bn++)Gt[bn]=arguments[bn+2];ue.children=Gt}if(oe&&oe.defaultProps)for(de in Pt=oe.defaultProps,Pt)ue[de]===void 0&&(ue[de]=Pt[de]);return C(oe,Ze,void 0,void 0,null,ue)},react_production.createRef=function(){return{current:null}},react_production.forwardRef=function(oe){return{$$typeof:_,render:oe}},react_production.isValidElement=D,react_production.lazy=function(oe){return{$$typeof:h,_payload:{_status:-1,_result:oe},_init:H}},react_production.memo=function(oe,K){return{$$typeof:d,type:oe,compare:K===void 0?null:K}},react_production.startTransition=function(oe){var K=E.T,Q={};E.T=Q;try{var de=oe(),ue=E.S;ue!==null&&ue(Q,de),typeof de=="object"&&de!==null&&typeof de.then=="function"&&de.then(Ce,he)}catch(Ze){he(Ze)}finally{E.T=K}},react_production.unstable_useCacheRefresh=function(){return E.H.useCacheRefresh()},react_production.use=function(oe){return E.H.use(oe)},react_production.useActionState=function(oe,K,Q){return E.H.useActionState(oe,K,Q)},react_production.useCallback=function(oe,K){return E.H.useCallback(oe,K)},react_production.useContext=function(oe){return E.H.useContext(oe)},react_production.useDebugValue=function(){},react_production.useDeferredValue=function(oe,K){return E.H.useDeferredValue(oe,K)},react_production.useEffect=function(oe,K,Q){var de=E.H;if(typeof Q=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return de.useEffect(oe,K)},react_production.useId=function(){return E.H.useId()},react_production.useImperativeHandle=function(oe,K,Q){return E.H.useImperativeHandle(oe,K,Q)},react_production.useInsertionEffect=function(oe,K){return E.H.useInsertionEffect(oe,K)},react_production.useLayoutEffect=function(oe,K){return E.H.useLayoutEffect(oe,K)},react_production.useMemo=function(oe,K){return E.H.useMemo(oe,K)},react_production.useOptimistic=function(oe,K){return E.H.useOptimistic(oe,K)},react_production.useReducer=function(oe,K,Q){return E.H.useReducer(oe,K,Q)},react_production.useRef=function(oe){return E.H.useRef(oe)},react_production.useState=function(oe){return E.H.useState(oe)},react_production.useSyncExternalStore=function(oe,K,Q){return E.H.useSyncExternalStore(oe,K,Q)},react_production.useTransition=function(){return E.H.useTransition()},react_production.version="19.1.1",react_production}var hasRequiredReact;function requireReact(){return hasRequiredReact||(hasRequiredReact=1,react.exports=requireReact_production()),react.exports}var reactExports=requireReact();const React=getDefaultExportFromCjs(reactExports);var client={exports:{}},reactDomClient_production={},scheduler={exports:{}},scheduler_production={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredScheduler_production;function requireScheduler_production(){return hasRequiredScheduler_production||(hasRequiredScheduler_production=1,(function(n){function e(z,H){var he=z.length;z.push(H);e:for(;0<he;){var Ce=he-1>>>1,oe=z[Ce];if(0<a(oe,H))z[Ce]=H,z[he]=oe,he=Ce;else break e}}function t(z){return z.length===0?null:z[0]}function s(z){if(z.length===0)return null;var H=z[0],he=z.pop();if(he!==H){z[0]=he;e:for(var Ce=0,oe=z.length,K=oe>>>1;Ce<K;){var Q=2*(Ce+1)-1,de=z[Q],ue=Q+1,Ze=z[ue];if(0>a(de,he))ue<oe&&0>a(Ze,de)?(z[Ce]=Ze,z[ue]=he,Ce=ue):(z[Ce]=de,z[Q]=he,Ce=Q);else if(ue<oe&&0>a(Ze,he))z[Ce]=Ze,z[ue]=he,Ce=ue;else break e}}return H}function a(z,H){var he=z.sortIndex-H.sortIndex;return he!==0?he:z.id-H.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var c=performance;n.unstable_now=function(){return c.now()}}else{var l=Date,_=l.now();n.unstable_now=function(){return l.now()-_}}var m=[],d=[],h=1,i=null,r=3,u=!1,f=!1,g=!1,w=!1,y=typeof setTimeout=="function"?setTimeout:null,x=typeof clearTimeout=="function"?clearTimeout:null,S=typeof setImmediate<"u"?setImmediate:null;function T(z){for(var H=t(d);H!==null;){if(H.callback===null)s(d);else if(H.startTime<=z)s(d),H.sortIndex=H.expirationTime,e(m,H);else break;H=t(d)}}function E(z){if(g=!1,T(z),!f)if(t(m)!==null)f=!0,A||(A=!0,re());else{var H=t(d);H!==null&&q(E,H.startTime-z)}}var A=!1,C=-1,I=5,D=-1;function R(){return w?!0:!(n.unstable_now()-D<I)}function Y(){if(w=!1,A){var z=n.unstable_now();D=z;var H=!0;try{e:{f=!1,g&&(g=!1,x(C),C=-1),u=!0;var he=r;try{t:{for(T(z),i=t(m);i!==null&&!(i.expirationTime>z&&R());){var Ce=i.callback;if(typeof Ce=="function"){i.callback=null,r=i.priorityLevel;var oe=Ce(i.expirationTime<=z);if(z=n.unstable_now(),typeof oe=="function"){i.callback=oe,T(z),H=!0;break t}i===t(m)&&s(m),T(z)}else s(m);i=t(m)}if(i!==null)H=!0;else{var K=t(d);K!==null&&q(E,K.startTime-z),H=!1}}break e}finally{i=null,r=he,u=!1}H=void 0}}finally{H?re():A=!1}}}var re;if(typeof S=="function")re=function(){S(Y)};else if(typeof MessageChannel<"u"){var G=new MessageChannel,te=G.port2;G.port1.onmessage=Y,re=function(){te.postMessage(null)}}else re=function(){y(Y,0)};function q(z,H){C=y(function(){z(n.unstable_now())},H)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(z){z.callback=null},n.unstable_forceFrameRate=function(z){0>z||125<z?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):I=0<z?Math.floor(1e3/z):5},n.unstable_getCurrentPriorityLevel=function(){return r},n.unstable_next=function(z){switch(r){case 1:case 2:case 3:var H=3;break;default:H=r}var he=r;r=H;try{return z()}finally{r=he}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(z,H){switch(z){case 1:case 2:case 3:case 4:case 5:break;default:z=3}var he=r;r=z;try{return H()}finally{r=he}},n.unstable_scheduleCallback=function(z,H,he){var Ce=n.unstable_now();switch(typeof he=="object"&&he!==null?(he=he.delay,he=typeof he=="number"&&0<he?Ce+he:Ce):he=Ce,z){case 1:var oe=-1;break;case 2:oe=250;break;case 5:oe=1073741823;break;case 4:oe=1e4;break;default:oe=5e3}return oe=he+oe,z={id:h++,callback:H,priorityLevel:z,startTime:he,expirationTime:oe,sortIndex:-1},he>Ce?(z.sortIndex=he,e(d,z),t(m)===null&&z===t(d)&&(g?(x(C),C=-1):g=!0,q(E,he-Ce))):(z.sortIndex=oe,e(m,z),f||u||(f=!0,A||(A=!0,re()))),z},n.unstable_shouldYield=R,n.unstable_wrapCallback=function(z){var H=r;return function(){var he=r;r=H;try{return z.apply(this,arguments)}finally{r=he}}}})(scheduler_production)),scheduler_production}var hasRequiredScheduler;function requireScheduler(){return hasRequiredScheduler||(hasRequiredScheduler=1,scheduler.exports=requireScheduler_production()),scheduler.exports}var reactDom={exports:{}},reactDom_production={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDom_production;function requireReactDom_production(){if(hasRequiredReactDom_production)return reactDom_production;hasRequiredReactDom_production=1;var n=requireReact();function e(m){var d="https://react.dev/errors/"+m;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var h=2;h<arguments.length;h++)d+="&args[]="+encodeURIComponent(arguments[h])}return"Minified React error #"+m+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},a=Symbol.for("react.portal");function c(m,d,h){var i=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:a,key:i==null?null:""+i,children:m,containerInfo:d,implementation:h}}var l=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function _(m,d){if(m==="font")return"";if(typeof d=="string")return d==="use-credentials"?d:""}return reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,reactDom_production.createPortal=function(m,d){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)throw Error(e(299));return c(m,d,null,h)},reactDom_production.flushSync=function(m){var d=l.T,h=s.p;try{if(l.T=null,s.p=2,m)return m()}finally{l.T=d,s.p=h,s.d.f()}},reactDom_production.preconnect=function(m,d){typeof m=="string"&&(d?(d=d.crossOrigin,d=typeof d=="string"?d==="use-credentials"?d:"":void 0):d=null,s.d.C(m,d))},reactDom_production.prefetchDNS=function(m){typeof m=="string"&&s.d.D(m)},reactDom_production.preinit=function(m,d){if(typeof m=="string"&&d&&typeof d.as=="string"){var h=d.as,i=_(h,d.crossOrigin),r=typeof d.integrity=="string"?d.integrity:void 0,u=typeof d.fetchPriority=="string"?d.fetchPriority:void 0;h==="style"?s.d.S(m,typeof d.precedence=="string"?d.precedence:void 0,{crossOrigin:i,integrity:r,fetchPriority:u}):h==="script"&&s.d.X(m,{crossOrigin:i,integrity:r,fetchPriority:u,nonce:typeof d.nonce=="string"?d.nonce:void 0})}},reactDom_production.preinitModule=function(m,d){if(typeof m=="string")if(typeof d=="object"&&d!==null){if(d.as==null||d.as==="script"){var h=_(d.as,d.crossOrigin);s.d.M(m,{crossOrigin:h,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0})}}else d==null&&s.d.M(m)},reactDom_production.preload=function(m,d){if(typeof m=="string"&&typeof d=="object"&&d!==null&&typeof d.as=="string"){var h=d.as,i=_(h,d.crossOrigin);s.d.L(m,h,{crossOrigin:i,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0,type:typeof d.type=="string"?d.type:void 0,fetchPriority:typeof d.fetchPriority=="string"?d.fetchPriority:void 0,referrerPolicy:typeof d.referrerPolicy=="string"?d.referrerPolicy:void 0,imageSrcSet:typeof d.imageSrcSet=="string"?d.imageSrcSet:void 0,imageSizes:typeof d.imageSizes=="string"?d.imageSizes:void 0,media:typeof d.media=="string"?d.media:void 0})}},reactDom_production.preloadModule=function(m,d){if(typeof m=="string")if(d){var h=_(d.as,d.crossOrigin);s.d.m(m,{as:typeof d.as=="string"&&d.as!=="script"?d.as:void 0,crossOrigin:h,integrity:typeof d.integrity=="string"?d.integrity:void 0})}else s.d.m(m)},reactDom_production.requestFormReset=function(m){s.d.r(m)},reactDom_production.unstable_batchedUpdates=function(m,d){return m(d)},reactDom_production.useFormState=function(m,d,h){return l.H.useFormState(m,d,h)},reactDom_production.useFormStatus=function(){return l.H.useHostTransitionStatus()},reactDom_production.version="19.1.1",reactDom_production}var hasRequiredReactDom;function requireReactDom(){if(hasRequiredReactDom)return reactDom.exports;hasRequiredReactDom=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),reactDom.exports=requireReactDom_production(),reactDom.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDomClient_production;function requireReactDomClient_production(){if(hasRequiredReactDomClient_production)return reactDomClient_production;hasRequiredReactDomClient_production=1;var n=requireScheduler(),e=requireReact(),t=requireReactDom();function s(o){var p="https://react.dev/errors/"+o;if(1<arguments.length){p+="?args[]="+encodeURIComponent(arguments[1]);for(var b=2;b<arguments.length;b++)p+="&args[]="+encodeURIComponent(arguments[b])}return"Minified React error #"+o+"; visit "+p+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function a(o){return!(!o||o.nodeType!==1&&o.nodeType!==9&&o.nodeType!==11)}function c(o){var p=o,b=o;if(o.alternate)for(;p.return;)p=p.return;else{o=p;do p=o,(p.flags&4098)!==0&&(b=p.return),o=p.return;while(o)}return p.tag===3?b:null}function l(o){if(o.tag===13){var p=o.memoizedState;if(p===null&&(o=o.alternate,o!==null&&(p=o.memoizedState)),p!==null)return p.dehydrated}return null}function _(o){if(c(o)!==o)throw Error(s(188))}function m(o){var p=o.alternate;if(!p){if(p=c(o),p===null)throw Error(s(188));return p!==o?null:o}for(var b=o,v=p;;){var O=b.return;if(O===null)break;var $=O.alternate;if($===null){if(v=O.return,v!==null){b=v;continue}break}if(O.child===$.child){for($=O.child;$;){if($===b)return _(O),o;if($===v)return _(O),p;$=$.sibling}throw Error(s(188))}if(b.return!==v.return)b=O,v=$;else{for(var ae=!1,Te=O.child;Te;){if(Te===b){ae=!0,b=O,v=$;break}if(Te===v){ae=!0,v=O,b=$;break}Te=Te.sibling}if(!ae){for(Te=$.child;Te;){if(Te===b){ae=!0,b=$,v=O;break}if(Te===v){ae=!0,v=$,b=O;break}Te=Te.sibling}if(!ae)throw Error(s(189))}}if(b.alternate!==v)throw Error(s(190))}if(b.tag!==3)throw Error(s(188));return b.stateNode.current===b?o:p}function d(o){var p=o.tag;if(p===5||p===26||p===27||p===6)return o;for(o=o.child;o!==null;){if(p=d(o),p!==null)return p;o=o.sibling}return null}var h=Object.assign,i=Symbol.for("react.element"),r=Symbol.for("react.transitional.element"),u=Symbol.for("react.portal"),f=Symbol.for("react.fragment"),g=Symbol.for("react.strict_mode"),w=Symbol.for("react.profiler"),y=Symbol.for("react.provider"),x=Symbol.for("react.consumer"),S=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),A=Symbol.for("react.suspense_list"),C=Symbol.for("react.memo"),I=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),R=Symbol.for("react.memo_cache_sentinel"),Y=Symbol.iterator;function re(o){return o===null||typeof o!="object"?null:(o=Y&&o[Y]||o["@@iterator"],typeof o=="function"?o:null)}var G=Symbol.for("react.client.reference");function te(o){if(o==null)return null;if(typeof o=="function")return o.$$typeof===G?null:o.displayName||o.name||null;if(typeof o=="string")return o;switch(o){case f:return"Fragment";case w:return"Profiler";case g:return"StrictMode";case E:return"Suspense";case A:return"SuspenseList";case D:return"Activity"}if(typeof o=="object")switch(o.$$typeof){case u:return"Portal";case S:return(o.displayName||"Context")+".Provider";case x:return(o._context.displayName||"Context")+".Consumer";case T:var p=o.render;return o=o.displayName,o||(o=p.displayName||p.name||"",o=o!==""?"ForwardRef("+o+")":"ForwardRef"),o;case C:return p=o.displayName||null,p!==null?p:te(o.type)||"Memo";case I:p=o._payload,o=o._init;try{return te(o(p))}catch{}}return null}var q=Array.isArray,z=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,H=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,he={pending:!1,data:null,method:null,action:null},Ce=[],oe=-1;function K(o){return{current:o}}function Q(o){0>oe||(o.current=Ce[oe],Ce[oe]=null,oe--)}function de(o,p){oe++,Ce[oe]=o.current,o.current=p}var ue=K(null),Ze=K(null),Pt=K(null),Gt=K(null);function bn(o,p){switch(de(Pt,p),de(Ze,o),de(ue,null),p.nodeType){case 9:case 11:o=(o=p.documentElement)&&(o=o.namespaceURI)?Yc(o):0;break;default:if(o=p.tagName,p=p.namespaceURI)p=Yc(p),o=vp(p,o);else switch(o){case"svg":o=1;break;case"math":o=2;break;default:o=0}}Q(ue),de(ue,o)}function ri(){Q(ue),Q(Ze),Q(Pt)}function hn(o){o.memoizedState!==null&&de(Gt,o);var p=ue.current,b=vp(p,o.type);p!==b&&(de(Ze,o),de(ue,b))}function ze(o){Ze.current===o&&(Q(ue),Q(Ze)),Gt.current===o&&(Q(Gt),wx._currentValue=he)}var wt=Object.prototype.hasOwnProperty,ke=n.unstable_scheduleCallback,Bt=n.unstable_cancelCallback,In=n.unstable_shouldYield,Tn=n.unstable_requestPaint,cn=n.unstable_now,kn=n.unstable_getCurrentPriorityLevel,yn=n.unstable_ImmediatePriority,$n=n.unstable_UserBlockingPriority,cr=n.unstable_NormalPriority,ti=n.unstable_LowPriority,vn=n.unstable_IdlePriority,xi=n.log,ir=n.unstable_setDisableYieldValue,ai=null,mi=null;function fi(o){if(typeof xi=="function"&&ir(o),mi&&typeof mi.setStrictMode=="function")try{mi.setStrictMode(ai,o)}catch{}}var ui=Math.clz32?Math.clz32:zi,wi=Math.log,Lo=Math.LN2;function zi(o){return o>>>=0,o===0?32:31-(wi(o)/Lo|0)|0}var Ci=256,Si=4194304;function zc(o){var p=o&42;if(p!==0)return p;switch(o&-o){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return o&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return o}}function Xc(o,p,b){var v=o.pendingLanes;if(v===0)return 0;var O=0,$=o.suspendedLanes,ae=o.pingedLanes;o=o.warmLanes;var Te=v&134217727;return Te!==0?(v=Te&~$,v!==0?O=zc(v):(ae&=Te,ae!==0?O=zc(ae):b||(b=Te&~o,b!==0&&(O=zc(b))))):(Te=v&~$,Te!==0?O=zc(Te):ae!==0?O=zc(ae):b||(b=v&~o,b!==0&&(O=zc(b)))),O===0?0:p!==0&&p!==O&&(p&$)===0&&($=O&-O,b=p&-p,$>=b||$===32&&(b&4194048)!==0)?p:O}function up(o,p){return(o.pendingLanes&~(o.suspendedLanes&~o.pingedLanes)&p)===0}function Jo(o,p){switch(o){case 1:case 2:case 4:case 8:case 64:return p+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return p+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Mo(){var o=Ci;return Ci<<=1,(Ci&4194048)===0&&(Ci=256),o}function $p(){var o=Si;return Si<<=1,(Si&62914560)===0&&(Si=4194304),o}function rf(o){for(var p=[],b=0;31>b;b++)p.push(o);return p}function cp(o,p){o.pendingLanes|=p,p!==268435456&&(o.suspendedLanes=0,o.pingedLanes=0,o.warmLanes=0)}function Wi(o,p,b,v,O,$){var ae=o.pendingLanes;o.pendingLanes=b,o.suspendedLanes=0,o.pingedLanes=0,o.warmLanes=0,o.expiredLanes&=b,o.entangledLanes&=b,o.errorRecoveryDisabledLanes&=b,o.shellSuspendCounter=0;var Te=o.entanglements,dt=o.expirationTimes,wn=o.hiddenUpdates;for(b=ae&~b;0<b;){var dr=31-ui(b),ni=1<<dr;Te[dr]=0,dt[dr]=-1;var Pn=wn[dr];if(Pn!==null)for(wn[dr]=null,dr=0;dr<Pn.length;dr++){var Cn=Pn[dr];Cn!==null&&(Cn.lane&=-536870913)}b&=~ni}v!==0&&si(o,v,0),$!==0&&O===0&&o.tag!==0&&(o.suspendedLanes|=$&~(ae&~p))}function si(o,p,b){o.pendingLanes|=p,o.suspendedLanes&=~p;var v=31-ui(p);o.entangledLanes|=p,o.entanglements[v]=o.entanglements[v]|1073741824|b&4194090}function Ri(o,p){var b=o.entangledLanes|=p;for(o=o.entanglements;b;){var v=31-ui(b),O=1<<v;O&p|o[v]&p&&(o[v]|=p),b&=~O}}function _c(o){switch(o){case 2:o=1;break;case 8:o=4;break;case 32:o=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:o=128;break;case 268435456:o=134217728;break;default:o=0}return o}function Ui(o){return o&=-o,2<o?8<o?(o&134217727)!==0?32:268435456:8:2}function Rp(){var o=H.p;return o!==0?o:(o=window.event,o===void 0?32:Jv(o.type))}function W(o,p){var b=H.p;try{return H.p=o,p()}finally{H.p=b}}var Qe=Math.random().toString(36).slice(2),ve="__reactFiber$"+Qe,Ke="__reactProps$"+Qe,lt="__reactContainer$"+Qe,_n="__reactEvents$"+Qe,ar="__reactListeners$"+Qe,vi="__reactHandles$"+Qe,Pi="__reactResources$"+Qe,hi="__reactMarker$"+Qe;function Oo(o){delete o[ve],delete o[Ke],delete o[_n],delete o[ar],delete o[vi]}function we(o){var p=o[ve];if(p)return p;for(var b=o.parentNode;b;){if(p=b[lt]||b[ve]){if(b=p.alternate,p.child!==null||b!==null&&b.child!==null)for(o=cv(o);o!==null;){if(b=o[ve])return b;o=cv(o)}return p}o=b,b=o.parentNode}return null}function it(o){if(o=o[ve]||o[lt]){var p=o.tag;if(p===5||p===6||p===13||p===26||p===27||p===3)return o}return null}function pt(o){var p=o.tag;if(p===5||p===26||p===27||p===6)return o.stateNode;throw Error(s(33))}function Ot(o){var p=o[Pi];return p||(p=o[Pi]={hoistableStyles:new Map,hoistableScripts:new Map}),p}function Ht(o){o[hi]=!0}var mn=new Set,ii={};function Ti(o,p){pi(o,p),pi(o+"Capture",p)}function pi(o,p){for(ii[o]=p,o=0;o<p.length;o++)mn.add(p[o])}var Do=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Ko={},yc={};function Dc(o){return wt.call(yc,o)?!0:wt.call(Ko,o)?!1:Do.test(o)?yc[o]=!0:(Ko[o]=!0,!1)}function En(o,p,b){if(Dc(p))if(b===null)o.removeAttribute(p);else{switch(typeof b){case"undefined":case"function":case"symbol":o.removeAttribute(p);return;case"boolean":var v=p.toLowerCase().slice(0,5);if(v!=="data-"&&v!=="aria-"){o.removeAttribute(p);return}}o.setAttribute(p,""+b)}}function Oi(o,p,b){if(b===null)o.removeAttribute(p);else{switch(typeof b){case"undefined":case"function":case"symbol":case"boolean":o.removeAttribute(p);return}o.setAttribute(p,""+b)}}function Ro(o,p,b,v){if(v===null)o.removeAttribute(b);else{switch(typeof v){case"undefined":case"function":case"symbol":case"boolean":o.removeAttribute(b);return}o.setAttributeNS(p,b,""+v)}}var bc,Oc;function dp(o){if(bc===void 0)try{throw Error()}catch(b){var p=b.stack.trim().match(/\n( *(at )?)/);bc=p&&p[1]||"",Oc=-1<b.stack.indexOf(`
    at`)?" (<anonymous>)":-1<b.stack.indexOf("@")?"@unknown:0:0":""}return`
`+bc+o+Oc}var Jf=!1;function kp(o,p){if(!o||Jf)return"";Jf=!0;var b=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var v={DetermineComponentFrameRoot:function(){try{if(p){var ni=function(){throw Error()};if(Object.defineProperty(ni.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(ni,[])}catch(Cn){var Pn=Cn}Reflect.construct(o,[],ni)}else{try{ni.call()}catch(Cn){Pn=Cn}o.call(ni.prototype)}}else{try{throw Error()}catch(Cn){Pn=Cn}(ni=o())&&typeof ni.catch=="function"&&ni.catch(function(){})}}catch(Cn){if(Cn&&Pn&&typeof Cn.stack=="string")return[Cn.stack,Pn.stack]}return[null,null]}};v.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var O=Object.getOwnPropertyDescriptor(v.DetermineComponentFrameRoot,"name");O&&O.configurable&&Object.defineProperty(v.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var $=v.DetermineComponentFrameRoot(),ae=$[0],Te=$[1];if(ae&&Te){var dt=ae.split(`
`),wn=Te.split(`
`);for(O=v=0;v<dt.length&&!dt[v].includes("DetermineComponentFrameRoot");)v++;for(;O<wn.length&&!wn[O].includes("DetermineComponentFrameRoot");)O++;if(v===dt.length||O===wn.length)for(v=dt.length-1,O=wn.length-1;1<=v&&0<=O&&dt[v]!==wn[O];)O--;for(;1<=v&&0<=O;v--,O--)if(dt[v]!==wn[O]){if(v!==1||O!==1)do if(v--,O--,0>O||dt[v]!==wn[O]){var dr=`
`+dt[v].replace(" at new "," at ");return o.displayName&&dr.includes("<anonymous>")&&(dr=dr.replace("<anonymous>",o.displayName)),dr}while(1<=v&&0<=O);break}}}finally{Jf=!1,Error.prepareStackTrace=b}return(b=o?o.displayName||o.name:"")?dp(b):""}function Qc(o){switch(o.tag){case 26:case 27:case 5:return dp(o.type);case 16:return dp("Lazy");case 13:return dp("Suspense");case 19:return dp("SuspenseList");case 0:case 15:return kp(o.type,!1);case 11:return kp(o.type.render,!1);case 1:return kp(o.type,!0);case 31:return dp("Activity");default:return""}}function sp(o){try{var p="";do p+=Qc(o),o=o.return;while(o);return p}catch(b){return`
Error generating stack: `+b.message+`
`+b.stack}}function mr(o){switch(typeof o){case"bigint":case"boolean":case"number":case"string":case"undefined":return o;case"object":return o;default:return""}}function ci(o){var p=o.type;return(o=o.nodeName)&&o.toLowerCase()==="input"&&(p==="checkbox"||p==="radio")}function Mi(o){var p=ci(o)?"checked":"value",b=Object.getOwnPropertyDescriptor(o.constructor.prototype,p),v=""+o[p];if(!o.hasOwnProperty(p)&&typeof b<"u"&&typeof b.get=="function"&&typeof b.set=="function"){var O=b.get,$=b.set;return Object.defineProperty(o,p,{configurable:!0,get:function(){return O.call(this)},set:function(ae){v=""+ae,$.call(this,ae)}}),Object.defineProperty(o,p,{enumerable:b.enumerable}),{getValue:function(){return v},setValue:function(ae){v=""+ae},stopTracking:function(){o._valueTracker=null,delete o[p]}}}}function Ac(o){o._valueTracker||(o._valueTracker=Mi(o))}function m_(o){if(!o)return!1;var p=o._valueTracker;if(!p)return!0;var b=p.getValue(),v="";return o&&(v=ci(o)?o.checked?"true":"false":o.value),o=v,o!==b?(p.setValue(o),!0):!1}function Op(o){if(o=o||(typeof document<"u"?document:void 0),typeof o>"u")return null;try{return o.activeElement||o.body}catch{return o.body}}var p_=/[\n"\\]/g;function Hc(o){return o.replace(p_,function(p){return"\\"+p.charCodeAt(0).toString(16)+" "})}function g_(o,p,b,v,O,$,ae,Te){o.name="",ae!=null&&typeof ae!="function"&&typeof ae!="symbol"&&typeof ae!="boolean"?o.type=ae:o.removeAttribute("type"),p!=null?ae==="number"?(p===0&&o.value===""||o.value!=p)&&(o.value=""+mr(p)):o.value!==""+mr(p)&&(o.value=""+mr(p)):ae!=="submit"&&ae!=="reset"||o.removeAttribute("value"),p!=null?M_(o,ae,mr(p)):b!=null?M_(o,ae,mr(b)):v!=null&&o.removeAttribute("value"),O==null&&$!=null&&(o.defaultChecked=!!$),O!=null&&(o.checked=O&&typeof O!="function"&&typeof O!="symbol"),Te!=null&&typeof Te!="function"&&typeof Te!="symbol"&&typeof Te!="boolean"?o.name=""+mr(Te):o.removeAttribute("name")}function T_(o,p,b,v,O,$,ae,Te){if($!=null&&typeof $!="function"&&typeof $!="symbol"&&typeof $!="boolean"&&(o.type=$),p!=null||b!=null){if(!($!=="submit"&&$!=="reset"||p!=null))return;b=b!=null?""+mr(b):"",p=p!=null?""+mr(p):b,Te||p===o.value||(o.value=p),o.defaultValue=p}v=v??O,v=typeof v!="function"&&typeof v!="symbol"&&!!v,o.checked=Te?o.checked:!!v,o.defaultChecked=!!v,ae!=null&&typeof ae!="function"&&typeof ae!="symbol"&&typeof ae!="boolean"&&(o.name=ae)}function M_(o,p,b){p==="number"&&Op(o.ownerDocument)===o||o.defaultValue===""+b||(o.defaultValue=""+b)}function Lt(o,p,b,v){if(o=o.options,p){p={};for(var O=0;O<b.length;O++)p["$"+b[O]]=!0;for(b=0;b<o.length;b++)O=p.hasOwnProperty("$"+o[b].value),o[b].selected!==O&&(o[b].selected=O),O&&v&&(o[b].defaultSelected=!0)}else{for(b=""+mr(b),p=null,O=0;O<o.length;O++){if(o[O].value===b){o[O].selected=!0,v&&(o[O].defaultSelected=!0);return}p!==null||o[O].disabled||(p=o[O])}p!==null&&(p.selected=!0)}}function X(o,p,b){if(p!=null&&(p=""+mr(p),p!==o.value&&(o.value=p),b==null)){o.defaultValue!==p&&(o.defaultValue=p);return}o.defaultValue=b!=null?""+mr(b):""}function $e(o,p,b,v){if(p==null){if(v!=null){if(b!=null)throw Error(s(92));if(q(v)){if(1<v.length)throw Error(s(93));v=v[0]}b=v}b==null&&(b=""),p=b}b=mr(p),o.defaultValue=b,v=o.textContent,v===b&&v!==""&&v!==null&&(o.value=v)}function at(o,p){if(p){var b=o.firstChild;if(b&&b===o.lastChild&&b.nodeType===3){b.nodeValue=p;return}}o.textContent=p}var ft=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function kt(o,p,b){var v=p.indexOf("--")===0;b==null||typeof b=="boolean"||b===""?v?o.setProperty(p,""):p==="float"?o.cssFloat="":o[p]="":v?o.setProperty(p,b):typeof b!="number"||b===0||ft.has(p)?p==="float"?o.cssFloat=b:o[p]=(""+b).trim():o[p]=b+"px"}function sr(o,p,b){if(p!=null&&typeof p!="object")throw Error(s(62));if(o=o.style,b!=null){for(var v in b)!b.hasOwnProperty(v)||p!=null&&p.hasOwnProperty(v)||(v.indexOf("--")===0?o.setProperty(v,""):v==="float"?o.cssFloat="":o[v]="");for(var O in p)v=p[O],p.hasOwnProperty(O)&&b[O]!==v&&kt(o,O,v)}else for(var $ in p)p.hasOwnProperty($)&&kt(o,$,p[$])}function or(o){if(o.indexOf("-")===-1)return!1;switch(o){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var lr=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),yi=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function di(o){return yi.test(""+o)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":o}var zo=null;function Hi(o){return o=o.target||o.srcElement||window,o.correspondingUseElement&&(o=o.correspondingUseElement),o.nodeType===3?o.parentNode:o}var Tc=null,Uc=null;function Cc(o){var p=it(o);if(p&&(o=p.stateNode)){var b=o[Ke]||null;e:switch(o=p.stateNode,p.type){case"input":if(g_(o,b.value,b.defaultValue,b.defaultValue,b.checked,b.defaultChecked,b.type,b.name),p=b.name,b.type==="radio"&&p!=null){for(b=o;b.parentNode;)b=b.parentNode;for(b=b.querySelectorAll('input[name="'+Hc(""+p)+'"][type="radio"]'),p=0;p<b.length;p++){var v=b[p];if(v!==o&&v.form===o.form){var O=v[Ke]||null;if(!O)throw Error(s(90));g_(v,O.value,O.defaultValue,O.defaultValue,O.checked,O.defaultChecked,O.type,O.name)}}for(p=0;p<b.length;p++)v=b[p],v.form===o.form&&m_(v)}break e;case"textarea":X(o,b.value,b.defaultValue);break e;case"select":p=b.value,p!=null&&Lt(o,!!b.multiple,p,!1)}}}var Lc=!1;function Mc(o,p,b){if(Lc)return o(p,b);Lc=!0;try{var v=o(p);return v}finally{if(Lc=!1,(Tc!==null||Uc!==null)&&(ny(),Tc&&(p=Tc,o=Uc,Uc=Tc=null,Cc(p),o)))for(p=0;p<o.length;p++)Cc(o[p])}}function ip(o,p){var b=o.stateNode;if(b===null)return null;var v=b[Ke]||null;if(v===null)return null;b=v[p];e:switch(p){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(v=!v.disabled)||(o=o.type,v=!(o==="button"||o==="input"||o==="select"||o==="textarea")),o=!v;break e;default:o=!1}if(o)return null;if(b&&typeof b!="function")throw Error(s(231,p,typeof b));return b}var ep=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),tp=!1;if(ep)try{var yp={};Object.defineProperty(yp,"passive",{get:function(){tp=!0}}),window.addEventListener("test",yp,yp),window.removeEventListener("test",yp,yp)}catch{tp=!1}var wc=null,Z=null,xe=null;function Ve(){if(xe)return xe;var o,p=Z,b=p.length,v,O="value"in wc?wc.value:wc.textContent,$=O.length;for(o=0;o<b&&p[o]===O[o];o++);var ae=b-o;for(v=1;v<=ae&&p[b-v]===O[$-v];v++);return xe=O.slice(o,1<v?1-v:void 0)}function ct(o){var p=o.keyCode;return"charCode"in o?(o=o.charCode,o===0&&p===13&&(o=13)):o=p,o===10&&(o=13),32<=o||o===13?o:0}function zt(){return!0}function Sn(){return!1}function pr(o){function p(b,v,O,$,ae){this._reactName=b,this._targetInst=O,this.type=v,this.nativeEvent=$,this.target=ae,this.currentTarget=null;for(var Te in o)o.hasOwnProperty(Te)&&(b=o[Te],this[Te]=b?b($):$[Te]);return this.isDefaultPrevented=($.defaultPrevented!=null?$.defaultPrevented:$.returnValue===!1)?zt:Sn,this.isPropagationStopped=Sn,this}return h(p.prototype,{preventDefault:function(){this.defaultPrevented=!0;var b=this.nativeEvent;b&&(b.preventDefault?b.preventDefault():typeof b.returnValue!="unknown"&&(b.returnValue=!1),this.isDefaultPrevented=zt)},stopPropagation:function(){var b=this.nativeEvent;b&&(b.stopPropagation?b.stopPropagation():typeof b.cancelBubble!="unknown"&&(b.cancelBubble=!0),this.isPropagationStopped=zt)},persist:function(){},isPersistent:zt}),p}var gi={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(o){return o.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Ii=pr(gi),ki=h({},gi,{view:0,detail:0}),Zo=pr(ki),pp,fp,An,Ho=h({},ki,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:q1,button:0,buttons:0,relatedTarget:function(o){return o.relatedTarget===void 0?o.fromElement===o.srcElement?o.toElement:o.fromElement:o.relatedTarget},movementX:function(o){return"movementX"in o?o.movementX:(o!==An&&(An&&o.type==="mousemove"?(pp=o.screenX-An.screenX,fp=o.screenY-An.screenY):fp=pp=0,An=o),pp)},movementY:function(o){return"movementY"in o?o.movementY:fp}}),Bc=pr(Ho),s_=h({},Ho,{dataTransfer:0}),E_=pr(s_),ly=h({},ki,{relatedTarget:0}),F_=pr(ly),uy=h({},gi,{animationName:0,elapsedTime:0,pseudoElement:0}),cy=pr(uy),dy=h({},gi,{clipboardData:function(o){return"clipboardData"in o?o.clipboardData:window.clipboardData}}),py=pr(dy),fy=h({},gi,{data:0}),J_=pr(fy),j0={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},U0={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},V0={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function hy(o){var p=this.nativeEvent;return p.getModifierState?p.getModifierState(o):(o=V0[o])?!!p[o]:!1}function q1(){return hy}var H1=h({},ki,{key:function(o){if(o.key){var p=j0[o.key]||o.key;if(p!=="Unidentified")return p}return o.type==="keypress"?(o=ct(o),o===13?"Enter":String.fromCharCode(o)):o.type==="keydown"||o.type==="keyup"?U0[o.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:q1,charCode:function(o){return o.type==="keypress"?ct(o):0},keyCode:function(o){return o.type==="keydown"||o.type==="keyup"?o.keyCode:0},which:function(o){return o.type==="keypress"?ct(o):o.type==="keydown"||o.type==="keyup"?o.keyCode:0}}),G0=pr(H1),zg=h({},Ho,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),K1=pr(zg),W0=h({},ki,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:q1}),q0=pr(W0),_y=h({},gi,{propertyName:0,elapsedTime:0,pseudoElement:0}),H0=pr(_y),K0=h({},Ho,{deltaX:function(o){return"deltaX"in o?o.deltaX:"wheelDeltaX"in o?-o.wheelDeltaX:0},deltaY:function(o){return"deltaY"in o?o.deltaY:"wheelDeltaY"in o?-o.wheelDeltaY:"wheelDelta"in o?-o.wheelDelta:0},deltaZ:0,deltaMode:0}),Y0=pr(K0),X0=h({},gi,{newState:0,oldState:0}),Q0=pr(X0),Y1=[9,13,27,32],X1=ep&&"CompositionEvent"in window,Bg=null;ep&&"documentMode"in document&&(Bg=document.documentMode);var my=ep&&"TextEvent"in window&&!Bg,Z0=ep&&(!X1||Bg&&8<Bg&&11>=Bg),J0=" ",eb=!1;function jg(o,p){switch(o){case"keyup":return Y1.indexOf(p.keyCode)!==-1;case"keydown":return p.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function gg(o){return o=o.detail,typeof o=="object"&&"data"in o?o.data:null}var S_=!1;function gy(o,p){switch(o){case"compositionend":return gg(p);case"keypress":return p.which!==32?null:(eb=!0,J0);case"textInput":return o=p.data,o===J0&&eb?null:o;default:return null}}function Q1(o,p){if(S_)return o==="compositionend"||!X1&&jg(o,p)?(o=Ve(),xe=Z=wc=null,S_=!1,o):null;switch(o){case"paste":return null;case"keypress":if(!(p.ctrlKey||p.altKey||p.metaKey)||p.ctrlKey&&p.altKey){if(p.char&&1<p.char.length)return p.char;if(p.which)return String.fromCharCode(p.which)}return null;case"compositionend":return Z0&&p.locale!=="ko"?null:p.data;default:return null}}var l1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function u1(o){var p=o&&o.nodeName&&o.nodeName.toLowerCase();return p==="input"?!!l1[o.type]:p==="textarea"}function c1(o,p,b,v){Tc?Uc?Uc.push(v):Uc=[v]:Tc=v,p=Ei(p,"onChange"),0<p.length&&(b=new Ii("onChange","change",null,b,v),o.push({event:b,listeners:p}))}var i_=null,wg=null;function by(o){j(o,0)}function Ug(o){var p=pt(o);if(m_(p))return o}function tb(o,p){if(o==="change")return p}var nb=!1;if(ep){var Vg;if(ep){var d1="oninput"in document;if(!d1){var Gg=document.createElement("div");Gg.setAttribute("oninput","return;"),d1=typeof Gg.oninput=="function"}Vg=d1}else Vg=!1;nb=Vg&&(!document.documentMode||9<document.documentMode)}function Li(){i_&&(i_.detachEvent("onpropertychange",rb),wg=i_=null)}function rb(o){if(o.propertyName==="value"&&Ug(wg)){var p=[];c1(p,wg,o,Hi(o)),Mc(by,p)}}function sb(o,p,b){o==="focusin"?(Li(),i_=p,wg=b,i_.attachEvent("onpropertychange",rb)):o==="focusout"&&Li()}function p1(o){if(o==="selectionchange"||o==="keyup"||o==="keydown")return Ug(wg)}function f1(o,p){if(o==="click")return Ug(p)}function f_(o,p){if(o==="input"||o==="change")return Ug(p)}function h1(o,p){return o===p&&(o!==0||1/o===1/p)||o!==o&&p!==p}var Tp=typeof Object.is=="function"?Object.is:h1;function xg(o,p){if(Tp(o,p))return!0;if(typeof o!="object"||o===null||typeof p!="object"||p===null)return!1;var b=Object.keys(o),v=Object.keys(p);if(b.length!==v.length)return!1;for(v=0;v<b.length;v++){var O=b[v];if(!wt.call(p,O)||!Tp(o[O],p[O]))return!1}return!0}function Z1(o){for(;o&&o.firstChild;)o=o.firstChild;return o}function _1(o,p){var b=Z1(o);o=0;for(var v;b;){if(b.nodeType===3){if(v=o+b.textContent.length,o<=p&&v>=p)return{node:b,offset:p-o};o=v}e:{for(;b;){if(b.nextSibling){b=b.nextSibling;break e}b=b.parentNode}b=void 0}b=Z1(b)}}function m1(o,p){return o&&p?o===p?!0:o&&o.nodeType===3?!1:p&&p.nodeType===3?m1(o,p.parentNode):"contains"in o?o.contains(p):o.compareDocumentPosition?!!(o.compareDocumentPosition(p)&16):!1:!1}function J1(o){o=o!=null&&o.ownerDocument!=null&&o.ownerDocument.defaultView!=null?o.ownerDocument.defaultView:window;for(var p=Op(o.document);p instanceof o.HTMLIFrameElement;){try{var b=typeof p.contentWindow.location.href=="string"}catch{b=!1}if(b)o=p.contentWindow;else break;p=Op(o.document)}return p}function Wg(o){var p=o&&o.nodeName&&o.nodeName.toLowerCase();return p&&(p==="input"&&(o.type==="text"||o.type==="search"||o.type==="tel"||o.type==="url"||o.type==="password")||p==="textarea"||o.contentEditable==="true")}var ib=ep&&"documentMode"in document&&11>=document.documentMode,b_=null,vg=null,N_=null,g1=!1;function b1(o,p,b){var v=b.window===b?b.document:b.nodeType===9?b:b.ownerDocument;g1||b_==null||b_!==Op(v)||(v=b_,"selectionStart"in v&&Wg(v)?v={start:v.selectionStart,end:v.selectionEnd}:(v=(v.ownerDocument&&v.ownerDocument.defaultView||window).getSelection(),v={anchorNode:v.anchorNode,anchorOffset:v.anchorOffset,focusNode:v.focusNode,focusOffset:v.focusOffset}),N_&&xg(N_,v)||(N_=v,v=Ei(vg,"onSelect"),0<v.length&&(p=new Ii("onSelect","select",null,p,b),o.push({event:p,listeners:v}),p.target=b_)))}function P_(o,p){var b={};return b[o.toLowerCase()]=p.toLowerCase(),b["Webkit"+o]="webkit"+p,b["Moz"+o]="moz"+p,b}var R_={animationend:P_("Animation","AnimationEnd"),animationiteration:P_("Animation","AnimationIteration"),animationstart:P_("Animation","AnimationStart"),transitionrun:P_("Transition","TransitionRun"),transitionstart:P_("Transition","TransitionStart"),transitioncancel:P_("Transition","TransitionCancel"),transitionend:P_("Transition","TransitionEnd")},qg={},L={};ep&&(L=document.createElement("div").style,"AnimationEvent"in window||(delete R_.animationend.animation,delete R_.animationiteration.animation,delete R_.animationstart.animation),"TransitionEvent"in window||delete R_.transitionend.transition);function V(o){if(qg[o])return qg[o];if(!R_[o])return o;var p=R_[o],b;for(b in p)if(p.hasOwnProperty(b)&&b in L)return qg[o]=p[b];return o}var le=V("animationend"),_e=V("animationiteration"),De=V("animationstart"),mt=V("transitionrun"),nr=V("transitionstart"),li=V("transitioncancel"),bi=V("transitionend"),Ai=new Map,Fo="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Fo.push("scrollEnd");function jo(o,p){Ai.set(o,p),Ti(p,[o])}var Ec=new WeakMap;function Ic(o,p){if(typeof o=="object"&&o!==null){var b=Ec.get(o);return b!==void 0?b:(p={value:o,source:p,stack:sp(p)},Ec.set(o,p),p)}return{value:o,source:p,stack:sp(p)}}var hp=[],Tg=0,yy=0;function e0(){for(var o=Tg,p=yy=Tg=0;p<o;){var b=hp[p];hp[p++]=null;var v=hp[p];hp[p++]=null;var O=hp[p];hp[p++]=null;var $=hp[p];if(hp[p++]=null,v!==null&&O!==null){var ae=v.pending;ae===null?O.next=O:(O.next=ae.next,ae.next=O),v.pending=O}$!==0&&Iw(b,O,$)}}function ab(o,p,b,v){hp[Tg++]=o,hp[Tg++]=p,hp[Tg++]=b,hp[Tg++]=v,yy|=v,o.lanes|=v,o=o.alternate,o!==null&&(o.lanes|=v)}function wy(o,p,b,v){return ab(o,p,b,v),ob(o)}function Hg(o,p){return ab(o,null,null,p),ob(o)}function Iw(o,p,b){o.lanes|=b;var v=o.alternate;v!==null&&(v.lanes|=b);for(var O=!1,$=o.return;$!==null;)$.childLanes|=b,v=$.alternate,v!==null&&(v.childLanes|=b),$.tag===22&&(o=$.stateNode,o===null||o._visibility&1||(O=!0)),o=$,$=$.return;return o.tag===3?($=o.stateNode,O&&p!==null&&(O=31-ui(b),o=$.hiddenUpdates,v=o[O],v===null?o[O]=[p]:v.push(p),p.lane=b|536870912),$):null}function ob(o){if(50<ty)throw ty=0,xw=null,Error(s(185));for(var p=o.return;p!==null;)o=p,p=o.return;return o.tag===3?o.stateNode:null}var Kg={};function Sx(o,p,b,v){this.tag=o,this.key=b,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=p,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=v,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function a_(o,p,b,v){return new Sx(o,p,b,v)}function lb(o){return o=o.prototype,!(!o||!o.isReactComponent)}function z_(o,p){var b=o.alternate;return b===null?(b=a_(o.tag,p,o.key,o.mode),b.elementType=o.elementType,b.type=o.type,b.stateNode=o.stateNode,b.alternate=o,o.alternate=b):(b.pendingProps=p,b.type=o.type,b.flags=0,b.subtreeFlags=0,b.deletions=null),b.flags=o.flags&65011712,b.childLanes=o.childLanes,b.lanes=o.lanes,b.child=o.child,b.memoizedProps=o.memoizedProps,b.memoizedState=o.memoizedState,b.updateQueue=o.updateQueue,p=o.dependencies,b.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext},b.sibling=o.sibling,b.index=o.index,b.ref=o.ref,b.refCleanup=o.refCleanup,b}function Dw(o,p){o.flags&=65011714;var b=o.alternate;return b===null?(o.childLanes=0,o.lanes=p,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=b.childLanes,o.lanes=b.lanes,o.child=b.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=b.memoizedProps,o.memoizedState=b.memoizedState,o.updateQueue=b.updateQueue,o.type=b.type,p=b.dependencies,o.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext}),o}function t0(o,p,b,v,O,$){var ae=0;if(v=o,typeof o=="function")lb(o)&&(ae=1);else if(typeof o=="string")ae=mT(o,b,ue.current)?26:o==="html"||o==="head"||o==="body"?27:5;else e:switch(o){case D:return o=a_(31,b,p,O),o.elementType=D,o.lanes=$,o;case f:return Yg(b.children,O,$,p);case g:ae=8,O|=24;break;case w:return o=a_(12,b,p,O|2),o.elementType=w,o.lanes=$,o;case E:return o=a_(13,b,p,O),o.elementType=E,o.lanes=$,o;case A:return o=a_(19,b,p,O),o.elementType=A,o.lanes=$,o;default:if(typeof o=="object"&&o!==null)switch(o.$$typeof){case y:case S:ae=10;break e;case x:ae=9;break e;case T:ae=11;break e;case C:ae=14;break e;case I:ae=16,v=null;break e}ae=29,b=Error(s(130,o===null?"null":typeof o,"")),v=null}return p=a_(ae,b,p,O),p.elementType=o,p.type=v,p.lanes=$,p}function Yg(o,p,b,v){return o=a_(7,o,v,p),o.lanes=b,o}function xy(o,p,b){return o=a_(6,o,null,p),o.lanes=b,o}function ub(o,p,b){return p=a_(4,o.children!==null?o.children:[],o.key,p),p.lanes=b,p.stateNode={containerInfo:o.containerInfo,pendingChildren:null,implementation:o.implementation},p}var y1=[],w1=0,n0=null,cb=0,h_=[],o_=0,Xg=null,B_=1,A_="";function Qg(o,p){y1[w1++]=cb,y1[w1++]=n0,n0=o,cb=p}function Lw(o,p,b){h_[o_++]=B_,h_[o_++]=A_,h_[o_++]=Xg,Xg=o;var v=B_;o=A_;var O=32-ui(v)-1;v&=~(1<<O),b+=1;var $=32-ui(p)+O;if(30<$){var ae=O-O%5;$=(v&(1<<ae)-1).toString(32),v>>=ae,O-=ae,B_=1<<32-ui(p)+O|b<<O|v,A_=$+o}else B_=1<<$|b<<O|v,A_=o}function db(o){o.return!==null&&(Qg(o,1),Lw(o,1,0))}function vy(o){for(;o===n0;)n0=y1[--w1],y1[w1]=null,cb=y1[--w1],y1[w1]=null;for(;o===Xg;)Xg=h_[--o_],h_[o_]=null,A_=h_[--o_],h_[o_]=null,B_=h_[--o_],h_[o_]=null}var eh=null,Zc=null,kc=!1,Zg=null,y_=!1,Ty=Error(s(519));function Jg(o){var p=Error(s(418,""));throw s0(Ic(p,o)),Ty}function My(o){var p=o.stateNode,b=o.type,v=o.memoizedProps;switch(p[ve]=o,p[Ke]=v,b){case"dialog":ye("cancel",p),ye("close",p);break;case"iframe":case"object":case"embed":ye("load",p);break;case"video":case"audio":for(b=0;b<k0.length;b++)ye(k0[b],p);break;case"source":ye("error",p);break;case"img":case"image":case"link":ye("error",p),ye("load",p);break;case"details":ye("toggle",p);break;case"input":ye("invalid",p),T_(p,v.value,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name,!0),Ac(p);break;case"select":ye("invalid",p);break;case"textarea":ye("invalid",p),$e(p,v.value,v.defaultValue,v.children),Ac(p)}b=v.children,typeof b!="string"&&typeof b!="number"&&typeof b!="bigint"||p.textContent===""+b||v.suppressHydrationWarning===!0||Gi(p.textContent,b)?(v.popover!=null&&(ye("beforetoggle",p),ye("toggle",p)),v.onScroll!=null&&ye("scroll",p),v.onScrollEnd!=null&&ye("scrollend",p),v.onClick!=null&&(p.onclick=Ni),p=!0):p=!1,p||Jg(o)}function $w(o){for(eh=o.return;eh;)switch(eh.tag){case 5:case 13:y_=!1;return;case 27:case 3:y_=!0;return;default:eh=eh.return}}function r0(o){if(o!==eh)return!1;if(!kc)return $w(o),kc=!0,!1;var p=o.tag,b;if((b=p!==3&&p!==27)&&((b=p===5)&&(b=o.type,b=!(b!=="form"&&b!=="button")||Rg(o.type,o.memoizedProps)),b=!b),b&&Zc&&Jg(o),$w(o),p===13){if(o=o.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(s(317));e:{for(o=o.nextSibling,p=0;o;){if(o.nodeType===8)if(b=o.data,b==="/$"){if(p===0){Zc=__(o.nextSibling);break e}p--}else b!=="$"&&b!=="$!"&&b!=="$?"||p++;o=o.nextSibling}Zc=null}}else p===27?(p=Zc,Pc(o.type)?(o=ay,ay=null,Zc=o):Zc=p):Zc=eh?__(o.stateNode.nextSibling):null;return!0}function x1(){Zc=eh=null,kc=!1}function Fw(){var o=Zg;return o!==null&&(e_===null?e_=o:e_.push.apply(e_,o),Zg=null),o}function s0(o){Zg===null?Zg=[o]:Zg.push(o)}var pb=K(null),e1=null,j_=null;function Mg(o,p,b){de(pb,p._currentValue),p._currentValue=b}function U_(o){o._currentValue=pb.current,Q(pb)}function fb(o,p,b){for(;o!==null;){var v=o.alternate;if((o.childLanes&p)!==p?(o.childLanes|=p,v!==null&&(v.childLanes|=p)):v!==null&&(v.childLanes&p)!==p&&(v.childLanes|=p),o===b)break;o=o.return}}function Ey(o,p,b,v){var O=o.child;for(O!==null&&(O.return=o);O!==null;){var $=O.dependencies;if($!==null){var ae=O.child;$=$.firstContext;e:for(;$!==null;){var Te=$;$=O;for(var dt=0;dt<p.length;dt++)if(Te.context===p[dt]){$.lanes|=b,Te=$.alternate,Te!==null&&(Te.lanes|=b),fb($.return,b,o),v||(ae=null);break e}$=Te.next}}else if(O.tag===18){if(ae=O.return,ae===null)throw Error(s(341));ae.lanes|=b,$=ae.alternate,$!==null&&($.lanes|=b),fb(ae,b,o),ae=null}else ae=O.child;if(ae!==null)ae.return=O;else for(ae=O;ae!==null;){if(ae===o){ae=null;break}if(O=ae.sibling,O!==null){O.return=ae.return,ae=O;break}ae=ae.return}O=ae}}function i0(o,p,b,v){o=null;for(var O=p,$=!1;O!==null;){if(!$){if((O.flags&524288)!==0)$=!0;else if((O.flags&262144)!==0)break}if(O.tag===10){var ae=O.alternate;if(ae===null)throw Error(s(387));if(ae=ae.memoizedProps,ae!==null){var Te=O.type;Tp(O.pendingProps.value,ae.value)||(o!==null?o.push(Te):o=[Te])}}else if(O===Gt.current){if(ae=O.alternate,ae===null)throw Error(s(387));ae.memoizedState.memoizedState!==O.memoizedState.memoizedState&&(o!==null?o.push(wx):o=[wx])}O=O.return}o!==null&&Ey(p,o,b,v),p.flags|=262144}function a0(o){for(o=o.firstContext;o!==null;){if(!Tp(o.context._currentValue,o.memoizedValue))return!0;o=o.next}return!1}function t1(o){e1=o,j_=null,o=o.dependencies,o!==null&&(o.firstContext=null)}function zp(o){return Nw(e1,o)}function o0(o,p){return e1===null&&t1(o),Nw(o,p)}function Nw(o,p){var b=p._currentValue;if(p={context:p,memoizedValue:b,next:null},j_===null){if(o===null)throw Error(s(308));j_=p,o.dependencies={lanes:0,firstContext:p},o.flags|=524288}else j_=j_.next=p;return b}var Px=typeof AbortController<"u"?AbortController:function(){var o=[],p=this.signal={aborted:!1,addEventListener:function(b,v){o.push(v)}};this.abort=function(){p.aborted=!0,o.forEach(function(b){return b()})}},Rw=n.unstable_scheduleCallback,Ax=n.unstable_NormalPriority,wp={$$typeof:S,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function hb(){return{controller:new Px,data:new Map,refCount:0}}function l0(o){o.refCount--,o.refCount===0&&Rw(Ax,function(){o.controller.abort()})}var u0=null,_b=0,v1=0,T1=null;function zw(o,p){if(u0===null){var b=u0=[];_b=0,v1=No(),T1={status:"pending",value:void 0,then:function(v){b.push(v)}}}return _b++,p.then(Bw,Bw),p}function Bw(){if(--_b===0&&u0!==null){T1!==null&&(T1.status="fulfilled");var o=u0;u0=null,v1=0,T1=null;for(var p=0;p<o.length;p++)(0,o[p])()}}function Cx(o,p){var b=[],v={status:"pending",value:null,reason:null,then:function(O){b.push(O)}};return o.then(function(){v.status="fulfilled",v.value=p;for(var O=0;O<b.length;O++)(0,b[O])(p)},function(O){for(v.status="rejected",v.reason=O,O=0;O<b.length;O++)(0,b[O])(void 0)}),v}var jw=z.S;z.S=function(o,p){typeof p=="object"&&p!==null&&typeof p.then=="function"&&zw(o,p),jw!==null&&jw(o,p)};var n1=K(null);function mb(){var o=n1.current;return o!==null?o:Vc.pooledCache}function gb(o,p){p===null?de(n1,n1.current):de(n1,p.pool)}function Uw(){var o=mb();return o===null?null:{parent:wp._currentValue,pool:o}}var c0=Error(s(460)),Vw=Error(s(474)),d0=Error(s(542)),Sy={then:function(){}};function Gw(o){return o=o.status,o==="fulfilled"||o==="rejected"}function bb(){}function Ww(o,p,b){switch(b=o[b],b===void 0?o.push(p):b!==p&&(p.then(bb,bb),p=b),p.status){case"fulfilled":return p.value;case"rejected":throw o=p.reason,Hw(o),o;default:if(typeof p.status=="string")p.then(bb,bb);else{if(o=Vc,o!==null&&100<o.shellSuspendCounter)throw Error(s(482));o=p,o.status="pending",o.then(function(v){if(p.status==="pending"){var O=p;O.status="fulfilled",O.value=v}},function(v){if(p.status==="pending"){var O=p;O.status="rejected",O.reason=v}})}switch(p.status){case"fulfilled":return p.value;case"rejected":throw o=p.reason,Hw(o),o}throw M1=p,c0}}var M1=null;function qw(){if(M1===null)throw Error(s(459));var o=M1;return M1=null,o}function Hw(o){if(o===c0||o===d0)throw Error(s(483))}var Eg=!1;function Py(o){o.updateQueue={baseState:o.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function yb(o,p){o=o.updateQueue,p.updateQueue===o&&(p.updateQueue={baseState:o.baseState,firstBaseUpdate:o.firstBaseUpdate,lastBaseUpdate:o.lastBaseUpdate,shared:o.shared,callbacks:null})}function Sg(o){return{lane:o,tag:0,payload:null,callback:null,next:null}}function Pg(o,p,b){var v=o.updateQueue;if(v===null)return null;if(v=v.shared,($c&2)!==0){var O=v.pending;return O===null?p.next=p:(p.next=O.next,O.next=p),v.pending=p,p=ob(o),Iw(o,null,b),p}return ab(o,v,p,b),ob(o)}function E1(o,p,b){if(p=p.updateQueue,p!==null&&(p=p.shared,(b&4194048)!==0)){var v=p.lanes;v&=o.pendingLanes,b|=v,p.lanes=b,Ri(o,b)}}function Ay(o,p){var b=o.updateQueue,v=o.alternate;if(v!==null&&(v=v.updateQueue,b===v)){var O=null,$=null;if(b=b.firstBaseUpdate,b!==null){do{var ae={lane:b.lane,tag:b.tag,payload:b.payload,callback:null,next:null};$===null?O=$=ae:$=$.next=ae,b=b.next}while(b!==null);$===null?O=$=p:$=$.next=p}else O=$=p;b={baseState:v.baseState,firstBaseUpdate:O,lastBaseUpdate:$,shared:v.shared,callbacks:v.callbacks},o.updateQueue=b;return}o=b.lastBaseUpdate,o===null?b.firstBaseUpdate=p:o.next=p,b.lastBaseUpdate=p}var Cy=!1;function S1(){if(Cy){var o=T1;if(o!==null)throw o}}function p0(o,p,b,v){Cy=!1;var O=o.updateQueue;Eg=!1;var $=O.firstBaseUpdate,ae=O.lastBaseUpdate,Te=O.shared.pending;if(Te!==null){O.shared.pending=null;var dt=Te,wn=dt.next;dt.next=null,ae===null?$=wn:ae.next=wn,ae=dt;var dr=o.alternate;dr!==null&&(dr=dr.updateQueue,Te=dr.lastBaseUpdate,Te!==ae&&(Te===null?dr.firstBaseUpdate=wn:Te.next=wn,dr.lastBaseUpdate=dt))}if($!==null){var ni=O.baseState;ae=0,dr=wn=dt=null,Te=$;do{var Pn=Te.lane&-536870913,Cn=Pn!==Te.lane;if(Cn?(vc&Pn)===Pn:(v&Pn)===Pn){Pn!==0&&Pn===v1&&(Cy=!0),dr!==null&&(dr=dr.next={lane:0,tag:Te.tag,payload:Te.payload,callback:null,next:null});e:{var Go=o,Bo=Te;Pn=p;var qc=b;switch(Bo.tag){case 1:if(Go=Bo.payload,typeof Go=="function"){ni=Go.call(qc,ni,Pn);break e}ni=Go;break e;case 3:Go.flags=Go.flags&-65537|128;case 0:if(Go=Bo.payload,Pn=typeof Go=="function"?Go.call(qc,ni,Pn):Go,Pn==null)break e;ni=h({},ni,Pn);break e;case 2:Eg=!0}}Pn=Te.callback,Pn!==null&&(o.flags|=64,Cn&&(o.flags|=8192),Cn=O.callbacks,Cn===null?O.callbacks=[Pn]:Cn.push(Pn))}else Cn={lane:Pn,tag:Te.tag,payload:Te.payload,callback:Te.callback,next:null},dr===null?(wn=dr=Cn,dt=ni):dr=dr.next=Cn,ae|=Pn;if(Te=Te.next,Te===null){if(Te=O.shared.pending,Te===null)break;Cn=Te,Te=Cn.next,Cn.next=null,O.lastBaseUpdate=Cn,O.shared.pending=null}}while(!0);dr===null&&(dt=ni),O.baseState=dt,O.firstBaseUpdate=wn,O.lastBaseUpdate=dr,$===null&&(O.shared.lanes=0),$g|=ae,o.lanes=ae,o.memoizedState=ni}}function Kw(o,p){if(typeof o!="function")throw Error(s(191,o));o.call(p)}function ky(o,p){var b=o.callbacks;if(b!==null)for(o.callbacks=null,o=0;o<b.length;o++)Kw(b[o],p)}var P1=K(null),wb=K(0);function Oy(o,p){o=Y_,de(wb,o),de(P1,p),Y_=o|p.baseLanes}function Iy(){de(wb,Y_),de(P1,P1.current)}function Dy(){Y_=wb.current,Q(P1),Q(wb)}var C_=0,Yo=null,jc=null,ap=null,f0=!1,A1=!1,Ag=!1,xb=0,h0=0,V_=null,Yw=0;function op(){throw Error(s(321))}function Ly(o,p){if(p===null)return!1;for(var b=0;b<p.length&&b<o.length;b++)if(!Tp(o[b],p[b]))return!1;return!0}function $y(o,p,b,v,O,$){return C_=$,Yo=p,p.memoizedState=null,p.updateQueue=null,p.lanes=0,z.H=o===null||o.memoizedState===null?E2:S2,Ag=!1,$=b(v,O),Ag=!1,A1&&($=Xw(p,b,v,O)),Fy(o),$}function Fy(o){z.H=b0;var p=jc!==null&&jc.next!==null;if(C_=0,ap=jc=Yo=null,f0=!1,h0=0,V_=null,p)throw Error(s(300));o===null||Ep||(o=o.dependencies,o!==null&&a0(o)&&(Ep=!0))}function Xw(o,p,b,v){Yo=o;var O=0;do{if(A1&&(V_=null),h0=0,A1=!1,25<=O)throw Error(s(301));if(O+=1,ap=jc=null,o.updateQueue!=null){var $=o.updateQueue;$.lastEffect=null,$.events=null,$.stores=null,$.memoCache!=null&&($.memoCache.index=0)}z.H=Lx,$=p(b,v)}while(A1);return $}function kx(){var o=z.H,p=o.useState()[0];return p=typeof p.then=="function"?_0(p):p,o=o.useState()[0],(jc!==null?jc.memoizedState:null)!==o&&(Yo.flags|=1024),p}function Ny(){var o=xb!==0;return xb=0,o}function vb(o,p,b){p.updateQueue=o.updateQueue,p.flags&=-2053,o.lanes&=~b}function Ry(o){if(f0){for(o=o.memoizedState;o!==null;){var p=o.queue;p!==null&&(p.pending=null),o=o.next}f0=!1}C_=0,ap=jc=Yo=null,A1=!1,h0=xb=0,V_=null}function n_(){var o={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return ap===null?Yo.memoizedState=ap=o:ap=ap.next=o,ap}function lp(){if(jc===null){var o=Yo.alternate;o=o!==null?o.memoizedState:null}else o=jc.next;var p=ap===null?Yo.memoizedState:ap.next;if(p!==null)ap=p,jc=o;else{if(o===null)throw Yo.alternate===null?Error(s(467)):Error(s(310));jc=o,o={memoizedState:jc.memoizedState,baseState:jc.baseState,baseQueue:jc.baseQueue,queue:jc.queue,next:null},ap===null?Yo.memoizedState=ap=o:ap=ap.next=o}return ap}function zy(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function _0(o){var p=h0;return h0+=1,V_===null&&(V_=[]),o=Ww(V_,o,p),p=Yo,(ap===null?p.memoizedState:ap.next)===null&&(p=p.alternate,z.H=p===null||p.memoizedState===null?E2:S2),o}function Tb(o){if(o!==null&&typeof o=="object"){if(typeof o.then=="function")return _0(o);if(o.$$typeof===S)return zp(o)}throw Error(s(438,String(o)))}function Mb(o){var p=null,b=Yo.updateQueue;if(b!==null&&(p=b.memoCache),p==null){var v=Yo.alternate;v!==null&&(v=v.updateQueue,v!==null&&(v=v.memoCache,v!=null&&(p={data:v.data.map(function(O){return O.slice()}),index:0})))}if(p==null&&(p={data:[],index:0}),b===null&&(b=zy(),Yo.updateQueue=b),b.memoCache=p,b=p.data[p.index],b===void 0)for(b=p.data[p.index]=Array(o),v=0;v<o;v++)b[v]=R;return p.index++,b}function G_(o,p){return typeof p=="function"?p(o):p}function Eb(o){var p=lp();return Sb(p,jc,o)}function Sb(o,p,b){var v=o.queue;if(v===null)throw Error(s(311));v.lastRenderedReducer=b;var O=o.baseQueue,$=v.pending;if($!==null){if(O!==null){var ae=O.next;O.next=$.next,$.next=ae}p.baseQueue=O=$,v.pending=null}if($=o.baseState,O===null)o.memoizedState=$;else{p=O.next;var Te=ae=null,dt=null,wn=p,dr=!1;do{var ni=wn.lane&-536870913;if(ni!==wn.lane?(vc&ni)===ni:(C_&ni)===ni){var Pn=wn.revertLane;if(Pn===0)dt!==null&&(dt=dt.next={lane:0,revertLane:0,action:wn.action,hasEagerState:wn.hasEagerState,eagerState:wn.eagerState,next:null}),ni===v1&&(dr=!0);else if((C_&Pn)===Pn){wn=wn.next,Pn===v1&&(dr=!0);continue}else ni={lane:0,revertLane:wn.revertLane,action:wn.action,hasEagerState:wn.hasEagerState,eagerState:wn.eagerState,next:null},dt===null?(Te=dt=ni,ae=$):dt=dt.next=ni,Yo.lanes|=Pn,$g|=Pn;ni=wn.action,Ag&&b($,ni),$=wn.hasEagerState?wn.eagerState:b($,ni)}else Pn={lane:ni,revertLane:wn.revertLane,action:wn.action,hasEagerState:wn.hasEagerState,eagerState:wn.eagerState,next:null},dt===null?(Te=dt=Pn,ae=$):dt=dt.next=Pn,Yo.lanes|=ni,$g|=ni;wn=wn.next}while(wn!==null&&wn!==p);if(dt===null?ae=$:dt.next=Te,!Tp($,o.memoizedState)&&(Ep=!0,dr&&(b=T1,b!==null)))throw b;o.memoizedState=$,o.baseState=ae,o.baseQueue=dt,v.lastRenderedState=$}return O===null&&(v.lanes=0),[o.memoizedState,v.dispatch]}function By(o){var p=lp(),b=p.queue;if(b===null)throw Error(s(311));b.lastRenderedReducer=o;var v=b.dispatch,O=b.pending,$=p.memoizedState;if(O!==null){b.pending=null;var ae=O=O.next;do $=o($,ae.action),ae=ae.next;while(ae!==O);Tp($,p.memoizedState)||(Ep=!0),p.memoizedState=$,p.baseQueue===null&&(p.baseState=$),b.lastRenderedState=$}return[$,v]}function Qw(o,p,b){var v=Yo,O=lp(),$=kc;if($){if(b===void 0)throw Error(s(407));b=b()}else b=p();var ae=!Tp((jc||O).memoizedState,b);ae&&(O.memoizedState=b,Ep=!0),O=O.queue;var Te=Jw.bind(null,v,O,o);if(m0(2048,8,Te,[o]),O.getSnapshot!==p||ae||ap!==null&&ap.memoizedState.tag&1){if(v.flags|=2048,C1(9,Cb(),Zw.bind(null,v,O,b,p),null),Vc===null)throw Error(s(349));$||(C_&124)!==0||jy(v,p,b)}return b}function jy(o,p,b){o.flags|=16384,o={getSnapshot:p,value:b},p=Yo.updateQueue,p===null?(p=zy(),Yo.updateQueue=p,p.stores=[o]):(b=p.stores,b===null?p.stores=[o]:b.push(o))}function Zw(o,p,b,v){p.value=b,p.getSnapshot=v,Pb(p)&&e2(o)}function Jw(o,p,b){return b(function(){Pb(p)&&e2(o)})}function Pb(o){var p=o.getSnapshot;o=o.value;try{var b=p();return!Tp(o,b)}catch{return!0}}function e2(o){var p=Hg(o,2);p!==null&&Dp(p,o,2)}function Uy(o){var p=n_();if(typeof o=="function"){var b=o;if(o=b(),Ag){fi(!0);try{b()}finally{fi(!1)}}}return p.memoizedState=p.baseState=o,p.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:G_,lastRenderedState:o},p}function t2(o,p,b,v){return o.baseState=b,Sb(o,jc,typeof v=="function"?v:G_)}function n2(o,p,b,v,O){if(Ib(o))throw Error(s(485));if(o=p.action,o!==null){var $={payload:O,action:o,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(ae){$.listeners.push(ae)}};z.T!==null?b(!0):$.isTransition=!1,v($),b=p.pending,b===null?($.next=p.pending=$,r2(p,$)):($.next=b.next,p.pending=b.next=$)}}function r2(o,p){var b=p.action,v=p.payload,O=o.state;if(p.isTransition){var $=z.T,ae={};z.T=ae;try{var Te=b(O,v),dt=z.S;dt!==null&&dt(ae,Te),s2(o,p,Te)}catch(wn){Gy(o,p,wn)}finally{z.T=$}}else try{$=b(O,v),s2(o,p,$)}catch(wn){Gy(o,p,wn)}}function s2(o,p,b){b!==null&&typeof b=="object"&&typeof b.then=="function"?b.then(function(v){Vy(o,p,v)},function(v){return Gy(o,p,v)}):Vy(o,p,b)}function Vy(o,p,b){p.status="fulfilled",p.value=b,i2(p),o.state=b,p=o.pending,p!==null&&(b=p.next,b===p?o.pending=null:(b=b.next,p.next=b,r2(o,b)))}function Gy(o,p,b){var v=o.pending;if(o.pending=null,v!==null){v=v.next;do p.status="rejected",p.reason=b,i2(p),p=p.next;while(p!==v)}o.action=null}function i2(o){o=o.listeners;for(var p=0;p<o.length;p++)(0,o[p])()}function a2(o,p){return p}function o2(o,p){if(kc){var b=Vc.formState;if(b!==null){e:{var v=Yo;if(kc){if(Zc){t:{for(var O=Zc,$=y_;O.nodeType!==8;){if(!$){O=null;break t}if(O=__(O.nextSibling),O===null){O=null;break t}}$=O.data,O=$==="F!"||$==="F"?O:null}if(O){Zc=__(O.nextSibling),v=O.data==="F!";break e}}Jg(v)}v=!1}v&&(p=b[0])}}return b=n_(),b.memoizedState=b.baseState=p,v={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a2,lastRenderedState:p},b.queue=v,b=v2.bind(null,Yo,v),v.dispatch=b,v=Uy(!1),$=Zy.bind(null,Yo,!1,v.queue),v=n_(),O={state:p,dispatch:null,action:o,pending:null},v.queue=O,b=n2.bind(null,Yo,O,$,b),O.dispatch=b,v.memoizedState=o,[p,b,!1]}function Ab(o){var p=lp();return l2(p,jc,o)}function l2(o,p,b){if(p=Sb(o,p,a2)[0],o=Eb(G_)[0],typeof p=="object"&&p!==null&&typeof p.then=="function")try{var v=_0(p)}catch(ae){throw ae===c0?d0:ae}else v=p;p=lp();var O=p.queue,$=O.dispatch;return b!==p.memoizedState&&(Yo.flags|=2048,C1(9,Cb(),Ox.bind(null,O,b),null)),[v,$,o]}function Ox(o,p){o.action=p}function u2(o){var p=lp(),b=jc;if(b!==null)return l2(p,b,o);lp(),p=p.memoizedState,b=lp();var v=b.queue.dispatch;return b.memoizedState=o,[p,v,!1]}function C1(o,p,b,v){return o={tag:o,create:b,deps:v,inst:p,next:null},p=Yo.updateQueue,p===null&&(p=zy(),Yo.updateQueue=p),b=p.lastEffect,b===null?p.lastEffect=o.next=o:(v=b.next,b.next=o,o.next=v,p.lastEffect=o),o}function Cb(){return{destroy:void 0,resource:void 0}}function c2(){return lp().memoizedState}function kb(o,p,b,v){var O=n_();v=v===void 0?null:v,Yo.flags|=o,O.memoizedState=C1(1|p,Cb(),b,v)}function m0(o,p,b,v){var O=lp();v=v===void 0?null:v;var $=O.memoizedState.inst;jc!==null&&v!==null&&Ly(v,jc.memoizedState.deps)?O.memoizedState=C1(p,$,b,v):(Yo.flags|=o,O.memoizedState=C1(1|p,$,b,v))}function d2(o,p){kb(8390656,8,o,p)}function Wy(o,p){m0(2048,8,o,p)}function p2(o,p){return m0(4,2,o,p)}function f2(o,p){return m0(4,4,o,p)}function qy(o,p){if(typeof p=="function"){o=o();var b=p(o);return function(){typeof b=="function"?b():p(null)}}if(p!=null)return o=o(),p.current=o,function(){p.current=null}}function h2(o,p,b){b=b!=null?b.concat([o]):null,m0(4,4,qy.bind(null,p,o),b)}function Hy(){}function _2(o,p){var b=lp();p=p===void 0?null:p;var v=b.memoizedState;return p!==null&&Ly(p,v[1])?v[0]:(b.memoizedState=[o,p],o)}function m2(o,p){var b=lp();p=p===void 0?null:p;var v=b.memoizedState;if(p!==null&&Ly(p,v[1]))return v[0];if(v=o(),Ag){fi(!0);try{o()}finally{fi(!1)}}return b.memoizedState=[v,p],v}function Ob(o,p,b){return b===void 0||(C_&1073741824)!==0?o.memoizedState=p:(o.memoizedState=b,o=ix(),Yo.lanes|=o,$g|=o,b)}function g2(o,p,b,v){return Tp(b,p)?b:P1.current!==null?(o=Ob(o,b,v),Tp(o,p)||(Ep=!0),o):(C_&42)===0?(Ep=!0,o.memoizedState=b):(o=ix(),Yo.lanes|=o,$g|=o,p)}function b2(o,p,b,v,O){var $=H.p;H.p=$!==0&&8>$?$:8;var ae=z.T,Te={};z.T=Te,Zy(o,!1,p,b);try{var dt=O(),wn=z.S;if(wn!==null&&wn(Te,dt),dt!==null&&typeof dt=="object"&&typeof dt.then=="function"){var dr=Cx(dt,v);g0(o,p,dr,c_(o))}else g0(o,p,v,c_(o))}catch(ni){g0(o,p,{then:function(){},status:"rejected",reason:ni},c_())}finally{H.p=$,z.T=ae}}function y2(){}function Ky(o,p,b,v){if(o.tag!==5)throw Error(s(476));var O=w2(o).queue;b2(o,O,p,he,b===null?y2:function(){return Yy(o),b(v)})}function w2(o){var p=o.memoizedState;if(p!==null)return p;p={memoizedState:he,baseState:he,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:G_,lastRenderedState:he},next:null};var b={};return p.next={memoizedState:b,baseState:b,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:G_,lastRenderedState:b},next:null},o.memoizedState=p,o=o.alternate,o!==null&&(o.memoizedState=p),p}function Yy(o){var p=w2(o).next.queue;g0(o,p,{},c_())}function Xy(){return zp(wx)}function x2(){return lp().memoizedState}function Qy(){return lp().memoizedState}function Ix(o){for(var p=o.return;p!==null;){switch(p.tag){case 24:case 3:var b=c_();o=Sg(b);var v=Pg(p,o,b);v!==null&&(Dp(v,p,b),E1(v,p,b)),p={cache:hb()},o.payload=p;return}p=p.return}}function Dx(o,p,b){var v=c_();b={lane:v,revertLane:0,action:b,hasEagerState:!1,eagerState:null,next:null},Ib(o)?T2(p,b):(b=wy(o,p,b,v),b!==null&&(Dp(b,o,v),M2(b,p,v)))}function v2(o,p,b){var v=c_();g0(o,p,b,v)}function g0(o,p,b,v){var O={lane:v,revertLane:0,action:b,hasEagerState:!1,eagerState:null,next:null};if(Ib(o))T2(p,O);else{var $=o.alternate;if(o.lanes===0&&($===null||$.lanes===0)&&($=p.lastRenderedReducer,$!==null))try{var ae=p.lastRenderedState,Te=$(ae,b);if(O.hasEagerState=!0,O.eagerState=Te,Tp(Te,ae))return ab(o,p,O,0),Vc===null&&e0(),!1}catch{}finally{}if(b=wy(o,p,O,v),b!==null)return Dp(b,o,v),M2(b,p,v),!0}return!1}function Zy(o,p,b,v){if(v={lane:2,revertLane:No(),action:v,hasEagerState:!1,eagerState:null,next:null},Ib(o)){if(p)throw Error(s(479))}else p=wy(o,b,v,2),p!==null&&Dp(p,o,2)}function Ib(o){var p=o.alternate;return o===Yo||p!==null&&p===Yo}function T2(o,p){A1=f0=!0;var b=o.pending;b===null?p.next=p:(p.next=b.next,b.next=p),o.pending=p}function M2(o,p,b){if((b&4194048)!==0){var v=p.lanes;v&=o.pendingLanes,b|=v,p.lanes=b,Ri(o,b)}}var b0={readContext:zp,use:Tb,useCallback:op,useContext:op,useEffect:op,useImperativeHandle:op,useLayoutEffect:op,useInsertionEffect:op,useMemo:op,useReducer:op,useRef:op,useState:op,useDebugValue:op,useDeferredValue:op,useTransition:op,useSyncExternalStore:op,useId:op,useHostTransitionStatus:op,useFormState:op,useActionState:op,useOptimistic:op,useMemoCache:op,useCacheRefresh:op},E2={readContext:zp,use:Tb,useCallback:function(o,p){return n_().memoizedState=[o,p===void 0?null:p],o},useContext:zp,useEffect:d2,useImperativeHandle:function(o,p,b){b=b!=null?b.concat([o]):null,kb(4194308,4,qy.bind(null,p,o),b)},useLayoutEffect:function(o,p){return kb(4194308,4,o,p)},useInsertionEffect:function(o,p){kb(4,2,o,p)},useMemo:function(o,p){var b=n_();p=p===void 0?null:p;var v=o();if(Ag){fi(!0);try{o()}finally{fi(!1)}}return b.memoizedState=[v,p],v},useReducer:function(o,p,b){var v=n_();if(b!==void 0){var O=b(p);if(Ag){fi(!0);try{b(p)}finally{fi(!1)}}}else O=p;return v.memoizedState=v.baseState=O,o={pending:null,lanes:0,dispatch:null,lastRenderedReducer:o,lastRenderedState:O},v.queue=o,o=o.dispatch=Dx.bind(null,Yo,o),[v.memoizedState,o]},useRef:function(o){var p=n_();return o={current:o},p.memoizedState=o},useState:function(o){o=Uy(o);var p=o.queue,b=v2.bind(null,Yo,p);return p.dispatch=b,[o.memoizedState,b]},useDebugValue:Hy,useDeferredValue:function(o,p){var b=n_();return Ob(b,o,p)},useTransition:function(){var o=Uy(!1);return o=b2.bind(null,Yo,o.queue,!0,!1),n_().memoizedState=o,[!1,o]},useSyncExternalStore:function(o,p,b){var v=Yo,O=n_();if(kc){if(b===void 0)throw Error(s(407));b=b()}else{if(b=p(),Vc===null)throw Error(s(349));(vc&124)!==0||jy(v,p,b)}O.memoizedState=b;var $={value:b,getSnapshot:p};return O.queue=$,d2(Jw.bind(null,v,$,o),[o]),v.flags|=2048,C1(9,Cb(),Zw.bind(null,v,$,b,p),null),b},useId:function(){var o=n_(),p=Vc.identifierPrefix;if(kc){var b=A_,v=B_;b=(v&~(1<<32-ui(v)-1)).toString(32)+b,p="«"+p+"R"+b,b=xb++,0<b&&(p+="H"+b.toString(32)),p+="»"}else b=Yw++,p="«"+p+"r"+b.toString(32)+"»";return o.memoizedState=p},useHostTransitionStatus:Xy,useFormState:o2,useActionState:o2,useOptimistic:function(o){var p=n_();p.memoizedState=p.baseState=o;var b={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return p.queue=b,p=Zy.bind(null,Yo,!0,b),b.dispatch=p,[o,p]},useMemoCache:Mb,useCacheRefresh:function(){return n_().memoizedState=Ix.bind(null,Yo)}},S2={readContext:zp,use:Tb,useCallback:_2,useContext:zp,useEffect:Wy,useImperativeHandle:h2,useInsertionEffect:p2,useLayoutEffect:f2,useMemo:m2,useReducer:Eb,useRef:c2,useState:function(){return Eb(G_)},useDebugValue:Hy,useDeferredValue:function(o,p){var b=lp();return g2(b,jc.memoizedState,o,p)},useTransition:function(){var o=Eb(G_)[0],p=lp().memoizedState;return[typeof o=="boolean"?o:_0(o),p]},useSyncExternalStore:Qw,useId:x2,useHostTransitionStatus:Xy,useFormState:Ab,useActionState:Ab,useOptimistic:function(o,p){var b=lp();return t2(b,jc,o,p)},useMemoCache:Mb,useCacheRefresh:Qy},Lx={readContext:zp,use:Tb,useCallback:_2,useContext:zp,useEffect:Wy,useImperativeHandle:h2,useInsertionEffect:p2,useLayoutEffect:f2,useMemo:m2,useReducer:By,useRef:c2,useState:function(){return By(G_)},useDebugValue:Hy,useDeferredValue:function(o,p){var b=lp();return jc===null?Ob(b,o,p):g2(b,jc.memoizedState,o,p)},useTransition:function(){var o=By(G_)[0],p=lp().memoizedState;return[typeof o=="boolean"?o:_0(o),p]},useSyncExternalStore:Qw,useId:x2,useHostTransitionStatus:Xy,useFormState:u2,useActionState:u2,useOptimistic:function(o,p){var b=lp();return jc!==null?t2(b,jc,o,p):(b.baseState=o,[o,b.queue.dispatch])},useMemoCache:Mb,useCacheRefresh:Qy},k1=null,y0=0;function Db(o){var p=y0;return y0+=1,k1===null&&(k1=[]),Ww(k1,o,p)}function O1(o,p){p=p.props.ref,o.ref=p!==void 0?p:null}function Lb(o,p){throw p.$$typeof===i?Error(s(525)):(o=Object.prototype.toString.call(p),Error(s(31,o==="[object Object]"?"object with keys {"+Object.keys(p).join(", ")+"}":o)))}function P2(o){var p=o._init;return p(o._payload)}function Jy(o){function p(pn,St){if(o){var gn=pn.deletions;gn===null?(pn.deletions=[St],pn.flags|=16):gn.push(St)}}function b(pn,St){if(!o)return null;for(;St!==null;)p(pn,St),St=St.sibling;return null}function v(pn){for(var St=new Map;pn!==null;)pn.key!==null?St.set(pn.key,pn):St.set(pn.index,pn),pn=pn.sibling;return St}function O(pn,St){return pn=z_(pn,St),pn.index=0,pn.sibling=null,pn}function $(pn,St,gn){return pn.index=gn,o?(gn=pn.alternate,gn!==null?(gn=gn.index,gn<St?(pn.flags|=67108866,St):gn):(pn.flags|=67108866,St)):(pn.flags|=1048576,St)}function ae(pn){return o&&pn.alternate===null&&(pn.flags|=67108866),pn}function Te(pn,St,gn,ei){return St===null||St.tag!==6?(St=xy(gn,pn.mode,ei),St.return=pn,St):(St=O(St,gn),St.return=pn,St)}function dt(pn,St,gn,ei){var $i=gn.type;return $i===f?dr(pn,St,gn.props.children,ei,gn.key):St!==null&&(St.elementType===$i||typeof $i=="object"&&$i!==null&&$i.$$typeof===I&&P2($i)===St.type)?(St=O(St,gn.props),O1(St,gn),St.return=pn,St):(St=t0(gn.type,gn.key,gn.props,null,pn.mode,ei),O1(St,gn),St.return=pn,St)}function wn(pn,St,gn,ei){return St===null||St.tag!==4||St.stateNode.containerInfo!==gn.containerInfo||St.stateNode.implementation!==gn.implementation?(St=ub(gn,pn.mode,ei),St.return=pn,St):(St=O(St,gn.children||[]),St.return=pn,St)}function dr(pn,St,gn,ei,$i){return St===null||St.tag!==7?(St=Yg(gn,pn.mode,ei,$i),St.return=pn,St):(St=O(St,gn),St.return=pn,St)}function ni(pn,St,gn){if(typeof St=="string"&&St!==""||typeof St=="number"||typeof St=="bigint")return St=xy(""+St,pn.mode,gn),St.return=pn,St;if(typeof St=="object"&&St!==null){switch(St.$$typeof){case r:return gn=t0(St.type,St.key,St.props,null,pn.mode,gn),O1(gn,St),gn.return=pn,gn;case u:return St=ub(St,pn.mode,gn),St.return=pn,St;case I:var ei=St._init;return St=ei(St._payload),ni(pn,St,gn)}if(q(St)||re(St))return St=Yg(St,pn.mode,gn,null),St.return=pn,St;if(typeof St.then=="function")return ni(pn,Db(St),gn);if(St.$$typeof===S)return ni(pn,o0(pn,St),gn);Lb(pn,St)}return null}function Pn(pn,St,gn,ei){var $i=St!==null?St.key:null;if(typeof gn=="string"&&gn!==""||typeof gn=="number"||typeof gn=="bigint")return $i!==null?null:Te(pn,St,""+gn,ei);if(typeof gn=="object"&&gn!==null){switch(gn.$$typeof){case r:return gn.key===$i?dt(pn,St,gn,ei):null;case u:return gn.key===$i?wn(pn,St,gn,ei):null;case I:return $i=gn._init,gn=$i(gn._payload),Pn(pn,St,gn,ei)}if(q(gn)||re(gn))return $i!==null?null:dr(pn,St,gn,ei,null);if(typeof gn.then=="function")return Pn(pn,St,Db(gn),ei);if(gn.$$typeof===S)return Pn(pn,St,o0(pn,gn),ei);Lb(pn,gn)}return null}function Cn(pn,St,gn,ei,$i){if(typeof ei=="string"&&ei!==""||typeof ei=="number"||typeof ei=="bigint")return pn=pn.get(gn)||null,Te(St,pn,""+ei,$i);if(typeof ei=="object"&&ei!==null){switch(ei.$$typeof){case r:return pn=pn.get(ei.key===null?gn:ei.key)||null,dt(St,pn,ei,$i);case u:return pn=pn.get(ei.key===null?gn:ei.key)||null,wn(St,pn,ei,$i);case I:var xc=ei._init;return ei=xc(ei._payload),Cn(pn,St,gn,ei,$i)}if(q(ei)||re(ei))return pn=pn.get(gn)||null,dr(St,pn,ei,$i,null);if(typeof ei.then=="function")return Cn(pn,St,gn,Db(ei),$i);if(ei.$$typeof===S)return Cn(pn,St,gn,o0(St,ei),$i);Lb(St,ei)}return null}function Go(pn,St,gn,ei){for(var $i=null,xc=null,Vi=St,Uo=St=0,t_=null;Vi!==null&&Uo<gn.length;Uo++){Vi.index>Uo?(t_=Vi,Vi=null):t_=Vi.sibling;var Rc=Pn(pn,Vi,gn[Uo],ei);if(Rc===null){Vi===null&&(Vi=t_);break}o&&Vi&&Rc.alternate===null&&p(pn,Vi),St=$(Rc,St,Uo),xc===null?$i=Rc:xc.sibling=Rc,xc=Rc,Vi=t_}if(Uo===gn.length)return b(pn,Vi),kc&&Qg(pn,Uo),$i;if(Vi===null){for(;Uo<gn.length;Uo++)Vi=ni(pn,gn[Uo],ei),Vi!==null&&(St=$(Vi,St,Uo),xc===null?$i=Vi:xc.sibling=Vi,xc=Vi);return kc&&Qg(pn,Uo),$i}for(Vi=v(Vi);Uo<gn.length;Uo++)t_=Cn(Vi,pn,Uo,gn[Uo],ei),t_!==null&&(o&&t_.alternate!==null&&Vi.delete(t_.key===null?Uo:t_.key),St=$(t_,St,Uo),xc===null?$i=t_:xc.sibling=t_,xc=t_);return o&&Vi.forEach(function(B0){return p(pn,B0)}),kc&&Qg(pn,Uo),$i}function Bo(pn,St,gn,ei){if(gn==null)throw Error(s(151));for(var $i=null,xc=null,Vi=St,Uo=St=0,t_=null,Rc=gn.next();Vi!==null&&!Rc.done;Uo++,Rc=gn.next()){Vi.index>Uo?(t_=Vi,Vi=null):t_=Vi.sibling;var B0=Pn(pn,Vi,Rc.value,ei);if(B0===null){Vi===null&&(Vi=t_);break}o&&Vi&&B0.alternate===null&&p(pn,Vi),St=$(B0,St,Uo),xc===null?$i=B0:xc.sibling=B0,xc=B0,Vi=t_}if(Rc.done)return b(pn,Vi),kc&&Qg(pn,Uo),$i;if(Vi===null){for(;!Rc.done;Uo++,Rc=gn.next())Rc=ni(pn,Rc.value,ei),Rc!==null&&(St=$(Rc,St,Uo),xc===null?$i=Rc:xc.sibling=Rc,xc=Rc);return kc&&Qg(pn,Uo),$i}for(Vi=v(Vi);!Rc.done;Uo++,Rc=gn.next())Rc=Cn(Vi,pn,Uo,Rc.value,ei),Rc!==null&&(o&&Rc.alternate!==null&&Vi.delete(Rc.key===null?Uo:Rc.key),St=$(Rc,St,Uo),xc===null?$i=Rc:xc.sibling=Rc,xc=Rc);return o&&Vi.forEach(function(AT){return p(pn,AT)}),kc&&Qg(pn,Uo),$i}function qc(pn,St,gn,ei){if(typeof gn=="object"&&gn!==null&&gn.type===f&&gn.key===null&&(gn=gn.props.children),typeof gn=="object"&&gn!==null){switch(gn.$$typeof){case r:e:{for(var $i=gn.key;St!==null;){if(St.key===$i){if($i=gn.type,$i===f){if(St.tag===7){b(pn,St.sibling),ei=O(St,gn.props.children),ei.return=pn,pn=ei;break e}}else if(St.elementType===$i||typeof $i=="object"&&$i!==null&&$i.$$typeof===I&&P2($i)===St.type){b(pn,St.sibling),ei=O(St,gn.props),O1(ei,gn),ei.return=pn,pn=ei;break e}b(pn,St);break}else p(pn,St);St=St.sibling}gn.type===f?(ei=Yg(gn.props.children,pn.mode,ei,gn.key),ei.return=pn,pn=ei):(ei=t0(gn.type,gn.key,gn.props,null,pn.mode,ei),O1(ei,gn),ei.return=pn,pn=ei)}return ae(pn);case u:e:{for($i=gn.key;St!==null;){if(St.key===$i)if(St.tag===4&&St.stateNode.containerInfo===gn.containerInfo&&St.stateNode.implementation===gn.implementation){b(pn,St.sibling),ei=O(St,gn.children||[]),ei.return=pn,pn=ei;break e}else{b(pn,St);break}else p(pn,St);St=St.sibling}ei=ub(gn,pn.mode,ei),ei.return=pn,pn=ei}return ae(pn);case I:return $i=gn._init,gn=$i(gn._payload),qc(pn,St,gn,ei)}if(q(gn))return Go(pn,St,gn,ei);if(re(gn)){if($i=re(gn),typeof $i!="function")throw Error(s(150));return gn=$i.call(gn),Bo(pn,St,gn,ei)}if(typeof gn.then=="function")return qc(pn,St,Db(gn),ei);if(gn.$$typeof===S)return qc(pn,St,o0(pn,gn),ei);Lb(pn,gn)}return typeof gn=="string"&&gn!==""||typeof gn=="number"||typeof gn=="bigint"?(gn=""+gn,St!==null&&St.tag===6?(b(pn,St.sibling),ei=O(St,gn),ei.return=pn,pn=ei):(b(pn,St),ei=xy(gn,pn.mode,ei),ei.return=pn,pn=ei),ae(pn)):b(pn,St)}return function(pn,St,gn,ei){try{y0=0;var $i=qc(pn,St,gn,ei);return k1=null,$i}catch(Vi){if(Vi===c0||Vi===d0)throw Vi;var xc=a_(29,Vi,null,pn.mode);return xc.lanes=ei,xc.return=pn,xc}finally{}}}var I1=Jy(!0),A2=Jy(!1),Mp=K(null),k_=null;function Cg(o){var p=o.alternate;de(xp,xp.current&1),de(Mp,o),k_===null&&(p===null||P1.current!==null||p.memoizedState!==null)&&(k_=o)}function C2(o){if(o.tag===22){if(de(xp,xp.current),de(Mp,o),k_===null){var p=o.alternate;p!==null&&p.memoizedState!==null&&(k_=o)}}else kg()}function kg(){de(xp,xp.current),de(Mp,Mp.current)}function O_(o){Q(Mp),k_===o&&(k_=null),Q(xp)}var xp=K(0);function $b(o){for(var p=o;p!==null;){if(p.tag===13){var b=p.memoizedState;if(b!==null&&(b=b.dehydrated,b===null||b.data==="$?"||D0(b)))return p}else if(p.tag===19&&p.memoizedProps.revealOrder!==void 0){if((p.flags&128)!==0)return p}else if(p.child!==null){p.child.return=p,p=p.child;continue}if(p===o)break;for(;p.sibling===null;){if(p.return===null||p.return===o)return null;p=p.return}p.sibling.return=p.return,p=p.sibling}return null}function ew(o,p,b,v){p=o.memoizedState,b=b(v,p),b=b==null?p:h({},p,b),o.memoizedState=b,o.lanes===0&&(o.updateQueue.baseState=b)}var tw={enqueueSetState:function(o,p,b){o=o._reactInternals;var v=c_(),O=Sg(v);O.payload=p,b!=null&&(O.callback=b),p=Pg(o,O,v),p!==null&&(Dp(p,o,v),E1(p,o,v))},enqueueReplaceState:function(o,p,b){o=o._reactInternals;var v=c_(),O=Sg(v);O.tag=1,O.payload=p,b!=null&&(O.callback=b),p=Pg(o,O,v),p!==null&&(Dp(p,o,v),E1(p,o,v))},enqueueForceUpdate:function(o,p){o=o._reactInternals;var b=c_(),v=Sg(b);v.tag=2,p!=null&&(v.callback=p),p=Pg(o,v,b),p!==null&&(Dp(p,o,b),E1(p,o,b))}};function Fb(o,p,b,v,O,$,ae){return o=o.stateNode,typeof o.shouldComponentUpdate=="function"?o.shouldComponentUpdate(v,$,ae):p.prototype&&p.prototype.isPureReactComponent?!xg(b,v)||!xg(O,$):!0}function k2(o,p,b,v){o=p.state,typeof p.componentWillReceiveProps=="function"&&p.componentWillReceiveProps(b,v),typeof p.UNSAFE_componentWillReceiveProps=="function"&&p.UNSAFE_componentWillReceiveProps(b,v),p.state!==o&&tw.enqueueReplaceState(p,p.state,null)}function r1(o,p){var b=p;if("ref"in p){b={};for(var v in p)v!=="ref"&&(b[v]=p[v])}if(o=o.defaultProps){b===p&&(b=h({},b));for(var O in o)b[O]===void 0&&(b[O]=o[O])}return b}var Nb=typeof reportError=="function"?reportError:function(o){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var p=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof o=="object"&&o!==null&&typeof o.message=="string"?String(o.message):String(o),error:o});if(!window.dispatchEvent(p))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",o);return}console.error(o)};function w0(o){Nb(o)}function O2(o){console.error(o)}function I2(o){Nb(o)}function Rb(o,p){try{var b=o.onUncaughtError;b(p.value,{componentStack:p.stack})}catch(v){setTimeout(function(){throw v})}}function D2(o,p,b){try{var v=o.onCaughtError;v(b.value,{componentStack:b.stack,errorBoundary:p.tag===1?p.stateNode:null})}catch(O){setTimeout(function(){throw O})}}function x0(o,p,b){return b=Sg(b),b.tag=3,b.payload={element:null},b.callback=function(){Rb(o,p)},b}function L2(o){return o=Sg(o),o.tag=3,o}function $2(o,p,b,v){var O=b.type.getDerivedStateFromError;if(typeof O=="function"){var $=v.value;o.payload=function(){return O($)},o.callback=function(){D2(p,b,v)}}var ae=b.stateNode;ae!==null&&typeof ae.componentDidCatch=="function"&&(o.callback=function(){D2(p,b,v),typeof O!="function"&&(X_===null?X_=new Set([this]):X_.add(this));var Te=v.stack;this.componentDidCatch(v.value,{componentStack:Te!==null?Te:""})})}function $x(o,p,b,v,O){if(b.flags|=32768,v!==null&&typeof v=="object"&&typeof v.then=="function"){if(p=b.alternate,p!==null&&i0(p,b,O,!0),b=Mp.current,b!==null){switch(b.tag){case 13:return k_===null?Tw():b.alternate===null&&np===0&&(np=3),b.flags&=-257,b.flags|=65536,b.lanes=O,v===Sy?b.flags|=16384:(p=b.updateQueue,p===null?b.updateQueue=new Set([v]):p.add(v),dx(o,v,O)),!1;case 22:return b.flags|=65536,v===Sy?b.flags|=16384:(p=b.updateQueue,p===null?(p={transitions:null,markerInstances:null,retryQueue:new Set([v])},b.updateQueue=p):(b=p.retryQueue,b===null?p.retryQueue=new Set([v]):b.add(v)),dx(o,v,O)),!1}throw Error(s(435,b.tag))}return dx(o,v,O),Tw(),!1}if(kc)return p=Mp.current,p!==null?((p.flags&65536)===0&&(p.flags|=256),p.flags|=65536,p.lanes=O,v!==Ty&&(o=Error(s(422),{cause:v}),s0(Ic(o,b)))):(v!==Ty&&(p=Error(s(423),{cause:v}),s0(Ic(p,b))),o=o.current.alternate,o.flags|=65536,O&=-O,o.lanes|=O,v=Ic(v,b),O=x0(o.stateNode,v,O),Ay(o,O),np!==4&&(np=2)),!1;var $=Error(s(520),{cause:v});if($=Ic($,b),Qb===null?Qb=[$]:Qb.push($),np!==4&&(np=2),p===null)return!0;v=Ic(v,b),b=p;do{switch(b.tag){case 3:return b.flags|=65536,o=O&-O,b.lanes|=o,o=x0(b.stateNode,v,o),Ay(b,o),!1;case 1:if(p=b.type,$=b.stateNode,(b.flags&128)===0&&(typeof p.getDerivedStateFromError=="function"||$!==null&&typeof $.componentDidCatch=="function"&&(X_===null||!X_.has($))))return b.flags|=65536,O&=-O,b.lanes|=O,O=L2(O),$2(O,o,b,v),Ay(b,O),!1}b=b.return}while(b!==null);return!1}var Fx=Error(s(461)),Ep=!1;function Ip(o,p,b,v){p.child=o===null?A2(p,null,b,v):I1(p,o.child,b,v)}function F2(o,p,b,v,O){b=b.render;var $=p.ref;if("ref"in v){var ae={};for(var Te in v)Te!=="ref"&&(ae[Te]=v[Te])}else ae=v;return t1(p),v=$y(o,p,b,ae,$,O),Te=Ny(),o!==null&&!Ep?(vb(o,p,O),W_(o,p,O)):(kc&&Te&&db(p),p.flags|=1,Ip(o,p,v,O),p.child)}function D1(o,p,b,v,O){if(o===null){var $=b.type;return typeof $=="function"&&!lb($)&&$.defaultProps===void 0&&b.compare===null?(p.tag=15,p.type=$,N2(o,p,$,v,O)):(o=t0(b.type,null,v,p,p.mode,O),o.ref=p.ref,o.return=p,p.child=o)}if($=o.child,!lw(o,O)){var ae=$.memoizedProps;if(b=b.compare,b=b!==null?b:xg,b(ae,v)&&o.ref===p.ref)return W_(o,p,O)}return p.flags|=1,o=z_($,v),o.ref=p.ref,o.return=p,p.child=o}function N2(o,p,b,v,O){if(o!==null){var $=o.memoizedProps;if(xg($,v)&&o.ref===p.ref)if(Ep=!1,p.pendingProps=v=$,lw(o,O))(o.flags&131072)!==0&&(Ep=!0);else return p.lanes=o.lanes,W_(o,p,O)}return nw(o,p,b,v,O)}function R2(o,p,b){var v=p.pendingProps,O=v.children,$=o!==null?o.memoizedState:null;if(v.mode==="hidden"){if((p.flags&128)!==0){if(v=$!==null?$.baseLanes|b:b,o!==null){for(O=p.child=o.child,$=0;O!==null;)$=$|O.lanes|O.childLanes,O=O.sibling;p.childLanes=$&~v}else p.childLanes=0,p.child=null;return z2(o,p,v,b)}if((b&536870912)!==0)p.memoizedState={baseLanes:0,cachePool:null},o!==null&&gb(p,$!==null?$.cachePool:null),$!==null?Oy(p,$):Iy(),C2(p);else return p.lanes=p.childLanes=536870912,z2(o,p,$!==null?$.baseLanes|b:b,b)}else $!==null?(gb(p,$.cachePool),Oy(p,$),kg(),p.memoizedState=null):(o!==null&&gb(p,null),Iy(),kg());return Ip(o,p,O,b),p.child}function z2(o,p,b,v){var O=mb();return O=O===null?null:{parent:wp._currentValue,pool:O},p.memoizedState={baseLanes:b,cachePool:O},o!==null&&gb(p,null),Iy(),C2(p),o!==null&&i0(o,p,v,!0),null}function zb(o,p){var b=p.ref;if(b===null)o!==null&&o.ref!==null&&(p.flags|=4194816);else{if(typeof b!="function"&&typeof b!="object")throw Error(s(284));(o===null||o.ref!==b)&&(p.flags|=4194816)}}function nw(o,p,b,v,O){return t1(p),b=$y(o,p,b,v,void 0,O),v=Ny(),o!==null&&!Ep?(vb(o,p,O),W_(o,p,O)):(kc&&v&&db(p),p.flags|=1,Ip(o,p,b,O),p.child)}function B2(o,p,b,v,O,$){return t1(p),p.updateQueue=null,b=Xw(p,v,b,O),Fy(o),v=Ny(),o!==null&&!Ep?(vb(o,p,$),W_(o,p,$)):(kc&&v&&db(p),p.flags|=1,Ip(o,p,b,$),p.child)}function j2(o,p,b,v,O){if(t1(p),p.stateNode===null){var $=Kg,ae=b.contextType;typeof ae=="object"&&ae!==null&&($=zp(ae)),$=new b(v,$),p.memoizedState=$.state!==null&&$.state!==void 0?$.state:null,$.updater=tw,p.stateNode=$,$._reactInternals=p,$=p.stateNode,$.props=v,$.state=p.memoizedState,$.refs={},Py(p),ae=b.contextType,$.context=typeof ae=="object"&&ae!==null?zp(ae):Kg,$.state=p.memoizedState,ae=b.getDerivedStateFromProps,typeof ae=="function"&&(ew(p,b,ae,v),$.state=p.memoizedState),typeof b.getDerivedStateFromProps=="function"||typeof $.getSnapshotBeforeUpdate=="function"||typeof $.UNSAFE_componentWillMount!="function"&&typeof $.componentWillMount!="function"||(ae=$.state,typeof $.componentWillMount=="function"&&$.componentWillMount(),typeof $.UNSAFE_componentWillMount=="function"&&$.UNSAFE_componentWillMount(),ae!==$.state&&tw.enqueueReplaceState($,$.state,null),p0(p,v,$,O),S1(),$.state=p.memoizedState),typeof $.componentDidMount=="function"&&(p.flags|=4194308),v=!0}else if(o===null){$=p.stateNode;var Te=p.memoizedProps,dt=r1(b,Te);$.props=dt;var wn=$.context,dr=b.contextType;ae=Kg,typeof dr=="object"&&dr!==null&&(ae=zp(dr));var ni=b.getDerivedStateFromProps;dr=typeof ni=="function"||typeof $.getSnapshotBeforeUpdate=="function",Te=p.pendingProps!==Te,dr||typeof $.UNSAFE_componentWillReceiveProps!="function"&&typeof $.componentWillReceiveProps!="function"||(Te||wn!==ae)&&k2(p,$,v,ae),Eg=!1;var Pn=p.memoizedState;$.state=Pn,p0(p,v,$,O),S1(),wn=p.memoizedState,Te||Pn!==wn||Eg?(typeof ni=="function"&&(ew(p,b,ni,v),wn=p.memoizedState),(dt=Eg||Fb(p,b,dt,v,Pn,wn,ae))?(dr||typeof $.UNSAFE_componentWillMount!="function"&&typeof $.componentWillMount!="function"||(typeof $.componentWillMount=="function"&&$.componentWillMount(),typeof $.UNSAFE_componentWillMount=="function"&&$.UNSAFE_componentWillMount()),typeof $.componentDidMount=="function"&&(p.flags|=4194308)):(typeof $.componentDidMount=="function"&&(p.flags|=4194308),p.memoizedProps=v,p.memoizedState=wn),$.props=v,$.state=wn,$.context=ae,v=dt):(typeof $.componentDidMount=="function"&&(p.flags|=4194308),v=!1)}else{$=p.stateNode,yb(o,p),ae=p.memoizedProps,dr=r1(b,ae),$.props=dr,ni=p.pendingProps,Pn=$.context,wn=b.contextType,dt=Kg,typeof wn=="object"&&wn!==null&&(dt=zp(wn)),Te=b.getDerivedStateFromProps,(wn=typeof Te=="function"||typeof $.getSnapshotBeforeUpdate=="function")||typeof $.UNSAFE_componentWillReceiveProps!="function"&&typeof $.componentWillReceiveProps!="function"||(ae!==ni||Pn!==dt)&&k2(p,$,v,dt),Eg=!1,Pn=p.memoizedState,$.state=Pn,p0(p,v,$,O),S1();var Cn=p.memoizedState;ae!==ni||Pn!==Cn||Eg||o!==null&&o.dependencies!==null&&a0(o.dependencies)?(typeof Te=="function"&&(ew(p,b,Te,v),Cn=p.memoizedState),(dr=Eg||Fb(p,b,dr,v,Pn,Cn,dt)||o!==null&&o.dependencies!==null&&a0(o.dependencies))?(wn||typeof $.UNSAFE_componentWillUpdate!="function"&&typeof $.componentWillUpdate!="function"||(typeof $.componentWillUpdate=="function"&&$.componentWillUpdate(v,Cn,dt),typeof $.UNSAFE_componentWillUpdate=="function"&&$.UNSAFE_componentWillUpdate(v,Cn,dt)),typeof $.componentDidUpdate=="function"&&(p.flags|=4),typeof $.getSnapshotBeforeUpdate=="function"&&(p.flags|=1024)):(typeof $.componentDidUpdate!="function"||ae===o.memoizedProps&&Pn===o.memoizedState||(p.flags|=4),typeof $.getSnapshotBeforeUpdate!="function"||ae===o.memoizedProps&&Pn===o.memoizedState||(p.flags|=1024),p.memoizedProps=v,p.memoizedState=Cn),$.props=v,$.state=Cn,$.context=dt,v=dr):(typeof $.componentDidUpdate!="function"||ae===o.memoizedProps&&Pn===o.memoizedState||(p.flags|=4),typeof $.getSnapshotBeforeUpdate!="function"||ae===o.memoizedProps&&Pn===o.memoizedState||(p.flags|=1024),v=!1)}return $=v,zb(o,p),v=(p.flags&128)!==0,$||v?($=p.stateNode,b=v&&typeof b.getDerivedStateFromError!="function"?null:$.render(),p.flags|=1,o!==null&&v?(p.child=I1(p,o.child,null,O),p.child=I1(p,null,b,O)):Ip(o,p,b,O),p.memoizedState=$.state,o=p.child):o=W_(o,p,O),o}function Bb(o,p,b,v){return x1(),p.flags|=256,Ip(o,p,b,v),p.child}var U2={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function rw(o){return{baseLanes:o,cachePool:Uw()}}function sw(o,p,b){return o=o!==null?o.childLanes&~b:0,p&&(o|=x_),o}function V2(o,p,b){var v=p.pendingProps,O=!1,$=(p.flags&128)!==0,ae;if((ae=$)||(ae=o!==null&&o.memoizedState===null?!1:(xp.current&2)!==0),ae&&(O=!0,p.flags&=-129),ae=(p.flags&32)!==0,p.flags&=-33,o===null){if(kc){if(O?Cg(p):kg(),kc){var Te=Zc,dt;if(dt=Te){e:{for(dt=Te,Te=y_;dt.nodeType!==8;){if(!Te){Te=null;break e}if(dt=__(dt.nextSibling),dt===null){Te=null;break e}}Te=dt}Te!==null?(p.memoizedState={dehydrated:Te,treeContext:Xg!==null?{id:B_,overflow:A_}:null,retryLane:536870912,hydrationErrors:null},dt=a_(18,null,null,0),dt.stateNode=Te,dt.return=p,p.child=dt,eh=p,Zc=null,dt=!0):dt=!1}dt||Jg(p)}if(Te=p.memoizedState,Te!==null&&(Te=Te.dehydrated,Te!==null))return D0(Te)?p.lanes=32:p.lanes=536870912,null;O_(p)}return Te=v.children,v=v.fallback,O?(kg(),O=p.mode,Te=jb({mode:"hidden",children:Te},O),v=Yg(v,O,b,null),Te.return=p,v.return=p,Te.sibling=v,p.child=Te,O=p.child,O.memoizedState=rw(b),O.childLanes=sw(o,ae,b),p.memoizedState=U2,v):(Cg(p),iw(p,Te))}if(dt=o.memoizedState,dt!==null&&(Te=dt.dehydrated,Te!==null)){if($)p.flags&256?(Cg(p),p.flags&=-257,p=Ub(o,p,b)):p.memoizedState!==null?(kg(),p.child=o.child,p.flags|=128,p=null):(kg(),O=v.fallback,Te=p.mode,v=jb({mode:"visible",children:v.children},Te),O=Yg(O,Te,b,null),O.flags|=2,v.return=p,O.return=p,v.sibling=O,p.child=v,I1(p,o.child,null,b),v=p.child,v.memoizedState=rw(b),v.childLanes=sw(o,ae,b),p.memoizedState=U2,p=O);else if(Cg(p),D0(Te)){if(ae=Te.nextSibling&&Te.nextSibling.dataset,ae)var wn=ae.dgst;ae=wn,v=Error(s(419)),v.stack="",v.digest=ae,s0({value:v,source:null,stack:null}),p=Ub(o,p,b)}else if(Ep||i0(o,p,b,!1),ae=(b&o.childLanes)!==0,Ep||ae){if(ae=Vc,ae!==null&&(v=b&-b,v=(v&42)!==0?1:_c(v),v=(v&(ae.suspendedLanes|b))!==0?0:v,v!==0&&v!==dt.retryLane))throw dt.retryLane=v,Hg(o,v),Dp(ae,o,v),Fx;Te.data==="$?"||Tw(),p=Ub(o,p,b)}else Te.data==="$?"?(p.flags|=192,p.child=o.child,p=null):(o=dt.treeContext,Zc=__(Te.nextSibling),eh=p,kc=!0,Zg=null,y_=!1,o!==null&&(h_[o_++]=B_,h_[o_++]=A_,h_[o_++]=Xg,B_=o.id,A_=o.overflow,Xg=p),p=iw(p,v.children),p.flags|=4096);return p}return O?(kg(),O=v.fallback,Te=p.mode,dt=o.child,wn=dt.sibling,v=z_(dt,{mode:"hidden",children:v.children}),v.subtreeFlags=dt.subtreeFlags&65011712,wn!==null?O=z_(wn,O):(O=Yg(O,Te,b,null),O.flags|=2),O.return=p,v.return=p,v.sibling=O,p.child=v,v=O,O=p.child,Te=o.child.memoizedState,Te===null?Te=rw(b):(dt=Te.cachePool,dt!==null?(wn=wp._currentValue,dt=dt.parent!==wn?{parent:wn,pool:wn}:dt):dt=Uw(),Te={baseLanes:Te.baseLanes|b,cachePool:dt}),O.memoizedState=Te,O.childLanes=sw(o,ae,b),p.memoizedState=U2,v):(Cg(p),b=o.child,o=b.sibling,b=z_(b,{mode:"visible",children:v.children}),b.return=p,b.sibling=null,o!==null&&(ae=p.deletions,ae===null?(p.deletions=[o],p.flags|=16):ae.push(o)),p.child=b,p.memoizedState=null,b)}function iw(o,p){return p=jb({mode:"visible",children:p},o.mode),p.return=o,o.child=p}function jb(o,p){return o=a_(22,o,null,p),o.lanes=0,o.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},o}function Ub(o,p,b){return I1(p,o.child,null,b),o=iw(p,p.pendingProps.children),o.flags|=2,p.memoizedState=null,o}function G2(o,p,b){o.lanes|=p;var v=o.alternate;v!==null&&(v.lanes|=p),fb(o.return,p,b)}function aw(o,p,b,v,O){var $=o.memoizedState;$===null?o.memoizedState={isBackwards:p,rendering:null,renderingStartTime:0,last:v,tail:b,tailMode:O}:($.isBackwards=p,$.rendering=null,$.renderingStartTime=0,$.last=v,$.tail=b,$.tailMode=O)}function ow(o,p,b){var v=p.pendingProps,O=v.revealOrder,$=v.tail;if(Ip(o,p,v.children,b),v=xp.current,(v&2)!==0)v=v&1|2,p.flags|=128;else{if(o!==null&&(o.flags&128)!==0)e:for(o=p.child;o!==null;){if(o.tag===13)o.memoizedState!==null&&G2(o,b,p);else if(o.tag===19)G2(o,b,p);else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===p)break e;for(;o.sibling===null;){if(o.return===null||o.return===p)break e;o=o.return}o.sibling.return=o.return,o=o.sibling}v&=1}switch(de(xp,v),O){case"forwards":for(b=p.child,O=null;b!==null;)o=b.alternate,o!==null&&$b(o)===null&&(O=b),b=b.sibling;b=O,b===null?(O=p.child,p.child=null):(O=b.sibling,b.sibling=null),aw(p,!1,O,b,$);break;case"backwards":for(b=null,O=p.child,p.child=null;O!==null;){if(o=O.alternate,o!==null&&$b(o)===null){p.child=O;break}o=O.sibling,O.sibling=b,b=O,O=o}aw(p,!0,b,null,$);break;case"together":aw(p,!1,null,null,void 0);break;default:p.memoizedState=null}return p.child}function W_(o,p,b){if(o!==null&&(p.dependencies=o.dependencies),$g|=p.lanes,(b&p.childLanes)===0)if(o!==null){if(i0(o,p,b,!1),(b&p.childLanes)===0)return null}else return null;if(o!==null&&p.child!==o.child)throw Error(s(153));if(p.child!==null){for(o=p.child,b=z_(o,o.pendingProps),p.child=b,b.return=p;o.sibling!==null;)o=o.sibling,b=b.sibling=z_(o,o.pendingProps),b.return=p;b.sibling=null}return p.child}function lw(o,p){return(o.lanes&p)!==0?!0:(o=o.dependencies,!!(o!==null&&a0(o)))}function W2(o,p,b){switch(p.tag){case 3:bn(p,p.stateNode.containerInfo),Mg(p,wp,o.memoizedState.cache),x1();break;case 27:case 5:hn(p);break;case 4:bn(p,p.stateNode.containerInfo);break;case 10:Mg(p,p.type,p.memoizedProps.value);break;case 13:var v=p.memoizedState;if(v!==null)return v.dehydrated!==null?(Cg(p),p.flags|=128,null):(b&p.child.childLanes)!==0?V2(o,p,b):(Cg(p),o=W_(o,p,b),o!==null?o.sibling:null);Cg(p);break;case 19:var O=(o.flags&128)!==0;if(v=(b&p.childLanes)!==0,v||(i0(o,p,b,!1),v=(b&p.childLanes)!==0),O){if(v)return ow(o,p,b);p.flags|=128}if(O=p.memoizedState,O!==null&&(O.rendering=null,O.tail=null,O.lastEffect=null),de(xp,xp.current),v)break;return null;case 22:case 23:return p.lanes=0,R2(o,p,b);case 24:Mg(p,wp,o.memoizedState.cache)}return W_(o,p,b)}function q2(o,p,b){if(o!==null)if(o.memoizedProps!==p.pendingProps)Ep=!0;else{if(!lw(o,b)&&(p.flags&128)===0)return Ep=!1,W2(o,p,b);Ep=(o.flags&131072)!==0}else Ep=!1,kc&&(p.flags&1048576)!==0&&Lw(p,cb,p.index);switch(p.lanes=0,p.tag){case 16:e:{o=p.pendingProps;var v=p.elementType,O=v._init;if(v=O(v._payload),p.type=v,typeof v=="function")lb(v)?(o=r1(v,o),p.tag=1,p=j2(null,p,v,o,b)):(p.tag=0,p=nw(null,p,v,o,b));else{if(v!=null){if(O=v.$$typeof,O===T){p.tag=11,p=F2(null,p,v,o,b);break e}else if(O===C){p.tag=14,p=D1(null,p,v,o,b);break e}}throw p=te(v)||v,Error(s(306,p,""))}}return p;case 0:return nw(o,p,p.type,p.pendingProps,b);case 1:return v=p.type,O=r1(v,p.pendingProps),j2(o,p,v,O,b);case 3:e:{if(bn(p,p.stateNode.containerInfo),o===null)throw Error(s(387));v=p.pendingProps;var $=p.memoizedState;O=$.element,yb(o,p),p0(p,v,null,b);var ae=p.memoizedState;if(v=ae.cache,Mg(p,wp,v),v!==$.cache&&Ey(p,[wp],b,!0),S1(),v=ae.element,$.isDehydrated)if($={element:v,isDehydrated:!1,cache:ae.cache},p.updateQueue.baseState=$,p.memoizedState=$,p.flags&256){p=Bb(o,p,v,b);break e}else if(v!==O){O=Ic(Error(s(424)),p),s0(O),p=Bb(o,p,v,b);break e}else{switch(o=p.stateNode.containerInfo,o.nodeType){case 9:o=o.body;break;default:o=o.nodeName==="HTML"?o.ownerDocument.body:o}for(Zc=__(o.firstChild),eh=p,kc=!0,Zg=null,y_=!0,b=A2(p,null,v,b),p.child=b;b;)b.flags=b.flags&-3|4096,b=b.sibling}else{if(x1(),v===O){p=W_(o,p,b);break e}Ip(o,p,v,b)}p=p.child}return p;case 26:return zb(o,p),o===null?(b=Uv(p.type,null,p.pendingProps,null))?p.memoizedState=b:kc||(b=p.type,o=p.pendingProps,v=qo(Pt.current).createElement(b),v[ve]=p,v[Ke]=o,Qo(v,b,o),Ht(v),p.stateNode=v):p.memoizedState=Uv(p.type,o.memoizedProps,p.pendingProps,o.memoizedState),null;case 27:return hn(p),o===null&&kc&&(v=p.stateNode=Cw(p.type,p.pendingProps,Pt.current),eh=p,y_=!0,O=Zc,Pc(p.type)?(ay=O,Zc=__(v.firstChild)):Zc=O),Ip(o,p,p.pendingProps.children,b),zb(o,p),o===null&&(p.flags|=4194304),p.child;case 5:return o===null&&kc&&((O=v=Zc)&&(v=W1(v,p.type,p.pendingProps,y_),v!==null?(p.stateNode=v,eh=p,Zc=__(v.firstChild),y_=!1,O=!0):O=!1),O||Jg(p)),hn(p),O=p.type,$=p.pendingProps,ae=o!==null?o.memoizedProps:null,v=$.children,Rg(O,$)?v=null:ae!==null&&Rg(O,ae)&&(p.flags|=32),p.memoizedState!==null&&(O=$y(o,p,kx,null,null,b),wx._currentValue=O),zb(o,p),Ip(o,p,v,b),p.child;case 6:return o===null&&kc&&((o=b=Zc)&&(b=I0(b,p.pendingProps,y_),b!==null?(p.stateNode=b,eh=p,Zc=null,o=!0):o=!1),o||Jg(p)),null;case 13:return V2(o,p,b);case 4:return bn(p,p.stateNode.containerInfo),v=p.pendingProps,o===null?p.child=I1(p,null,v,b):Ip(o,p,v,b),p.child;case 11:return F2(o,p,p.type,p.pendingProps,b);case 7:return Ip(o,p,p.pendingProps,b),p.child;case 8:return Ip(o,p,p.pendingProps.children,b),p.child;case 12:return Ip(o,p,p.pendingProps.children,b),p.child;case 10:return v=p.pendingProps,Mg(p,p.type,v.value),Ip(o,p,v.children,b),p.child;case 9:return O=p.type._context,v=p.pendingProps.children,t1(p),O=zp(O),v=v(O),p.flags|=1,Ip(o,p,v,b),p.child;case 14:return D1(o,p,p.type,p.pendingProps,b);case 15:return N2(o,p,p.type,p.pendingProps,b);case 19:return ow(o,p,b);case 31:return v=p.pendingProps,b=p.mode,v={mode:v.mode,children:v.children},o===null?(b=jb(v,b),b.ref=p.ref,p.child=b,b.return=p,p=b):(b=z_(o.child,v),b.ref=p.ref,p.child=b,b.return=p,p=b),p;case 22:return R2(o,p,b);case 24:return t1(p),v=zp(wp),o===null?(O=mb(),O===null&&(O=Vc,$=hb(),O.pooledCache=$,$.refCount++,$!==null&&(O.pooledCacheLanes|=b),O=$),p.memoizedState={parent:v,cache:O},Py(p),Mg(p,wp,O)):((o.lanes&b)!==0&&(yb(o,p),p0(p,null,null,b),S1()),O=o.memoizedState,$=p.memoizedState,O.parent!==v?(O={parent:v,cache:v},p.memoizedState=O,p.lanes===0&&(p.memoizedState=p.updateQueue.baseState=O),Mg(p,wp,v)):(v=$.cache,Mg(p,wp,v),v!==O.cache&&Ey(p,[wp],b,!0))),Ip(o,p,p.pendingProps.children,b),p.child;case 29:throw p.pendingProps}throw Error(s(156,p.tag))}function q_(o){o.flags|=4}function uw(o,p){if(p.type!=="stylesheet"||(p.state.loading&4)!==0)o.flags&=-16777217;else if(o.flags|=16777216,!Hv(p)){if(p=Mp.current,p!==null&&((vc&4194048)===vc?k_!==null:(vc&62914560)!==vc&&(vc&536870912)===0||p!==k_))throw M1=Sy,Vw;o.flags|=8192}}function Vb(o,p){p!==null&&(o.flags|=4),o.flags&16384&&(p=o.tag!==22?$p():536870912,o.lanes|=p,P0|=p)}function v0(o,p){if(!kc)switch(o.tailMode){case"hidden":p=o.tail;for(var b=null;p!==null;)p.alternate!==null&&(b=p),p=p.sibling;b===null?o.tail=null:b.sibling=null;break;case"collapsed":b=o.tail;for(var v=null;b!==null;)b.alternate!==null&&(v=b),b=b.sibling;v===null?p||o.tail===null?o.tail=null:o.tail.sibling=null:v.sibling=null}}function Wc(o){var p=o.alternate!==null&&o.alternate.child===o.child,b=0,v=0;if(p)for(var O=o.child;O!==null;)b|=O.lanes|O.childLanes,v|=O.subtreeFlags&65011712,v|=O.flags&65011712,O.return=o,O=O.sibling;else for(O=o.child;O!==null;)b|=O.lanes|O.childLanes,v|=O.subtreeFlags,v|=O.flags,O.return=o,O=O.sibling;return o.subtreeFlags|=v,o.childLanes=b,p}function Nx(o,p,b){var v=p.pendingProps;switch(vy(p),p.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Wc(p),null;case 1:return Wc(p),null;case 3:return b=p.stateNode,v=null,o!==null&&(v=o.memoizedState.cache),p.memoizedState.cache!==v&&(p.flags|=2048),U_(wp),ri(),b.pendingContext&&(b.context=b.pendingContext,b.pendingContext=null),(o===null||o.child===null)&&(r0(p)?q_(p):o===null||o.memoizedState.isDehydrated&&(p.flags&256)===0||(p.flags|=1024,Fw())),Wc(p),null;case 26:return b=p.memoizedState,o===null?(q_(p),b!==null?(Wc(p),uw(p,b)):(Wc(p),p.flags&=-16777217)):b?b!==o.memoizedState?(q_(p),Wc(p),uw(p,b)):(Wc(p),p.flags&=-16777217):(o.memoizedProps!==v&&q_(p),Wc(p),p.flags&=-16777217),null;case 27:ze(p),b=Pt.current;var O=p.type;if(o!==null&&p.stateNode!=null)o.memoizedProps!==v&&q_(p);else{if(!v){if(p.stateNode===null)throw Error(s(166));return Wc(p),null}o=ue.current,r0(p)?My(p):(o=Cw(O,v,b),p.stateNode=o,q_(p))}return Wc(p),null;case 5:if(ze(p),b=p.type,o!==null&&p.stateNode!=null)o.memoizedProps!==v&&q_(p);else{if(!v){if(p.stateNode===null)throw Error(s(166));return Wc(p),null}if(o=ue.current,r0(p))My(p);else{switch(O=qo(Pt.current),o){case 1:o=O.createElementNS("http://www.w3.org/2000/svg",b);break;case 2:o=O.createElementNS("http://www.w3.org/1998/Math/MathML",b);break;default:switch(b){case"svg":o=O.createElementNS("http://www.w3.org/2000/svg",b);break;case"math":o=O.createElementNS("http://www.w3.org/1998/Math/MathML",b);break;case"script":o=O.createElement("div"),o.innerHTML="<script><\/script>",o=o.removeChild(o.firstChild);break;case"select":o=typeof v.is=="string"?O.createElement("select",{is:v.is}):O.createElement("select"),v.multiple?o.multiple=!0:v.size&&(o.size=v.size);break;default:o=typeof v.is=="string"?O.createElement(b,{is:v.is}):O.createElement(b)}}o[ve]=p,o[Ke]=v;e:for(O=p.child;O!==null;){if(O.tag===5||O.tag===6)o.appendChild(O.stateNode);else if(O.tag!==4&&O.tag!==27&&O.child!==null){O.child.return=O,O=O.child;continue}if(O===p)break e;for(;O.sibling===null;){if(O.return===null||O.return===p)break e;O=O.return}O.sibling.return=O.return,O=O.sibling}p.stateNode=o;e:switch(Qo(o,b,v),b){case"button":case"input":case"select":case"textarea":o=!!v.autoFocus;break e;case"img":o=!0;break e;default:o=!1}o&&q_(p)}}return Wc(p),p.flags&=-16777217,null;case 6:if(o&&p.stateNode!=null)o.memoizedProps!==v&&q_(p);else{if(typeof v!="string"&&p.stateNode===null)throw Error(s(166));if(o=Pt.current,r0(p)){if(o=p.stateNode,b=p.memoizedProps,v=null,O=eh,O!==null)switch(O.tag){case 27:case 5:v=O.memoizedProps}o[ve]=p,o=!!(o.nodeValue===b||v!==null&&v.suppressHydrationWarning===!0||Gi(o.nodeValue,b)),o||Jg(p)}else o=qo(o).createTextNode(v),o[ve]=p,p.stateNode=o}return Wc(p),null;case 13:if(v=p.memoizedState,o===null||o.memoizedState!==null&&o.memoizedState.dehydrated!==null){if(O=r0(p),v!==null&&v.dehydrated!==null){if(o===null){if(!O)throw Error(s(318));if(O=p.memoizedState,O=O!==null?O.dehydrated:null,!O)throw Error(s(317));O[ve]=p}else x1(),(p.flags&128)===0&&(p.memoizedState=null),p.flags|=4;Wc(p),O=!1}else O=Fw(),o!==null&&o.memoizedState!==null&&(o.memoizedState.hydrationErrors=O),O=!0;if(!O)return p.flags&256?(O_(p),p):(O_(p),null)}if(O_(p),(p.flags&128)!==0)return p.lanes=b,p;if(b=v!==null,o=o!==null&&o.memoizedState!==null,b){v=p.child,O=null,v.alternate!==null&&v.alternate.memoizedState!==null&&v.alternate.memoizedState.cachePool!==null&&(O=v.alternate.memoizedState.cachePool.pool);var $=null;v.memoizedState!==null&&v.memoizedState.cachePool!==null&&($=v.memoizedState.cachePool.pool),$!==O&&(v.flags|=2048)}return b!==o&&b&&(p.child.flags|=8192),Vb(p,p.updateQueue),Wc(p),null;case 4:return ri(),o===null&&xn(p.stateNode.containerInfo),Wc(p),null;case 10:return U_(p.type),Wc(p),null;case 19:if(Q(xp),O=p.memoizedState,O===null)return Wc(p),null;if(v=(p.flags&128)!==0,$=O.rendering,$===null)if(v)v0(O,!1);else{if(np!==0||o!==null&&(o.flags&128)!==0)for(o=p.child;o!==null;){if($=$b(o),$!==null){for(p.flags|=128,v0(O,!1),o=$.updateQueue,p.updateQueue=o,Vb(p,o),p.subtreeFlags=0,o=b,b=p.child;b!==null;)Dw(b,o),b=b.sibling;return de(xp,xp.current&1|2),p.child}o=o.sibling}O.tail!==null&&cn()>Zb&&(p.flags|=128,v=!0,v0(O,!1),p.lanes=4194304)}else{if(!v)if(o=$b($),o!==null){if(p.flags|=128,v=!0,o=o.updateQueue,p.updateQueue=o,Vb(p,o),v0(O,!0),O.tail===null&&O.tailMode==="hidden"&&!$.alternate&&!kc)return Wc(p),null}else 2*cn()-O.renderingStartTime>Zb&&b!==536870912&&(p.flags|=128,v=!0,v0(O,!1),p.lanes=4194304);O.isBackwards?($.sibling=p.child,p.child=$):(o=O.last,o!==null?o.sibling=$:p.child=$,O.last=$)}return O.tail!==null?(p=O.tail,O.rendering=p,O.tail=p.sibling,O.renderingStartTime=cn(),p.sibling=null,o=xp.current,de(xp,v?o&1|2:o&1),p):(Wc(p),null);case 22:case 23:return O_(p),Dy(),v=p.memoizedState!==null,o!==null?o.memoizedState!==null!==v&&(p.flags|=8192):v&&(p.flags|=8192),v?(b&536870912)!==0&&(p.flags&128)===0&&(Wc(p),p.subtreeFlags&6&&(p.flags|=8192)):Wc(p),b=p.updateQueue,b!==null&&Vb(p,b.retryQueue),b=null,o!==null&&o.memoizedState!==null&&o.memoizedState.cachePool!==null&&(b=o.memoizedState.cachePool.pool),v=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(v=p.memoizedState.cachePool.pool),v!==b&&(p.flags|=2048),o!==null&&Q(n1),null;case 24:return b=null,o!==null&&(b=o.memoizedState.cache),p.memoizedState.cache!==b&&(p.flags|=2048),U_(wp),Wc(p),null;case 25:return null;case 30:return null}throw Error(s(156,p.tag))}function Rx(o,p){switch(vy(p),p.tag){case 1:return o=p.flags,o&65536?(p.flags=o&-65537|128,p):null;case 3:return U_(wp),ri(),o=p.flags,(o&65536)!==0&&(o&128)===0?(p.flags=o&-65537|128,p):null;case 26:case 27:case 5:return ze(p),null;case 13:if(O_(p),o=p.memoizedState,o!==null&&o.dehydrated!==null){if(p.alternate===null)throw Error(s(340));x1()}return o=p.flags,o&65536?(p.flags=o&-65537|128,p):null;case 19:return Q(xp),null;case 4:return ri(),null;case 10:return U_(p.type),null;case 22:case 23:return O_(p),Dy(),o!==null&&Q(n1),o=p.flags,o&65536?(p.flags=o&-65537|128,p):null;case 24:return U_(wp),null;case 25:return null;default:return null}}function H2(o,p){switch(vy(p),p.tag){case 3:U_(wp),ri();break;case 26:case 27:case 5:ze(p);break;case 4:ri();break;case 13:O_(p);break;case 19:Q(xp);break;case 10:U_(p.type);break;case 22:case 23:O_(p),Dy(),o!==null&&Q(n1);break;case 24:U_(wp)}}function T0(o,p){try{var b=p.updateQueue,v=b!==null?b.lastEffect:null;if(v!==null){var O=v.next;b=O;do{if((b.tag&o)===o){v=void 0;var $=b.create,ae=b.inst;v=$(),ae.destroy=v}b=b.next}while(b!==O)}}catch(Te){Gc(p,p.return,Te)}}function H_(o,p,b){try{var v=p.updateQueue,O=v!==null?v.lastEffect:null;if(O!==null){var $=O.next;v=$;do{if((v.tag&o)===o){var ae=v.inst,Te=ae.destroy;if(Te!==void 0){ae.destroy=void 0,O=p;var dt=b,wn=Te;try{wn()}catch(dr){Gc(O,dt,dr)}}}v=v.next}while(v!==$)}}catch(dr){Gc(p,p.return,dr)}}function Gb(o){var p=o.updateQueue;if(p!==null){var b=o.stateNode;try{ky(p,b)}catch(v){Gc(o,o.return,v)}}}function zx(o,p,b){b.props=r1(o.type,o.memoizedProps),b.state=o.memoizedState;try{b.componentWillUnmount()}catch(v){Gc(o,p,v)}}function M0(o,p){try{var b=o.ref;if(b!==null){switch(o.tag){case 26:case 27:case 5:var v=o.stateNode;break;case 30:v=o.stateNode;break;default:v=o.stateNode}typeof b=="function"?o.refCleanup=b(v):b.current=v}}catch(O){Gc(o,p,O)}}function I_(o,p){var b=o.ref,v=o.refCleanup;if(b!==null)if(typeof v=="function")try{v()}catch(O){Gc(o,p,O)}finally{o.refCleanup=null,o=o.alternate,o!=null&&(o.refCleanup=null)}else if(typeof b=="function")try{b(null)}catch(O){Gc(o,p,O)}else b.current=null}function cw(o){var p=o.type,b=o.memoizedProps,v=o.stateNode;try{e:switch(p){case"button":case"input":case"select":case"textarea":b.autoFocus&&v.focus();break e;case"img":b.src?v.src=b.src:b.srcSet&&(v.srcset=b.srcSet)}}catch(O){Gc(o,o.return,O)}}function dw(o,p,b){try{var v=o.stateNode;gp(v,o.type,b,p),v[Ke]=p}catch(O){Gc(o,o.return,O)}}function K2(o){return o.tag===5||o.tag===3||o.tag===26||o.tag===27&&Pc(o.type)||o.tag===4}function Wb(o){e:for(;;){for(;o.sibling===null;){if(o.return===null||K2(o.return))return null;o=o.return}for(o.sibling.return=o.return,o=o.sibling;o.tag!==5&&o.tag!==6&&o.tag!==18;){if(o.tag===27&&Pc(o.type)||o.flags&2||o.child===null||o.tag===4)continue e;o.child.return=o,o=o.child}if(!(o.flags&2))return o.stateNode}}function pw(o,p,b){var v=o.tag;if(v===5||v===6)o=o.stateNode,p?(b.nodeType===9?b.body:b.nodeName==="HTML"?b.ownerDocument.body:b).insertBefore(o,p):(p=b.nodeType===9?b.body:b.nodeName==="HTML"?b.ownerDocument.body:b,p.appendChild(o),b=b._reactRootContainer,b!=null||p.onclick!==null||(p.onclick=Ni));else if(v!==4&&(v===27&&Pc(o.type)&&(b=o.stateNode,p=null),o=o.child,o!==null))for(pw(o,p,b),o=o.sibling;o!==null;)pw(o,p,b),o=o.sibling}function qb(o,p,b){var v=o.tag;if(v===5||v===6)o=o.stateNode,p?b.insertBefore(o,p):b.appendChild(o);else if(v!==4&&(v===27&&Pc(o.type)&&(b=o.stateNode),o=o.child,o!==null))for(qb(o,p,b),o=o.sibling;o!==null;)qb(o,p,b),o=o.sibling}function fw(o){var p=o.stateNode,b=o.memoizedProps;try{for(var v=o.type,O=p.attributes;O.length;)p.removeAttributeNode(O[0]);Qo(p,v,b),p[ve]=o,p[Ke]=b}catch($){Gc(o,o.return,$)}}var Og=!1,_p=!1,Hb=!1,Kb=typeof WeakSet=="function"?WeakSet:Set,Sp=null;function Bx(o,p){if(o=o.containerInfo,rp=_v,o=J1(o),Wg(o)){if("selectionStart"in o)var b={start:o.selectionStart,end:o.selectionEnd};else e:{b=(b=o.ownerDocument)&&b.defaultView||window;var v=b.getSelection&&b.getSelection();if(v&&v.rangeCount!==0){b=v.anchorNode;var O=v.anchorOffset,$=v.focusNode;v=v.focusOffset;try{b.nodeType,$.nodeType}catch{b=null;break e}var ae=0,Te=-1,dt=-1,wn=0,dr=0,ni=o,Pn=null;t:for(;;){for(var Cn;ni!==b||O!==0&&ni.nodeType!==3||(Te=ae+O),ni!==$||v!==0&&ni.nodeType!==3||(dt=ae+v),ni.nodeType===3&&(ae+=ni.nodeValue.length),(Cn=ni.firstChild)!==null;)Pn=ni,ni=Cn;for(;;){if(ni===o)break t;if(Pn===b&&++wn===O&&(Te=ae),Pn===$&&++dr===v&&(dt=ae),(Cn=ni.nextSibling)!==null)break;ni=Pn,Pn=ni.parentNode}ni=Cn}b=Te===-1||dt===-1?null:{start:Te,end:dt}}else b=null}b=b||{start:0,end:0}}else b=null;for(Jc={focusedElem:o,selectionRange:b},_v=!1,Sp=p;Sp!==null;)if(p=Sp,o=p.child,(p.subtreeFlags&1024)!==0&&o!==null)o.return=p,Sp=o;else for(;Sp!==null;){switch(p=Sp,$=p.alternate,o=p.flags,p.tag){case 0:break;case 11:case 15:break;case 1:if((o&1024)!==0&&$!==null){o=void 0,b=p,O=$.memoizedProps,$=$.memoizedState,v=b.stateNode;try{var Go=r1(b.type,O,b.elementType===b.type);o=v.getSnapshotBeforeUpdate(Go,$),v.__reactInternalSnapshotBeforeUpdate=o}catch(Bo){Gc(b,b.return,Bo)}}break;case 3:if((o&1024)!==0){if(o=p.stateNode.containerInfo,b=o.nodeType,b===9)Z_(o);else if(b===1)switch(o.nodeName){case"HEAD":case"HTML":case"BODY":Z_(o);break;default:o.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((o&1024)!==0)throw Error(s(163))}if(o=p.sibling,o!==null){o.return=p.return,Sp=o;break}Sp=p.return}}function Y2(o,p,b){var v=b.flags;switch(b.tag){case 0:case 11:case 15:Ig(o,b),v&4&&T0(5,b);break;case 1:if(Ig(o,b),v&4)if(o=b.stateNode,p===null)try{o.componentDidMount()}catch(ae){Gc(b,b.return,ae)}else{var O=r1(b.type,p.memoizedProps);p=p.memoizedState;try{o.componentDidUpdate(O,p,o.__reactInternalSnapshotBeforeUpdate)}catch(ae){Gc(b,b.return,ae)}}v&64&&Gb(b),v&512&&M0(b,b.return);break;case 3:if(Ig(o,b),v&64&&(o=b.updateQueue,o!==null)){if(p=null,b.child!==null)switch(b.child.tag){case 27:case 5:p=b.child.stateNode;break;case 1:p=b.child.stateNode}try{ky(o,p)}catch(ae){Gc(b,b.return,ae)}}break;case 27:p===null&&v&4&&fw(b);case 26:case 5:Ig(o,b),p===null&&v&4&&cw(b),v&512&&M0(b,b.return);break;case 12:Ig(o,b);break;case 13:Ig(o,b),v&4&&X2(o,b),v&64&&(o=b.memoizedState,o!==null&&(o=o.dehydrated,o!==null&&(b=Mv.bind(null,b),_x(o,b))));break;case 22:if(v=b.memoizedState!==null||Og,!v){p=p!==null&&p.memoizedState!==null||_p,O=Og;var $=_p;Og=v,(_p=p)&&!$?Dg(o,b,(b.subtreeFlags&8772)!==0):Ig(o,b),Og=O,_p=$}break;case 30:break;default:Ig(o,b)}}function Yb(o){var p=o.alternate;p!==null&&(o.alternate=null,Yb(p)),o.child=null,o.deletions=null,o.sibling=null,o.tag===5&&(p=o.stateNode,p!==null&&Oo(p)),o.stateNode=null,o.return=null,o.dependencies=null,o.memoizedProps=null,o.memoizedState=null,o.pendingProps=null,o.stateNode=null,o.updateQueue=null}var Kc=null,r_=!1;function K_(o,p,b){for(b=b.child;b!==null;)Xb(o,p,b),b=b.sibling}function Xb(o,p,b){if(mi&&typeof mi.onCommitFiberUnmount=="function")try{mi.onCommitFiberUnmount(ai,b)}catch{}switch(b.tag){case 26:_p||I_(b,p),K_(o,p,b),b.memoizedState?b.memoizedState.count--:b.stateNode&&(b=b.stateNode,b.parentNode.removeChild(b));break;case 27:_p||I_(b,p);var v=Kc,O=r_;Pc(b.type)&&(Kc=b.stateNode,r_=!1),K_(o,p,b),a1(b.stateNode),Kc=v,r_=O;break;case 5:_p||I_(b,p);case 6:if(v=Kc,O=r_,Kc=null,K_(o,p,b),Kc=v,r_=O,Kc!==null)if(r_)try{(Kc.nodeType===9?Kc.body:Kc.nodeName==="HTML"?Kc.ownerDocument.body:Kc).removeChild(b.stateNode)}catch($){Gc(b,p,$)}else try{Kc.removeChild(b.stateNode)}catch($){Gc(b,p,$)}break;case 18:Kc!==null&&(r_?(o=Kc,bp(o.nodeType===9?o.body:o.nodeName==="HTML"?o.ownerDocument.body:o,b.stateNode),Mx(o)):bp(Kc,b.stateNode));break;case 4:v=Kc,O=r_,Kc=b.stateNode.containerInfo,r_=!0,K_(o,p,b),Kc=v,r_=O;break;case 0:case 11:case 14:case 15:_p||H_(2,b,p),_p||H_(4,b,p),K_(o,p,b);break;case 1:_p||(I_(b,p),v=b.stateNode,typeof v.componentWillUnmount=="function"&&zx(b,p,v)),K_(o,p,b);break;case 21:K_(o,p,b);break;case 22:_p=(v=_p)||b.memoizedState!==null,K_(o,p,b),_p=v;break;default:K_(o,p,b)}}function X2(o,p){if(p.memoizedState===null&&(o=p.alternate,o!==null&&(o=o.memoizedState,o!==null&&(o=o.dehydrated,o!==null))))try{Mx(o)}catch(b){Gc(p,p.return,b)}}function jx(o){switch(o.tag){case 13:case 19:var p=o.stateNode;return p===null&&(p=o.stateNode=new Kb),p;case 22:return o=o.stateNode,p=o._retryCache,p===null&&(p=o._retryCache=new Kb),p;default:throw Error(s(435,o.tag))}}function hw(o,p){var b=jx(o);p.forEach(function(v){var O=Ev.bind(null,o,v);b.has(v)||(b.add(v),v.then(O,O))})}function Eh(o,p){var b=p.deletions;if(b!==null)for(var v=0;v<b.length;v++){var O=b[v],$=o,ae=p,Te=ae;e:for(;Te!==null;){switch(Te.tag){case 27:if(Pc(Te.type)){Kc=Te.stateNode,r_=!1;break e}break;case 5:Kc=Te.stateNode,r_=!1;break e;case 3:case 4:Kc=Te.stateNode.containerInfo,r_=!0;break e}Te=Te.return}if(Kc===null)throw Error(s(160));Xb($,ae,O),Kc=null,r_=!1,$=O.alternate,$!==null&&($.return=null),O.return=null}if(p.subtreeFlags&13878)for(p=p.child;p!==null;)Q2(p,o),p=p.sibling}var w_=null;function Q2(o,p){var b=o.alternate,v=o.flags;switch(o.tag){case 0:case 11:case 14:case 15:Eh(p,o),l_(o),v&4&&(H_(3,o,o.return),T0(3,o),H_(5,o,o.return));break;case 1:Eh(p,o),l_(o),v&512&&(_p||b===null||I_(b,b.return)),v&64&&Og&&(o=o.updateQueue,o!==null&&(v=o.callbacks,v!==null&&(b=o.shared.hiddenCallbacks,o.shared.hiddenCallbacks=b===null?v:b.concat(v))));break;case 26:var O=w_;if(Eh(p,o),l_(o),v&512&&(_p||b===null||I_(b,b.return)),v&4){var $=b!==null?b.memoizedState:null;if(v=o.memoizedState,b===null)if(v===null)if(o.stateNode===null){e:{v=o.type,b=o.memoizedProps,O=O.ownerDocument||O;t:switch(v){case"title":$=O.getElementsByTagName("title")[0],(!$||$[hi]||$[ve]||$.namespaceURI==="http://www.w3.org/2000/svg"||$.hasAttribute("itemprop"))&&($=O.createElement(v),O.head.insertBefore($,O.querySelector("head > title"))),Qo($,v,b),$[ve]=o,Ht($),v=$;break e;case"link":var ae=Wv("link","href",O).get(v+(b.href||""));if(ae){for(var Te=0;Te<ae.length;Te++)if($=ae[Te],$.getAttribute("href")===(b.href==null||b.href===""?null:b.href)&&$.getAttribute("rel")===(b.rel==null?null:b.rel)&&$.getAttribute("title")===(b.title==null?null:b.title)&&$.getAttribute("crossorigin")===(b.crossOrigin==null?null:b.crossOrigin)){ae.splice(Te,1);break t}}$=O.createElement(v),Qo($,v,b),O.head.appendChild($);break;case"meta":if(ae=Wv("meta","content",O).get(v+(b.content||""))){for(Te=0;Te<ae.length;Te++)if($=ae[Te],$.getAttribute("content")===(b.content==null?null:""+b.content)&&$.getAttribute("name")===(b.name==null?null:b.name)&&$.getAttribute("property")===(b.property==null?null:b.property)&&$.getAttribute("http-equiv")===(b.httpEquiv==null?null:b.httpEquiv)&&$.getAttribute("charset")===(b.charSet==null?null:b.charSet)){ae.splice(Te,1);break t}}$=O.createElement(v),Qo($,v,b),O.head.appendChild($);break;default:throw Error(s(468,v))}$[ve]=o,Ht($),v=$}o.stateNode=v}else qv(O,o.type,o.stateNode);else o.stateNode=Gv(O,v,o.memoizedProps);else $!==v?($===null?b.stateNode!==null&&(b=b.stateNode,b.parentNode.removeChild(b)):$.count--,v===null?qv(O,o.type,o.stateNode):Gv(O,v,o.memoizedProps)):v===null&&o.stateNode!==null&&dw(o,o.memoizedProps,b.memoizedProps)}break;case 27:Eh(p,o),l_(o),v&512&&(_p||b===null||I_(b,b.return)),b!==null&&v&4&&dw(o,o.memoizedProps,b.memoizedProps);break;case 5:if(Eh(p,o),l_(o),v&512&&(_p||b===null||I_(b,b.return)),o.flags&32){O=o.stateNode;try{at(O,"")}catch(Cn){Gc(o,o.return,Cn)}}v&4&&o.stateNode!=null&&(O=o.memoizedProps,dw(o,O,b!==null?b.memoizedProps:O)),v&1024&&(Hb=!0);break;case 6:if(Eh(p,o),l_(o),v&4){if(o.stateNode===null)throw Error(s(162));v=o.memoizedProps,b=o.stateNode;try{b.nodeValue=v}catch(Cn){Gc(o,o.return,Cn)}}break;case 3:if(pv=null,O=w_,w_=L0(p.containerInfo),Eh(p,o),w_=O,l_(o),v&4&&b!==null&&b.memoizedState.isDehydrated)try{Mx(p.containerInfo)}catch(Cn){Gc(o,o.return,Cn)}Hb&&(Hb=!1,Z2(o));break;case 4:v=w_,w_=L0(o.stateNode.containerInfo),Eh(p,o),l_(o),w_=v;break;case 12:Eh(p,o),l_(o);break;case 13:Eh(p,o),l_(o),o.child.flags&8192&&o.memoizedState!==null!=(b!==null&&b.memoizedState!==null)&&(yw=cn()),v&4&&(v=o.updateQueue,v!==null&&(o.updateQueue=null,hw(o,v)));break;case 22:O=o.memoizedState!==null;var dt=b!==null&&b.memoizedState!==null,wn=Og,dr=_p;if(Og=wn||O,_p=dr||dt,Eh(p,o),_p=dr,Og=wn,l_(o),v&8192)e:for(p=o.stateNode,p._visibility=O?p._visibility&-2:p._visibility|1,O&&(b===null||dt||Og||_p||s1(o)),b=null,p=o;;){if(p.tag===5||p.tag===26){if(b===null){dt=b=p;try{if($=dt.stateNode,O)ae=$.style,typeof ae.setProperty=="function"?ae.setProperty("display","none","important"):ae.display="none";else{Te=dt.stateNode;var ni=dt.memoizedProps.style,Pn=ni!=null&&ni.hasOwnProperty("display")?ni.display:null;Te.style.display=Pn==null||typeof Pn=="boolean"?"":(""+Pn).trim()}}catch(Cn){Gc(dt,dt.return,Cn)}}}else if(p.tag===6){if(b===null){dt=p;try{dt.stateNode.nodeValue=O?"":dt.memoizedProps}catch(Cn){Gc(dt,dt.return,Cn)}}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===o)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===o)break e;for(;p.sibling===null;){if(p.return===null||p.return===o)break e;b===p&&(b=null),p=p.return}b===p&&(b=null),p.sibling.return=p.return,p=p.sibling}v&4&&(v=o.updateQueue,v!==null&&(b=v.retryQueue,b!==null&&(v.retryQueue=null,hw(o,b))));break;case 19:Eh(p,o),l_(o),v&4&&(v=o.updateQueue,v!==null&&(o.updateQueue=null,hw(o,v)));break;case 30:break;case 21:break;default:Eh(p,o),l_(o)}}function l_(o){var p=o.flags;if(p&2){try{for(var b,v=o.return;v!==null;){if(K2(v)){b=v;break}v=v.return}if(b==null)throw Error(s(160));switch(b.tag){case 27:var O=b.stateNode,$=Wb(o);qb(o,$,O);break;case 5:var ae=b.stateNode;b.flags&32&&(at(ae,""),b.flags&=-33);var Te=Wb(o);qb(o,Te,ae);break;case 3:case 4:var dt=b.stateNode.containerInfo,wn=Wb(o);pw(o,wn,dt);break;default:throw Error(s(161))}}catch(dr){Gc(o,o.return,dr)}o.flags&=-3}p&4096&&(o.flags&=-4097)}function Z2(o){if(o.subtreeFlags&1024)for(o=o.child;o!==null;){var p=o;Z2(p),p.tag===5&&p.flags&1024&&p.stateNode.reset(),o=o.sibling}}function Ig(o,p){if(p.subtreeFlags&8772)for(p=p.child;p!==null;)Y2(o,p.alternate,p),p=p.sibling}function s1(o){for(o=o.child;o!==null;){var p=o;switch(p.tag){case 0:case 11:case 14:case 15:H_(4,p,p.return),s1(p);break;case 1:I_(p,p.return);var b=p.stateNode;typeof b.componentWillUnmount=="function"&&zx(p,p.return,b),s1(p);break;case 27:a1(p.stateNode);case 26:case 5:I_(p,p.return),s1(p);break;case 22:p.memoizedState===null&&s1(p);break;case 30:s1(p);break;default:s1(p)}o=o.sibling}}function Dg(o,p,b){for(b=b&&(p.subtreeFlags&8772)!==0,p=p.child;p!==null;){var v=p.alternate,O=o,$=p,ae=$.flags;switch($.tag){case 0:case 11:case 15:Dg(O,$,b),T0(4,$);break;case 1:if(Dg(O,$,b),v=$,O=v.stateNode,typeof O.componentDidMount=="function")try{O.componentDidMount()}catch(wn){Gc(v,v.return,wn)}if(v=$,O=v.updateQueue,O!==null){var Te=v.stateNode;try{var dt=O.shared.hiddenCallbacks;if(dt!==null)for(O.shared.hiddenCallbacks=null,O=0;O<dt.length;O++)Kw(dt[O],Te)}catch(wn){Gc(v,v.return,wn)}}b&&ae&64&&Gb($),M0($,$.return);break;case 27:fw($);case 26:case 5:Dg(O,$,b),b&&v===null&&ae&4&&cw($),M0($,$.return);break;case 12:Dg(O,$,b);break;case 13:Dg(O,$,b),b&&ae&4&&X2(O,$);break;case 22:$.memoizedState===null&&Dg(O,$,b),M0($,$.return);break;case 30:break;default:Dg(O,$,b)}p=p.sibling}}function _w(o,p){var b=null;o!==null&&o.memoizedState!==null&&o.memoizedState.cachePool!==null&&(b=o.memoizedState.cachePool.pool),o=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(o=p.memoizedState.cachePool.pool),o!==b&&(o!=null&&o.refCount++,b!=null&&l0(b))}function mw(o,p){o=null,p.alternate!==null&&(o=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==o&&(p.refCount++,o!=null&&l0(o))}function D_(o,p,b,v){if(p.subtreeFlags&10256)for(p=p.child;p!==null;)gw(o,p,b,v),p=p.sibling}function gw(o,p,b,v){var O=p.flags;switch(p.tag){case 0:case 11:case 15:D_(o,p,b,v),O&2048&&T0(9,p);break;case 1:D_(o,p,b,v);break;case 3:D_(o,p,b,v),O&2048&&(o=null,p.alternate!==null&&(o=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==o&&(p.refCount++,o!=null&&l0(o)));break;case 12:if(O&2048){D_(o,p,b,v),o=p.stateNode;try{var $=p.memoizedProps,ae=$.id,Te=$.onPostCommit;typeof Te=="function"&&Te(ae,p.alternate===null?"mount":"update",o.passiveEffectDuration,-0)}catch(dt){Gc(p,p.return,dt)}}else D_(o,p,b,v);break;case 13:D_(o,p,b,v);break;case 23:break;case 22:$=p.stateNode,ae=p.alternate,p.memoizedState!==null?$._visibility&2?D_(o,p,b,v):E0(o,p):$._visibility&2?D_(o,p,b,v):($._visibility|=2,L1(o,p,b,v,(p.subtreeFlags&10256)!==0)),O&2048&&_w(ae,p);break;case 24:D_(o,p,b,v),O&2048&&mw(p.alternate,p);break;default:D_(o,p,b,v)}}function L1(o,p,b,v,O){for(O=O&&(p.subtreeFlags&10256)!==0,p=p.child;p!==null;){var $=o,ae=p,Te=b,dt=v,wn=ae.flags;switch(ae.tag){case 0:case 11:case 15:L1($,ae,Te,dt,O),T0(8,ae);break;case 23:break;case 22:var dr=ae.stateNode;ae.memoizedState!==null?dr._visibility&2?L1($,ae,Te,dt,O):E0($,ae):(dr._visibility|=2,L1($,ae,Te,dt,O)),O&&wn&2048&&_w(ae.alternate,ae);break;case 24:L1($,ae,Te,dt,O),O&&wn&2048&&mw(ae.alternate,ae);break;default:L1($,ae,Te,dt,O)}p=p.sibling}}function E0(o,p){if(p.subtreeFlags&10256)for(p=p.child;p!==null;){var b=o,v=p,O=v.flags;switch(v.tag){case 22:E0(b,v),O&2048&&_w(v.alternate,v);break;case 24:E0(b,v),O&2048&&mw(v.alternate,v);break;default:E0(b,v)}p=p.sibling}}var $1=8192;function F1(o){if(o.subtreeFlags&$1)for(o=o.child;o!==null;)J2(o),o=o.sibling}function J2(o){switch(o.tag){case 26:F1(o),o.flags&$1&&o.memoizedState!==null&&bT(w_,o.memoizedState,o.memoizedProps);break;case 5:F1(o);break;case 3:case 4:var p=w_;w_=L0(o.stateNode.containerInfo),F1(o),w_=p;break;case 22:o.memoizedState===null&&(p=o.alternate,p!==null&&p.memoizedState!==null?(p=$1,$1=16777216,F1(o),$1=p):F1(o));break;default:F1(o)}}function ex(o){var p=o.alternate;if(p!==null&&(o=p.child,o!==null)){p.child=null;do p=o.sibling,o.sibling=null,o=p;while(o!==null)}}function N1(o){var p=o.deletions;if((o.flags&16)!==0){if(p!==null)for(var b=0;b<p.length;b++){var v=p[b];Sp=v,nx(v,o)}ex(o)}if(o.subtreeFlags&10256)for(o=o.child;o!==null;)tx(o),o=o.sibling}function tx(o){switch(o.tag){case 0:case 11:case 15:N1(o),o.flags&2048&&H_(9,o,o.return);break;case 3:N1(o);break;case 12:N1(o);break;case 22:var p=o.stateNode;o.memoizedState!==null&&p._visibility&2&&(o.return===null||o.return.tag!==13)?(p._visibility&=-3,R1(o)):N1(o);break;default:N1(o)}}function R1(o){var p=o.deletions;if((o.flags&16)!==0){if(p!==null)for(var b=0;b<p.length;b++){var v=p[b];Sp=v,nx(v,o)}ex(o)}for(o=o.child;o!==null;){switch(p=o,p.tag){case 0:case 11:case 15:H_(8,p,p.return),R1(p);break;case 22:b=p.stateNode,b._visibility&2&&(b._visibility&=-3,R1(p));break;default:R1(p)}o=o.sibling}}function nx(o,p){for(;Sp!==null;){var b=Sp;switch(b.tag){case 0:case 11:case 15:H_(8,b,p);break;case 23:case 22:if(b.memoizedState!==null&&b.memoizedState.cachePool!==null){var v=b.memoizedState.cachePool.pool;v!=null&&v.refCount++}break;case 24:l0(b.memoizedState.cache)}if(v=b.child,v!==null)v.return=b,Sp=v;else e:for(b=o;Sp!==null;){v=Sp;var O=v.sibling,$=v.return;if(Yb(v),v===b){Sp=null;break e}if(O!==null){O.return=$,Sp=O;break e}Sp=$}}}var Ux={getCacheForType:function(o){var p=zp(wp),b=p.data.get(o);return b===void 0&&(b=o(),p.data.set(o,b)),b}},Vx=typeof WeakMap=="function"?WeakMap:Map,$c=0,Vc=null,Xo=null,vc=0,Fc=0,u_=null,Lg=!1,z1=!1,S0=!1,Y_=0,np=0,$g=0,bu=0,rx=0,x_=0,P0=0,Qb=null,e_=null,bw=!1,yw=0,Zb=1/0,Jb=null,X_=null,Pp=0,i1=null,B1=null,j1=0,ey=0,ww=null,sx=null,ty=0,xw=null;function c_(){if(($c&2)!==0&&vc!==0)return vc&-vc;if(z.T!==null){var o=v1;return o!==0?o:No()}return Rp()}function ix(){x_===0&&(x_=(vc&536870912)===0||kc?Mo():536870912);var o=Mp.current;return o!==null&&(o.flags|=32),x_}function Dp(o,p,b){(o===Vc&&(Fc===2||Fc===9)||o.cancelPendingCommit!==null)&&(U1(o,0),Fg(o,vc,x_,!1)),cp(o,b),(($c&2)===0||o!==Vc)&&(o===Vc&&(($c&2)===0&&(bu|=b),np===4&&Fg(o,vc,x_,!1)),Q_(o))}function ax(o,p,b){if(($c&6)!==0)throw Error(s(327));var v=!b&&(p&124)===0&&(p&o.expiredLanes)===0||up(o,p),O=v?Hx(o,p):Mw(o,p,!0),$=v;do{if(O===0){z1&&!v&&Fg(o,p,0,!1);break}else{if(b=o.current.alternate,$&&!Gx(b)){O=Mw(o,p,!1),$=!1;continue}if(O===2){if($=p,o.errorRecoveryDisabledLanes&$)var ae=0;else ae=o.pendingLanes&-536870913,ae=ae!==0?ae:ae&536870912?536870912:0;if(ae!==0){p=ae;e:{var Te=o;O=Qb;var dt=Te.current.memoizedState.isDehydrated;if(dt&&(U1(Te,ae).flags|=256),ae=Mw(Te,ae,!1),ae!==2){if(S0&&!dt){Te.errorRecoveryDisabledLanes|=$,bu|=$,O=4;break e}$=e_,e_=O,$!==null&&(e_===null?e_=$:e_.push.apply(e_,$))}O=ae}if($=!1,O!==2)continue}}if(O===1){U1(o,0),Fg(o,p,0,!0);break}e:{switch(v=o,$=O,$){case 0:case 1:throw Error(s(345));case 4:if((p&4194048)!==p)break;case 6:Fg(v,p,x_,!Lg);break e;case 2:e_=null;break;case 3:case 5:break;default:throw Error(s(329))}if((p&62914560)===p&&(O=yw+300-cn(),10<O)){if(Fg(v,p,x_,!Lg),Xc(v,0,!0)!==0)break e;v.timeoutHandle=G1(ox.bind(null,v,b,e_,Jb,bw,p,x_,bu,P0,Lg,$,2,-0,0),O);break e}ox(v,b,e_,Jb,bw,p,x_,bu,P0,Lg,$,0,-0,0)}}break}while(!0);Q_(o)}function ox(o,p,b,v,O,$,ae,Te,dt,wn,dr,ni,Pn,Cn){if(o.timeoutHandle=-1,ni=p.subtreeFlags,(ni&8192||(ni&16785408)===16785408)&&(yx={stylesheets:null,count:0,unsuspend:gT},J2(p),ni=yT(),ni!==null)){o.cancelPendingCommit=ni(Qx.bind(null,o,p,$,b,v,O,ae,Te,dt,dr,1,Pn,Cn)),Fg(o,$,ae,!wn);return}Qx(o,p,$,b,v,O,ae,Te,dt)}function Gx(o){for(var p=o;;){var b=p.tag;if((b===0||b===11||b===15)&&p.flags&16384&&(b=p.updateQueue,b!==null&&(b=b.stores,b!==null)))for(var v=0;v<b.length;v++){var O=b[v],$=O.getSnapshot;O=O.value;try{if(!Tp($(),O))return!1}catch{return!1}}if(b=p.child,p.subtreeFlags&16384&&b!==null)b.return=p,p=b;else{if(p===o)break;for(;p.sibling===null;){if(p.return===null||p.return===o)return!0;p=p.return}p.sibling.return=p.return,p=p.sibling}}return!0}function Fg(o,p,b,v){p&=~rx,p&=~bu,o.suspendedLanes|=p,o.pingedLanes&=~p,v&&(o.warmLanes|=p),v=o.expirationTimes;for(var O=p;0<O;){var $=31-ui(O),ae=1<<$;v[$]=-1,O&=~ae}b!==0&&si(o,b,p)}function ny(){return($c&6)===0?(ry(0),!1):!0}function vw(){if(Xo!==null){if(Fc===0)var o=Xo.return;else o=Xo,j_=e1=null,Ry(o),k1=null,y0=0,o=Xo;for(;o!==null;)H2(o.alternate,o),o=o.return;Xo=null}}function U1(o,p){var b=o.timeoutHandle;b!==-1&&(o.timeoutHandle=-1,O0(b)),b=o.cancelPendingCommit,b!==null&&(o.cancelPendingCommit=null,b()),vw(),Vc=o,Xo=b=z_(o.current,null),vc=p,Fc=0,u_=null,Lg=!1,z1=up(o,p),S0=!1,P0=x_=rx=bu=$g=np=0,e_=Qb=null,bw=!1,(p&8)!==0&&(p|=p&32);var v=o.entangledLanes;if(v!==0)for(o=o.entanglements,v&=p;0<v;){var O=31-ui(v),$=1<<O;p|=o[O],v&=~$}return Y_=p,e0(),b}function lx(o,p){Yo=null,z.H=b0,p===c0||p===d0?(p=qw(),Fc=3):p===Vw?(p=qw(),Fc=4):Fc=p===Fx?8:p!==null&&typeof p=="object"&&typeof p.then=="function"?6:1,u_=p,Xo===null&&(np=1,Rb(o,Ic(p,o.current)))}function Wx(){var o=z.H;return z.H=b0,o===null?b0:o}function ux(){var o=z.A;return z.A=Ux,o}function Tw(){np=4,Lg||(vc&4194048)!==vc&&Mp.current!==null||(z1=!0),($g&134217727)===0&&(bu&134217727)===0||Vc===null||Fg(Vc,vc,x_,!1)}function Mw(o,p,b){var v=$c;$c|=2;var O=Wx(),$=ux();(Vc!==o||vc!==p)&&(Jb=null,U1(o,p)),p=!1;var ae=np;e:do try{if(Fc!==0&&Xo!==null){var Te=Xo,dt=u_;switch(Fc){case 8:vw(),ae=6;break e;case 3:case 2:case 9:case 6:Mp.current===null&&(p=!0);var wn=Fc;if(Fc=0,u_=null,A0(o,Te,dt,wn),b&&z1){ae=0;break e}break;default:wn=Fc,Fc=0,u_=null,A0(o,Te,dt,wn)}}qx(),ae=np;break}catch(dr){lx(o,dr)}while(!0);return p&&o.shellSuspendCounter++,j_=e1=null,$c=v,z.H=O,z.A=$,Xo===null&&(Vc=null,vc=0,e0()),ae}function qx(){for(;Xo!==null;)Yx(Xo)}function Hx(o,p){var b=$c;$c|=2;var v=Wx(),O=ux();Vc!==o||vc!==p?(Jb=null,Zb=cn()+500,U1(o,p)):z1=up(o,p);e:do try{if(Fc!==0&&Xo!==null){p=Xo;var $=u_;t:switch(Fc){case 1:Fc=0,u_=null,A0(o,p,$,1);break;case 2:case 9:if(Gw($)){Fc=0,u_=null,cx(p);break}p=function(){Fc!==2&&Fc!==9||Vc!==o||(Fc=7),Q_(o)},$.then(p,p);break e;case 3:Fc=7;break e;case 4:Fc=5;break e;case 7:Gw($)?(Fc=0,u_=null,cx(p)):(Fc=0,u_=null,A0(o,p,$,7));break;case 5:var ae=null;switch(Xo.tag){case 26:ae=Xo.memoizedState;case 5:case 27:var Te=Xo;if(!ae||Hv(ae)){Fc=0,u_=null;var dt=Te.sibling;if(dt!==null)Xo=dt;else{var wn=Te.return;wn!==null?(Xo=wn,Ew(wn)):Xo=null}break t}}Fc=0,u_=null,A0(o,p,$,5);break;case 6:Fc=0,u_=null,A0(o,p,$,6);break;case 8:vw(),np=6;break e;default:throw Error(s(462))}}Kx();break}catch(dr){lx(o,dr)}while(!0);return j_=e1=null,z.H=v,z.A=O,$c=b,Xo!==null?0:(Vc=null,vc=0,e0(),np)}function Kx(){for(;Xo!==null&&!In();)Yx(Xo)}function Yx(o){var p=q2(o.alternate,o,Y_);o.memoizedProps=o.pendingProps,p===null?Ew(o):Xo=p}function cx(o){var p=o,b=p.alternate;switch(p.tag){case 15:case 0:p=B2(b,p,p.pendingProps,p.type,void 0,vc);break;case 11:p=B2(b,p,p.pendingProps,p.type.render,p.ref,vc);break;case 5:Ry(p);default:H2(b,p),p=Xo=Dw(p,Y_),p=q2(b,p,Y_)}o.memoizedProps=o.pendingProps,p===null?Ew(o):Xo=p}function A0(o,p,b,v){j_=e1=null,Ry(p),k1=null,y0=0;var O=p.return;try{if($x(o,O,p,b,vc)){np=1,Rb(o,Ic(b,o.current)),Xo=null;return}}catch($){if(O!==null)throw Xo=O,$;np=1,Rb(o,Ic(b,o.current)),Xo=null;return}p.flags&32768?(kc||v===1?o=!0:z1||(vc&536870912)!==0?o=!1:(Lg=o=!0,(v===2||v===9||v===3||v===6)&&(v=Mp.current,v!==null&&v.tag===13&&(v.flags|=16384))),Xx(p,o)):Ew(p)}function Ew(o){var p=o;do{if((p.flags&32768)!==0){Xx(p,Lg);return}o=p.return;var b=Nx(p.alternate,p,Y_);if(b!==null){Xo=b;return}if(p=p.sibling,p!==null){Xo=p;return}Xo=p=o}while(p!==null);np===0&&(np=5)}function Xx(o,p){do{var b=Rx(o.alternate,o);if(b!==null){b.flags&=32767,Xo=b;return}if(b=o.return,b!==null&&(b.flags|=32768,b.subtreeFlags=0,b.deletions=null),!p&&(o=o.sibling,o!==null)){Xo=o;return}Xo=o=b}while(o!==null);np=6,Xo=null}function Qx(o,p,b,v,O,$,ae,Te,dt){o.cancelPendingCommit=null;do Sw();while(Pp!==0);if(($c&6)!==0)throw Error(s(327));if(p!==null){if(p===o.current)throw Error(s(177));if($=p.lanes|p.childLanes,$|=yy,Wi(o,b,$,ae,Te,dt),o===Vc&&(Xo=Vc=null,vc=0),B1=p,i1=o,j1=b,ey=$,ww=O,sx=v,(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?(o.callbackNode=null,o.callbackPriority=0,Sv(cr,function(){return nv(),null})):(o.callbackNode=null,o.callbackPriority=0),v=(p.flags&13878)!==0,(p.subtreeFlags&13878)!==0||v){v=z.T,z.T=null,O=H.p,H.p=2,ae=$c,$c|=4;try{Bx(o,p,b)}finally{$c=ae,H.p=O,z.T=v}}Pp=1,Zx(),Jx(),ev()}}function Zx(){if(Pp===1){Pp=0;var o=i1,p=B1,b=(p.flags&13878)!==0;if((p.subtreeFlags&13878)!==0||b){b=z.T,z.T=null;var v=H.p;H.p=2;var O=$c;$c|=4;try{Q2(p,o);var $=Jc,ae=J1(o.containerInfo),Te=$.focusedElem,dt=$.selectionRange;if(ae!==Te&&Te&&Te.ownerDocument&&m1(Te.ownerDocument.documentElement,Te)){if(dt!==null&&Wg(Te)){var wn=dt.start,dr=dt.end;if(dr===void 0&&(dr=wn),"selectionStart"in Te)Te.selectionStart=wn,Te.selectionEnd=Math.min(dr,Te.value.length);else{var ni=Te.ownerDocument||document,Pn=ni&&ni.defaultView||window;if(Pn.getSelection){var Cn=Pn.getSelection(),Go=Te.textContent.length,Bo=Math.min(dt.start,Go),qc=dt.end===void 0?Bo:Math.min(dt.end,Go);!Cn.extend&&Bo>qc&&(ae=qc,qc=Bo,Bo=ae);var pn=_1(Te,Bo),St=_1(Te,qc);if(pn&&St&&(Cn.rangeCount!==1||Cn.anchorNode!==pn.node||Cn.anchorOffset!==pn.offset||Cn.focusNode!==St.node||Cn.focusOffset!==St.offset)){var gn=ni.createRange();gn.setStart(pn.node,pn.offset),Cn.removeAllRanges(),Bo>qc?(Cn.addRange(gn),Cn.extend(St.node,St.offset)):(gn.setEnd(St.node,St.offset),Cn.addRange(gn))}}}}for(ni=[],Cn=Te;Cn=Cn.parentNode;)Cn.nodeType===1&&ni.push({element:Cn,left:Cn.scrollLeft,top:Cn.scrollTop});for(typeof Te.focus=="function"&&Te.focus(),Te=0;Te<ni.length;Te++){var ei=ni[Te];ei.element.scrollLeft=ei.left,ei.element.scrollTop=ei.top}}_v=!!rp,Jc=rp=null}finally{$c=O,H.p=v,z.T=b}}o.current=p,Pp=2}}function Jx(){if(Pp===2){Pp=0;var o=i1,p=B1,b=(p.flags&8772)!==0;if((p.subtreeFlags&8772)!==0||b){b=z.T,z.T=null;var v=H.p;H.p=2;var O=$c;$c|=4;try{Y2(o,p.alternate,p)}finally{$c=O,H.p=v,z.T=b}}Pp=3}}function ev(){if(Pp===4||Pp===3){Pp=0,Tn();var o=i1,p=B1,b=j1,v=sx;(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?Pp=5:(Pp=0,B1=i1=null,tv(o,o.pendingLanes));var O=o.pendingLanes;if(O===0&&(X_=null),Ui(b),p=p.stateNode,mi&&typeof mi.onCommitFiberRoot=="function")try{mi.onCommitFiberRoot(ai,p,void 0,(p.current.flags&128)===128)}catch{}if(v!==null){p=z.T,O=H.p,H.p=2,z.T=null;try{for(var $=o.onRecoverableError,ae=0;ae<v.length;ae++){var Te=v[ae];$(Te.value,{componentStack:Te.stack})}}finally{z.T=p,H.p=O}}(j1&3)!==0&&Sw(),Q_(o),O=o.pendingLanes,(b&4194090)!==0&&(O&42)!==0?o===xw?ty++:(ty=0,xw=o):ty=0,ry(0)}}function tv(o,p){(o.pooledCacheLanes&=p)===0&&(p=o.pooledCache,p!=null&&(o.pooledCache=null,l0(p)))}function Sw(o){return Zx(),Jx(),ev(),nv()}function nv(){if(Pp!==5)return!1;var o=i1,p=ey;ey=0;var b=Ui(j1),v=z.T,O=H.p;try{H.p=32>b?32:b,z.T=null,b=ww,ww=null;var $=i1,ae=j1;if(Pp=0,B1=i1=null,j1=0,($c&6)!==0)throw Error(s(331));var Te=$c;if($c|=4,tx($.current),gw($,$.current,ae,b),$c=Te,ry(0,!1),mi&&typeof mi.onPostCommitFiberRoot=="function")try{mi.onPostCommitFiberRoot(ai,$)}catch{}return!0}finally{H.p=O,z.T=v,tv(o,p)}}function rv(o,p,b){p=Ic(b,p),p=x0(o.stateNode,p,2),o=Pg(o,p,2),o!==null&&(cp(o,2),Q_(o))}function Gc(o,p,b){if(o.tag===3)rv(o,o,b);else for(;p!==null;){if(p.tag===3){rv(p,o,b);break}else if(p.tag===1){var v=p.stateNode;if(typeof p.type.getDerivedStateFromError=="function"||typeof v.componentDidCatch=="function"&&(X_===null||!X_.has(v))){o=Ic(b,o),b=L2(2),v=Pg(p,b,2),v!==null&&($2(b,v,p,o),cp(v,2),Q_(v));break}}p=p.return}}function dx(o,p,b){var v=o.pingCache;if(v===null){v=o.pingCache=new Vx;var O=new Set;v.set(p,O)}else O=v.get(p),O===void 0&&(O=new Set,v.set(p,O));O.has(b)||(S0=!0,O.add(b),o=Tv.bind(null,o,p,b),p.then(o,o))}function Tv(o,p,b){var v=o.pingCache;v!==null&&v.delete(p),o.pingedLanes|=o.suspendedLanes&b,o.warmLanes&=~b,Vc===o&&(vc&b)===b&&(np===4||np===3&&(vc&62914560)===vc&&300>cn()-yw?($c&2)===0&&U1(o,0):rx|=b,P0===vc&&(P0=0)),Q_(o)}function sv(o,p){p===0&&(p=$p()),o=Hg(o,p),o!==null&&(cp(o,p),Q_(o))}function Mv(o){var p=o.memoizedState,b=0;p!==null&&(b=p.retryLane),sv(o,b)}function Ev(o,p){var b=0;switch(o.tag){case 13:var v=o.stateNode,O=o.memoizedState;O!==null&&(b=O.retryLane);break;case 19:v=o.stateNode;break;case 22:v=o.stateNode._retryCache;break;default:throw Error(s(314))}v!==null&&v.delete(p),sv(o,b)}function Sv(o,p){return ke(o,p)}var Pw=null,C0=null,px=!1,Aw=!1,fx=!1,V1=0;function Q_(o){o!==C0&&o.next===null&&(C0===null?Pw=C0=o:C0=C0.next=o),Aw=!0,px||(px=!0,Av())}function ry(o,p){if(!fx&&Aw){fx=!0;do for(var b=!1,v=Pw;v!==null;){if(o!==0){var O=v.pendingLanes;if(O===0)var $=0;else{var ae=v.suspendedLanes,Te=v.pingedLanes;$=(1<<31-ui(42|o)+1)-1,$&=O&~(ae&~Te),$=$&201326741?$&201326741|1:$?$|2:0}$!==0&&(b=!0,lv(v,$))}else $=vc,$=Xc(v,v===Vc?$:0,v.cancelPendingCommit!==null||v.timeoutHandle!==-1),($&3)===0||up(v,$)||(b=!0,lv(v,$));v=v.next}while(b);fx=!1}}function Pv(){iv()}function iv(){Aw=px=!1;var o=0;V1!==0&&(L_()&&(o=V1),V1=0);for(var p=cn(),b=null,v=Pw;v!==null;){var O=v.next,$=av(v,p);$===0?(v.next=null,b===null?Pw=O:b.next=O,O===null&&(C0=b)):(b=v,(o!==0||($&3)!==0)&&(Aw=!0)),v=O}ry(o)}function av(o,p){for(var b=o.suspendedLanes,v=o.pingedLanes,O=o.expirationTimes,$=o.pendingLanes&-62914561;0<$;){var ae=31-ui($),Te=1<<ae,dt=O[ae];dt===-1?((Te&b)===0||(Te&v)!==0)&&(O[ae]=Jo(Te,p)):dt<=p&&(o.expiredLanes|=Te),$&=~Te}if(p=Vc,b=vc,b=Xc(o,o===p?b:0,o.cancelPendingCommit!==null||o.timeoutHandle!==-1),v=o.callbackNode,b===0||o===p&&(Fc===2||Fc===9)||o.cancelPendingCommit!==null)return v!==null&&v!==null&&Bt(v),o.callbackNode=null,o.callbackPriority=0;if((b&3)===0||up(o,b)){if(p=b&-b,p===o.callbackPriority)return p;switch(v!==null&&Bt(v),Ui(b)){case 2:case 8:b=$n;break;case 32:b=cr;break;case 268435456:b=vn;break;default:b=cr}return v=ov.bind(null,o),b=ke(b,v),o.callbackPriority=p,o.callbackNode=b,p}return v!==null&&v!==null&&Bt(v),o.callbackPriority=2,o.callbackNode=null,2}function ov(o,p){if(Pp!==0&&Pp!==5)return o.callbackNode=null,o.callbackPriority=0,null;var b=o.callbackNode;if(Sw()&&o.callbackNode!==b)return null;var v=vc;return v=Xc(o,o===Vc?v:0,o.cancelPendingCommit!==null||o.timeoutHandle!==-1),v===0?null:(ax(o,v,p),av(o,cn()),o.callbackNode!=null&&o.callbackNode===b?ov.bind(null,o):null)}function lv(o,p){if(Sw())return null;ax(o,p,!0)}function Av(){iy(function(){($c&6)!==0?ke(yn,Pv):iv()})}function No(){return V1===0&&(V1=Mo()),V1}function hx(o){return o==null||typeof o=="symbol"||typeof o=="boolean"?null:typeof o=="function"?o:di(""+o)}function mp(o,p){var b=p.ownerDocument.createElement("input");return b.name=p.name,b.value=p.value,o.id&&b.setAttribute("form",o.id),p.parentNode.insertBefore(b,p),o=new FormData(o),b.parentNode.removeChild(b),o}function Ap(o,p,b,v,O){if(p==="submit"&&b&&b.stateNode===O){var $=hx((O[Ke]||null).action),ae=v.submitter;ae&&(p=(p=ae[Ke]||null)?hx(p.formAction):ae.getAttribute("formAction"),p!==null&&($=p,ae=null));var Te=new Ii("action","action",null,v,O);o.push({event:Te,listeners:[{instance:null,listener:function(){if(v.defaultPrevented){if(V1!==0){var dt=ae?mp(O,ae):new FormData(O);Ky(b,{pending:!0,data:dt,method:O.method,action:$},null,dt)}}else typeof $=="function"&&(Te.preventDefault(),dt=ae?mp(O,ae):new FormData(O),Ky(b,{pending:!0,data:dt,method:O.method,action:$},$,dt))},currentTarget:O}]})}}for(var Cp=0;Cp<Fo.length;Cp++){var Ng=Fo[Cp],Cv=Ng.toLowerCase(),uv=Ng[0].toUpperCase()+Ng.slice(1);jo(Cv,"on"+uv)}jo(le,"onAnimationEnd"),jo(_e,"onAnimationIteration"),jo(De,"onAnimationStart"),jo("dblclick","onDoubleClick"),jo("focusin","onFocus"),jo("focusout","onBlur"),jo(mt,"onTransitionRun"),jo(nr,"onTransitionStart"),jo(li,"onTransitionCancel"),jo(bi,"onTransitionEnd"),pi("onMouseEnter",["mouseout","mouseover"]),pi("onMouseLeave",["mouseout","mouseover"]),pi("onPointerEnter",["pointerout","pointerover"]),pi("onPointerLeave",["pointerout","pointerover"]),Ti("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ti("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ti("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ti("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ti("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ti("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var k0="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),B=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(k0));function j(o,p){p=(p&4)!==0;for(var b=0;b<o.length;b++){var v=o[b],O=v.event;v=v.listeners;e:{var $=void 0;if(p)for(var ae=v.length-1;0<=ae;ae--){var Te=v[ae],dt=Te.instance,wn=Te.currentTarget;if(Te=Te.listener,dt!==$&&O.isPropagationStopped())break e;$=Te,O.currentTarget=wn;try{$(O)}catch(dr){Nb(dr)}O.currentTarget=null,$=dt}else for(ae=0;ae<v.length;ae++){if(Te=v[ae],dt=Te.instance,wn=Te.currentTarget,Te=Te.listener,dt!==$&&O.isPropagationStopped())break e;$=Te,O.currentTarget=wn;try{$(O)}catch(dr){Nb(dr)}O.currentTarget=null,$=dt}}}}function ye(o,p){var b=p[_n];b===void 0&&(b=p[_n]=new Set);var v=o+"__bubble";b.has(v)||(ur(p,o,2,!1),b.add(v))}function _t(o,p,b){var v=0;p&&(v|=4),ur(b,o,v,p)}var fn="_reactListening"+Math.random().toString(36).slice(2);function xn(o){if(!o[fn]){o[fn]=!0,mn.forEach(function(b){b!=="selectionchange"&&(B.has(b)||_t(b,!1,o),_t(b,!0,o))});var p=o.nodeType===9?o:o.ownerDocument;p===null||p[fn]||(p[fn]=!0,_t("selectionchange",!1,p))}}function ur(o,p,b,v){switch(Jv(p)){case 2:var O=vT;break;case 8:O=TT;break;default:O=Nv}b=O.bind(null,p,b,o),O=void 0,!tp||p!=="touchstart"&&p!=="touchmove"&&p!=="wheel"||(O=!0),v?O!==void 0?o.addEventListener(p,b,{capture:!0,passive:O}):o.addEventListener(p,b,!0):O!==void 0?o.addEventListener(p,b,{passive:O}):o.addEventListener(p,b,!1)}function oi(o,p,b,v,O){var $=v;if((p&1)===0&&(p&2)===0&&v!==null)e:for(;;){if(v===null)return;var ae=v.tag;if(ae===3||ae===4){var Te=v.stateNode.containerInfo;if(Te===O)break;if(ae===4)for(ae=v.return;ae!==null;){var dt=ae.tag;if((dt===3||dt===4)&&ae.stateNode.containerInfo===O)return;ae=ae.return}for(;Te!==null;){if(ae=we(Te),ae===null)return;if(dt=ae.tag,dt===5||dt===6||dt===26||dt===27){v=$=ae;continue e}Te=Te.parentNode}}v=v.return}Mc(function(){var wn=$,dr=Hi(b),ni=[];e:{var Pn=Ai.get(o);if(Pn!==void 0){var Cn=Ii,Go=o;switch(o){case"keypress":if(ct(b)===0)break e;case"keydown":case"keyup":Cn=G0;break;case"focusin":Go="focus",Cn=F_;break;case"focusout":Go="blur",Cn=F_;break;case"beforeblur":case"afterblur":Cn=F_;break;case"click":if(b.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Cn=Bc;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Cn=E_;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Cn=q0;break;case le:case _e:case De:Cn=cy;break;case bi:Cn=H0;break;case"scroll":case"scrollend":Cn=Zo;break;case"wheel":Cn=Y0;break;case"copy":case"cut":case"paste":Cn=py;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Cn=K1;break;case"toggle":case"beforetoggle":Cn=Q0}var Bo=(p&4)!==0,qc=!Bo&&(o==="scroll"||o==="scrollend"),pn=Bo?Pn!==null?Pn+"Capture":null:Pn;Bo=[];for(var St=wn,gn;St!==null;){var ei=St;if(gn=ei.stateNode,ei=ei.tag,ei!==5&&ei!==26&&ei!==27||gn===null||pn===null||(ei=ip(St,pn),ei!=null&&Bo.push(_i(St,ei,gn))),qc)break;St=St.return}0<Bo.length&&(Pn=new Cn(Pn,Go,null,b,dr),ni.push({event:Pn,listeners:Bo}))}}if((p&7)===0){e:{if(Pn=o==="mouseover"||o==="pointerover",Cn=o==="mouseout"||o==="pointerout",Pn&&b!==zo&&(Go=b.relatedTarget||b.fromElement)&&(we(Go)||Go[lt]))break e;if((Cn||Pn)&&(Pn=dr.window===dr?dr:(Pn=dr.ownerDocument)?Pn.defaultView||Pn.parentWindow:window,Cn?(Go=b.relatedTarget||b.toElement,Cn=wn,Go=Go?we(Go):null,Go!==null&&(qc=c(Go),Bo=Go.tag,Go!==qc||Bo!==5&&Bo!==27&&Bo!==6)&&(Go=null)):(Cn=null,Go=wn),Cn!==Go)){if(Bo=Bc,ei="onMouseLeave",pn="onMouseEnter",St="mouse",(o==="pointerout"||o==="pointerover")&&(Bo=K1,ei="onPointerLeave",pn="onPointerEnter",St="pointer"),qc=Cn==null?Pn:pt(Cn),gn=Go==null?Pn:pt(Go),Pn=new Bo(ei,St+"leave",Cn,b,dr),Pn.target=qc,Pn.relatedTarget=gn,ei=null,we(dr)===wn&&(Bo=new Bo(pn,St+"enter",Go,b,dr),Bo.target=gn,Bo.relatedTarget=qc,ei=Bo),qc=ei,Cn&&Go)t:{for(Bo=Cn,pn=Go,St=0,gn=Bo;gn;gn=Ya(gn))St++;for(gn=0,ei=pn;ei;ei=Ya(ei))gn++;for(;0<St-gn;)Bo=Ya(Bo),St--;for(;0<gn-St;)pn=Ya(pn),gn--;for(;St--;){if(Bo===pn||pn!==null&&Bo===pn.alternate)break t;Bo=Ya(Bo),pn=Ya(pn)}Bo=null}else Bo=null;Cn!==null&&Vo(ni,Pn,Cn,Bo,!1),Go!==null&&qc!==null&&Vo(ni,qc,Go,Bo,!0)}}e:{if(Pn=wn?pt(wn):window,Cn=Pn.nodeName&&Pn.nodeName.toLowerCase(),Cn==="select"||Cn==="input"&&Pn.type==="file")var $i=tb;else if(u1(Pn))if(nb)$i=f_;else{$i=p1;var xc=sb}else Cn=Pn.nodeName,!Cn||Cn.toLowerCase()!=="input"||Pn.type!=="checkbox"&&Pn.type!=="radio"?wn&&or(wn.elementType)&&($i=tb):$i=f1;if($i&&($i=$i(o,wn))){c1(ni,$i,b,dr);break e}xc&&xc(o,Pn,wn),o==="focusout"&&wn&&Pn.type==="number"&&wn.memoizedProps.value!=null&&M_(Pn,"number",Pn.value)}switch(xc=wn?pt(wn):window,o){case"focusin":(u1(xc)||xc.contentEditable==="true")&&(b_=xc,vg=wn,N_=null);break;case"focusout":N_=vg=b_=null;break;case"mousedown":g1=!0;break;case"contextmenu":case"mouseup":case"dragend":g1=!1,b1(ni,b,dr);break;case"selectionchange":if(ib)break;case"keydown":case"keyup":b1(ni,b,dr)}var Vi;if(X1)e:{switch(o){case"compositionstart":var Uo="onCompositionStart";break e;case"compositionend":Uo="onCompositionEnd";break e;case"compositionupdate":Uo="onCompositionUpdate";break e}Uo=void 0}else S_?jg(o,b)&&(Uo="onCompositionEnd"):o==="keydown"&&b.keyCode===229&&(Uo="onCompositionStart");Uo&&(Z0&&b.locale!=="ko"&&(S_||Uo!=="onCompositionStart"?Uo==="onCompositionEnd"&&S_&&(Vi=Ve()):(wc=dr,Z="value"in wc?wc.value:wc.textContent,S_=!0)),xc=Ei(wn,Uo),0<xc.length&&(Uo=new J_(Uo,o,null,b,dr),ni.push({event:Uo,listeners:xc}),Vi?Uo.data=Vi:(Vi=gg(b),Vi!==null&&(Uo.data=Vi)))),(Vi=my?gy(o,b):Q1(o,b))&&(Uo=Ei(wn,"onBeforeInput"),0<Uo.length&&(xc=new J_("onBeforeInput","beforeinput",null,b,dr),ni.push({event:xc,listeners:Uo}),xc.data=Vi)),Ap(ni,o,wn,b,dr)}j(ni,p)})}function _i(o,p,b){return{instance:o,listener:p,currentTarget:b}}function Ei(o,p){for(var b=p+"Capture",v=[];o!==null;){var O=o,$=O.stateNode;if(O=O.tag,O!==5&&O!==26&&O!==27||$===null||(O=ip(o,b),O!=null&&v.unshift(_i(o,O,$)),O=ip(o,p),O!=null&&v.push(_i(o,O,$))),o.tag===3)return v;o=o.return}return[]}function Ya(o){if(o===null)return null;do o=o.return;while(o&&o.tag!==5&&o.tag!==27);return o||null}function Vo(o,p,b,v,O){for(var $=p._reactName,ae=[];b!==null&&b!==v;){var Te=b,dt=Te.alternate,wn=Te.stateNode;if(Te=Te.tag,dt!==null&&dt===v)break;Te!==5&&Te!==26&&Te!==27||wn===null||(dt=wn,O?(wn=ip(b,$),wn!=null&&ae.unshift(_i(b,wn,dt))):O||(wn=ip(b,$),wn!=null&&ae.push(_i(b,wn,dt)))),b=b.return}ae.length!==0&&o.push({event:p,listeners:ae})}var Wo=/\r\n?/g,Bi=/\u0000|\uFFFD/g;function Sc(o){return(typeof o=="string"?o:""+o).replace(Wo,`
`).replace(Bi,"")}function Gi(o,p){return p=Sc(p),Sc(o)===p}function Ni(){}function Di(o,p,b,v,O,$){switch(b){case"children":typeof v=="string"?p==="body"||p==="textarea"&&v===""||at(o,v):(typeof v=="number"||typeof v=="bigint")&&p!=="body"&&at(o,""+v);break;case"className":Oi(o,"class",v);break;case"tabIndex":Oi(o,"tabindex",v);break;case"dir":case"role":case"viewBox":case"width":case"height":Oi(o,b,v);break;case"style":sr(o,v,$);break;case"data":if(p!=="object"){Oi(o,"data",v);break}case"src":case"href":if(v===""&&(p!=="a"||b!=="href")){o.removeAttribute(b);break}if(v==null||typeof v=="function"||typeof v=="symbol"||typeof v=="boolean"){o.removeAttribute(b);break}v=di(""+v),o.setAttribute(b,v);break;case"action":case"formAction":if(typeof v=="function"){o.setAttribute(b,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof $=="function"&&(b==="formAction"?(p!=="input"&&Di(o,p,"name",O.name,O,null),Di(o,p,"formEncType",O.formEncType,O,null),Di(o,p,"formMethod",O.formMethod,O,null),Di(o,p,"formTarget",O.formTarget,O,null)):(Di(o,p,"encType",O.encType,O,null),Di(o,p,"method",O.method,O,null),Di(o,p,"target",O.target,O,null)));if(v==null||typeof v=="symbol"||typeof v=="boolean"){o.removeAttribute(b);break}v=di(""+v),o.setAttribute(b,v);break;case"onClick":v!=null&&(o.onclick=Ni);break;case"onScroll":v!=null&&ye("scroll",o);break;case"onScrollEnd":v!=null&&ye("scrollend",o);break;case"dangerouslySetInnerHTML":if(v!=null){if(typeof v!="object"||!("__html"in v))throw Error(s(61));if(b=v.__html,b!=null){if(O.children!=null)throw Error(s(60));o.innerHTML=b}}break;case"multiple":o.multiple=v&&typeof v!="function"&&typeof v!="symbol";break;case"muted":o.muted=v&&typeof v!="function"&&typeof v!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(v==null||typeof v=="function"||typeof v=="boolean"||typeof v=="symbol"){o.removeAttribute("xlink:href");break}b=di(""+v),o.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",b);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":v!=null&&typeof v!="function"&&typeof v!="symbol"?o.setAttribute(b,""+v):o.removeAttribute(b);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":v&&typeof v!="function"&&typeof v!="symbol"?o.setAttribute(b,""):o.removeAttribute(b);break;case"capture":case"download":v===!0?o.setAttribute(b,""):v!==!1&&v!=null&&typeof v!="function"&&typeof v!="symbol"?o.setAttribute(b,v):o.removeAttribute(b);break;case"cols":case"rows":case"size":case"span":v!=null&&typeof v!="function"&&typeof v!="symbol"&&!isNaN(v)&&1<=v?o.setAttribute(b,v):o.removeAttribute(b);break;case"rowSpan":case"start":v==null||typeof v=="function"||typeof v=="symbol"||isNaN(v)?o.removeAttribute(b):o.setAttribute(b,v);break;case"popover":ye("beforetoggle",o),ye("toggle",o),En(o,"popover",v);break;case"xlinkActuate":Ro(o,"http://www.w3.org/1999/xlink","xlink:actuate",v);break;case"xlinkArcrole":Ro(o,"http://www.w3.org/1999/xlink","xlink:arcrole",v);break;case"xlinkRole":Ro(o,"http://www.w3.org/1999/xlink","xlink:role",v);break;case"xlinkShow":Ro(o,"http://www.w3.org/1999/xlink","xlink:show",v);break;case"xlinkTitle":Ro(o,"http://www.w3.org/1999/xlink","xlink:title",v);break;case"xlinkType":Ro(o,"http://www.w3.org/1999/xlink","xlink:type",v);break;case"xmlBase":Ro(o,"http://www.w3.org/XML/1998/namespace","xml:base",v);break;case"xmlLang":Ro(o,"http://www.w3.org/XML/1998/namespace","xml:lang",v);break;case"xmlSpace":Ro(o,"http://www.w3.org/XML/1998/namespace","xml:space",v);break;case"is":En(o,"is",v);break;case"innerText":case"textContent":break;default:(!(2<b.length)||b[0]!=="o"&&b[0]!=="O"||b[1]!=="n"&&b[1]!=="N")&&(b=lr.get(b)||b,En(o,b,v))}}function Nc(o,p,b,v,O,$){switch(b){case"style":sr(o,v,$);break;case"dangerouslySetInnerHTML":if(v!=null){if(typeof v!="object"||!("__html"in v))throw Error(s(61));if(b=v.__html,b!=null){if(O.children!=null)throw Error(s(60));o.innerHTML=b}}break;case"children":typeof v=="string"?at(o,v):(typeof v=="number"||typeof v=="bigint")&&at(o,""+v);break;case"onScroll":v!=null&&ye("scroll",o);break;case"onScrollEnd":v!=null&&ye("scrollend",o);break;case"onClick":v!=null&&(o.onclick=Ni);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!ii.hasOwnProperty(b))e:{if(b[0]==="o"&&b[1]==="n"&&(O=b.endsWith("Capture"),p=b.slice(2,O?b.length-7:void 0),$=o[Ke]||null,$=$!=null?$[b]:null,typeof $=="function"&&o.removeEventListener(p,$,O),typeof v=="function")){typeof $!="function"&&$!==null&&(b in o?o[b]=null:o.hasAttribute(b)&&o.removeAttribute(b)),o.addEventListener(p,v,O);break e}b in o?o[b]=v:v===!0?o.setAttribute(b,""):En(o,b,v)}}}function Qo(o,p,b){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":ye("error",o),ye("load",o);var v=!1,O=!1,$;for($ in b)if(b.hasOwnProperty($)){var ae=b[$];if(ae!=null)switch($){case"src":v=!0;break;case"srcSet":O=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,p));default:Di(o,p,$,ae,b,null)}}O&&Di(o,p,"srcSet",b.srcSet,b,null),v&&Di(o,p,"src",b.src,b,null);return;case"input":ye("invalid",o);var Te=$=ae=O=null,dt=null,wn=null;for(v in b)if(b.hasOwnProperty(v)){var dr=b[v];if(dr!=null)switch(v){case"name":O=dr;break;case"type":ae=dr;break;case"checked":dt=dr;break;case"defaultChecked":wn=dr;break;case"value":$=dr;break;case"defaultValue":Te=dr;break;case"children":case"dangerouslySetInnerHTML":if(dr!=null)throw Error(s(137,p));break;default:Di(o,p,v,dr,b,null)}}T_(o,$,Te,dt,wn,ae,O,!1),Ac(o);return;case"select":ye("invalid",o),v=ae=$=null;for(O in b)if(b.hasOwnProperty(O)&&(Te=b[O],Te!=null))switch(O){case"value":$=Te;break;case"defaultValue":ae=Te;break;case"multiple":v=Te;default:Di(o,p,O,Te,b,null)}p=$,b=ae,o.multiple=!!v,p!=null?Lt(o,!!v,p,!1):b!=null&&Lt(o,!!v,b,!0);return;case"textarea":ye("invalid",o),$=O=v=null;for(ae in b)if(b.hasOwnProperty(ae)&&(Te=b[ae],Te!=null))switch(ae){case"value":v=Te;break;case"defaultValue":O=Te;break;case"children":$=Te;break;case"dangerouslySetInnerHTML":if(Te!=null)throw Error(s(91));break;default:Di(o,p,ae,Te,b,null)}$e(o,v,O,$),Ac(o);return;case"option":for(dt in b)if(b.hasOwnProperty(dt)&&(v=b[dt],v!=null))switch(dt){case"selected":o.selected=v&&typeof v!="function"&&typeof v!="symbol";break;default:Di(o,p,dt,v,b,null)}return;case"dialog":ye("beforetoggle",o),ye("toggle",o),ye("cancel",o),ye("close",o);break;case"iframe":case"object":ye("load",o);break;case"video":case"audio":for(v=0;v<k0.length;v++)ye(k0[v],o);break;case"image":ye("error",o),ye("load",o);break;case"details":ye("toggle",o);break;case"embed":case"source":case"link":ye("error",o),ye("load",o);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(wn in b)if(b.hasOwnProperty(wn)&&(v=b[wn],v!=null))switch(wn){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,p));default:Di(o,p,wn,v,b,null)}return;default:if(or(p)){for(dr in b)b.hasOwnProperty(dr)&&(v=b[dr],v!==void 0&&Nc(o,p,dr,v,b,void 0));return}}for(Te in b)b.hasOwnProperty(Te)&&(v=b[Te],v!=null&&Di(o,p,Te,v,b,null))}function gp(o,p,b,v){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var O=null,$=null,ae=null,Te=null,dt=null,wn=null,dr=null;for(Cn in b){var ni=b[Cn];if(b.hasOwnProperty(Cn)&&ni!=null)switch(Cn){case"checked":break;case"value":break;case"defaultValue":dt=ni;default:v.hasOwnProperty(Cn)||Di(o,p,Cn,null,v,ni)}}for(var Pn in v){var Cn=v[Pn];if(ni=b[Pn],v.hasOwnProperty(Pn)&&(Cn!=null||ni!=null))switch(Pn){case"type":$=Cn;break;case"name":O=Cn;break;case"checked":wn=Cn;break;case"defaultChecked":dr=Cn;break;case"value":ae=Cn;break;case"defaultValue":Te=Cn;break;case"children":case"dangerouslySetInnerHTML":if(Cn!=null)throw Error(s(137,p));break;default:Cn!==ni&&Di(o,p,Pn,Cn,v,ni)}}g_(o,ae,Te,dt,wn,dr,$,O);return;case"select":Cn=ae=Te=Pn=null;for($ in b)if(dt=b[$],b.hasOwnProperty($)&&dt!=null)switch($){case"value":break;case"multiple":Cn=dt;default:v.hasOwnProperty($)||Di(o,p,$,null,v,dt)}for(O in v)if($=v[O],dt=b[O],v.hasOwnProperty(O)&&($!=null||dt!=null))switch(O){case"value":Pn=$;break;case"defaultValue":Te=$;break;case"multiple":ae=$;default:$!==dt&&Di(o,p,O,$,v,dt)}p=Te,b=ae,v=Cn,Pn!=null?Lt(o,!!b,Pn,!1):!!v!=!!b&&(p!=null?Lt(o,!!b,p,!0):Lt(o,!!b,b?[]:"",!1));return;case"textarea":Cn=Pn=null;for(Te in b)if(O=b[Te],b.hasOwnProperty(Te)&&O!=null&&!v.hasOwnProperty(Te))switch(Te){case"value":break;case"children":break;default:Di(o,p,Te,null,v,O)}for(ae in v)if(O=v[ae],$=b[ae],v.hasOwnProperty(ae)&&(O!=null||$!=null))switch(ae){case"value":Pn=O;break;case"defaultValue":Cn=O;break;case"children":break;case"dangerouslySetInnerHTML":if(O!=null)throw Error(s(91));break;default:O!==$&&Di(o,p,ae,O,v,$)}X(o,Pn,Cn);return;case"option":for(var Go in b)if(Pn=b[Go],b.hasOwnProperty(Go)&&Pn!=null&&!v.hasOwnProperty(Go))switch(Go){case"selected":o.selected=!1;break;default:Di(o,p,Go,null,v,Pn)}for(dt in v)if(Pn=v[dt],Cn=b[dt],v.hasOwnProperty(dt)&&Pn!==Cn&&(Pn!=null||Cn!=null))switch(dt){case"selected":o.selected=Pn&&typeof Pn!="function"&&typeof Pn!="symbol";break;default:Di(o,p,dt,Pn,v,Cn)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Bo in b)Pn=b[Bo],b.hasOwnProperty(Bo)&&Pn!=null&&!v.hasOwnProperty(Bo)&&Di(o,p,Bo,null,v,Pn);for(wn in v)if(Pn=v[wn],Cn=b[wn],v.hasOwnProperty(wn)&&Pn!==Cn&&(Pn!=null||Cn!=null))switch(wn){case"children":case"dangerouslySetInnerHTML":if(Pn!=null)throw Error(s(137,p));break;default:Di(o,p,wn,Pn,v,Cn)}return;default:if(or(p)){for(var qc in b)Pn=b[qc],b.hasOwnProperty(qc)&&Pn!==void 0&&!v.hasOwnProperty(qc)&&Nc(o,p,qc,void 0,v,Pn);for(dr in v)Pn=v[dr],Cn=b[dr],!v.hasOwnProperty(dr)||Pn===Cn||Pn===void 0&&Cn===void 0||Nc(o,p,dr,Pn,v,Cn);return}}for(var pn in b)Pn=b[pn],b.hasOwnProperty(pn)&&Pn!=null&&!v.hasOwnProperty(pn)&&Di(o,p,pn,null,v,Pn);for(ni in v)Pn=v[ni],Cn=b[ni],!v.hasOwnProperty(ni)||Pn===Cn||Pn==null&&Cn==null||Di(o,p,ni,Pn,v,Cn)}var rp=null,Jc=null;function qo(o){return o.nodeType===9?o:o.ownerDocument}function Yc(o){switch(o){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function vp(o,p){if(o===0)switch(p){case"svg":return 1;case"math":return 2;default:return 0}return o===1&&p==="foreignObject"?0:o}function Rg(o,p){return o==="textarea"||o==="noscript"||typeof p.children=="string"||typeof p.children=="number"||typeof p.children=="bigint"||typeof p.dangerouslySetInnerHTML=="object"&&p.dangerouslySetInnerHTML!==null&&p.dangerouslySetInnerHTML.__html!=null}var Bp=null;function L_(){var o=window.event;return o&&o.type==="popstate"?o===Bp?!1:(Bp=o,!0):(Bp=null,!1)}var G1=typeof setTimeout=="function"?setTimeout:void 0,O0=typeof clearTimeout=="function"?clearTimeout:void 0,sy=typeof Promise=="function"?Promise:void 0,iy=typeof queueMicrotask=="function"?queueMicrotask:typeof sy<"u"?function(o){return sy.resolve(null).then(o).catch(kv)}:G1;function kv(o){setTimeout(function(){throw o})}function Pc(o){return o==="head"}function bp(o,p){var b=p,v=0,O=0;do{var $=b.nextSibling;if(o.removeChild(b),$&&$.nodeType===8)if(b=$.data,b==="/$"){if(0<v&&8>v){b=v;var ae=o.ownerDocument;if(b&1&&a1(ae.documentElement),b&2&&a1(ae.body),b&4)for(b=ae.head,a1(b),ae=b.firstChild;ae;){var Te=ae.nextSibling,dt=ae.nodeName;ae[hi]||dt==="SCRIPT"||dt==="STYLE"||dt==="LINK"&&ae.rel.toLowerCase()==="stylesheet"||b.removeChild(ae),ae=Te}}if(O===0){o.removeChild($),Mx(p);return}O--}else b==="$"||b==="$?"||b==="$!"?O++:v=b.charCodeAt(0)-48;else v=0;b=$}while(b);Mx(p)}function Z_(o){var p=o.firstChild;for(p&&p.nodeType===10&&(p=p.nextSibling);p;){var b=p;switch(p=p.nextSibling,b.nodeName){case"HTML":case"HEAD":case"BODY":Z_(b),Oo(b);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(b.rel.toLowerCase()==="stylesheet")continue}o.removeChild(b)}}function W1(o,p,b,v){for(;o.nodeType===1;){var O=b;if(o.nodeName.toLowerCase()!==p.toLowerCase()){if(!v&&(o.nodeName!=="INPUT"||o.type!=="hidden"))break}else if(v){if(!o[hi])switch(p){case"meta":if(!o.hasAttribute("itemprop"))break;return o;case"link":if($=o.getAttribute("rel"),$==="stylesheet"&&o.hasAttribute("data-precedence"))break;if($!==O.rel||o.getAttribute("href")!==(O.href==null||O.href===""?null:O.href)||o.getAttribute("crossorigin")!==(O.crossOrigin==null?null:O.crossOrigin)||o.getAttribute("title")!==(O.title==null?null:O.title))break;return o;case"style":if(o.hasAttribute("data-precedence"))break;return o;case"script":if($=o.getAttribute("src"),($!==(O.src==null?null:O.src)||o.getAttribute("type")!==(O.type==null?null:O.type)||o.getAttribute("crossorigin")!==(O.crossOrigin==null?null:O.crossOrigin))&&$&&o.hasAttribute("async")&&!o.hasAttribute("itemprop"))break;return o;default:return o}}else if(p==="input"&&o.type==="hidden"){var $=O.name==null?null:""+O.name;if(O.type==="hidden"&&o.getAttribute("name")===$)return o}else return o;if(o=__(o.nextSibling),o===null)break}return null}function I0(o,p,b){if(p==="")return null;for(;o.nodeType!==3;)if((o.nodeType!==1||o.nodeName!=="INPUT"||o.type!=="hidden")&&!b||(o=__(o.nextSibling),o===null))return null;return o}function D0(o){return o.data==="$!"||o.data==="$?"&&o.ownerDocument.readyState==="complete"}function _x(o,p){var b=o.ownerDocument;if(o.data!=="$?"||b.readyState==="complete")p();else{var v=function(){p(),b.removeEventListener("DOMContentLoaded",v)};b.addEventListener("DOMContentLoaded",v),o._reactRetry=v}}function __(o){for(;o!=null;o=o.nextSibling){var p=o.nodeType;if(p===1||p===3)break;if(p===8){if(p=o.data,p==="$"||p==="$!"||p==="$?"||p==="F!"||p==="F")break;if(p==="/$")return null}}return o}var ay=null;function cv(o){o=o.previousSibling;for(var p=0;o;){if(o.nodeType===8){var b=o.data;if(b==="$"||b==="$!"||b==="$?"){if(p===0)return o;p--}else b==="/$"&&p++}o=o.previousSibling}return null}function Cw(o,p,b){switch(p=qo(b),o){case"html":if(o=p.documentElement,!o)throw Error(s(452));return o;case"head":if(o=p.head,!o)throw Error(s(453));return o;case"body":if(o=p.body,!o)throw Error(s(454));return o;default:throw Error(s(451))}}function a1(o){for(var p=o.attributes;p.length;)o.removeAttributeNode(p[0]);Oo(o)}var d_=new Map,mx=new Set;function L0(o){return typeof o.getRootNode=="function"?o.getRootNode():o.nodeType===9?o:o.ownerDocument}var v_=H.d;H.d={f:Ov,r:Iv,D:$_,C:uT,L:cT,m:dT,X:fT,S:pT,M:hT};function Ov(){var o=v_.f(),p=ny();return o||p}function Iv(o){var p=it(o);p!==null&&p.tag===5&&p.type==="form"?Yy(p):v_.r(o)}var $0=typeof document>"u"?null:document;function o1(o,p,b){var v=$0;if(v&&typeof p=="string"&&p){var O=Hc(p);O='link[rel="'+o+'"][href="'+O+'"]',typeof b=="string"&&(O+='[crossorigin="'+b+'"]'),mx.has(O)||(mx.add(O),o={rel:o,crossOrigin:b,href:p},v.querySelector(O)===null&&(p=v.createElement("link"),Qo(p,"link",o),Ht(p),v.head.appendChild(p)))}}function $_(o){v_.D(o),o1("dns-prefetch",o,null)}function uT(o,p){v_.C(o,p),o1("preconnect",o,p)}function cT(o,p,b){v_.L(o,p,b);var v=$0;if(v&&o&&p){var O='link[rel="preload"][as="'+Hc(p)+'"]';p==="image"&&b&&b.imageSrcSet?(O+='[imagesrcset="'+Hc(b.imageSrcSet)+'"]',typeof b.imageSizes=="string"&&(O+='[imagesizes="'+Hc(b.imageSizes)+'"]')):O+='[href="'+Hc(o)+'"]';var $=O;switch(p){case"style":$=kw(o);break;case"script":$=Ow(o)}d_.has($)||(o=h({rel:"preload",href:p==="image"&&b&&b.imageSrcSet?void 0:o,as:p},b),d_.set($,o),v.querySelector(O)!==null||p==="style"&&v.querySelector(gx($))||p==="script"&&v.querySelector(bx($))||(p=v.createElement("link"),Qo(p,"link",o),Ht(p),v.head.appendChild(p)))}}function dT(o,p){v_.m(o,p);var b=$0;if(b&&o){var v=p&&typeof p.as=="string"?p.as:"script",O='link[rel="modulepreload"][as="'+Hc(v)+'"][href="'+Hc(o)+'"]',$=O;switch(v){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":$=Ow(o)}if(!d_.has($)&&(o=h({rel:"modulepreload",href:o},p),d_.set($,o),b.querySelector(O)===null)){switch(v){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(b.querySelector(bx($)))return}v=b.createElement("link"),Qo(v,"link",o),Ht(v),b.head.appendChild(v)}}}function pT(o,p,b){v_.S(o,p,b);var v=$0;if(v&&o){var O=Ot(v).hoistableStyles,$=kw(o);p=p||"default";var ae=O.get($);if(!ae){var Te={loading:0,preload:null};if(ae=v.querySelector(gx($)))Te.loading=5;else{o=h({rel:"stylesheet",href:o,"data-precedence":p},b),(b=d_.get($))&&Dv(o,b);var dt=ae=v.createElement("link");Ht(dt),Qo(dt,"link",o),dt._p=new Promise(function(wn,dr){dt.onload=wn,dt.onerror=dr}),dt.addEventListener("load",function(){Te.loading|=1}),dt.addEventListener("error",function(){Te.loading|=2}),Te.loading|=4,dv(ae,p,v)}ae={type:"stylesheet",instance:ae,count:1,state:Te},O.set($,ae)}}}function fT(o,p){v_.X(o,p);var b=$0;if(b&&o){var v=Ot(b).hoistableScripts,O=Ow(o),$=v.get(O);$||($=b.querySelector(bx(O)),$||(o=h({src:o,async:!0},p),(p=d_.get(O))&&Lv(o,p),$=b.createElement("script"),Ht($),Qo($,"link",o),b.head.appendChild($)),$={type:"script",instance:$,count:1,state:null},v.set(O,$))}}function hT(o,p){v_.M(o,p);var b=$0;if(b&&o){var v=Ot(b).hoistableScripts,O=Ow(o),$=v.get(O);$||($=b.querySelector(bx(O)),$||(o=h({src:o,async:!0,type:"module"},p),(p=d_.get(O))&&Lv(o,p),$=b.createElement("script"),Ht($),Qo($,"link",o),b.head.appendChild($)),$={type:"script",instance:$,count:1,state:null},v.set(O,$))}}function Uv(o,p,b,v){var O=(O=Pt.current)?L0(O):null;if(!O)throw Error(s(446));switch(o){case"meta":case"title":return null;case"style":return typeof b.precedence=="string"&&typeof b.href=="string"?(p=kw(b.href),b=Ot(O).hoistableStyles,v=b.get(p),v||(v={type:"style",instance:null,count:0,state:null},b.set(p,v)),v):{type:"void",instance:null,count:0,state:null};case"link":if(b.rel==="stylesheet"&&typeof b.href=="string"&&typeof b.precedence=="string"){o=kw(b.href);var $=Ot(O).hoistableStyles,ae=$.get(o);if(ae||(O=O.ownerDocument||O,ae={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},$.set(o,ae),($=O.querySelector(gx(o)))&&!$._p&&(ae.instance=$,ae.state.loading=5),d_.has(o)||(b={rel:"preload",as:"style",href:b.href,crossOrigin:b.crossOrigin,integrity:b.integrity,media:b.media,hrefLang:b.hrefLang,referrerPolicy:b.referrerPolicy},d_.set(o,b),$||_T(O,o,b,ae.state))),p&&v===null)throw Error(s(528,""));return ae}if(p&&v!==null)throw Error(s(529,""));return null;case"script":return p=b.async,b=b.src,typeof b=="string"&&p&&typeof p!="function"&&typeof p!="symbol"?(p=Ow(b),b=Ot(O).hoistableScripts,v=b.get(p),v||(v={type:"script",instance:null,count:0,state:null},b.set(p,v)),v):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,o))}}function kw(o){return'href="'+Hc(o)+'"'}function gx(o){return'link[rel="stylesheet"]['+o+"]"}function Vv(o){return h({},o,{"data-precedence":o.precedence,precedence:null})}function _T(o,p,b,v){o.querySelector('link[rel="preload"][as="style"]['+p+"]")?v.loading=1:(p=o.createElement("link"),v.preload=p,p.addEventListener("load",function(){return v.loading|=1}),p.addEventListener("error",function(){return v.loading|=2}),Qo(p,"link",b),Ht(p),o.head.appendChild(p))}function Ow(o){return'[src="'+Hc(o)+'"]'}function bx(o){return"script[async]"+o}function Gv(o,p,b){if(p.count++,p.instance===null)switch(p.type){case"style":var v=o.querySelector('style[data-href~="'+Hc(b.href)+'"]');if(v)return p.instance=v,Ht(v),v;var O=h({},b,{"data-href":b.href,"data-precedence":b.precedence,href:null,precedence:null});return v=(o.ownerDocument||o).createElement("style"),Ht(v),Qo(v,"style",O),dv(v,b.precedence,o),p.instance=v;case"stylesheet":O=kw(b.href);var $=o.querySelector(gx(O));if($)return p.state.loading|=4,p.instance=$,Ht($),$;v=Vv(b),(O=d_.get(O))&&Dv(v,O),$=(o.ownerDocument||o).createElement("link"),Ht($);var ae=$;return ae._p=new Promise(function(Te,dt){ae.onload=Te,ae.onerror=dt}),Qo($,"link",v),p.state.loading|=4,dv($,b.precedence,o),p.instance=$;case"script":return $=Ow(b.src),(O=o.querySelector(bx($)))?(p.instance=O,Ht(O),O):(v=b,(O=d_.get($))&&(v=h({},b),Lv(v,O)),o=o.ownerDocument||o,O=o.createElement("script"),Ht(O),Qo(O,"link",v),o.head.appendChild(O),p.instance=O);case"void":return null;default:throw Error(s(443,p.type))}else p.type==="stylesheet"&&(p.state.loading&4)===0&&(v=p.instance,p.state.loading|=4,dv(v,b.precedence,o));return p.instance}function dv(o,p,b){for(var v=b.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),O=v.length?v[v.length-1]:null,$=O,ae=0;ae<v.length;ae++){var Te=v[ae];if(Te.dataset.precedence===p)$=Te;else if($!==O)break}$?$.parentNode.insertBefore(o,$.nextSibling):(p=b.nodeType===9?b.head:b,p.insertBefore(o,p.firstChild))}function Dv(o,p){o.crossOrigin==null&&(o.crossOrigin=p.crossOrigin),o.referrerPolicy==null&&(o.referrerPolicy=p.referrerPolicy),o.title==null&&(o.title=p.title)}function Lv(o,p){o.crossOrigin==null&&(o.crossOrigin=p.crossOrigin),o.referrerPolicy==null&&(o.referrerPolicy=p.referrerPolicy),o.integrity==null&&(o.integrity=p.integrity)}var pv=null;function Wv(o,p,b){if(pv===null){var v=new Map,O=pv=new Map;O.set(b,v)}else O=pv,v=O.get(b),v||(v=new Map,O.set(b,v));if(v.has(o))return v;for(v.set(o,null),b=b.getElementsByTagName(o),O=0;O<b.length;O++){var $=b[O];if(!($[hi]||$[ve]||o==="link"&&$.getAttribute("rel")==="stylesheet")&&$.namespaceURI!=="http://www.w3.org/2000/svg"){var ae=$.getAttribute(p)||"";ae=o+ae;var Te=v.get(ae);Te?Te.push($):v.set(ae,[$])}}return v}function qv(o,p,b){o=o.ownerDocument||o,o.head.insertBefore(b,p==="title"?o.querySelector("head > title"):null)}function mT(o,p,b){if(b===1||p.itemProp!=null)return!1;switch(o){case"meta":case"title":return!0;case"style":if(typeof p.precedence!="string"||typeof p.href!="string"||p.href==="")break;return!0;case"link":if(typeof p.rel!="string"||typeof p.href!="string"||p.href===""||p.onLoad||p.onError)break;switch(p.rel){case"stylesheet":return o=p.disabled,typeof p.precedence=="string"&&o==null;default:return!0}case"script":if(p.async&&typeof p.async!="function"&&typeof p.async!="symbol"&&!p.onLoad&&!p.onError&&p.src&&typeof p.src=="string")return!0}return!1}function Hv(o){return!(o.type==="stylesheet"&&(o.state.loading&3)===0)}var yx=null;function gT(){}function bT(o,p,b){if(yx===null)throw Error(s(475));var v=yx;if(p.type==="stylesheet"&&(typeof b.media!="string"||matchMedia(b.media).matches!==!1)&&(p.state.loading&4)===0){if(p.instance===null){var O=kw(b.href),$=o.querySelector(gx(O));if($){o=$._p,o!==null&&typeof o=="object"&&typeof o.then=="function"&&(v.count++,v=fv.bind(v),o.then(v,v)),p.state.loading|=4,p.instance=$,Ht($);return}$=o.ownerDocument||o,b=Vv(b),(O=d_.get(O))&&Dv(b,O),$=$.createElement("link"),Ht($);var ae=$;ae._p=new Promise(function(Te,dt){ae.onload=Te,ae.onerror=dt}),Qo($,"link",b),p.instance=$}v.stylesheets===null&&(v.stylesheets=new Map),v.stylesheets.set(p,o),(o=p.state.preload)&&(p.state.loading&3)===0&&(v.count++,p=fv.bind(v),o.addEventListener("load",p),o.addEventListener("error",p))}}function yT(){if(yx===null)throw Error(s(475));var o=yx;return o.stylesheets&&o.count===0&&$v(o,o.stylesheets),0<o.count?function(p){var b=setTimeout(function(){if(o.stylesheets&&$v(o,o.stylesheets),o.unsuspend){var v=o.unsuspend;o.unsuspend=null,v()}},6e4);return o.unsuspend=p,function(){o.unsuspend=null,clearTimeout(b)}}:null}function fv(){if(this.count--,this.count===0){if(this.stylesheets)$v(this,this.stylesheets);else if(this.unsuspend){var o=this.unsuspend;this.unsuspend=null,o()}}}var hv=null;function $v(o,p){o.stylesheets=null,o.unsuspend!==null&&(o.count++,hv=new Map,p.forEach(wT,o),hv=null,fv.call(o))}function wT(o,p){if(!(p.state.loading&4)){var b=hv.get(o);if(b)var v=b.get(null);else{b=new Map,hv.set(o,b);for(var O=o.querySelectorAll("link[data-precedence],style[data-precedence]"),$=0;$<O.length;$++){var ae=O[$];(ae.nodeName==="LINK"||ae.getAttribute("media")!=="not all")&&(b.set(ae.dataset.precedence,ae),v=ae)}v&&b.set(null,v)}O=p.instance,ae=O.getAttribute("data-precedence"),$=b.get(ae)||v,$===v&&b.set(null,O),b.set(ae,O),this.count++,v=fv.bind(this),O.addEventListener("load",v),O.addEventListener("error",v),$?$.parentNode.insertBefore(O,$.nextSibling):(o=o.nodeType===9?o.head:o,o.insertBefore(O,o.firstChild)),p.state.loading|=4}}var wx={$$typeof:S,Provider:null,Consumer:null,_currentValue:he,_currentValue2:he,_threadCount:0};function xT(o,p,b,v,O,$,ae,Te){this.tag=1,this.containerInfo=o,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=rf(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=rf(0),this.hiddenUpdates=rf(null),this.identifierPrefix=v,this.onUncaughtError=O,this.onCaughtError=$,this.onRecoverableError=ae,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=Te,this.incompleteTransitions=new Map}function Kv(o,p,b,v,O,$,ae,Te,dt,wn,dr,ni){return o=new xT(o,p,b,ae,Te,dt,wn,ni),p=1,$===!0&&(p|=24),$=a_(3,null,null,p),o.current=$,$.stateNode=o,p=hb(),p.refCount++,o.pooledCache=p,p.refCount++,$.memoizedState={element:v,isDehydrated:b,cache:p},Py($),o}function Yv(o){return o?(o=Kg,o):Kg}function Xv(o,p,b,v,O,$){O=Yv(O),v.context===null?v.context=O:v.pendingContext=O,v=Sg(p),v.payload={element:b},$=$===void 0?null:$,$!==null&&(v.callback=$),b=Pg(o,v,p),b!==null&&(Dp(b,o,p),E1(b,o,p))}function Qv(o,p){if(o=o.memoizedState,o!==null&&o.dehydrated!==null){var b=o.retryLane;o.retryLane=b!==0&&b<p?b:p}}function Fv(o,p){Qv(o,p),(o=o.alternate)&&Qv(o,p)}function Zv(o){if(o.tag===13){var p=Hg(o,67108864);p!==null&&Dp(p,o,67108864),Fv(o,67108864)}}var _v=!0;function vT(o,p,b,v){var O=z.T;z.T=null;var $=H.p;try{H.p=2,Nv(o,p,b,v)}finally{H.p=$,z.T=O}}function TT(o,p,b,v){var O=z.T;z.T=null;var $=H.p;try{H.p=8,Nv(o,p,b,v)}finally{H.p=$,z.T=O}}function Nv(o,p,b,v){if(_v){var O=Rv(v);if(O===null)oi(o,p,v,mv,b),eT(o,v);else if(ET(O,o,p,b,v))v.stopPropagation();else if(eT(o,v),p&4&&-1<MT.indexOf(o)){for(;O!==null;){var $=it(O);if($!==null)switch($.tag){case 3:if($=$.stateNode,$.current.memoizedState.isDehydrated){var ae=zc($.pendingLanes);if(ae!==0){var Te=$;for(Te.pendingLanes|=2,Te.entangledLanes|=2;ae;){var dt=1<<31-ui(ae);Te.entanglements[1]|=dt,ae&=~dt}Q_($),($c&6)===0&&(Zb=cn()+500,ry(0))}}break;case 13:Te=Hg($,2),Te!==null&&Dp(Te,$,2),ny(),Fv($,2)}if($=Rv(v),$===null&&oi(o,p,v,mv,b),$===O)break;O=$}O!==null&&v.stopPropagation()}else oi(o,p,v,null,b)}}function Rv(o){return o=Hi(o),zv(o)}var mv=null;function zv(o){if(mv=null,o=we(o),o!==null){var p=c(o);if(p===null)o=null;else{var b=p.tag;if(b===13){if(o=l(p),o!==null)return o;o=null}else if(b===3){if(p.stateNode.current.memoizedState.isDehydrated)return p.tag===3?p.stateNode.containerInfo:null;o=null}else p!==o&&(o=null)}}return mv=o,null}function Jv(o){switch(o){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(kn()){case yn:return 2;case $n:return 8;case cr:case ti:return 32;case vn:return 268435456;default:return 32}default:return 32}}var Bv=!1,F0=null,N0=null,R0=null,xx=new Map,vx=new Map,z0=[],MT="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function eT(o,p){switch(o){case"focusin":case"focusout":F0=null;break;case"dragenter":case"dragleave":N0=null;break;case"mouseover":case"mouseout":R0=null;break;case"pointerover":case"pointerout":xx.delete(p.pointerId);break;case"gotpointercapture":case"lostpointercapture":vx.delete(p.pointerId)}}function Tx(o,p,b,v,O,$){return o===null||o.nativeEvent!==$?(o={blockedOn:p,domEventName:b,eventSystemFlags:v,nativeEvent:$,targetContainers:[O]},p!==null&&(p=it(p),p!==null&&Zv(p)),o):(o.eventSystemFlags|=v,p=o.targetContainers,O!==null&&p.indexOf(O)===-1&&p.push(O),o)}function ET(o,p,b,v,O){switch(p){case"focusin":return F0=Tx(F0,o,p,b,v,O),!0;case"dragenter":return N0=Tx(N0,o,p,b,v,O),!0;case"mouseover":return R0=Tx(R0,o,p,b,v,O),!0;case"pointerover":var $=O.pointerId;return xx.set($,Tx(xx.get($)||null,o,p,b,v,O)),!0;case"gotpointercapture":return $=O.pointerId,vx.set($,Tx(vx.get($)||null,o,p,b,v,O)),!0}return!1}function tT(o){var p=we(o.target);if(p!==null){var b=c(p);if(b!==null){if(p=b.tag,p===13){if(p=l(b),p!==null){o.blockedOn=p,W(o.priority,function(){if(b.tag===13){var v=c_();v=_c(v);var O=Hg(b,v);O!==null&&Dp(O,b,v),Fv(b,v)}});return}}else if(p===3&&b.stateNode.current.memoizedState.isDehydrated){o.blockedOn=b.tag===3?b.stateNode.containerInfo:null;return}}}o.blockedOn=null}function gv(o){if(o.blockedOn!==null)return!1;for(var p=o.targetContainers;0<p.length;){var b=Rv(o.nativeEvent);if(b===null){b=o.nativeEvent;var v=new b.constructor(b.type,b);zo=v,b.target.dispatchEvent(v),zo=null}else return p=it(b),p!==null&&Zv(p),o.blockedOn=b,!1;p.shift()}return!0}function nT(o,p,b){gv(o)&&b.delete(p)}function ST(){Bv=!1,F0!==null&&gv(F0)&&(F0=null),N0!==null&&gv(N0)&&(N0=null),R0!==null&&gv(R0)&&(R0=null),xx.forEach(nT),vx.forEach(nT)}function bv(o,p){o.blockedOn===p&&(o.blockedOn=null,Bv||(Bv=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,ST)))}var yv=null;function rT(o){yv!==o&&(yv=o,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){yv===o&&(yv=null);for(var p=0;p<o.length;p+=3){var b=o[p],v=o[p+1],O=o[p+2];if(typeof v!="function"){if(zv(v||b)===null)continue;break}var $=it(b);$!==null&&(o.splice(p,3),p-=3,Ky($,{pending:!0,data:O,method:b.method,action:v},v,O))}}))}function Mx(o){function p(dt){return bv(dt,o)}F0!==null&&bv(F0,o),N0!==null&&bv(N0,o),R0!==null&&bv(R0,o),xx.forEach(p),vx.forEach(p);for(var b=0;b<z0.length;b++){var v=z0[b];v.blockedOn===o&&(v.blockedOn=null)}for(;0<z0.length&&(b=z0[0],b.blockedOn===null);)tT(b),b.blockedOn===null&&z0.shift();if(b=(o.ownerDocument||o).$$reactFormReplay,b!=null)for(v=0;v<b.length;v+=3){var O=b[v],$=b[v+1],ae=O[Ke]||null;if(typeof $=="function")ae||rT(b);else if(ae){var Te=null;if($&&$.hasAttribute("formAction")){if(O=$,ae=$[Ke]||null)Te=ae.formAction;else if(zv(O)!==null)continue}else Te=ae.action;typeof Te=="function"?b[v+1]=Te:(b.splice(v,3),v-=3),rT(b)}}}function jv(o){this._internalRoot=o}wv.prototype.render=jv.prototype.render=function(o){var p=this._internalRoot;if(p===null)throw Error(s(409));var b=p.current,v=c_();Xv(b,v,o,p,null,null)},wv.prototype.unmount=jv.prototype.unmount=function(){var o=this._internalRoot;if(o!==null){this._internalRoot=null;var p=o.containerInfo;Xv(o.current,2,null,o,null,null),ny(),p[lt]=null}};function wv(o){this._internalRoot=o}wv.prototype.unstable_scheduleHydration=function(o){if(o){var p=Rp();o={blockedOn:null,target:o,priority:p};for(var b=0;b<z0.length&&p!==0&&p<z0[b].priority;b++);z0.splice(b,0,o),b===0&&tT(o)}};var sT=e.version;if(sT!=="19.1.1")throw Error(s(527,sT,"19.1.1"));H.findDOMNode=function(o){var p=o._reactInternals;if(p===void 0)throw typeof o.render=="function"?Error(s(188)):(o=Object.keys(o).join(","),Error(s(268,o)));return o=m(p),o=o!==null?d(o):null,o=o===null?null:o.stateNode,o};var PT={bundleType:0,version:"19.1.1",rendererPackageName:"react-dom",currentDispatcherRef:z,reconcilerVersion:"19.1.1"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var xv=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!xv.isDisabled&&xv.supportsFiber)try{ai=xv.inject(PT),mi=xv}catch{}}return reactDomClient_production.createRoot=function(o,p){if(!a(o))throw Error(s(299));var b=!1,v="",O=w0,$=O2,ae=I2,Te=null;return p!=null&&(p.unstable_strictMode===!0&&(b=!0),p.identifierPrefix!==void 0&&(v=p.identifierPrefix),p.onUncaughtError!==void 0&&(O=p.onUncaughtError),p.onCaughtError!==void 0&&($=p.onCaughtError),p.onRecoverableError!==void 0&&(ae=p.onRecoverableError),p.unstable_transitionCallbacks!==void 0&&(Te=p.unstable_transitionCallbacks)),p=Kv(o,1,!1,null,null,b,v,O,$,ae,Te,null),o[lt]=p.current,xn(o),new jv(p)},reactDomClient_production.hydrateRoot=function(o,p,b){if(!a(o))throw Error(s(299));var v=!1,O="",$=w0,ae=O2,Te=I2,dt=null,wn=null;return b!=null&&(b.unstable_strictMode===!0&&(v=!0),b.identifierPrefix!==void 0&&(O=b.identifierPrefix),b.onUncaughtError!==void 0&&($=b.onUncaughtError),b.onCaughtError!==void 0&&(ae=b.onCaughtError),b.onRecoverableError!==void 0&&(Te=b.onRecoverableError),b.unstable_transitionCallbacks!==void 0&&(dt=b.unstable_transitionCallbacks),b.formState!==void 0&&(wn=b.formState)),p=Kv(o,1,!0,p,b??null,v,O,$,ae,Te,dt,wn),p.context=Yv(null),b=p.current,v=c_(),v=_c(v),O=Sg(v),O.callback=null,Pg(b,O,v),b=v,p.current.lanes=b,cp(p,b),Q_(p),o[lt]=p.current,xn(o),new wv(p)},reactDomClient_production.version="19.1.1",reactDomClient_production}var hasRequiredClient;function requireClient(){if(hasRequiredClient)return client.exports;hasRequiredClient=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),client.exports=requireReactDomClient_production(),client.exports}var clientExports=requireClient();const ReactDOM=getDefaultExportFromCjs(clientExports),backends$1=new Map,backendsSortedByPriority$1=[],registerBackend$1=(n,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){const s=backends$1.get(n);if(s===void 0)backends$1.set(n,{backend:e,priority:t});else{if(s.priority>t)return;if(s.priority===t&&s.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${t}`)}if(t>=0){const a=backendsSortedByPriority$1.indexOf(n);a!==-1&&backendsSortedByPriority$1.splice(a,1);for(let c=0;c<backendsSortedByPriority$1.length;c++)if(backends$1.get(backendsSortedByPriority$1[c]).priority<=t){backendsSortedByPriority$1.splice(c,0,n);return}backendsSortedByPriority$1.push(n)}return}throw new TypeError("not a valid backend")},tryResolveAndInitializeBackend=async n=>{const e=backends$1.get(n);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{const t=!!e.initPromise;try{return t||(e.initPromise=e.backend.init(n)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return t||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},resolveBackendAndExecutionProviders=async n=>{const e=n.executionProviders||[],t=e.map(m=>typeof m=="string"?m:m.name),s=t.length===0?backendsSortedByPriority$1:t;let a;const c=[],l=new Set;for(const m of s){const d=await tryResolveAndInitializeBackend(m);typeof d=="string"?c.push({name:m,err:d}):(a||(a=d),a===d&&l.add(m))}if(!a)throw new Error(`no available backend found. ERR: ${c.map(m=>`[${m.name}] ${m.err}`).join(", ")}`);for(const{name:m,err:d}of c)t.includes(m)&&console.warn(`removing requested execution provider "${m}" from session options because it is not available: ${d}`);const _=e.filter(m=>l.has(typeof m=="string"?m:m.name));return[a,new Proxy(n,{get:(m,d)=>d==="executionProviders"?_:Reflect.get(m,d)})]},version="1.21.0";let logLevelValue="warning";const env$4={wasm:{},webgl:{},webgpu:{},versions:{common:version},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);logLevelValue=n}},get logLevel(){return logLevelValue}};Object.defineProperty(env$4,"logLevel",{enumerable:!0});const env$3=env$4,tensorToDataURL=(n,e)=>{const t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=n.dims[3],t.height=n.dims[2];const s=t.getContext("2d");if(s!=null){let a,c;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=n.dims[2],c=n.dims[3]):(a=n.dims[3],c=n.dims[2]);const l=e?.format!==void 0?e.format:"RGB",_=e?.norm;let m,d;_===void 0||_.mean===void 0?m=[255,255,255,255]:typeof _.mean=="number"?m=[_.mean,_.mean,_.mean,_.mean]:(m=[_.mean[0],_.mean[1],_.mean[2],0],_.mean[3]!==void 0&&(m[3]=_.mean[3])),_===void 0||_.bias===void 0?d=[0,0,0,0]:typeof _.bias=="number"?d=[_.bias,_.bias,_.bias,_.bias]:(d=[_.bias[0],_.bias[1],_.bias[2],0],_.bias[3]!==void 0&&(d[3]=_.bias[3]));const h=c*a;let i=0,r=h,u=h*2,f=-1;l==="RGBA"?(i=0,r=h,u=h*2,f=h*3):l==="RGB"?(i=0,r=h,u=h*2):l==="RBG"&&(i=0,u=h,r=h*2);for(let g=0;g<c;g++)for(let w=0;w<a;w++){const y=(n.data[i++]-d[0])*m[0],x=(n.data[r++]-d[1])*m[1],S=(n.data[u++]-d[2])*m[2],T=f===-1?255:(n.data[f++]-d[3])*m[3];s.fillStyle="rgba("+y+","+x+","+S+","+T+")",s.fillRect(w,g,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},tensorToImageData=(n,e)=>{const t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let s;if(t!=null){let a,c,l;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=n.dims[2],c=n.dims[1],l=n.dims[3]):(a=n.dims[3],c=n.dims[2],l=n.dims[1]);const _=e!==void 0&&e.format!==void 0?e.format:"RGB",m=e?.norm;let d,h;m===void 0||m.mean===void 0?d=[255,255,255,255]:typeof m.mean=="number"?d=[m.mean,m.mean,m.mean,m.mean]:(d=[m.mean[0],m.mean[1],m.mean[2],255],m.mean[3]!==void 0&&(d[3]=m.mean[3])),m===void 0||m.bias===void 0?h=[0,0,0,0]:typeof m.bias=="number"?h=[m.bias,m.bias,m.bias,m.bias]:(h=[m.bias[0],m.bias[1],m.bias[2],0],m.bias[3]!==void 0&&(h[3]=m.bias[3]));const i=c*a;if(e!==void 0&&(e.format!==void 0&&l===4&&e.format!=="RGBA"||l===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const r=4;let u=0,f=1,g=2,w=3,y=0,x=i,S=i*2,T=-1;_==="RGBA"?(y=0,x=i,S=i*2,T=i*3):_==="RGB"?(y=0,x=i,S=i*2):_==="RBG"&&(y=0,S=i,x=i*2),s=t.createImageData(a,c);for(let E=0;E<c*a;u+=r,f+=r,g+=r,w+=r,E++)s.data[u]=(n.data[y++]-h[0])*d[0],s.data[f]=(n.data[x++]-h[1])*d[1],s.data[g]=(n.data[S++]-h[2])*d[2],s.data[w]=T===-1?255:(n.data[T++]-h[3])*d[3]}else throw new Error("Can not access image data");return s},bufferToTensor=(n,e)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:t,width:s}=e,a=e.norm??{mean:255,bias:0};let c,l;typeof a.mean=="number"?c=[a.mean,a.mean,a.mean,a.mean]:c=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:l=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];const _=e.format!==void 0?e.format:"RGBA",m=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",d=t*s,h=m==="RGBA"?new Float32Array(d*4):new Float32Array(d*3);let i=4,r=0,u=1,f=2,g=3,w=0,y=d,x=d*2,S=-1;_==="RGB"&&(i=3,r=0,u=1,f=2,g=-1),m==="RGBA"?S=d*3:m==="RBG"?(w=0,x=d,y=d*2):m==="BGR"&&(x=0,y=d,w=d*2);for(let E=0;E<d;E++,r+=i,f+=i,u+=i,g+=i)h[w++]=(n[r]+l[0])/c[0],h[y++]=(n[u]+l[1])/c[1],h[x++]=(n[f]+l[2])/c[2],S!==-1&&g!==-1&&(h[S++]=(n[g]+l[3])/c[3]);return m==="RGBA"?new Tensor$4("float32",h,[1,4,t,s]):new Tensor$4("float32",h,[1,3,t,s])},tensorFromImage=async(n,e)=>{const t=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,s=typeof ImageData<"u"&&n instanceof ImageData,a=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,c=typeof n=="string";let l,_=e??{};const m=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=h=>typeof HTMLCanvasElement<"u"&&h instanceof HTMLCanvasElement||h instanceof OffscreenCanvas?h.getContext("2d"):null;if(t){const h=m();h.width=n.width,h.height=n.height;const i=d(h);if(i!=null){let r=n.height,u=n.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(r=e.resizedHeight,u=e.resizedWidth),e!==void 0){if(_=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");_.tensorFormat="RGBA",_.height=r,_.width=u}else _.tensorFormat="RGBA",_.height=r,_.width=u;i.drawImage(n,0,0),l=i.getImageData(0,0,u,r).data}else throw new Error("Can not access image data")}else if(s){let h,i;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(h=e.resizedHeight,i=e.resizedWidth):(h=n.height,i=n.width),e!==void 0&&(_=e),_.format="RGBA",_.height=h,_.width=i,e!==void 0){const r=m();r.width=i,r.height=h;const u=d(r);if(u!=null)u.putImageData(n,0,0),l=u.getImageData(0,0,i,h).data;else throw new Error("Can not access image data")}else l=n.data}else if(a){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");const h=m();h.width=n.width,h.height=n.height;const i=d(h);if(i!=null){const r=n.height,u=n.width;return i.drawImage(n,0,0,u,r),l=i.getImageData(0,0,u,r).data,_.height=r,_.width=u,bufferToTensor(l,_)}else throw new Error("Can not access image data")}else{if(c)return new Promise((h,i)=>{const r=m(),u=d(r);if(!n||!u)return i();const f=new Image;f.crossOrigin="Anonymous",f.src=n,f.onload=()=>{r.width=f.width,r.height=f.height,u.drawImage(f,0,0,r.width,r.height);const g=u.getImageData(0,0,r.width,r.height);_.height=r.height,_.width=r.width,h(bufferToTensor(g.data,_))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(l!==void 0)return bufferToTensor(l,_);throw new Error("Input data provided is not supported - aborted tensor creation")},tensorFromTexture=(n,e)=>{const{width:t,height:s,download:a,dispose:c}=e,l=[1,s,t,4];return new Tensor$4({location:"texture",type:"float32",texture:n,dims:l,download:a,dispose:c})},tensorFromGpuBuffer=(n,e)=>{const{dataType:t,dims:s,download:a,dispose:c}=e;return new Tensor$4({location:"gpu-buffer",type:t??"float32",gpuBuffer:n,dims:s,download:a,dispose:c})},tensorFromMLTensor=(n,e)=>{const{dataType:t,dims:s,download:a,dispose:c}=e;return new Tensor$4({location:"ml-tensor",type:t??"float32",mlTensor:n,dims:s,download:a,dispose:c})},tensorFromPinnedBuffer=(n,e,t)=>new Tensor$4({location:"cpu-pinned",type:n,data:e,dims:t??[e.length]}),NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let isTypedArrayChecked=!1;const checkTypedArray=()=>{if(!isTypedArrayChecked){isTypedArrayChecked=!0;const n=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,s=typeof t<"u"&&t.from;n&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.set(BigInt64Array,"int64")),e&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.set(BigUint64Array,"uint64")),s?(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.set("float16",t),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.set(t,"float16")):NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.set("float16",Uint16Array)}},calculateSize$1=n=>{let e=1;for(let t=0;t<n.length;t++){const s=n[t];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${t}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${s}`);e*=s}return e},tensorReshape=(n,e)=>{switch(n.location){case"cpu":return new Tensor$4(n.type,n.data,e);case"cpu-pinned":return new Tensor$4({location:"cpu-pinned",data:n.data,type:n.type,dims:e});case"texture":return new Tensor$4({location:"texture",texture:n.texture,type:n.type,dims:e});case"gpu-buffer":return new Tensor$4({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:e});case"ml-tensor":return new Tensor$4({location:"ml-tensor",mlTensor:n.mlTensor,type:n.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}};let Tensor$4=class{constructor(e,t,s){checkTypedArray();let a,c;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,a=e.type,c=e.dims,e.location){case"cpu-pinned":{const _=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.get(a);if(!_)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(e.data instanceof _))throw new TypeError(`buffer should be of type ${_.name}`);this.cpuData=e.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint64"&&a!=="int8"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let _,m;if(typeof e=="string")if(a=e,m=s,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");_=t}else{const d=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.get(e);if(d===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&d===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${d.name} as data.`);e==="uint64"||e==="int64"?_=d.from(t,BigInt):_=d.from(t)}else if(t instanceof d)_=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")_=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&d!==Uint16Array)_=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${a} tensor's data must be type of ${d}`)}else if(m=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const d=typeof e[0];if(d==="string")a="string",_=e;else if(d==="boolean")a="bool",_=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${d}.`)}else if(e instanceof Uint8ClampedArray)a="uint8",_=Uint8Array.from(e);else{const d=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.get(e.constructor);if(d===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);a=d,_=e}if(m===void 0)m=[_.length];else if(!Array.isArray(m))throw new TypeError("A tensor's dims must be a number array");c=m,this.cpuData=_,this.dataLocation="cpu"}const l=calculateSize$1(c);if(this.cpuData&&l!==this.cpuData.length&&!((a==="uint4"||a==="int4")&&Math.ceil(l/2)===this.cpuData.length))throw new Error(`Tensor's size(${l}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=c,this.size=l}static async fromImage(e,t){return tensorFromImage(e,t)}static fromTexture(e,t){return tensorFromTexture(e,t)}static fromGpuBuffer(e,t){return tensorFromGpuBuffer(e,t)}static fromMLTensor(e,t){return tensorFromMLTensor(e,t)}static fromPinnedBuffer(e,t,s){return tensorFromPinnedBuffer(e,t,s)}toDataURL(e){return tensorToDataURL(this,e)}toImageData(e){return tensorToImageData(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return tensorReshape(this,e)}};const Tensor$3=Tensor$4,TRACE=(n,e)=>{(typeof env$4.trace>"u"?!env$4.wasm.trace:!env$4.trace)||console.timeStamp(`${n}::ORT::${e}`)},TRACE_FUNC=(n,e)=>{const t=new Error().stack?.split(/\r\n|\r|\n/g)||[];let s=!1;for(let a=0;a<t.length;a++){if(s&&!t[a].includes("TRACE_FUNC")){let c=`FUNC_${n}::${t[a].trim().split(" ")[1]}`;e&&(c+=`::${e}`),TRACE("CPU",c);return}t[a].includes("TRACE_FUNC")&&(s=!0)}},TRACE_FUNC_BEGIN=n=>{(typeof env$4.trace>"u"?!env$4.wasm.trace:!env$4.trace)||TRACE_FUNC("BEGIN",n)},TRACE_FUNC_END=n=>{(typeof env$4.trace>"u"?!env$4.wasm.trace:!env$4.trace)||TRACE_FUNC("END",n)};let InferenceSession$4=class iT{constructor(e){this.handler=e}async run(e,t,s){TRACE_FUNC_BEGIN();const a={};let c={};if(typeof e!="object"||e===null||e instanceof Tensor$3||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let l=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Tensor$3)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");l=!1;for(const d of t){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);a[d]=null}if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let d=!1;const h=Object.getOwnPropertyNames(t);for(const i of this.outputNames)if(h.indexOf(i)!==-1){const r=t[i];(r===null||r instanceof Tensor$3)&&(d=!0,l=!1,a[i]=r)}if(d){if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else c=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const d of this.inputNames)if(typeof e[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(l)for(const d of this.outputNames)a[d]=null;const _=await this.handler.run(e,a,c),m={};for(const d in _)if(Object.hasOwnProperty.call(_,d)){const h=_[d];h instanceof Tensor$3?m[d]=h:m[d]=new Tensor$3(h.type,h.data,h.dims)}return TRACE_FUNC_END(),m}async release(){return this.handler.dispose()}static async create(e,t,s,a){TRACE_FUNC_BEGIN();let c,l={};if(typeof e=="string"){if(c=e,typeof t=="object"&&t!==null)l=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(c=e,typeof t=="object"&&t!==null)l=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){const h=e;let i=0,r=e.byteLength;if(typeof t=="object"&&t!==null)l=t;else if(typeof t=="number"){if(i=t,!Number.isSafeInteger(i))throw new RangeError("'byteOffset' must be an integer.");if(i<0||i>=h.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${h.byteLength}).`);if(r=e.byteLength-i,typeof s=="number"){if(r=s,!Number.isSafeInteger(r))throw new RangeError("'byteLength' must be an integer.");if(r<=0||i+r>h.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${h.byteLength-i}].`);if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(h,i,r)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[_,m]=await resolveBackendAndExecutionProviders(l),d=await _.createInferenceSessionHandler(c,m);return TRACE_FUNC_END(),new iT(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$3=InferenceSession$4,__WEBPACK_EXTERNAL_MODULE_onnxruntime_common_82b39e9f__=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:InferenceSession$3,TRACE,TRACE_FUNC_BEGIN,TRACE_FUNC_END,Tensor:Tensor$3,env:env$3,registerBackend:registerBackend$1},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.22.0-dev.20250409-89f8206ba4
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var zn=Object.defineProperty,Up=Object.getOwnPropertyDescriptor,Np=Object.getOwnPropertyNames,Vp=Object.prototype.hasOwnProperty,On=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')}),U=(n,e)=>()=>(n&&(e=n(n=0)),e),Dt=(n,e)=>{for(var t in e)zn(n,t,{get:e[t],enumerable:!0})},Wp=(n,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of Np(e))!Vp.call(n,a)&&a!==t&&zn(n,a,{get:()=>e[a],enumerable:!(s=Up(e,a))||s.enumerable});return n},Ft=n=>Wp(zn({},"__esModule",{value:!0}),n),fr,vt,$t,Lp,Fi,Bn=U(()=>{fr=new Map,vt=[],$t=(n,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let s=fr.get(n);if(s===void 0)fr.set(n,{backend:e,priority:t});else{if(s.priority>t)return;if(s.priority===t&&s.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${t}`)}if(t>=0){let a=vt.indexOf(n);a!==-1&&vt.splice(a,1);for(let c=0;c<vt.length;c++)if(fr.get(vt[c]).priority<=t){vt.splice(c,0,n);return}vt.push(n)}return}throw new TypeError("not a valid backend")},Lp=async n=>{let e=fr.get(n);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let t=!!e.initPromise;try{return t||(e.initPromise=e.backend.init(n)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return t||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},Fi=async n=>{let e=n.executionProviders||[],t=e.map(m=>typeof m=="string"?m:m.name),s=t.length===0?vt:t,a,c=[],l=new Set;for(let m of s){let d=await Lp(m);typeof d=="string"?c.push({name:m,err:d}):(a||(a=d),a===d&&l.add(m))}if(!a)throw new Error(`no available backend found. ERR: ${c.map(m=>`[${m.name}] ${m.err}`).join(", ")}`);for(let{name:m,err:d}of c)t.includes(m)&&console.warn(`removing requested execution provider "${m}" from session options because it is not available: ${d}`);let _=e.filter(m=>l.has(typeof m=="string"?m:m.name));return[a,new Proxy(n,{get:(m,d)=>d==="executionProviders"?_:Reflect.get(m,d)})]}}),qi=U(()=>{Bn()}),ji,Ki=U(()=>{ji="1.22.0-dev.20250409-89f8206ba4"}),Zi,Me,Dn=U(()=>{Ki(),Zi="warning",Me={wasm:{},webgl:{},webgpu:{},versions:{common:ji},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);Zi=n}},get logLevel(){return Zi}},Object.defineProperty(Me,"logLevel",{enumerable:!0})}),ge,Qi=U(()=>{Dn(),ge=Me}),Yi,Xi,Ji=U(()=>{Yi=(n,e)=>{let t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=n.dims[3],t.height=n.dims[2];let s=t.getContext("2d");if(s!=null){let a,c;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=n.dims[2],c=n.dims[3]):(a=n.dims[3],c=n.dims[2]);let l=e?.format!==void 0?e.format:"RGB",_=e?.norm,m,d;_===void 0||_.mean===void 0?m=[255,255,255,255]:typeof _.mean=="number"?m=[_.mean,_.mean,_.mean,_.mean]:(m=[_.mean[0],_.mean[1],_.mean[2],0],_.mean[3]!==void 0&&(m[3]=_.mean[3])),_===void 0||_.bias===void 0?d=[0,0,0,0]:typeof _.bias=="number"?d=[_.bias,_.bias,_.bias,_.bias]:(d=[_.bias[0],_.bias[1],_.bias[2],0],_.bias[3]!==void 0&&(d[3]=_.bias[3]));let h=c*a,i=0,r=h,u=h*2,f=-1;l==="RGBA"?(i=0,r=h,u=h*2,f=h*3):l==="RGB"?(i=0,r=h,u=h*2):l==="RBG"&&(i=0,u=h,r=h*2);for(let g=0;g<c;g++)for(let w=0;w<a;w++){let y=(n.data[i++]-d[0])*m[0],x=(n.data[r++]-d[1])*m[1],S=(n.data[u++]-d[2])*m[2],T=f===-1?255:(n.data[f++]-d[3])*m[3];s.fillStyle="rgba("+y+","+x+","+S+","+T+")",s.fillRect(w,g,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Xi=(n,e)=>{let t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(t!=null){let a,c,l;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(a=n.dims[2],c=n.dims[1],l=n.dims[3]):(a=n.dims[3],c=n.dims[2],l=n.dims[1]);let _=e!==void 0&&e.format!==void 0?e.format:"RGB",m=e?.norm,d,h;m===void 0||m.mean===void 0?d=[255,255,255,255]:typeof m.mean=="number"?d=[m.mean,m.mean,m.mean,m.mean]:(d=[m.mean[0],m.mean[1],m.mean[2],255],m.mean[3]!==void 0&&(d[3]=m.mean[3])),m===void 0||m.bias===void 0?h=[0,0,0,0]:typeof m.bias=="number"?h=[m.bias,m.bias,m.bias,m.bias]:(h=[m.bias[0],m.bias[1],m.bias[2],0],m.bias[3]!==void 0&&(h[3]=m.bias[3]));let i=c*a;if(e!==void 0&&(e.format!==void 0&&l===4&&e.format!=="RGBA"||l===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let r=4,u=0,f=1,g=2,w=3,y=0,x=i,S=i*2,T=-1;_==="RGBA"?(y=0,x=i,S=i*2,T=i*3):_==="RGB"?(y=0,x=i,S=i*2):_==="RBG"&&(y=0,S=i,x=i*2),s=t.createImageData(a,c);for(let E=0;E<c*a;u+=r,f+=r,g+=r,w+=r,E++)s.data[u]=(n.data[y++]-h[0])*d[0],s.data[f]=(n.data[x++]-h[1])*d[1],s.data[g]=(n.data[S++]-h[2])*d[2],s.data[w]=T===-1?255:(n.data[T++]-h[3])*d[3]}else throw new Error("Can not access image data");return s}}),Mn,ea,ta,ra,na,oa,ia=U(()=>{hr(),Mn=(n,e)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:t,width:s}=e,a=e.norm??{mean:255,bias:0},c,l;typeof a.mean=="number"?c=[a.mean,a.mean,a.mean,a.mean]:c=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:l=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let _=e.format!==void 0?e.format:"RGBA",m=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",d=t*s,h=m==="RGBA"?new Float32Array(d*4):new Float32Array(d*3),i=4,r=0,u=1,f=2,g=3,w=0,y=d,x=d*2,S=-1;_==="RGB"&&(i=3,r=0,u=1,f=2,g=-1),m==="RGBA"?S=d*3:m==="RBG"?(w=0,x=d,y=d*2):m==="BGR"&&(x=0,y=d,w=d*2);for(let T=0;T<d;T++,r+=i,f+=i,u+=i,g+=i)h[w++]=(n[r]+l[0])/c[0],h[y++]=(n[u]+l[1])/c[1],h[x++]=(n[f]+l[2])/c[2],S!==-1&&g!==-1&&(h[S++]=(n[g]+l[3])/c[3]);return m==="RGBA"?new Pe("float32",h,[1,4,t,s]):new Pe("float32",h,[1,3,t,s])},ea=async(n,e)=>{let t=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,s=typeof ImageData<"u"&&n instanceof ImageData,a=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,c=typeof n=="string",l,_=e??{},m=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=h=>typeof HTMLCanvasElement<"u"&&h instanceof HTMLCanvasElement||h instanceof OffscreenCanvas?h.getContext("2d"):null;if(t){let h=m();h.width=n.width,h.height=n.height;let i=d(h);if(i!=null){let r=n.height,u=n.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(r=e.resizedHeight,u=e.resizedWidth),e!==void 0){if(_=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");_.tensorFormat="RGBA",_.height=r,_.width=u}else _.tensorFormat="RGBA",_.height=r,_.width=u;i.drawImage(n,0,0),l=i.getImageData(0,0,u,r).data}else throw new Error("Can not access image data")}else if(s){let h,i;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(h=e.resizedHeight,i=e.resizedWidth):(h=n.height,i=n.width),e!==void 0&&(_=e),_.format="RGBA",_.height=h,_.width=i,e!==void 0){let r=m();r.width=i,r.height=h;let u=d(r);if(u!=null)u.putImageData(n,0,0),l=u.getImageData(0,0,i,h).data;else throw new Error("Can not access image data")}else l=n.data}else if(a){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let h=m();h.width=n.width,h.height=n.height;let i=d(h);if(i!=null){let r=n.height,u=n.width;return i.drawImage(n,0,0,u,r),l=i.getImageData(0,0,u,r).data,_.height=r,_.width=u,Mn(l,_)}else throw new Error("Can not access image data")}else{if(c)return new Promise((h,i)=>{let r=m(),u=d(r);if(!n||!u)return i();let f=new Image;f.crossOrigin="Anonymous",f.src=n,f.onload=()=>{r.width=f.width,r.height=f.height,u.drawImage(f,0,0,r.width,r.height);let g=u.getImageData(0,0,r.width,r.height);_.height=r.height,_.width=r.width,h(Mn(g.data,_))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(l!==void 0)return Mn(l,_);throw new Error("Input data provided is not supported - aborted tensor creation")},ta=(n,e)=>{let{width:t,height:s,download:a,dispose:c}=e,l=[1,s,t,4];return new Pe({location:"texture",type:"float32",texture:n,dims:l,download:a,dispose:c})},ra=(n,e)=>{let{dataType:t,dims:s,download:a,dispose:c}=e;return new Pe({location:"gpu-buffer",type:t??"float32",gpuBuffer:n,dims:s,download:a,dispose:c})},na=(n,e)=>{let{dataType:t,dims:s,download:a,dispose:c}=e;return new Pe({location:"ml-tensor",type:t??"float32",mlTensor:n,dims:s,download:a,dispose:c})},oa=(n,e,t)=>new Pe({location:"cpu-pinned",type:n,data:e,dims:t??[e.length]})}),xt,qt,aa,sa,ua=U(()=>{xt=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),qt=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),aa=!1,sa=()=>{if(!aa){aa=!0;let n=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,s=typeof t<"u"&&t.from;n&&(xt.set("int64",BigInt64Array),qt.set(BigInt64Array,"int64")),e&&(xt.set("uint64",BigUint64Array),qt.set(BigUint64Array,"uint64")),s?(xt.set("float16",t),qt.set(t,"float16")):xt.set("float16",Uint16Array)}}}),da,la,ca=U(()=>{hr(),da=n=>{let e=1;for(let t=0;t<n.length;t++){let s=n[t];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${t}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${s}`);e*=s}return e},la=(n,e)=>{switch(n.location){case"cpu":return new Pe(n.type,n.data,e);case"cpu-pinned":return new Pe({location:"cpu-pinned",data:n.data,type:n.type,dims:e});case"texture":return new Pe({location:"texture",texture:n.texture,type:n.type,dims:e});case"gpu-buffer":return new Pe({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:e});case"ml-tensor":return new Pe({location:"ml-tensor",mlTensor:n.mlTensor,type:n.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}}}),Pe,hr=U(()=>{Ji(),ia(),ua(),ca(),Pe=class{constructor(n,e,t){sa();let s,a;if(typeof n=="object"&&"location"in n)switch(this.dataLocation=n.location,s=n.type,a=n.dims,n.location){case"cpu-pinned":{let l=xt.get(s);if(!l)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(n.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=n.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=n.texture,this.downloader=n.download,this.disposer=n.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=n.gpuBuffer,this.downloader=n.download,this.disposer=n.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=n.mlTensor,this.downloader=n.download,this.disposer=n.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,_;if(typeof n=="string")if(s=n,_=t,n==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");l=e}else{let m=xt.get(n);if(m===void 0)throw new TypeError(`Unsupported tensor type: ${n}.`);if(Array.isArray(e)){if(n==="float16"&&m===Uint16Array||n==="uint4"||n==="int4")throw new TypeError(`Creating a ${n} tensor from number array is not supported. Please use ${m.name} as data.`);n==="uint64"||n==="int64"?l=m.from(e,BigInt):l=m.from(e)}else if(e instanceof m)l=e;else if(e instanceof Uint8ClampedArray)if(n==="uint8")l=Uint8Array.from(e);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(n==="float16"&&e instanceof Uint16Array&&m!==Uint16Array)l=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw new TypeError(`A ${s} tensor's data must be type of ${m}`)}else if(_=e,Array.isArray(n)){if(n.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let m=typeof n[0];if(m==="string")s="string",l=n;else if(m==="boolean")s="bool",l=Uint8Array.from(n);else throw new TypeError(`Invalid element type of data array: ${m}.`)}else if(n instanceof Uint8ClampedArray)s="uint8",l=Uint8Array.from(n);else{let m=qt.get(n.constructor);if(m===void 0)throw new TypeError(`Unsupported type for tensor data: ${n.constructor}.`);s=m,l=n}if(_===void 0)_=[l.length];else if(!Array.isArray(_))throw new TypeError("A tensor's dims must be a number array");a=_,this.cpuData=l,this.dataLocation="cpu"}let c=da(a);if(this.cpuData&&c!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(c/2)===this.cpuData.length))throw new Error(`Tensor's size(${c}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=a,this.size=c}static async fromImage(n,e){return ea(n,e)}static fromTexture(n,e){return ta(n,e)}static fromGpuBuffer(n,e){return ra(n,e)}static fromMLTensor(n,e){return na(n,e)}static fromPinnedBuffer(n,e,t){return oa(n,e,t)}toDataURL(n){return Yi(this,n)}toImageData(n){return Xi(this,n)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(n){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,n&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(n){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return la(this,n)}}}),Ge,Rn=U(()=>{hr(),Ge=Pe}),gr,pa,Re,Oe,Un=U(()=>{Dn(),gr=(n,e)=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||console.timeStamp(`${n}::ORT::${e}`)},pa=(n,e)=>{let t=new Error().stack?.split(/\r\n|\r|\n/g)||[],s=!1;for(let a=0;a<t.length;a++){if(s&&!t[a].includes("TRACE_FUNC")){let c=`FUNC_${n}::${t[a].trim().split(" ")[1]}`;e&&(c+=`::${e}`),gr("CPU",c);return}t[a].includes("TRACE_FUNC")&&(s=!0)}},Re=n=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||pa("BEGIN",n)},Oe=n=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||pa("END",n)}}),br,ma=U(()=>{Bn(),Rn(),Un(),br=class aT{constructor(e){this.handler=e}async run(e,t,s){Re();let a={},c={};if(typeof e!="object"||e===null||e instanceof Ge||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let l=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Ge)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");l=!1;for(let d of t){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);a[d]=null}if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let d=!1,h=Object.getOwnPropertyNames(t);for(let i of this.outputNames)if(h.indexOf(i)!==-1){let r=t[i];(r===null||r instanceof Ge)&&(d=!0,l=!1,a[i]=r)}if(d){if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else c=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let d of this.inputNames)if(typeof e[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(l)for(let d of this.outputNames)a[d]=null;let _=await this.handler.run(e,a,c),m={};for(let d in _)if(Object.hasOwnProperty.call(_,d)){let h=_[d];h instanceof Ge?m[d]=h:m[d]=new Ge(h.type,h.data,h.dims)}return Oe(),m}async release(){return this.handler.dispose()}static async create(e,t,s,a){Re();let c,l={};if(typeof e=="string"){if(c=e,typeof t=="object"&&t!==null)l=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(c=e,typeof t=="object"&&t!==null)l=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let h=e,i=0,r=e.byteLength;if(typeof t=="object"&&t!==null)l=t;else if(typeof t=="number"){if(i=t,!Number.isSafeInteger(i))throw new RangeError("'byteOffset' must be an integer.");if(i<0||i>=h.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${h.byteLength}).`);if(r=e.byteLength-i,typeof s=="number"){if(r=s,!Number.isSafeInteger(r))throw new RangeError("'byteLength' must be an integer.");if(r<=0||i+r>h.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${h.byteLength-i}].`);if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(h,i,r)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[_,m]=await Fi(l),d=await _.createInferenceSessionHandler(c,m);return Oe(),new aT(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),Gp,fa=U(()=>{ma(),Gp=br}),ha=U(()=>{}),ga=U(()=>{}),ba=U(()=>{}),ya=U(()=>{}),Nn={};Dt(Nn,{InferenceSession:()=>Gp,TRACE:()=>gr,TRACE_FUNC_BEGIN:()=>Re,TRACE_FUNC_END:()=>Oe,Tensor:()=>Ge,env:()=>ge,registerBackend:()=>$t});var We=U(()=>{qi(),Qi(),fa(),Rn(),ha(),ga(),Un(),ba(),ya()}),yr=U(()=>{}),$a={};Dt($a,{default:()=>Hp});var wa,va,Hp,xa=U(()=>{Vn(),ht(),_r(),wa="ort-wasm-proxy-worker",va=globalThis.self?.name===wa,va&&(self.onmessage=n=>{let{type:e,in:t}=n.data;try{switch(e){case"init-wasm":wr(t.wasm).then(()=>{vr(t).then(()=>{postMessage({type:e})},s=>{postMessage({type:e,err:s})})},s=>{postMessage({type:e,err:s})});break;case"init-ep":{let{epName:s,env:a}=t;$r(a,s).then(()=>{postMessage({type:e})},c=>{postMessage({type:e,err:c})});break}case"copy-from":{let{buffer:s}=t,a=jt(s);postMessage({type:e,out:a});break}case"create":{let{model:s,options:a}=t;xr(s,a).then(c=>{postMessage({type:e,out:c})},c=>{postMessage({type:e,err:c})});break}case"release":Sr(t),postMessage({type:e});break;case"run":{let{sessionId:s,inputIndices:a,inputs:c,outputIndices:l,options:_}=t;Tr(s,a,c,l,new Array(l.length).fill(null),_).then(m=>{m.some(d=>d[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:m},Cr([...c,...m]))},m=>{postMessage({type:e,err:m})});break}case"end-profiling":Ir(t),postMessage({type:e});break;default:}}catch(s){postMessage({type:e,err:s})}}),Hp=va?null:n=>new Worker(n??Ue,{type:"module",name:wa})}),Ta={};Dt(Ta,{default:()=>Fp});var Wn,Sa,Fp,qp,Ia=U(()=>{Sa=(Wn=import.meta.url,async function(n={}){var e,t,s=n,a=new Promise((L,V)=>{e=L,t=V}),c=typeof window=="object",l=typeof WorkerGlobalScope<"u",_=l&&self.name?.startsWith("em-pthread");s.mountExternalData=(L,V)=>{L.startsWith("./")&&(L=L.substring(2)),(s.Eb||(s.Eb=new Map)).set(L,V)},s.unmountExternalData=()=>{delete s.Eb};var m=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let d=L=>async(...V)=>{try{if(s.Fb)throw Error("Session already started");let le=s.Fb={dc:V[0],errors:[]},_e=await L(...V);if(s.Fb!==le)throw Error("Session mismatch");s.Jb?.flush();let De=le.errors;if(0<De.length){let mt=await Promise.all(De);if(mt=mt.filter(nr=>nr),0<mt.length)throw Error(mt.join(`
`))}return _e}finally{s.Fb=null}};s.jsepInit=(L,V)=>{if(L==="webgpu"){[s.Jb,s.Ub,s.Yb,s.Kb,s.Xb,s.jb,s.Zb,s.ac,s.Vb,s.Wb,s.$b]=V;let le=s.Jb;s.jsepRegisterBuffer=(_e,De,mt,nr)=>le.registerBuffer(_e,De,mt,nr),s.jsepGetBuffer=_e=>le.getBuffer(_e),s.jsepCreateDownloader=(_e,De,mt)=>le.createDownloader(_e,De,mt),s.jsepOnCreateSession=_e=>{le.onCreateSession(_e)},s.jsepOnReleaseSession=_e=>{le.onReleaseSession(_e)},s.jsepOnRunStart=_e=>le.onRunStart(_e),s.bc=(_e,De)=>{le.upload(_e,De)}}else if(L==="webnn"){let le=V[0];[s.nc,s.Nb,s.webnnEnsureTensor,s.Ob,s.webnnDownloadTensor]=V.slice(1),s.webnnReleaseTensorId=s.Nb,s.webnnUploadTensor=s.Ob,s.webnnOnRunStart=_e=>le.onRunStart(_e),s.webnnOnRunEnd=le.onRunEnd.bind(le),s.webnnRegisterMLContext=(_e,De)=>{le.registerMLContext(_e,De)},s.webnnOnReleaseSession=_e=>{le.onReleaseSession(_e)},s.webnnCreateMLTensorDownloader=(_e,De)=>le.createMLTensorDownloader(_e,De),s.webnnRegisterMLTensor=(_e,De,mt,nr)=>le.registerMLTensor(_e,De,mt,nr),s.webnnCreateMLContext=_e=>le.createMLContext(_e),s.webnnRegisterMLConstant=(_e,De,mt,nr,li,bi)=>le.registerMLConstant(_e,De,mt,nr,li,s.Eb,bi),s.webnnRegisterGraphInput=le.registerGraphInput.bind(le),s.webnnIsGraphInput=le.isGraphInput.bind(le),s.webnnCreateTemporaryTensor=le.createTemporaryTensor.bind(le),s.webnnIsInt64Supported=le.isInt64Supported.bind(le)}};let h=()=>{let L=(V,le,_e)=>(...De)=>{let mt=Mc,nr=le?.();De=V(...De);let li=le?.();return nr!==li&&(V=li,_e(nr),le=_e=null),Mc!=mt?new Promise((bi,Ai)=>{Z={resolve:bi,reject:Ai}}):De};(()=>{for(let V of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])s[V]=L(s[V],()=>s[V],le=>s[V]=le)})(),d!==void 0&&(s._OrtRun=d(s._OrtRun),s._OrtRunWithBinding=d(s._OrtRunWithBinding)),h=void 0};s.asyncInit=()=>{h?.()};var i,r,u=Object.assign({},s),f=(L,V)=>{throw V},g="";(c||l)&&(l?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),Wn&&(g=Wn),g=g.startsWith("blob:")?"":g.slice(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),l&&(r=L=>{var V=new XMLHttpRequest;return V.open("GET",L,!1),V.responseType="arraybuffer",V.send(null),new Uint8Array(V.response)}),i=async L=>{if(Ce(L))return new Promise((le,_e)=>{var De=new XMLHttpRequest;De.open("GET",L,!0),De.responseType="arraybuffer",De.onload=()=>{De.status==200||De.status==0&&De.response?le(De.response):_e(De.status)},De.onerror=_e,De.send(null)});var V=await fetch(L,{credentials:"same-origin"});if(V.ok)return V.arrayBuffer();throw Error(V.status+" : "+V.url)});var w=console.log.bind(console),y=console.error.bind(console),x=w,S=y;Object.assign(s,u),u=null;var T,E,A,C,I,D,R,Y,re,G,te,q,z,H=s.wasmBinary,he=!1,Ce=L=>L.startsWith("file://");function oe(){return T.buffer!=C.buffer&&hn(),C}function K(){return T.buffer!=C.buffer&&hn(),I}function Q(){return T.buffer!=C.buffer&&hn(),D}function de(){return T.buffer!=C.buffer&&hn(),R}function ue(){return T.buffer!=C.buffer&&hn(),Y}function Ze(){return T.buffer!=C.buffer&&hn(),re}function Pt(){return T.buffer!=C.buffer&&hn(),G}function Gt(){return T.buffer!=C.buffer&&hn(),z}if(_){let L=function(V){try{var le=V.data,_e=le.Bb;if(_e==="load"){let De=[];self.onmessage=mt=>De.push(mt),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let mt of De)L(mt);self.onmessage=L};for(let mt of le.Rb)s[mt]&&!s[mt].proxy||(s[mt]=(...nr)=>{postMessage({Bb:"callHandler",Qb:mt,args:nr})},mt=="print"&&(x=s[mt]),mt=="printErr"&&(S=s[mt]));T=le.kc,hn(),bn(le.lc)}else if(_e==="run"){Jo(le.Ab),Tp(le.Ab,0,0,1,0,0),zc(),at(le.Ab),ri||(p1(),ri=!0);try{Mo(le.fc,le.Hb)}catch(De){if(De!="unwind")throw De}}else le.target!=="setimmediate"&&(_e==="checkMailbox"?ri&&ft():_e&&(S(`worker: received unknown command ${_e}`),S(le)))}catch(De){throw xg(),De}};var bn,ri=!1;S=function(...V){V=V.join(" "),console.error(V)},self.alert=function(...V){postMessage({Bb:"alert",text:V.join(" "),ic:f1()})},self.onunhandledrejection=V=>{throw V.reason||V},self.onmessage=L}function hn(){var L=T.buffer;s.HEAP8=C=new Int8Array(L),s.HEAP16=D=new Int16Array(L),s.HEAPU8=I=new Uint8Array(L),s.HEAPU16=R=new Uint16Array(L),s.HEAP32=Y=new Int32Array(L),s.HEAPU32=re=new Uint32Array(L),s.HEAPF32=G=new Float32Array(L),s.HEAPF64=z=new Float64Array(L),s.HEAP64=te=new BigInt64Array(L),s.HEAPU64=q=new BigUint64Array(L)}function ze(){_?startWorker(s):Li.Ca()}_||(T=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),hn());var wt,ke=0,Bt=null;function In(){if(--ke==0&&Bt){var L=Bt;Bt=null,L()}}function Tn(L){throw S(L="Aborted("+L+")"),he=!0,L=new WebAssembly.RuntimeError(L+". Build with -sASSERTIONS for more info."),t(L),L}function cn(){return{a:{L:$n,Aa:yn,b:rf,$:Wi,A:Ui,pa:Rp,X:ve,Z:Ke,qa:lt,na:_n,ga:ar,ma:vi,J:Pi,Y:hi,V:Oo,oa:we,W:it,va:Ht,E:Ko,Q:Dc,O:kp,D:sp,u:mr,r:ci,P:Mi,z:M_,R:Lt,ja:X,T:kt,aa:or,M:lr,F:yi,ia:at,sa:di,t:Tc,Ba:Uc,w:ct,o:Sn,l:Ii,c:Ro,n:Zo,j:Ho,v:Bc,p:s_,f:E_,s:ly,m:F_,e:uy,k:cy,i:dy,g:py,d:fy,da:J_,ea:hy,fa:q1,ba:H1,ca:G0,N:W0,xa:q0,ua:H0,h:X0,C:Q0,G:Y1,ta:_y,x:X1,ra:Bg,U:my,q:K1,y:Z0,K:J0,S:eb,za:gy,ya:Q1,ka:i_,la:wg,_:ui,B:by,I:Ug,ha:tb,H:Vg,a:T,wa:mi}}}var kn={829644:(L,V,le,_e,De)=>{if(s===void 0||!s.Eb)return 1;if((L=_c(Number(L>>>0))).startsWith("./")&&(L=L.substring(2)),!(L=s.Eb.get(L)))return 2;if(V=Number(V>>>0),le=Number(le>>>0),_e=Number(_e>>>0),V+le>L.byteLength)return 3;try{let mt=L.subarray(V,V+le);switch(De){case 0:K().set(mt,_e>>>0);break;case 1:s.mc?s.mc(_e,mt):s.bc(_e,mt);break;default:return 4}return 0}catch{return 4}},830468:(L,V,le)=>{s.Ob(L,K().subarray(V>>>0,V+le>>>0))},830532:()=>s.nc(),830574:L=>{s.Nb(L)},830611:()=>{s.Vb()},830642:()=>{s.Wb()},830671:()=>{s.$b()},830696:L=>s.Ub(L),830729:L=>s.Yb(L),830761:(L,V,le)=>{s.Kb(Number(L),Number(V),Number(le),!0)},830824:(L,V,le)=>{s.Kb(Number(L),Number(V),Number(le))},830881:()=>typeof wasmOffsetConverter<"u",830938:L=>{s.jb("Abs",L,void 0)},830989:L=>{s.jb("Neg",L,void 0)},831040:L=>{s.jb("Floor",L,void 0)},831093:L=>{s.jb("Ceil",L,void 0)},831145:L=>{s.jb("Reciprocal",L,void 0)},831203:L=>{s.jb("Sqrt",L,void 0)},831255:L=>{s.jb("Exp",L,void 0)},831306:L=>{s.jb("Erf",L,void 0)},831357:L=>{s.jb("Sigmoid",L,void 0)},831412:(L,V,le)=>{s.jb("HardSigmoid",L,{alpha:V,beta:le})},831491:L=>{s.jb("Log",L,void 0)},831542:L=>{s.jb("Sin",L,void 0)},831593:L=>{s.jb("Cos",L,void 0)},831644:L=>{s.jb("Tan",L,void 0)},831695:L=>{s.jb("Asin",L,void 0)},831747:L=>{s.jb("Acos",L,void 0)},831799:L=>{s.jb("Atan",L,void 0)},831851:L=>{s.jb("Sinh",L,void 0)},831903:L=>{s.jb("Cosh",L,void 0)},831955:L=>{s.jb("Asinh",L,void 0)},832008:L=>{s.jb("Acosh",L,void 0)},832061:L=>{s.jb("Atanh",L,void 0)},832114:L=>{s.jb("Tanh",L,void 0)},832166:L=>{s.jb("Not",L,void 0)},832217:(L,V,le)=>{s.jb("Clip",L,{min:V,max:le})},832286:L=>{s.jb("Clip",L,void 0)},832338:(L,V)=>{s.jb("Elu",L,{alpha:V})},832396:L=>{s.jb("Gelu",L,void 0)},832448:L=>{s.jb("Relu",L,void 0)},832500:(L,V)=>{s.jb("LeakyRelu",L,{alpha:V})},832564:(L,V)=>{s.jb("ThresholdedRelu",L,{alpha:V})},832634:(L,V)=>{s.jb("Cast",L,{to:V})},832692:L=>{s.jb("Add",L,void 0)},832743:L=>{s.jb("Sub",L,void 0)},832794:L=>{s.jb("Mul",L,void 0)},832845:L=>{s.jb("Div",L,void 0)},832896:L=>{s.jb("Pow",L,void 0)},832947:L=>{s.jb("Equal",L,void 0)},833e3:L=>{s.jb("Greater",L,void 0)},833055:L=>{s.jb("GreaterOrEqual",L,void 0)},833117:L=>{s.jb("Less",L,void 0)},833169:L=>{s.jb("LessOrEqual",L,void 0)},833228:(L,V,le,_e,De)=>{s.jb("ReduceMean",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},833403:(L,V,le,_e,De)=>{s.jb("ReduceMax",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},833577:(L,V,le,_e,De)=>{s.jb("ReduceMin",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},833751:(L,V,le,_e,De)=>{s.jb("ReduceProd",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},833926:(L,V,le,_e,De)=>{s.jb("ReduceSum",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},834100:(L,V,le,_e,De)=>{s.jb("ReduceL1",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},834273:(L,V,le,_e,De)=>{s.jb("ReduceL2",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},834446:(L,V,le,_e,De)=>{s.jb("ReduceLogSum",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},834623:(L,V,le,_e,De)=>{s.jb("ReduceSumSquare",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},834803:(L,V,le,_e,De)=>{s.jb("ReduceLogSumExp",L,{keepDims:!!V,noopWithEmptyAxes:!!le,axes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},834983:L=>{s.jb("Where",L,void 0)},835036:(L,V,le)=>{s.jb("Transpose",L,{perm:V?Array.from(ue().subarray(Number(V)>>>0,Number(le)>>>0)):[]})},835160:(L,V,le,_e)=>{s.jb("DepthToSpace",L,{blocksize:V,mode:_c(le),format:_e?"NHWC":"NCHW"})},835293:(L,V,le,_e)=>{s.jb("DepthToSpace",L,{blocksize:V,mode:_c(le),format:_e?"NHWC":"NCHW"})},835426:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic,hp)=>{s.jb("ConvTranspose",L,{format:bi?"NHWC":"NCHW",autoPad:V,dilations:[le],group:_e,kernelShape:[De],pads:[mt,nr],strides:[li],wIsConst:()=>!!oe()[Ai>>>0],outputPadding:Fo?Array.from(ue().subarray(Number(Fo)>>>0,Number(jo)>>>0)):[],outputShape:Ec?Array.from(ue().subarray(Number(Ec)>>>0,Number(Ic)>>>0)):[],activation:_c(hp)})},835859:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic)=>{s.jb("ConvTranspose",L,{format:li?"NHWC":"NCHW",autoPad:V,dilations:Array.from(ue().subarray(Number(le)>>>0,2+(Number(le)>>>0)>>>0)),group:_e,kernelShape:Array.from(ue().subarray(Number(De)>>>0,2+(Number(De)>>>0)>>>0)),pads:Array.from(ue().subarray(Number(mt)>>>0,4+(Number(mt)>>>0)>>>0)),strides:Array.from(ue().subarray(Number(nr)>>>0,2+(Number(nr)>>>0)>>>0)),wIsConst:()=>!!oe()[bi>>>0],outputPadding:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],outputShape:jo?Array.from(ue().subarray(Number(jo)>>>0,Number(Ec)>>>0)):[],activation:_c(Ic)})},836520:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic,hp)=>{s.jb("ConvTranspose",L,{format:bi?"NHWC":"NCHW",autoPad:V,dilations:[le],group:_e,kernelShape:[De],pads:[mt,nr],strides:[li],wIsConst:()=>!!oe()[Ai>>>0],outputPadding:Fo?Array.from(ue().subarray(Number(Fo)>>>0,Number(jo)>>>0)):[],outputShape:Ec?Array.from(ue().subarray(Number(Ec)>>>0,Number(Ic)>>>0)):[],activation:_c(hp)})},836953:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic)=>{s.jb("ConvTranspose",L,{format:li?"NHWC":"NCHW",autoPad:V,dilations:Array.from(ue().subarray(Number(le)>>>0,2+(Number(le)>>>0)>>>0)),group:_e,kernelShape:Array.from(ue().subarray(Number(De)>>>0,2+(Number(De)>>>0)>>>0)),pads:Array.from(ue().subarray(Number(mt)>>>0,4+(Number(mt)>>>0)>>>0)),strides:Array.from(ue().subarray(Number(nr)>>>0,2+(Number(nr)>>>0)>>>0)),wIsConst:()=>!!oe()[bi>>>0],outputPadding:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],outputShape:jo?Array.from(ue().subarray(Number(jo)>>>0,Number(Ec)>>>0)):[],activation:_c(Ic)})},837614:(L,V)=>{s.jb("GlobalAveragePool",L,{format:V?"NHWC":"NCHW"})},837705:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic)=>{s.jb("AveragePool",L,{format:Ic?"NHWC":"NCHW",auto_pad:V,ceil_mode:le,count_include_pad:_e,storage_order:De,dilations:mt?Array.from(ue().subarray(Number(mt)>>>0,Number(nr)>>>0)):[],kernel_shape:li?Array.from(ue().subarray(Number(li)>>>0,Number(bi)>>>0)):[],pads:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],strides:jo?Array.from(ue().subarray(Number(jo)>>>0,Number(Ec)>>>0)):[]})},838184:(L,V)=>{s.jb("GlobalAveragePool",L,{format:V?"NHWC":"NCHW"})},838275:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic)=>{s.jb("AveragePool",L,{format:Ic?"NHWC":"NCHW",auto_pad:V,ceil_mode:le,count_include_pad:_e,storage_order:De,dilations:mt?Array.from(ue().subarray(Number(mt)>>>0,Number(nr)>>>0)):[],kernel_shape:li?Array.from(ue().subarray(Number(li)>>>0,Number(bi)>>>0)):[],pads:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],strides:jo?Array.from(ue().subarray(Number(jo)>>>0,Number(Ec)>>>0)):[]})},838754:(L,V)=>{s.jb("GlobalMaxPool",L,{format:V?"NHWC":"NCHW"})},838841:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic)=>{s.jb("MaxPool",L,{format:Ic?"NHWC":"NCHW",auto_pad:V,ceil_mode:le,count_include_pad:_e,storage_order:De,dilations:mt?Array.from(ue().subarray(Number(mt)>>>0,Number(nr)>>>0)):[],kernel_shape:li?Array.from(ue().subarray(Number(li)>>>0,Number(bi)>>>0)):[],pads:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],strides:jo?Array.from(ue().subarray(Number(jo)>>>0,Number(Ec)>>>0)):[]})},839316:(L,V)=>{s.jb("GlobalMaxPool",L,{format:V?"NHWC":"NCHW"})},839403:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic)=>{s.jb("MaxPool",L,{format:Ic?"NHWC":"NCHW",auto_pad:V,ceil_mode:le,count_include_pad:_e,storage_order:De,dilations:mt?Array.from(ue().subarray(Number(mt)>>>0,Number(nr)>>>0)):[],kernel_shape:li?Array.from(ue().subarray(Number(li)>>>0,Number(bi)>>>0)):[],pads:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],strides:jo?Array.from(ue().subarray(Number(jo)>>>0,Number(Ec)>>>0)):[]})},839878:(L,V,le,_e,De)=>{s.jb("Gemm",L,{alpha:V,beta:le,transA:_e,transB:De})},839982:L=>{s.jb("MatMul",L,void 0)},840036:(L,V,le,_e)=>{s.jb("ArgMax",L,{keepDims:!!V,selectLastIndex:!!le,axis:_e})},840144:(L,V,le,_e)=>{s.jb("ArgMin",L,{keepDims:!!V,selectLastIndex:!!le,axis:_e})},840252:(L,V)=>{s.jb("Softmax",L,{axis:V})},840315:(L,V)=>{s.jb("Concat",L,{axis:V})},840375:(L,V,le,_e,De)=>{s.jb("Split",L,{axis:V,numOutputs:le,splitSizes:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},840531:L=>{s.jb("Expand",L,void 0)},840585:(L,V)=>{s.jb("Gather",L,{axis:Number(V)})},840656:(L,V)=>{s.jb("GatherElements",L,{axis:Number(V)})},840735:(L,V)=>{s.jb("GatherND",L,{batch_dims:Number(V)})},840814:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo)=>{s.jb("Resize",L,{antialias:V,axes:le?Array.from(ue().subarray(Number(le)>>>0,Number(_e)>>>0)):[],coordinateTransformMode:_c(De),cubicCoeffA:mt,excludeOutside:nr,extrapolationValue:li,keepAspectRatioPolicy:_c(bi),mode:_c(Ai),nearestMode:_c(Fo)})},841176:(L,V,le,_e,De,mt,nr)=>{s.jb("Slice",L,{starts:V?Array.from(ue().subarray(Number(V)>>>0,Number(le)>>>0)):[],ends:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[],axes:mt?Array.from(ue().subarray(Number(mt)>>>0,Number(nr)>>>0)):[]})},841440:L=>{s.jb("Tile",L,void 0)},841492:(L,V,le)=>{s.jb("InstanceNormalization",L,{epsilon:V,format:le?"NHWC":"NCHW"})},841606:(L,V,le)=>{s.jb("InstanceNormalization",L,{epsilon:V,format:le?"NHWC":"NCHW"})},841720:L=>{s.jb("Range",L,void 0)},841773:(L,V)=>{s.jb("Einsum",L,{equation:_c(V)})},841854:(L,V,le,_e,De)=>{s.jb("Pad",L,{mode:V,value:le,pads:_e?Array.from(ue().subarray(Number(_e)>>>0,Number(De)>>>0)):[]})},841997:(L,V,le,_e,De,mt)=>{s.jb("BatchNormalization",L,{epsilon:V,momentum:le,spatial:!!De,trainingMode:!!_e,format:mt?"NHWC":"NCHW"})},842166:(L,V,le,_e,De,mt)=>{s.jb("BatchNormalization",L,{epsilon:V,momentum:le,spatial:!!De,trainingMode:!!_e,format:mt?"NHWC":"NCHW"})},842335:(L,V,le)=>{s.jb("CumSum",L,{exclusive:Number(V),reverse:Number(le)})},842432:(L,V,le)=>{s.jb("DequantizeLinear",L,{axis:V,blockSize:le})},842522:(L,V,le,_e,De)=>{s.jb("GridSample",L,{align_corners:V,mode:_c(le),padding_mode:_c(_e),format:De?"NHWC":"NCHW"})},842692:(L,V,le,_e,De)=>{s.jb("GridSample",L,{align_corners:V,mode:_c(le),padding_mode:_c(_e),format:De?"NHWC":"NCHW"})},842862:(L,V)=>{s.jb("ScatterND",L,{reduction:_c(V)})},842947:(L,V,le,_e,De,mt,nr,li,bi)=>{s.jb("Attention",L,{numHeads:V,isUnidirectional:le,maskFilterValue:_e,scale:De,doRotary:mt,qkvHiddenSizes:nr?Array.from(ue().subarray(Number(li)>>>0,Number(li)+nr>>>0)):[],pastPresentShareBuffer:!!bi})},843219:L=>{s.jb("BiasAdd",L,void 0)},843274:L=>{s.jb("BiasSplitGelu",L,void 0)},843335:L=>{s.jb("FastGelu",L,void 0)},843391:(L,V,le,_e,De,mt,nr,li,bi,Ai,Fo,jo,Ec,Ic,hp,Tg)=>{s.jb("Conv",L,{format:jo?"NHWC":"NCHW",auto_pad:V,dilations:le?Array.from(ue().subarray(Number(le)>>>0,Number(_e)>>>0)):[],group:De,kernel_shape:mt?Array.from(ue().subarray(Number(mt)>>>0,Number(nr)>>>0)):[],pads:li?Array.from(ue().subarray(Number(li)>>>0,Number(bi)>>>0)):[],strides:Ai?Array.from(ue().subarray(Number(Ai)>>>0,Number(Fo)>>>0)):[],w_is_const:()=>!!oe()[Number(Ec)>>>0],activation:_c(Ic),activation_params:hp?Array.from(Pt().subarray(Number(hp)>>>0,Number(Tg)>>>0)):[]})},843975:L=>{s.jb("Gelu",L,void 0)},844027:(L,V,le,_e,De,mt,nr,li,bi)=>{s.jb("GroupQueryAttention",L,{numHeads:V,kvNumHeads:le,scale:_e,softcap:De,doRotary:mt,rotaryInterleaved:nr,smoothSoftmax:li,localWindowSize:bi})},844244:(L,V,le,_e)=>{s.jb("LayerNormalization",L,{axis:V,epsilon:le,simplified:!!_e})},844355:(L,V,le,_e)=>{s.jb("LayerNormalization",L,{axis:V,epsilon:le,simplified:!!_e})},844466:(L,V,le,_e,De,mt)=>{s.jb("MatMulNBits",L,{k:V,n:le,accuracyLevel:_e,bits:De,blockSize:mt})},844593:(L,V,le,_e,De,mt)=>{s.jb("MultiHeadAttention",L,{numHeads:V,isUnidirectional:le,maskFilterValue:_e,scale:De,doRotary:mt})},844752:(L,V)=>{s.jb("QuickGelu",L,{alpha:V})},844816:(L,V,le,_e,De)=>{s.jb("RotaryEmbedding",L,{interleaved:!!V,numHeads:le,rotaryEmbeddingDim:_e,scale:De})},844955:(L,V,le)=>{s.jb("SkipLayerNormalization",L,{epsilon:V,simplified:!!le})},845057:(L,V,le)=>{s.jb("SkipLayerNormalization",L,{epsilon:V,simplified:!!le})},845159:(L,V,le,_e)=>{s.jb("GatherBlockQuantized",L,{gatherAxis:V,quantizeAxis:le,blockSize:_e})},845280:L=>{s.Zb(L)},845314:(L,V)=>s.ac(Number(L),Number(V),s.Fb.dc,s.Fb.errors)};function yn(L,V,le){return Ve(async()=>{await s.Xb(Number(L),Number(V),Number(le))})}function $n(){return typeof wasmOffsetConverter<"u"}class cr{name="ExitStatus";constructor(V){this.message=`Program terminated with exit(${V})`,this.status=V}}var ti=L=>{L.terminate(),L.onmessage=()=>{}},vn=[],xi=L=>{wi.length==0&&(up(),Xc(wi[0]));var V=wi.pop();if(!V)return 6;Lo.push(V),Ci[L.Ab]=V,V.Ab=L.Ab;var le={Bb:"run",fc:L.ec,Hb:L.Hb,Ab:L.Ab};return V.postMessage(le,L.Mb),0},ir=0,ai=(L,V,...le)=>{for(var _e=2*le.length,De=N_(),mt=vg(8*_e),nr=mt>>>3,li=0;li<le.length;li++){var bi=le[li];typeof bi=="bigint"?(te[nr+2*li]=1n,te[nr+2*li+1]=bi):(te[nr+2*li]=0n,Gt()[nr+2*li+1>>>0]=bi)}return L=Z1(L,0,_e,mt,V),b_(De),L};function mi(L){if(_)return ai(0,1,L);if(A=L,!(0<ir)){for(var V of Lo)ti(V);for(V of wi)ti(V);wi=[],Lo=[],Ci={},he=!0}f(0,new cr(L))}function fi(L){if(_)return ai(1,0,L);ui(L)}var ui=L=>{if(A=L,_)throw fi(L),"unwind";mi(L)},wi=[],Lo=[],zi=[],Ci={},Si=L=>{var V=L.Ab;delete Ci[V],wi.push(L),Lo.splice(Lo.indexOf(L),1),L.Ab=0,_1(V)};function zc(){zi.forEach(L=>L())}var Xc=L=>new Promise(V=>{L.onmessage=De=>{var mt=(De=De.data).Bb;if(De.Gb&&De.Gb!=f1()){var nr=Ci[De.Gb];nr?nr.postMessage(De,De.Mb):S(`Internal error! Worker sent a message "${mt}" to target pthread ${De.Gb}, but that thread no longer exists!`)}else mt==="checkMailbox"?ft():mt==="spawnThread"?xi(De):mt==="cleanupThread"?Si(Ci[De.hc]):mt==="loaded"?(L.loaded=!0,V(L)):mt==="alert"?alert(`Thread ${De.ic}: ${De.text}`):De.target==="setimmediate"?L.postMessage(De):mt==="callHandler"?s[De.Qb](...De.args):mt&&S(`worker sent an unknown command ${mt}`)},L.onerror=De=>{throw S(`worker sent an error! ${De.filename}:${De.lineno}: ${De.message}`),De};var le,_e=[];for(le of[])s.propertyIsEnumerable(le)&&_e.push(le);L.postMessage({Bb:"load",Rb:_e,kc:T,lc:E})});function up(){var L=new Worker((()=>{let V=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new V("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});wi.push(L)}var Jo=L=>{hn();var V=Ze()[L+52>>>2>>>0];L=Ze()[L+56>>>2>>>0],ib(V,V-L),b_(V)},Mo=(L,V)=>{ir=0,L=g1(L,V),0<ir?A=L:m1(L)};class $p{constructor(V){this.Ib=V-24}}function rf(L,V,le){var _e=new $p(L>>>=0);throw V>>>=0,le>>>=0,Ze()[_e.Ib+16>>>2>>>0]=0,Ze()[_e.Ib+4>>>2>>>0]=V,Ze()[_e.Ib+8>>>2>>>0]=le,L}function cp(L,V,le,_e){return _?ai(2,1,L,V,le,_e):Wi(L,V,le,_e)}function Wi(L,V,le,_e){if(L>>>=0,le>>>=0,_e>>>=0,m===void 0)return 6;var De=[];return _&&De.length===0?cp(L,V>>>=0,le,_e):(L={ec:le,Ab:L,Hb:_e,Mb:De},_?(L.Bb="spawnThread",postMessage(L,De),0):xi(L))}var si=typeof TextDecoder<"u"?new TextDecoder:void 0,Ri=(L,V=0,le=NaN)=>{var _e=(V>>>=0)+le;for(le=V;L[le]&&!(le>=_e);)++le;if(16<le-V&&L.buffer&&si)return si.decode(L.buffer instanceof ArrayBuffer?L.subarray(V,le):L.slice(V,le));for(_e="";V<le;){var De=L[V++];if(128&De){var mt=63&L[V++];if((224&De)==192)_e+=String.fromCharCode((31&De)<<6|mt);else{var nr=63&L[V++];65536>(De=(240&De)==224?(15&De)<<12|mt<<6|nr:(7&De)<<18|mt<<12|nr<<6|63&L[V++])?_e+=String.fromCharCode(De):(De-=65536,_e+=String.fromCharCode(55296|De>>10,56320|1023&De))}}else _e+=String.fromCharCode(De)}return _e},_c=(L,V)=>(L>>>=0)?Ri(K(),L,V):"";function Ui(L,V,le){return _?ai(3,1,L,V,le):0}function Rp(L,V){if(_)return ai(4,1,L,V)}var W=L=>{for(var V=0,le=0;le<L.length;++le){var _e=L.charCodeAt(le);127>=_e?V++:2047>=_e?V+=2:55296<=_e&&57343>=_e?(V+=4,++le):V+=3}return V},Qe=(L,V,le)=>{var _e=K();if(V>>>=0,0<le){var De=V;le=V+le-1;for(var mt=0;mt<L.length;++mt){var nr=L.charCodeAt(mt);if(55296<=nr&&57343>=nr&&(nr=65536+((1023&nr)<<10)|1023&L.charCodeAt(++mt)),127>=nr){if(V>=le)break;_e[V++>>>0]=nr}else{if(2047>=nr){if(V+1>=le)break;_e[V++>>>0]=192|nr>>6}else{if(65535>=nr){if(V+2>=le)break;_e[V++>>>0]=224|nr>>12}else{if(V+3>=le)break;_e[V++>>>0]=240|nr>>18,_e[V++>>>0]=128|nr>>12&63}_e[V++>>>0]=128|nr>>6&63}_e[V++>>>0]=128|63&nr}}_e[V>>>0]=0,L=V-De}else L=0;return L};function ve(L,V){if(_)return ai(5,1,L,V)}function Ke(L,V,le){if(_)return ai(6,1,L,V,le)}function lt(L,V,le){return _?ai(7,1,L,V,le):0}function _n(L,V){if(_)return ai(8,1,L,V)}function ar(L,V,le){if(_)return ai(9,1,L,V,le)}function vi(L,V,le,_e){if(_)return ai(10,1,L,V,le,_e)}function Pi(L,V,le,_e){if(_)return ai(11,1,L,V,le,_e)}function hi(L,V,le,_e){if(_)return ai(12,1,L,V,le,_e)}function Oo(L){if(_)return ai(13,1,L)}function we(L,V){if(_)return ai(14,1,L,V)}function it(L,V,le){if(_)return ai(15,1,L,V,le)}var pt,Ot,Ht=()=>Tn(""),mn=L=>{for(var V="";K()[L>>>0];)V+=pt[K()[L++>>>0]];return V},ii={},Ti={};function pi(L,V,le={}){return(function(_e,De,mt={}){var nr=De.name;if(!_e)throw new Ot(`type "${nr}" must have a positive integer typeid pointer`);if(Ti.hasOwnProperty(_e)){if(mt.Sb)return;throw new Ot(`Cannot register type '${nr}' twice`)}Ti[_e]=De,ii.hasOwnProperty(_e)&&(De=ii[_e],delete ii[_e],De.forEach(li=>li()))})(L,V,le)}var Do=(L,V,le)=>{switch(V){case 1:return le?_e=>oe()[_e>>>0]:_e=>K()[_e>>>0];case 2:return le?_e=>Q()[_e>>>1>>>0]:_e=>de()[_e>>>1>>>0];case 4:return le?_e=>ue()[_e>>>2>>>0]:_e=>Ze()[_e>>>2>>>0];case 8:return le?_e=>te[_e>>>3]:_e=>q[_e>>>3];default:throw new TypeError(`invalid integer width (${V}): ${L}`)}};function Ko(L,V,le){le>>>=0,pi(L>>>=0,{name:V=mn(V>>>0),fromWireType:_e=>_e,toWireType:function(_e,De){if(typeof De!="bigint"&&typeof De!="number")throw De=De===null?"null":(_e=typeof De)=="object"||_e==="array"||_e==="function"?De.toString():""+De,new TypeError(`Cannot convert "${De}" to ${this.name}`);return typeof De=="number"&&(De=BigInt(De)),De},Cb:yc,readValueFromPointer:Do(V,le,V.indexOf("u")==-1),Db:null})}var yc=8;function Dc(L,V,le,_e){pi(L>>>=0,{name:V=mn(V>>>0),fromWireType:function(De){return!!De},toWireType:function(De,mt){return mt?le:_e},Cb:yc,readValueFromPointer:function(De){return this.fromWireType(K()[De>>>0])},Db:null})}var En=[],Oi=[];function Ro(L){9<(L>>>=0)&&--Oi[L+1]==0&&(Oi[L]=void 0,En.push(L))}var bc=L=>{if(!L)throw new Ot("Cannot use deleted val. handle = "+L);return Oi[L]},Oc=L=>{switch(L){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let V=En.pop()||Oi.length;return Oi[V]=L,Oi[V+1]=1,V}};function dp(L){return this.fromWireType(Ze()[L>>>2>>>0])}var Jf={name:"emscripten::val",fromWireType:L=>{var V=bc(L);return Ro(L),V},toWireType:(L,V)=>Oc(V),Cb:yc,readValueFromPointer:dp,Db:null};function kp(L){return pi(L>>>0,Jf)}var Qc=(L,V)=>{switch(V){case 4:return function(le){return this.fromWireType(Pt()[le>>>2>>>0])};case 8:return function(le){return this.fromWireType(Gt()[le>>>3>>>0])};default:throw new TypeError(`invalid float width (${V}): ${L}`)}};function sp(L,V,le){le>>>=0,pi(L>>>=0,{name:V=mn(V>>>0),fromWireType:_e=>_e,toWireType:(_e,De)=>De,Cb:yc,readValueFromPointer:Qc(V,le),Db:null})}function mr(L,V,le,_e,De){if(L>>>=0,le>>>=0,V=mn(V>>>0),De===-1&&(De=4294967295),De=li=>li,_e===0){var mt=32-8*le;De=li=>li<<mt>>>mt}var nr=V.includes("unsigned")?function(li,bi){return bi>>>0}:function(li,bi){return bi};pi(L,{name:V,fromWireType:De,toWireType:nr,Cb:yc,readValueFromPointer:Do(V,le,_e!==0),Db:null})}function ci(L,V,le){function _e(mt){var nr=Ze()[mt>>>2>>>0];return mt=Ze()[mt+4>>>2>>>0],new De(oe().buffer,mt,nr)}var De=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][V];pi(L>>>=0,{name:le=mn(le>>>0),fromWireType:_e,Cb:yc,readValueFromPointer:_e},{Sb:!0})}function Mi(L,V){pi(L>>>=0,{name:V=mn(V>>>0),fromWireType:function(le){for(var _e,De=Ze()[le>>>2>>>0],mt=le+4,nr=mt,li=0;li<=De;++li){var bi=mt+li;li!=De&&K()[bi>>>0]!=0||(nr=_c(nr,bi-nr),_e===void 0?_e=nr:(_e+="\0",_e+=nr),nr=bi+1)}return f_(le),_e},toWireType:function(le,_e){_e instanceof ArrayBuffer&&(_e=new Uint8Array(_e));var De=typeof _e=="string";if(!(De||_e instanceof Uint8Array||_e instanceof Uint8ClampedArray||_e instanceof Int8Array))throw new Ot("Cannot pass non-string to std::string");var mt=De?W(_e):_e.length,nr=h1(4+mt+1),li=nr+4;if(Ze()[nr>>>2>>>0]=mt,De)Qe(_e,li,mt+1);else if(De)for(De=0;De<mt;++De){var bi=_e.charCodeAt(De);if(255<bi)throw f_(nr),new Ot("String has UTF-16 code units that do not fit in 8 bits");K()[li+De>>>0]=bi}else for(De=0;De<mt;++De)K()[li+De>>>0]=_e[De];return le!==null&&le.push(f_,nr),nr},Cb:yc,readValueFromPointer:dp,Db(le){f_(le)}})}var Ac=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,m_=(L,V)=>{for(var le=L>>1,_e=le+V/2;!(le>=_e)&&de()[le>>>0];)++le;if(32<(le<<=1)-L&&Ac)return Ac.decode(K().slice(L,le));for(le="",_e=0;!(_e>=V/2);++_e){var De=Q()[L+2*_e>>>1>>>0];if(De==0)break;le+=String.fromCharCode(De)}return le},Op=(L,V,le)=>{if(le??=2147483647,2>le)return 0;var _e=V;le=(le-=2)<2*L.length?le/2:L.length;for(var De=0;De<le;++De){var mt=L.charCodeAt(De);Q()[V>>>1>>>0]=mt,V+=2}return Q()[V>>>1>>>0]=0,V-_e},p_=L=>2*L.length,Hc=(L,V)=>{for(var le=0,_e="";!(le>=V/4);){var De=ue()[L+4*le>>>2>>>0];if(De==0)break;++le,65536<=De?(De-=65536,_e+=String.fromCharCode(55296|De>>10,56320|1023&De)):_e+=String.fromCharCode(De)}return _e},g_=(L,V,le)=>{if(V>>>=0,le??=2147483647,4>le)return 0;var _e=V;le=_e+le-4;for(var De=0;De<L.length;++De){var mt=L.charCodeAt(De);if(55296<=mt&&57343>=mt&&(mt=65536+((1023&mt)<<10)|1023&L.charCodeAt(++De)),ue()[V>>>2>>>0]=mt,(V+=4)+4>le)break}return ue()[V>>>2>>>0]=0,V-_e},T_=L=>{for(var V=0,le=0;le<L.length;++le){var _e=L.charCodeAt(le);55296<=_e&&57343>=_e&&++le,V+=4}return V};function M_(L,V,le){if(L>>>=0,V>>>=0,le=mn(le>>>=0),V===2)var _e=m_,De=Op,mt=p_,nr=li=>de()[li>>>1>>>0];else V===4&&(_e=Hc,De=g_,mt=T_,nr=li=>Ze()[li>>>2>>>0]);pi(L,{name:le,fromWireType:li=>{for(var bi,Ai=Ze()[li>>>2>>>0],Fo=li+4,jo=0;jo<=Ai;++jo){var Ec=li+4+jo*V;jo!=Ai&&nr(Ec)!=0||(Fo=_e(Fo,Ec-Fo),bi===void 0?bi=Fo:(bi+="\0",bi+=Fo),Fo=Ec+V)}return f_(li),bi},toWireType:(li,bi)=>{if(typeof bi!="string")throw new Ot(`Cannot pass non-string to C++ string type ${le}`);var Ai=mt(bi),Fo=h1(4+Ai+V);return Ze()[Fo>>>2>>>0]=Ai/V,De(bi,Fo+4,Ai+V),li!==null&&li.push(f_,Fo),Fo},Cb:yc,readValueFromPointer:dp,Db(li){f_(li)}})}function Lt(L,V){pi(L>>>=0,{Tb:!0,name:V=mn(V>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function X(L){Tp(L>>>0,!l,1,!c,131072,!1),zc()}var $e=L=>{if(!he)try{if(L(),!(0<ir))try{_?m1(A):ui(A)}catch(V){V instanceof cr||V=="unwind"||f(0,V)}}catch(V){V instanceof cr||V=="unwind"||f(0,V)}};function at(L){L>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(ue(),L>>>2,L).value.then(ft),L+=128,Atomics.store(ue(),L>>>2,1))}var ft=()=>{var L=f1();L&&(at(L),$e(Wg))};function kt(L,V){(L>>>=0)==V>>>0?setTimeout(ft):_?postMessage({Gb:L,Bb:"checkMailbox"}):(L=Ci[L])&&L.postMessage({Bb:"checkMailbox"})}var sr=[];function or(L,V,le,_e,De){for(V>>>=0,_e/=2,sr.length=_e,le=De>>>0>>>3,De=0;De<_e;De++)sr[De]=te[le+2*De]?te[le+2*De+1]:Gt()[le+2*De+1>>>0];return(V?kn[V]:rb[L])(...sr)}var lr=()=>{ir=0};function yi(L){L>>>=0,_?postMessage({Bb:"cleanupThread",hc:L}):Si(Ci[L])}function di(L){}var zo=(L,V)=>{var le=Ti[L];if(le===void 0)throw L=sb(L),le=mn(L),f_(L),new Ot(`${V} has unknown type ${le}`);return le},Hi=(L,V,le)=>{var _e=[];return L=L.toWireType(_e,le),_e.length&&(Ze()[V>>>2>>>0]=Oc(_e)),L};function Tc(L,V,le){return V>>>=0,le>>>=0,L=bc(L>>>0),V=zo(V,"emval::as"),Hi(V,le,L)}function Uc(L,V){return V>>>=0,L=bc(L>>>0),(V=zo(V,"emval::as")).toWireType(null,L)}var Cc=L=>{try{L()}catch(V){Tn(V)}},Lc=0,Mc=null,ip=0,ep=[],tp={},yp={},wc=0,Z=null,xe=[];function Ve(L){return(function(V){if(!he){if(Lc===0){var le=!1,_e=!1;V((De=0)=>{if(!he&&(ip=De,le=!0,_e)){Lc=2,Cc(()=>R_(Mc)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),De=!1;try{var mt=(function(){var bi=ue()[Mc+8>>>2>>>0];return bi=Li[yp[bi]],--ir,bi()})()}catch(bi){mt=bi,De=!0}var nr=!1;if(!Mc){var li=Z;li&&(Z=null,(De?li.reject:li.resolve)(mt),nr=!0)}if(De&&!nr)throw mt}}),_e=!0,le||(Lc=1,Mc=(function(){var De=h1(65548),mt=De+12;Ze()[De>>>2>>>0]=mt,Ze()[De+4>>>2>>>0]=mt+65536,mt=ep[0];var nr=tp[mt];return nr===void 0&&(nr=wc++,tp[mt]=nr,yp[nr]=mt),mt=nr,ue()[De+8>>>2>>>0]=mt,De})(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),Cc(()=>b1(Mc)))}else Lc===2?(Lc=0,Cc(qg),f_(Mc),Mc=null,xe.forEach($e)):Tn(`invalid state: ${Lc}`);return ip}})(V=>{L().then(V)})}function ct(L){return L>>>=0,Ve(async()=>{var V=await bc(L);return Oc(V)})}var zt=[];function Sn(L,V,le,_e){return le>>>=0,_e>>>=0,(L=zt[L>>>0])(null,V=bc(V>>>0),le,_e)}var pr={},gi=L=>{var V=pr[L];return V===void 0?mn(L):V};function Ii(L,V,le,_e,De){return le>>>=0,_e>>>=0,De>>>=0,(L=zt[L>>>0])(V=bc(V>>>0),V[le=gi(le)],_e,De)}var ki=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Zo(L){return(L>>>=0)==0?Oc(ki()):(L=gi(L),Oc(ki()[L]))}var pp=L=>{var V=zt.length;return zt.push(L),V},fp=(L,V)=>{for(var le=Array(L),_e=0;_e<L;++_e)le[_e]=zo(Ze()[V+4*_e>>>2>>>0],"parameter "+_e);return le},An=(L,V)=>Object.defineProperty(V,"name",{value:L});function Ho(L,V,le){var _e=(V=fp(L,V>>>0)).shift();L--;var De=`return function (obj, func, destructorsRef, args) {
`,mt=0,nr=[];le===0&&nr.push("obj");for(var li=["retType"],bi=[_e],Ai=0;Ai<L;++Ai)nr.push("arg"+Ai),li.push("argType"+Ai),bi.push(V[Ai]),De+=`  var arg${Ai} = argType${Ai}.readValueFromPointer(args${mt?"+"+mt:""});
`,mt+=V[Ai].Cb;return De+=`  var rv = ${le===1?"new func":"func.call"}(${nr.join(", ")});
`,_e.Tb||(li.push("emval_returnValue"),bi.push(Hi),De+=`  return emval_returnValue(retType, destructorsRef, rv);
`),li.push(De+`};
`),L=(function(Fo){var jo=Function;if(!(jo instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof jo} which is not a function`);var Ec=An(jo.name||"unknownFunctionName",function(){});return Ec.prototype=jo.prototype,Ec=new Ec,(Fo=jo.apply(Ec,Fo))instanceof Object?Fo:Ec})(li)(...bi),le=`methodCaller<(${V.map(Fo=>Fo.name).join(", ")}) => ${_e.name}>`,pp(An(le,L))}function Bc(L){return L=gi(L>>>0),Oc(s[L])}function s_(L,V){return V>>>=0,L=bc(L>>>0),V=bc(V),Oc(L[V])}function E_(L){9<(L>>>=0)&&(Oi[L+1]+=1)}function ly(){return Oc([])}function F_(L){L=bc(L>>>0);for(var V=Array(L.length),le=0;le<L.length;le++)V[le]=L[le];return Oc(V)}function uy(L){return Oc(gi(L>>>0))}function cy(){return Oc({})}function dy(L){for(var V=bc(L>>>=0);V.length;){var le=V.pop();V.pop()(le)}Ro(L)}function py(L,V,le){V>>>=0,le>>>=0,L=bc(L>>>0),V=bc(V),le=bc(le),L[V]=le}function fy(L,V){return V>>>=0,L=(L=zo(L>>>0,"_emval_take_value")).readValueFromPointer(V),Oc(L)}function J_(L,V){L=-9007199254740992>L||9007199254740992<L?NaN:Number(L),V>>>=0,L=new Date(1e3*L),ue()[V>>>2>>>0]=L.getUTCSeconds(),ue()[V+4>>>2>>>0]=L.getUTCMinutes(),ue()[V+8>>>2>>>0]=L.getUTCHours(),ue()[V+12>>>2>>>0]=L.getUTCDate(),ue()[V+16>>>2>>>0]=L.getUTCMonth(),ue()[V+20>>>2>>>0]=L.getUTCFullYear()-1900,ue()[V+24>>>2>>>0]=L.getUTCDay(),L=(L.getTime()-Date.UTC(L.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,ue()[V+28>>>2>>>0]=L}var j0=L=>L%4==0&&(L%100!=0||L%400==0),U0=[0,31,60,91,121,152,182,213,244,274,305,335],V0=[0,31,59,90,120,151,181,212,243,273,304,334];function hy(L,V){L=-9007199254740992>L||9007199254740992<L?NaN:Number(L),V>>>=0,L=new Date(1e3*L),ue()[V>>>2>>>0]=L.getSeconds(),ue()[V+4>>>2>>>0]=L.getMinutes(),ue()[V+8>>>2>>>0]=L.getHours(),ue()[V+12>>>2>>>0]=L.getDate(),ue()[V+16>>>2>>>0]=L.getMonth(),ue()[V+20>>>2>>>0]=L.getFullYear()-1900,ue()[V+24>>>2>>>0]=L.getDay();var le=(j0(L.getFullYear())?U0:V0)[L.getMonth()]+L.getDate()-1|0;ue()[V+28>>>2>>>0]=le,ue()[V+36>>>2>>>0]=-60*L.getTimezoneOffset(),le=new Date(L.getFullYear(),6,1).getTimezoneOffset();var _e=new Date(L.getFullYear(),0,1).getTimezoneOffset();L=0|(le!=_e&&L.getTimezoneOffset()==Math.min(_e,le)),ue()[V+32>>>2>>>0]=L}function q1(L){L>>>=0;var V=new Date(ue()[L+20>>>2>>>0]+1900,ue()[L+16>>>2>>>0],ue()[L+12>>>2>>>0],ue()[L+8>>>2>>>0],ue()[L+4>>>2>>>0],ue()[L>>>2>>>0],0),le=ue()[L+32>>>2>>>0],_e=V.getTimezoneOffset(),De=new Date(V.getFullYear(),6,1).getTimezoneOffset(),mt=new Date(V.getFullYear(),0,1).getTimezoneOffset(),nr=Math.min(mt,De);return 0>le?ue()[L+32>>>2>>>0]=+(De!=mt&&nr==_e):0<le!=(nr==_e)&&(De=Math.max(mt,De),V.setTime(V.getTime()+6e4*((0<le?nr:De)-_e))),ue()[L+24>>>2>>>0]=V.getDay(),le=(j0(V.getFullYear())?U0:V0)[V.getMonth()]+V.getDate()-1|0,ue()[L+28>>>2>>>0]=le,ue()[L>>>2>>>0]=V.getSeconds(),ue()[L+4>>>2>>>0]=V.getMinutes(),ue()[L+8>>>2>>>0]=V.getHours(),ue()[L+12>>>2>>>0]=V.getDate(),ue()[L+16>>>2>>>0]=V.getMonth(),ue()[L+20>>>2>>>0]=V.getYear(),L=V.getTime(),BigInt(isNaN(L)?-1:L/1e3)}function H1(L,V,le,_e,De,mt,nr){return _?ai(16,1,L,V,le,_e,De,mt,nr):-52}function G0(L,V,le,_e,De,mt){if(_)return ai(17,1,L,V,le,_e,De,mt)}var zg={},K1=()=>performance.timeOrigin+performance.now();function W0(L,V){if(_)return ai(18,1,L,V);if(zg[L]&&(clearTimeout(zg[L].id),delete zg[L]),!V)return 0;var le=setTimeout(()=>{delete zg[L],$e(()=>J1(L,performance.timeOrigin+performance.now()))},V);return zg[L]={id:le,qc:V},0}function q0(L,V,le,_e){L>>>=0,V>>>=0,le>>>=0,_e>>>=0;var De=new Date().getFullYear(),mt=new Date(De,0,1).getTimezoneOffset();De=new Date(De,6,1).getTimezoneOffset();var nr=Math.max(mt,De);Ze()[L>>>2>>>0]=60*nr,ue()[V>>>2>>>0]=+(mt!=De),L=(V=li=>{var bi=Math.abs(li);return`UTC${0<=li?"-":"+"}${String(Math.floor(bi/60)).padStart(2,"0")}${String(bi%60).padStart(2,"0")}`})(mt),V=V(De),De<mt?(Qe(L,le,17),Qe(V,_e,17)):(Qe(L,_e,17),Qe(V,le,17))}var _y=()=>Date.now();function H0(L,V,le){return 0<=L&&3>=L?(L===0?L=Date.now():L=performance.timeOrigin+performance.now(),te[le>>>0>>>3]=BigInt(Math.round(1e6*L)),0):28}var K0=[],Y0=(L,V)=>{K0.length=0;for(var le;le=K()[L++>>>0];){var _e=le!=105;V+=(_e&=le!=112)&&V%8?4:0,K0.push(le==112?Ze()[V>>>2>>>0]:le==106?te[V>>>3]:le==105?ue()[V>>>2>>>0]:Gt()[V>>>3>>>0]),V+=_e?8:4}return K0};function X0(L,V,le){return L>>>=0,V=Y0(V>>>0,le>>>0),kn[L](...V)}function Q0(L,V,le){return L>>>=0,V=Y0(V>>>0,le>>>0),kn[L](...V)}var Y1=()=>{};function X1(L,V){return S(_c(L>>>0,V>>>0))}var Bg=()=>{throw ir+=1,"unwind"};function my(){return 4294901760}var Z0=()=>navigator.hardwareConcurrency;function J0(){return Tn("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function eb(L){L>>>=0;var V=K().length;if(L<=V||4294901760<L)return!1;for(var le=1;4>=le;le*=2){var _e=V*(1+.2/le);_e=Math.min(_e,L+100663296);e:{_e=(Math.min(4294901760,65536*Math.ceil(Math.max(L,_e)/65536))-T.buffer.byteLength+65535)/65536|0;try{T.grow(_e),hn();var De=1;break e}catch{}De=void 0}if(De)return!0}return!1}var jg=()=>(Tn("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),gg={},S_=L=>{L.forEach(V=>{jg()})};function gy(){var L=Error().stack.toString().split(`
`);return L[0]=="Error"&&L.shift(),S_(L),gg.Lb=jg(),gg.cc=L,gg.Lb}function Q1(L,V,le){if(L>>>=0,V>>>=0,gg.Lb==L)var _e=gg.cc;else(_e=Error().stack.toString().split(`
`))[0]=="Error"&&_e.shift(),S_(_e);for(var De=3;_e[De]&&jg()!=L;)++De;for(L=0;L<le&&_e[L+De];++L)ue()[V+4*L>>>2>>>0]=jg();return L}var l1,u1={},c1=()=>{if(!l1){var L,V={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(L in u1)u1[L]===void 0?delete V[L]:V[L]=u1[L];var le=[];for(L in V)le.push(`${L}=${V[L]}`);l1=le}return l1};function i_(L,V){if(_)return ai(19,1,L,V);L>>>=0,V>>>=0;var le=0;return c1().forEach((_e,De)=>{var mt=V+le;for(De=Ze()[L+4*De>>>2>>>0]=mt,mt=0;mt<_e.length;++mt)oe()[De++>>>0]=_e.charCodeAt(mt);oe()[De>>>0]=0,le+=_e.length+1}),0}function wg(L,V){if(_)return ai(20,1,L,V);L>>>=0,V>>>=0;var le=c1();Ze()[L>>>2>>>0]=le.length;var _e=0;return le.forEach(De=>_e+=De.length+1),Ze()[V>>>2>>>0]=_e,0}function by(L){return _?ai(21,1,L):52}function Ug(L,V,le,_e){return _?ai(22,1,L,V,le,_e):52}function tb(L,V,le,_e){return _?ai(23,1,L,V,le,_e):70}var nb=[null,[],[]];function Vg(L,V,le,_e){if(_)return ai(24,1,L,V,le,_e);V>>>=0,le>>>=0,_e>>>=0;for(var De=0,mt=0;mt<le;mt++){var nr=Ze()[V>>>2>>>0],li=Ze()[V+4>>>2>>>0];V+=8;for(var bi=0;bi<li;bi++){var Ai=K()[nr+bi>>>0],Fo=nb[L];Ai===0||Ai===10?((L===1?x:S)(Ri(Fo)),Fo.length=0):Fo.push(Ai)}De+=li}return Ze()[_e>>>2>>>0]=De,0}_||(function(){for(var L=s.numThreads-1;L--;)up();vn.unshift(()=>{ke++,(function(V){_?V():Promise.all(wi.map(Xc)).then(V)})(()=>In())})})();for(var d1=Array(256),Gg=0;256>Gg;++Gg)d1[Gg]=String.fromCharCode(Gg);pt=d1,Ot=s.BindingError=class extends Error{constructor(L){super(L),this.name="BindingError"}},s.InternalError=class extends Error{constructor(L){super(L),this.name="InternalError"}},Oi.push(0,1,void 0,1,null,1,!0,1,!1,1),s.count_emval_handles=()=>Oi.length/2-5-En.length;var Li,rb=[mi,fi,cp,Ui,Rp,ve,Ke,lt,_n,ar,vi,Pi,hi,Oo,we,it,H1,G0,W0,i_,wg,by,Ug,tb,Vg];(async function(){function L(_e,De){return Li=_e.exports,Li=(function(){var mt=Li,nr={};for(let[li,bi]of Object.entries(mt))nr[li]=typeof bi=="function"?(...Ai)=>{ep.push(li);try{return bi(...Ai)}finally{he||(ep.pop(),Mc&&Lc===1&&ep.length===0&&(Lc=0,ir+=1,Cc(P_),typeof Fibers<"u"&&Fibers.rc()))}}:bi;return nr})(),Li=(function(){var mt=Li,nr=bi=>Ai=>bi(Ai)>>>0,li=bi=>()=>bi()>>>0;return(mt=Object.assign({},mt)).Da=nr(mt.Da),mt.fb=li(mt.fb),mt.hb=nr(mt.hb),mt.tb=nr(mt.tb),mt.ub=li(mt.ub),mt.__cxa_get_exception_ptr=nr(mt.__cxa_get_exception_ptr),mt})(),zi.push(Li.ib),E=De,In(),Li}ke++;var V=cn();if(s.instantiateWasm)return new Promise(_e=>{s.instantiateWasm(V,(De,mt)=>{L(De,mt),_e(De.exports)})});if(_)return new Promise(_e=>{bn=De=>{var mt=new WebAssembly.Instance(De,cn());_e(L(mt,De))}});wt??=s.locateFile?s.locateFile?s.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL("/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href;try{var le=await(async function(_e){var De=wt;if(!H&&typeof WebAssembly.instantiateStreaming=="function"&&!Ce(De))try{var mt=fetch(De,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(mt,_e)}catch(nr){S(`wasm streaming compile failed: ${nr}`),S("falling back to ArrayBuffer instantiation")}return(async function(nr,li){try{var bi=await(async function(Ai){if(!H)try{var Fo=await i(Ai);return new Uint8Array(Fo)}catch{}if(Ai==wt&&H)Ai=new Uint8Array(H);else{if(!r)throw"both async and sync fetching of the wasm failed";Ai=r(Ai)}return Ai})(nr);return await WebAssembly.instantiate(bi,li)}catch(Ai){S(`failed to asynchronously prepare wasm: ${Ai}`),Tn(Ai)}})(De,_e)})(V);return L(le.instance,le.module)}catch(_e){return t(_e),Promise.reject(_e)}})();var sb=L=>(sb=Li.Da)(L),p1=()=>(p1=Li.Ea)();s._OrtInit=(L,V)=>(s._OrtInit=Li.Fa)(L,V),s._OrtGetLastError=(L,V)=>(s._OrtGetLastError=Li.Ga)(L,V),s._OrtCreateSessionOptions=(L,V,le,_e,De,mt,nr,li,bi,Ai)=>(s._OrtCreateSessionOptions=Li.Ha)(L,V,le,_e,De,mt,nr,li,bi,Ai),s._OrtAppendExecutionProvider=(L,V,le,_e,De)=>(s._OrtAppendExecutionProvider=Li.Ia)(L,V,le,_e,De),s._OrtAddFreeDimensionOverride=(L,V,le)=>(s._OrtAddFreeDimensionOverride=Li.Ja)(L,V,le),s._OrtAddSessionConfigEntry=(L,V,le)=>(s._OrtAddSessionConfigEntry=Li.Ka)(L,V,le),s._OrtReleaseSessionOptions=L=>(s._OrtReleaseSessionOptions=Li.La)(L),s._OrtCreateSession=(L,V,le)=>(s._OrtCreateSession=Li.Ma)(L,V,le),s._OrtReleaseSession=L=>(s._OrtReleaseSession=Li.Na)(L),s._OrtGetInputOutputCount=(L,V,le)=>(s._OrtGetInputOutputCount=Li.Oa)(L,V,le),s._OrtGetInputOutputMetadata=(L,V,le,_e)=>(s._OrtGetInputOutputMetadata=Li.Pa)(L,V,le,_e),s._OrtFree=L=>(s._OrtFree=Li.Qa)(L),s._OrtCreateTensor=(L,V,le,_e,De,mt)=>(s._OrtCreateTensor=Li.Ra)(L,V,le,_e,De,mt),s._OrtGetTensorData=(L,V,le,_e,De)=>(s._OrtGetTensorData=Li.Sa)(L,V,le,_e,De),s._OrtReleaseTensor=L=>(s._OrtReleaseTensor=Li.Ta)(L),s._OrtCreateRunOptions=(L,V,le,_e)=>(s._OrtCreateRunOptions=Li.Ua)(L,V,le,_e),s._OrtAddRunConfigEntry=(L,V,le)=>(s._OrtAddRunConfigEntry=Li.Va)(L,V,le),s._OrtReleaseRunOptions=L=>(s._OrtReleaseRunOptions=Li.Wa)(L),s._OrtCreateBinding=L=>(s._OrtCreateBinding=Li.Xa)(L),s._OrtBindInput=(L,V,le)=>(s._OrtBindInput=Li.Ya)(L,V,le),s._OrtBindOutput=(L,V,le,_e)=>(s._OrtBindOutput=Li.Za)(L,V,le,_e),s._OrtClearBoundOutputs=L=>(s._OrtClearBoundOutputs=Li._a)(L),s._OrtReleaseBinding=L=>(s._OrtReleaseBinding=Li.$a)(L),s._OrtRunWithBinding=(L,V,le,_e,De)=>(s._OrtRunWithBinding=Li.ab)(L,V,le,_e,De),s._OrtRun=(L,V,le,_e,De,mt,nr,li)=>(s._OrtRun=Li.bb)(L,V,le,_e,De,mt,nr,li),s._OrtEndProfiling=L=>(s._OrtEndProfiling=Li.cb)(L),s._JsepOutput=(L,V,le)=>(s._JsepOutput=Li.db)(L,V,le),s._JsepGetNodeName=L=>(s._JsepGetNodeName=Li.eb)(L);var f1=()=>(f1=Li.fb)(),f_=s._free=L=>(f_=s._free=Li.gb)(L),h1=s._malloc=L=>(h1=s._malloc=Li.hb)(L),Tp=(L,V,le,_e,De,mt)=>(Tp=Li.kb)(L,V,le,_e,De,mt),xg=()=>(xg=Li.lb)(),Z1=(L,V,le,_e,De)=>(Z1=Li.mb)(L,V,le,_e,De),_1=L=>(_1=Li.nb)(L),m1=L=>(m1=Li.ob)(L),J1=(L,V)=>(J1=Li.pb)(L,V),Wg=()=>(Wg=Li.qb)(),ib=(L,V)=>(ib=Li.rb)(L,V),b_=L=>(b_=Li.sb)(L),vg=L=>(vg=Li.tb)(L),N_=()=>(N_=Li.ub)(),g1=s.dynCall_ii=(L,V)=>(g1=s.dynCall_ii=Li.vb)(L,V),b1=L=>(b1=Li.wb)(L),P_=()=>(P_=Li.xb)(),R_=L=>(R_=Li.yb)(L),qg=()=>(qg=Li.zb)();return s.stackSave=()=>N_(),s.stackRestore=L=>b_(L),s.stackAlloc=L=>vg(L),s.setValue=function(L,V,le="i8"){switch(le.endsWith("*")&&(le="*"),le){case"i1":case"i8":oe()[L>>>0]=V;break;case"i16":Q()[L>>>1>>>0]=V;break;case"i32":ue()[L>>>2>>>0]=V;break;case"i64":te[L>>>3]=BigInt(V);break;case"float":Pt()[L>>>2>>>0]=V;break;case"double":Gt()[L>>>3>>>0]=V;break;case"*":Ze()[L>>>2>>>0]=V;break;default:Tn(`invalid type for setValue: ${le}`)}},s.getValue=function(L,V="i8"){switch(V.endsWith("*")&&(V="*"),V){case"i1":case"i8":return oe()[L>>>0];case"i16":return Q()[L>>>1>>>0];case"i32":return ue()[L>>>2>>>0];case"i64":return te[L>>>3];case"float":return Pt()[L>>>2>>>0];case"double":return Gt()[L>>>3>>>0];case"*":return Ze()[L>>>2>>>0];default:Tn(`invalid type for getValue: ${V}`)}},s.UTF8ToString=_c,s.stringToUTF8=Qe,s.lengthBytesUTF8=W,(function L(){if(0<ke)Bt=L;else if(_)e(s),ze();else{for(;0<vn.length;)vn.shift()(s);0<ke?Bt=L:(s.calledRun=!0,he||(ze(),e(s)))}})(),s.PTR_SIZE=4,a}),Fp=Sa,qp=globalThis.self?.name?.startsWith("em-pthread"),qp&&Sa()}),Ea,Gn,jp,Ue,ka,Ln,Kp,Zp,Pa,Qp,Ca,za,Aa,Oa,_r=U(()=>{yr(),Ea=typeof location>"u"?void 0:location.origin,Gn=import.meta.url>"file:"&&import.meta.url<"file;",jp=()=>{{if(Gn){let n=URL;return new URL(new n("ort.bundle.min.mjs",import.meta.url).href,Ea).href}return import.meta.url}},Ue=jp(),ka=()=>{if(Ue&&!Ue.startsWith("blob:"))return Ue.substring(0,Ue.lastIndexOf("/")+1)},Ln=(n,e)=>{try{let t=e??Ue;return(t?new URL(n,t):new URL(n)).origin===Ea}catch{return!1}},Kp=(n,e)=>{let t=e??Ue;try{return(t?new URL(n,t):new URL(n)).href}catch{return}},Zp=(n,e)=>`${e??"./"}${n}`,Pa=async n=>{let e=await(await fetch(n,{credentials:"same-origin"})).blob();return URL.createObjectURL(e)},Qp=async n=>(await import(n)).default,Ca=(xa(),Ft($a)).default,za=async()=>{if(!Ue)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ln(Ue))return[void 0,Ca()];let n=await Pa(Ue);return[n,Ca(n)]},Aa=(Ia(),Ft(Ta)).default,Oa=async(n,e,t)=>{if(!n&&!e&&Aa&&Ue&&Ln(Ue))return[void 0,Aa];{let s="ort-wasm-simd-threaded.jsep.mjs",a=n??Kp(s,e),c=t&&a&&!Ln(a,e),l=c?await Pa(a):a??Zp(s,e);return[c?l:void 0,await Qp(l)]}}}),Hn,Fn,Ar,Ba,Yp,Xp,Jp,wr,fe,ht=U(()=>{_r(),Fn=!1,Ar=!1,Ba=!1,Yp=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Xp=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Jp=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},wr=async n=>{if(Fn)return Promise.resolve();if(Ar)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ba)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ar=!0;let e=n.initTimeout,t=n.numThreads;if(n.simd!==!1){if(n.simd==="relaxed"){if(!Jp())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!Xp())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let s=Yp();t>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+t+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),n.numThreads=t=1);let a=n.wasmPaths,c=typeof a=="string"?a:void 0,l=a?.mjs,_=l?.href??l,m=a?.wasm,d=m?.href??m,h=n.wasmBinary,[i,r]=await Oa(_,c,t>1),u=!1,f=[];if(e>0&&f.push(new Promise(g=>{setTimeout(()=>{u=!0,g()},e)})),f.push(new Promise((g,w)=>{let y={numThreads:t};if(h)y.wasmBinary=h;else if(d||c)y.locateFile=x=>d??c+x;else if(_&&_.indexOf("blob:")!==0)y.locateFile=x=>new URL(x,_).href;else if(i){let x=ka();x&&(y.locateFile=S=>x+S)}r(y).then(x=>{Ar=!1,Fn=!0,Hn=x,g(),i&&URL.revokeObjectURL(i)},x=>{Ar=!1,Ba=!0,w(x)})})),await Promise.race(f),u)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},fe=()=>{if(Fn&&Hn)return Hn;throw new Error("WebAssembly is not initialized yet.")}}),Ne,Kt,pe,Er=U(()=>{ht(),Ne=(n,e)=>{let t=fe(),s=t.lengthBytesUTF8(n)+1,a=t._malloc(s);return t.stringToUTF8(n,a,s),e.push(a),a},Kt=(n,e,t,s)=>{if(typeof n=="object"&&n!==null){if(t.has(n))throw new Error("Circular reference in options");t.add(n)}Object.entries(n).forEach(([a,c])=>{let l=e?e+a:a;if(typeof c=="object")Kt(c,l+".",t,s);else if(typeof c=="string"||typeof c=="number")s(l,c.toString());else if(typeof c=="boolean")s(l,c?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof c}`)})},pe=n=>{let e=fe(),t=e.stackSave();try{let s=e.PTR_SIZE,a=e.stackAlloc(2*s);e._OrtGetLastError(a,a+s);let c=Number(e.getValue(a,s===4?"i32":"i64")),l=e.getValue(a+s,"*"),_=l?e.UTF8ToString(l):"";throw new Error(`${n} ERROR_CODE: ${c}, ERROR_MESSAGE: ${_}`)}finally{e.stackRestore(t)}}}),Da,Ma=U(()=>{ht(),Er(),Da=n=>{let e=fe(),t=0,s=[],a=n||{};try{if(n?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof n.logSeverityLevel!="number"||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if(n?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof n.logVerbosityLevel!="number"||!Number.isInteger(n.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);n?.terminate===void 0&&(a.terminate=!1);let c=0;return n?.tag!==void 0&&(c=Ne(n.tag,s)),t=e._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,c),t===0&&pe("Can't create run options."),n?.extra!==void 0&&Kt(n.extra,"",new WeakSet,(l,_)=>{let m=Ne(l,s),d=Ne(_,s);e._OrtAddRunConfigEntry(t,m,d)!==0&&pe(`Can't set a run config entry: ${l} - ${_}.`)}),[t,s]}catch(c){throw t!==0&&e._OrtReleaseRunOptions(t),s.forEach(l=>e._free(l)),c}}}),em,tm,rm,kr,nm,Ra,Ua=U(()=>{ht(),Er(),em=n=>{switch(n){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${n}`)}},tm=n=>{switch(n){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${n}`)}},rm=n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});let e=n.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),n.executionProviders&&n.executionProviders.some(t=>(typeof t=="string"?t:t.name)==="webgpu")&&(n.enableMemPattern=!1)},kr=(n,e,t,s)=>{let a=Ne(e,s),c=Ne(t,s);fe()._OrtAddSessionConfigEntry(n,a,c)!==0&&pe(`Can't set a session config entry: ${e} - ${t}.`)},nm=async(n,e,t)=>{for(let s of e){let a=typeof s=="string"?s:s.name,c=[];switch(a){case"webnn":if(a="WEBNN",typeof s!="string"){let h=s?.deviceType;h&&kr(n,"deviceType",h,t)}break;case"webgpu":if(a="JS",typeof s!="string"){let h=s;if(h?.preferredLayout){if(h.preferredLayout!=="NCHW"&&h.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${h.preferredLayout}`);kr(n,"preferredLayout",h.preferredLayout,t)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let l=Ne(a,t),_=c.length,m=0,d=0;if(_>0){m=fe()._malloc(_*fe().PTR_SIZE),t.push(m),d=fe()._malloc(_*fe().PTR_SIZE),t.push(d);for(let h=0;h<_;h++)fe().setValue(m+h*fe().PTR_SIZE,c[h][0],"*"),fe().setValue(d+h*fe().PTR_SIZE,c[h][1],"*")}await fe()._OrtAppendExecutionProvider(n,l,m,d,_)!==0&&pe(`Can't append execution provider: ${a}.`)}},Ra=async n=>{let e=fe(),t=0,s=[],a=n||{};rm(a);try{let c=em(a.graphOptimizationLevel??"all"),l=tm(a.executionMode??"sequential"),_=typeof a.logId=="string"?Ne(a.logId,s):0,m=a.logSeverityLevel??2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);let d=a.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let h=typeof a.optimizedModelFilePath=="string"?Ne(a.optimizedModelFilePath,s):0;if(t=e._OrtCreateSessionOptions(c,!!a.enableCpuMemArena,!!a.enableMemPattern,l,!!a.enableProfiling,0,_,m,d,h),t===0&&pe("Can't create session options."),a.executionProviders&&await nm(t,a.executionProviders,s),a.enableGraphCapture!==void 0){if(typeof a.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${a.enableGraphCapture}`);kr(t,"enableGraphCapture",a.enableGraphCapture.toString(),s)}if(a.freeDimensionOverrides)for(let[i,r]of Object.entries(a.freeDimensionOverrides)){if(typeof i!="string")throw new Error(`free dimension override name must be a string: ${i}`);if(typeof r!="number"||!Number.isInteger(r)||r<0)throw new Error(`free dimension override value must be a non-negative integer: ${r}`);let u=Ne(i,s);e._OrtAddFreeDimensionOverride(t,u,r)!==0&&pe(`Can't set a free dimension override: ${i} - ${r}.`)}return a.extra!==void 0&&Kt(a.extra,"",new WeakSet,(i,r)=>{kr(t,i,r,s)}),[t,s]}catch(c){throw t!==0&&e._OrtReleaseSessionOptions(t)!==0&&pe("Can't release session options."),s.forEach(l=>e._free(l)),c}}}),Mt,Ye,gt,Pr,Zt,zr,Or,qn,ee=U(()=>{Mt=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${n}`)}},Ye=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${n}`)}},gt=(n,e)=>{let t=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][n],s=typeof e=="number"?e:e.reduce((a,c)=>a*c,1);return t>0?Math.ceil(s*t):void 0},Pr=n=>{switch(n){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${n}`)}},Zt=n=>{switch(n){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${n}`)}},zr=n=>n==="float32"||n==="float16"||n==="int32"||n==="int64"||n==="uint32"||n==="uint8"||n==="bool"||n==="uint4"||n==="int4",Or=n=>n==="float32"||n==="float16"||n==="int32"||n==="int64"||n==="uint32"||n==="uint64"||n==="int8"||n==="uint8"||n==="bool"||n==="uint4"||n==="int4",qn=n=>{switch(n){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${n}`)}}}),Qt,jn=U(()=>{yr(),Qt=async n=>{if(typeof n=="string"){let e=await fetch(n);if(!e.ok)throw new Error(`failed to load external data file: ${n}`);let t=e.headers.get("Content-Length"),s=t?parseInt(t,10):0;if(s<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${n}, no response body.`);let a=e.body.getReader(),c;try{c=new ArrayBuffer(s)}catch(_){if(_ instanceof RangeError){let m=Math.ceil(s/65536);c=new WebAssembly.Memory({initial:m,maximum:m}).buffer}else throw _}let l=0;for(;;){let{done:_,value:m}=await a.read();if(_)break;let d=m.byteLength;new Uint8Array(c,l,d).set(m),l+=d}return new Uint8Array(c,0,s)}}else return n instanceof Blob?new Uint8Array(await n.arrayBuffer()):n instanceof Uint8Array?n:new Uint8Array(n)}}),om,im,Na,Va,Br,am,se,Xe=U(()=>{ee(),om=["V","I","W","E","F"],im=(n,e)=>{console.log(`[${om[n]},${new Date().toISOString()}]${e}`)},Br=(n,e)=>{Na=n,Va=e},am=(n,e)=>{let t=Zt(n),s=Zt(Na);t>=s&&im(t,typeof e=="function"?e():e)},se=(...n)=>{Va&&am(...n)}}),Kn,Je,k,Tt,Dr,Wa,La,ne=U(()=>{Kn=class{static calcMatMulShape(n,e){return n[1]!==e[0]?void 0:[n[0],e[1]]}},Je=class{static calcShape(n,e,t=!1){let s=n.length,a=e.length;if(s===0)return e;if(a===0)return n;let c=Math.max(n.length,e.length),l=new Array(c);if(t){if(s<2||a<2)return;let _=Kn.calcMatMulShape([n[s-2],n[s-1]],[e[a-2],e[a-1]]);if(_===void 0)return;[l[c-2],l[c-1]]=_}for(let _=t?3:1;_<=c;_++){let m=s-_<0?1:n[s-_],d=a-_<0?1:e[a-_];if(m!==d&&m>1&&d>1)return;let h=Math.max(m,d);if(m&&d)l[c-_]=Math.max(m,d);else{if(h>1)return;l[c-_]=0}}return l}static isValidBroadcast(n,e){let t=n.length,s=e.length;if(t>s)return!1;for(let a=1;a<=t;a++)if(n[t-a]!==1&&n[t-a]!==e[s-a])return!1;return!0}},k=class vv{static size(e){return vv.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,t=4){let s=e.length;if(s===0)return[];let a=new Array(s),c=s-1;for(;c>=0;){if(e[c]%t===0){a[c]=e[c]/t;break}if(t%e[c]!==0)throw new Error("cannot convert shape");a[c]=1,t/=e[c],c--}for(c--;c>=0;c--)a[c]=e[c];return a}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return vv.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return vv.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,s){let a=1;for(let c=t;c<s;c++){if(e[c]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=Number(e[c])}return a}static computeStrides(e){let t=e.length;if(t===0)return[];if(t===1)return[1];let s=new Array(t);s[t-1]=1,s[t-2]=e[t-1];for(let a=t-3;a>=0;--a)s[a]=s[a+1]*e[a+1];return s}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(s=>this.normalizeAxis(s,t??e.length))}static sortBasedOnPerm(e,t){return t?t.map(s=>e[s]):e.slice().reverse()}static padShape(e,t){let s=e.length;return e.map((a,c)=>a+t[c]+t[c+s])}static areEqual(e,t){return e.length!==t.length?!1:e.every((s,a)=>s===t[a])}},Tt=class Ex{static adjustPoolAttributes(e,t,s,a,c,l){if(!e&&s.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let _=0;_<t.length-2;_++)_>=s.length?s.push(t[_+2]):s[_]=t[_+2];for(let _=0;_<s.length;_++)if(_<a.length){if(a[_]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let _=0;_<s.length;_++)if(_<c.length){if(c[_]<0)throw new Error("dilations should be greater than or equal to 1")}else c.push(1);for(let _=0;_<s.length*2;_++)if(_<l.length){if(l[_]<0)throw new Error("pad should be greater than or equal to 1")}else l.push(0);for(let _=0;_<s.length;_++){if(s[_]<=0)throw new Error("kernel shapes need to be greater than 0");if(l[_]>=s[_]||l[_+s.length]>=s[_])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,s,a,c,l,_){if(_){if(c.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let m=0;m<e.length-2;m++)Ex.adjustPadAndReturnShape(e[m+(l?1:2)],t[m],s[m],a[m],c,m,m+e.length-2,_)}}static computePoolOutputShape(e,t,s,a,c,l,_){if(t.length<=0)throw new Error("input shape must be of size greater than 0");let m=[t[0],t[1]];return Ex.computeShapeHelper(e,t,m,s,a,c,l,_),m}static computeConvOutputShape(e,t,s,a,c,l,_){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let m=[e[0],t[0]];return Ex.computeShapeHelper(!1,e,m,s,a,c,l,_),m}static computeShapeHelper(e,t,s,a,c,l,_,m){if(e)for(let d=0;d<t.length-2;d++)s.push(1);else for(let d=0;d<t.length-2;d++)s.push(Ex.adjustPadAndReturnShape(t[d+2],a[d],c[d],l[d],_,d,d+t.length-2,m))}static adjustPadAndReturnShape(e,t,s,a,c,l,_,m){let d=s*(a-1)+1;if(m&&m!=="NOTSET")switch(m){case"VALID":return c[l]=0,c[_]=0,Math.floor((e-d)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let h=((e+t-1)/t-1)*t+a-e;return c[l]=Math.floor(m==="SAME_LOWER"?(h+1)/2:h/2),c[_]=h-c[l],Math.floor((e+h-a)/t+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+c[l]+c[_]-d)/t+1)}},Dr=class{static getShapeOfGemmResult(n,e,t,s,a){if(n.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let c,l,_;e?(c=n[1],l=n[0]):(c=n[0],l=n[1]);let m=-1;if(s?(_=t[0],m=1):(_=t[1],m=0),t[m]!==l)throw new Error("dimension mismatch");if(c<=0||_<=0||l<=0)throw new Error("invalid shape specified");if(a&&!Je.isValidBroadcast(a,[c,_]))throw new Error("gemm: invalid bias shape for broadcast");return[c,_,l]}},Wa=-34028234663852886e22,La=34028234663852886e22}),Mr,Zn=U(()=>{ee(),Mr=(n,e)=>new(Pr(e))(n)}),Yn,Ha,sm,Ga,um,Fa,Rr,Ur,Qn,qa,ja=U(()=>{Xe(),Yn=(n,e=!0)=>{if(n.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let t=n.byteLength/8,s=new BigInt64Array(n.buffer,n.byteOffset,t),a=new Int32Array(t);for(let c=0;c<t;c++){let l=s[c];if(l>2147483647n||l<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${c}: ${l}`);a[c]=Number(l)}return e?new Uint8Array(a.buffer):a},Ha=(n,e=!0)=>{if(n.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let t=n.byteLength/4,s=new Int32Array(n.buffer,n.byteOffset,t),a=BigInt64Array.from(s,BigInt);return e?new Uint8Array(a.buffer):a},sm=1,Ga=()=>sm++,um=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Fa=(n,e)=>{let t=um.get(n);if(!t)throw new Error("Unsupported data type.");return e.length>0?Math.ceil(e.reduce((s,a)=>s*a)*t/8):0},Rr=class{constructor(n){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:e,context:t,tensor:s,dataType:a,shape:c,shouldConvertInt64toInt32:l=!1}=n;this.sessionId=e,this.mlContext=t,this.mlTensor=s,this.dataType=a,this.tensorShape=c,this.shouldConvertInt64toInt32=l}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Fa(this.dataType,this.tensorShape)}destroy(){se("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(n){this.mlContext.writeTensor(this.mlTensor,n)}async read(n,e){if(n){let t=await this.mlContext.readTensor(this.mlTensor),s=Ha(new Uint8Array(t));if(e){(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(s);return}else return s.buffer}else return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(n,e,t){return this.mlContext===n&&this.dataType===e&&this.tensorShape.length===t.length&&this.tensorShape.every((s,a)=>s===t[a])}setIsInt64ToInt32Converted(n){this.isInt64ToInt32Converted=n}},Ur=class{constructor(n,e){this.tensorManager=n,this.wrapper=e}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(n,e,t,s){let a=e,c=this.tensorManager.getMLContext(n),l=a==="int64"&&!c.opSupportLimits().input.dataTypes.includes("int64");if(l&&(a="int32",se("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(c,a,t))return this.wrapper.tensor;if(s){if(this.wrapper.byteLength!==Fa(a,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let _=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(n,a,t,_,!0,!0,l),s&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(n){let e=n;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(e=Yn(n,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),e.byteLength===this.wrapper.byteLength){this.wrapper.write(e);return}else se("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(n){if(this.activeUpload){let e=this.wrapper?.isInt64ToInt32Converted?Ha(this.activeUpload):this.activeUpload;if(n){n instanceof ArrayBuffer?new Uint8Array(n).set(e):new Uint8Array(n.buffer,n.byteOffset,n.byteLength).set(e);return}else return e.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return n?this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32,n):this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32)}},Qn=class{constructor(n){this.backend=n,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(n){let e=this.backend.getMLContext(n);if(!e)throw new Error("MLContext not found for session.");return e}reserveTensorId(){let n=Ga();return this.tensorTrackersById.set(n,new Ur(this)),n}releaseTensorId(n){let e=this.tensorTrackersById.get(n);e&&(this.tensorTrackersById.delete(n),e.tensorWrapper&&this.releaseTensor(e.tensorWrapper))}async ensureTensor(n,e,t,s,a){se("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${s}, copyOld: ${a}}`);let c=this.tensorTrackersById.get(e);if(!c)throw new Error("Tensor not found.");return c.ensureTensor(n,t,s,a)}upload(n,e){let t=this.tensorTrackersById.get(n);if(!t)throw new Error("Tensor not found.");t.upload(e)}async download(n,e){se("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${n}, dstBuffer: ${e?.byteLength}}`);let t=this.tensorTrackersById.get(n);if(!t)throw new Error("Tensor not found.");return t.download(e)}releaseTensorsForSession(n){for(let e of this.freeTensors)e.sessionId===n&&e.destroy();this.freeTensors=this.freeTensors.filter(e=>e.sessionId!==n)}registerTensor(n,e,t,s){let a=this.getMLContext(n),c=Ga(),l=new Rr({sessionId:n,context:a,tensor:e,dataType:t,shape:s});return this.tensorTrackersById.set(c,new Ur(this,l)),this.externalTensors.add(l),c}async getCachedTensor(n,e,t,s,a,c,l=!1){let _=this.getMLContext(n);for(let[d,h]of this.freeTensors.entries())if(h.canReuseTensor(_,e,t)){se("verbose",()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${t}}`);let i=this.freeTensors.splice(d,1)[0];return i.sessionId=n,i}se("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`);let m=await _.createTensor({dataType:e,shape:t,dimensions:t,usage:s,writable:a,readable:c});return new Rr({sessionId:n,context:_,tensor:m,dataType:e,shape:t,shouldConvertInt64toInt32:l})}releaseTensor(n){this.externalTensors.has(n)&&this.externalTensors.delete(n),this.freeTensors.push(n)}},qa=(...n)=>new Qn(...n)}),Xn,dm,Nr,Ka=U(()=>{ee(),ht(),Zn(),ja(),Xe(),Xn=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),dm=(n,e)=>{if(n===e)return!0;if(n===void 0||e===void 0)return!1;let t=Object.keys(n).sort(),s=Object.keys(e).sort();return t.length===s.length&&t.every((a,c)=>a===s[c]&&n[a]===e[a])},Nr=class{constructor(n){this.tensorManager=qa(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Br(n.logLevel,!!n.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(n){se("verbose",()=>`[WebNN] onRunStart {sessionId: ${n}}`),this.activeSessionId=n}onRunEnd(n){se("verbose",()=>`[WebNN] onRunEnd {sessionId: ${n}}`);let e=this.temporarySessionTensorIds.get(n);if(e){for(let t of e)se("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t);this.temporarySessionTensorIds.delete(n),this.activeSessionId=void 0}}async createMLContext(n){if(n instanceof GPUDevice){let t=this.mlContextCache.findIndex(s=>s.gpuDevice===n);if(t!==-1)return this.mlContextCache[t].mlContext;{let s=await navigator.ml.createContext(n);return this.mlContextCache.push({gpuDevice:n,mlContext:s}),s}}else if(n===void 0){let t=this.mlContextCache.findIndex(s=>s.options===void 0&&s.gpuDevice===void 0);if(t!==-1)return this.mlContextCache[t].mlContext;{let s=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:s}),s}}let e=this.mlContextCache.findIndex(t=>dm(t.options,n));if(e!==-1)return this.mlContextCache[e].mlContext;{let t=await navigator.ml.createContext(n);return this.mlContextCache.push({options:n,mlContext:t}),t}}registerMLContext(n,e){this.mlContextBySessionId.set(n,e);let t=this.sessionIdsByMLContext.get(e);t||(t=new Set,this.sessionIdsByMLContext.set(e,t)),t.add(n),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(n,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(n){this.sessionGraphInputs.delete(n);let e=this.mlContextBySessionId.get(n);if(!e)return;this.tensorManager.releaseTensorsForSession(n),this.mlContextBySessionId.delete(n);let t=this.sessionIdsByMLContext.get(e);if(t.delete(n),t.size===0){this.sessionIdsByMLContext.delete(e);let s=this.mlContextCache.findIndex(a=>a.mlContext===e);s!==-1&&this.mlContextCache.splice(s,1)}}getMLContext(n){return this.mlContextBySessionId.get(n)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(n){se("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n)}async ensureTensor(n,e,t,s,a){let c=Xn.get(t);if(!c)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(n??this.currentSessionId,e,c,s,a)}async createTemporaryTensor(n,e,t){se("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${t}}`);let s=Xn.get(e);if(!s)throw new Error(`Unsupported ONNX data type: ${e}`);let a=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(n,a,s,t,!1);let c=this.temporarySessionTensorIds.get(n);return c?c.push(a):this.temporarySessionTensorIds.set(n,[a]),a}uploadTensor(n,e){if(!fe().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");se("verbose",()=>`[WebNN] uploadTensor {tensorId: ${n}, data: ${e.byteLength}}`),this.tensorManager.upload(n,e)}async downloadTensor(n,e){return this.tensorManager.download(n,e)}createMLTensorDownloader(n,e){return async()=>{let t=await this.tensorManager.download(n);return Mr(t,e)}}registerMLTensor(n,e,t,s){let a=Xn.get(t);if(!a)throw new Error(`Unsupported ONNX data type: ${t}`);let c=this.tensorManager.registerTensor(n,e,a,s);return se("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${a}, dimensions: ${s}} -> {tensorId: ${c}}`),c}registerMLConstant(n,e,t,s,a,c,l=!1){if(!c)throw new Error("External mounted files are not available.");let _=n;n.startsWith("./")&&(_=n.substring(2));let m=c.get(_);if(!m)throw new Error(`File with name ${_} not found in preloaded files.`);if(e+t>m.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let d=m.slice(e,e+t).buffer,h;switch(a.dataType){case"float32":h=new Float32Array(d);break;case"float16":h=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":h=new Int32Array(d);break;case"uint32":h=new Uint32Array(d);break;case"int64":l?(h=Yn(new Uint8Array(d),!1),a.dataType="int32"):h=new BigInt64Array(d);break;case"uint64":h=new BigUint64Array(d);break;case"int8":h=new Int8Array(d);break;case"int4":case"uint4":case"uint8":h=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${a.dataType} in creating WebNN Constant from external data.`)}return se("verbose",()=>`[WebNN] registerMLConstant {dataType: ${a.dataType}, shape: ${a.shape}}} ${l?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),s.constant(a,h)}registerGraphInput(n){this.temporaryGraphInputs.push(n)}isGraphInput(n,e){let t=this.sessionGraphInputs.get(n);return t?t.includes(e):!1}isInt64Supported(n){return!!this.mlContextBySessionId.get(n)?.opSupportLimits().input.dataTypes.includes("int64")}flush(){}}}),Vr=U(()=>{}),Za,Jn,eo,lm,cm,Qa,ro,to,Xa,Ja=U(()=>{Xe(),Vr(),Za=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Jn=[],eo=n=>Math.ceil(Number(n)/16)*16,lm=n=>{for(let e=0;e<Jn.length;e++){let t=Jn[e];if(n<=t)return t}return Math.ceil(n/16)*16},cm=1,Qa=()=>cm++,ro=async(n,e,t,s)=>{let a=eo(t),c=n.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let l=n.getCommandEncoder();n.endComputePass(),l.copyBufferToBuffer(e,0,c,0,a),n.flush(),await c.mapAsync(GPUMapMode.READ);let _=c.getMappedRange();if(s){let m=s();return m.set(new Uint8Array(_,0,t)),m}else return new Uint8Array(_.slice(0,t))}finally{c.destroy()}},to=class{constructor(n){this.backend=n,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Za)Jn.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(n,e){let t=e.buffer,s=e.byteOffset,a=e.byteLength,c=eo(a),l=this.storageCache.get(n);if(!l)throw new Error("gpu data for uploading does not exist");if(Number(l.originalSize)!==a)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${a}`);let _=this.backend.device.createBuffer({mappedAtCreation:!0,size:c,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=_.getMappedRange();new Uint8Array(m).set(new Uint8Array(t,s,a)),_.unmap();let d=this.backend.device.createCommandEncoder();d.copyBufferToBuffer(_,0,l.gpuData.buffer,0,c),this.backend.device.queue.submit([d.finish()]),_.destroy(),se("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${n})`)}memcpy(n,e){let t=this.storageCache.get(n);if(!t)throw new Error("source gpu data for memcpy does not exist");let s=this.storageCache.get(e);if(!s)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==s.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=eo(t.originalSize),c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(t.gpuData.buffer,0,s.gpuData.buffer,0,a)}registerExternalBuffer(n,e,t){let s;if(t){if(s=t[0],n===t[1])return se("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, buffer is the same, skip.`),s;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else s=Qa();return this.storageCache.set(s,{gpuData:{id:s,type:0,buffer:n},originalSize:e}),se("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, registered.`),s}unregisterExternalBuffer(n){n!==void 0&&(this.storageCache.delete(n),se("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${n}`))}create(n,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=lm(n),s,a=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,c=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||c){let _=(a?this.freeBuffers:this.freeUniformBuffers).get(t);_?_.length>0?s=_.pop():s=this.backend.device.createBuffer({size:t,usage:e}):s=this.backend.device.createBuffer({size:t,usage:e})}else s=this.backend.device.createBuffer({size:t,usage:e});let l={id:Qa(),type:0,buffer:s};return this.storageCache.set(l.id,{gpuData:l,originalSize:Number(n)}),se("verbose",()=>`[WebGPU] GpuDataManager.create(size=${n}) => id=${l.id}`),l}get(n){return this.storageCache.get(n)?.gpuData}release(n){let e=typeof n=="bigint"?Number(n):n,t=this.storageCache.get(e);if(!t){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return se("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(n,e){let t=this.storageCache.get(Number(n));if(!t)throw new Error("data does not exist");await ro(this.backend,t.gpuData.buffer,t.originalSize,e)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let n of this.buffersPending){let e=Za.get(n.size);if((n.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let t=this.freeBuffers.get(n.size)||[];e===void 0||t.length>=e?n.destroy():t.push(n)}else if((n.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let t=this.freeUniformBuffers.get(n.size)||[];e===void 0||t.length>=e?n.destroy():t.push(n)}else n.destroy()}this.buffersPending=[]}else{let n=this.capturedPendingBuffers.get(this.backend.currentSessionId);n||(n=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,n));for(let e of this.buffersPending)n.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(n=>{n.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(n=>{n.forEach(e=>{e.destroy()})}),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(n=>{n.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(n){let e=this.capturedPendingBuffers.get(n);e&&(e.forEach(t=>{t.destroy()}),this.capturedPendingBuffers.delete(n)),this.sessionCount-=1,this.sessionCount===0&&(se("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Xa=(...n)=>new to(...n)}),no,J,Se=U(()=>{no=class{constructor(n){Object.assign(this,n)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(n=>`${this[n]}`).join(";")),this.key}},J=n=>new no(n)}),It,io,be,Ae,N,ce,ao,Ct,He,F,Wr,P,M,es,Lr,oo,ts,ie=U(()=>{ee(),ne(),It=64,io=(n,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(n)){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${n}`)}},be=(n,e=1)=>{let t=io(n,e);return typeof t=="string"?t:t[0]},Ae=(n,e=1)=>{let t=io(n,e);return typeof t=="string"?t:t[1]},N=(...n)=>{let e=[];return n.forEach(t=>{t.length!==0&&e.push({type:12,data:t},{type:12,data:k.computeStrides(t)})}),e},ce=n=>n%4===0?4:n%2===0?2:1,ao=(n="f32",e,t="0")=>!e||e===1?`${n}(${t})`:`vec${e}<${n}>(${t})`,Ct=(n,e,t)=>n==="f32"?t:e===1?`f32(${t})`:`vec${e}<f32>(${t})`,He=(n,e)=>e===4?`(${n}.x + ${n}.y + ${n}.z + ${n}.w)`:e===2?`(${n}.x + ${n}.y)`:e===3?`(${n}.x + ${n}.y + ${n}.z)`:n,F=(n,e,t,s)=>n.startsWith("uniforms.")&&t>4?typeof e=="string"?s==="f16"?`${n}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${n}[(${e}) / 4][(${e}) % 4]`:s==="f16"?`${n}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${n}[${Math.floor(e/4)}][${e%4}]`:t>1?`${n}[${e}]`:n,Wr=(n,e,t,s,a)=>{let c=typeof t=="number",l=c?t:t.length,_=[...new Array(l).keys()],m=l<2?"u32":l<=4?`vec${l}<u32>`:`array<u32, ${l}>`,d=io(e,a),h=typeof d=="string"?d:d[1],i=typeof d=="string"?d:d[0],r={indices:m,value:h,storage:i,tensor:e},u=K=>typeof K=="string"?K:`${K}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=c?"uniforms.":"",w=`${g}${n}_shape`,y=`${g}${n}_strides`,x="";for(let K=0;K<l-1;K++)x+=`
    let dim${K} = current / ${F(y,K,l)};
    let rest${K} = current % ${F(y,K,l)};
    indices[${K}] = dim${K};
    current = rest${K};
    `;x+=`indices[${l-1}] = current;`;let S=l<2?"":`
  fn o2i_${n}(offset: u32) -> ${r.indices} {
    var indices: ${r.indices};
    var current = offset;
    ${x}
    return indices;
  }`,T=K=>(f.offsetToIndices=!0,l<2?K:`o2i_${n}(${K})`),E=[];if(l>=2)for(let K=l-1;K>=0;K--)E.push(`${F(y,K,l)} * (indices[${K}])`);let A=l<2?"":`
  fn i2o_${n}(indices: ${r.indices}) -> u32 {
    return ${E.join("+")};
  }`,C=K=>(f.indicesToOffset=!0,l<2?K:`i2o_${n}(${K})`),I=(...K)=>l===0?"0u":`${r.indices}(${K.map(u).join(",")})`,D=(K,Q)=>l<2?`${K}`:`${F(K,Q,l)}`,R=(K,Q,de)=>l<2?`${K}=${de};`:`${F(K,Q,l)}=${de};`,Y={},re=(K,Q)=>{f.broadcastedIndicesToOffset=!0;let de=`${Q.name}broadcastedIndicesTo${n}Offset`;if(de in Y)return`${de}(${K})`;let ue=[];for(let Ze=l-1;Ze>=0;Ze--){let Pt=Q.indicesGet("outputIndices",Ze+Q.rank-l);ue.push(`${D(y,Ze)} * (${Pt} % ${D(w,Ze)})`)}return Y[de]=`fn ${de}(outputIndices: ${Q.type.indices}) -> u32 {
             return ${ue.length>0?ue.join("+"):"0u"};
           }`,`${de}(${K})`},G=(K,Q)=>(()=>{if(r.storage===r.value)return`${n}[${K}]=${Q};`;if(r.storage==="vec2<u32>"&&r.value==="i32")return`${n}[${K}]=vec2<u32>(u32(${Q}), select(0u, 0xFFFFFFFFu, ${Q} < 0));`;if(r.storage==="vec2<u32>"&&r.value==="u32")return`${n}[${K}]=vec2<u32>(u32(${Q}), 0u);`;if(r.storage==="u32"&&r.value==="vec4<bool>")return`${n}[${K}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Q}));`;throw new Error(`not supported combination of storage type ${r.storage} and value type ${r.value} yet`)})(),te=K=>(()=>{if(r.storage===r.value)return`${n}[${K}]`;if(r.storage==="vec2<u32>"&&r.value==="i32")return`i32(${n}[${K}].x)`;if(r.storage==="vec2<u32>"&&r.value==="u32")return`u32(${n}[${K}].x)`;if(r.storage==="u32"&&r.value==="vec4<bool>")return`vec4<bool>(bool(${n}[${K}] & 0xFFu), bool(${n}[${K}] & 0xFF00u), bool(${n}[${K}] & 0xFF0000u), bool(${n}[${K}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${r.storage} and value type ${r.value} yet`)})(),q=l<2?"":`
  fn get_${n}ByIndices(indices: ${r.indices}) -> ${h} {
    return ${te(`i2o_${n}(indices)`)};
  }`,z=l<2?"":(()=>{let K=_.map(de=>`d${de}: u32`).join(", "),Q=_.map(de=>`d${de}`).join(", ");return`
  fn get_${n}(${K}) -> ${h} {
    return get_${n}ByIndices(${I(Q)});
  }`})(),H=(...K)=>{if(K.length!==l)throw new Error(`indices length must be ${l}`);let Q=K.map(u).join(",");return l===0?te("0u"):l===1?te(Q[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${n}(${Q})`)},he=K=>l<2?te(K):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${n}ByIndices(${K})`),Ce=l<2?"":`
  fn set_${n}ByIndices(indices: ${r.indices}, value: ${h}) {
    ${G(`i2o_${n}(indices)`,"value")}
  }`,oe=l<2?"":(()=>{let K=_.map(de=>`d${de}: u32`).join(", "),Q=_.map(de=>`d${de}`).join(", ");return`
  fn set_${n}(${K}, value: ${h}) {
    set_${n}ByIndices(${I(Q)}, value);
  }`})();return{impl:()=>{let K=[],Q=!1;return f.offsetToIndices&&(K.push(S),Q=!0),f.indicesToOffset&&(K.push(A),Q=!0),f.broadcastedIndicesToOffset&&(Object.values(Y).forEach(de=>K.push(de)),Q=!0),f.set&&(K.push(oe),Q=!0),f.setByIndices&&(K.push(Ce),Q=!0),f.get&&(K.push(z),Q=!0),f.getByIndices&&(K.push(q),Q=!0),!c&&Q&&K.unshift(`const ${w} = ${r.indices}(${t.join(",")});`,`const ${y} = ${r.indices}(${k.computeStrides(t).join(",")});`),K.join(`
`)},type:r,offsetToIndices:T,indicesToOffset:C,broadcastedIndicesToOffset:re,indices:I,indicesGet:D,indicesSet:R,set:(...K)=>{if(K.length!==l+1)throw new Error(`indices length must be ${l}`);let Q=K[l];if(typeof Q!="string")throw new Error("value must be string");let de=K.slice(0,l).map(u).join(",");return l===0?G("0u",Q):l===1?G(de[0],Q):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${n}(${de}, ${Q})`)},setByOffset:G,setByIndices:(K,Q)=>l<2?G(K,Q):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${n}ByIndices(${K}, ${Q});`),get:H,getByOffset:te,getByIndices:he,usage:s,name:n,strides:y,shape:w,rank:l}},P=(n,e,t,s=1)=>Wr(n,e,t,"input",s),M=(n,e,t,s=1)=>Wr(n,e,t,"output",s),es=(n,e,t)=>Wr(n,e,t,"atomicOutput",1),Lr=(n,e,t,s=1)=>Wr(n,e,t,"internal",s),oo=class{constructor(n,e){this.normalizedDispatchGroup=n,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(n){return`if (global_idx >= ${typeof n=="number"?`${n}u`:n}) { return; }`}mainStart(n=It){let e=typeof n=="number"?n:n[0],t=typeof n=="number"?1:n[1],s=typeof n=="number"?1:n[2];if(e>this.limits.maxComputeWorkgroupSizeX||t>this.limits.maxComputeWorkgroupSizeY||s>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${t}, ${s}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*t*s>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${t}, ${s}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let a=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,c=a?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=a?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e*t*s}u + local_idx;`;return`@compute @workgroup_size(${e}, ${t}, ${s})
  fn main(${c}) {
    ${l}
  `}appendVariableUniforms(n){n.rank!==0&&(n.shape.startsWith("uniforms.")&&this.uniforms.push({name:n.shape.replace("uniforms.",""),type:"u32",length:n.rank}),n.strides.startsWith("uniforms.")&&this.uniforms.push({name:n.strides.replace("uniforms.",""),type:"u32",length:n.rank}))}declareVariable(n,e){if(n.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(n),this.appendVariableUniforms(n);let t=n.usage==="input"?"read":"read_write",s=n.usage==="atomicOutput"?"atomic<i32>":n.type.storage;return`@group(0) @binding(${e}) var<storage, ${t}> ${n.name}: array<${s}>;`}declareVariables(...n){return n.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(n){if(n.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(n),this.appendVariableUniforms(n)}registerInternalVariables(...n){return n.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(n,e,t=1){return this.uniforms.push({name:n,type:e,length:t}),this}registerUniforms(n){return this.uniforms=this.uniforms.concat(n),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let n=[];for(let{name:e,type:t,length:s}of this.uniforms)if(s&&s>4)t==="f16"?n.push(`@align(16) ${e}:array<mat2x4<${t}>, ${Math.ceil(s/8)}>`):n.push(`${e}:array<vec4<${t}>, ${Math.ceil(s/4)}>`);else{let a=s==null||s===1?t:`vec${s}<${t}>`;n.push(`${e}:${a}`)}return`
      struct Uniforms { ${n.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(n=>n.impl()).join(`
`)+this.internalVariables.map(n=>n.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let n=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[n(e.type),e.length??1])}},ts=(n,e)=>new oo(n,e)}),pm,rs,mm,fm,hm,gm,Ee,ns,os,st=U(()=>{ee(),ne(),Se(),ie(),pm=(n,e)=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.");if(e.length!==0&&e.length!==n[0].dims.length)throw new Error(`perm size ${e.length} does not match input rank ${n[0].dims.length}`)},rs=(n,e)=>e.length!==0?e:[...new Array(n).keys()].reverse(),mm=(n,e)=>k.sortBasedOnPerm(n,rs(n.length,e)),fm=(n,e,t,s)=>{let a=`fn perm(i: ${s.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`;for(let c=0;c<e;++c)a+=`a[${n[c]}]=i[${c}];`;return a+="return a;}"},hm=(n,e)=>{let t=[],s=[];for(let a=0;a<n.length;++a)n[a]!==1&&t.push(n[a]),n[e[a]]!==1&&s.push(e[a]);return{newShape:t,newPerm:s}},gm=(n,e)=>{let t=0;for(let s=0;s<n.length;++s)if(e[n[s]]!==1){if(n[s]<t)return!1;t=n[s]}return!0},Ee=(n,e)=>{let t=n.dataType,s=n.dims.length,a=rs(s,e),c=mm(n.dims,a),l=n.dims,_=c,m=s<2||gm(a,n.dims),d;if(m)return d=f=>{let g=P("input",t,l,4),w=M("output",t,_,4);return`
  ${f.registerUniform("output_size","u32").declareVariables(g,w)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let f=k.size(c);return{outputs:[{dims:c,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(f/64/4)},programUniforms:[{type:12,data:Math.ceil(f/4)}]}},getShaderSource:d};let{newShape:h,newPerm:i}=hm(n.dims,a),r=k.areEqual(i,[2,3,1]),u=k.areEqual(i,[3,1,2]);if(h.length===2||r||u){l=r?[h[0],h[1]*h[2]]:u?[h[0]*h[1],h[2]]:h,_=[l[1],l[0]];let f=16;return d=g=>{let w=P("a",t,l.length),y=M("output",t,_.length);return`
  ${g.registerUniform("output_size","u32").declareVariables(w,y)}
  var<workgroup> tile : array<array<${y.type.value}, ${f+1}>, ${f}>;
  ${g.mainStart([f,f,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${f} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${f}u + local_id.x;
    let input_row = workgroup_id_x * ${f}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${w.getByIndices(`${w.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${f}u + local_id.x;
    let output_row = workgroup_id_y * ${f}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${y.setByIndices(`${y.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let g=k.size(c);return{outputs:[{dims:c,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(_[1]/f),y:Math.ceil(_[0]/f)},programUniforms:[{type:12,data:g},...N(l,_)]}},getShaderSource:d}}return d=f=>{let g=P("a",t,l.length),w=M("output",t,_.length);return`
  ${f.registerUniform("output_size","u32").declareVariables(g,w)}

  ${fm(a,s,g,w)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${w.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${w.setByOffset("global_idx",g.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:()=>{let f=k.size(c);return{outputs:[{dims:c,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...N(l,_)]}},getShaderSource:d}},ns=(n,e)=>{pm(n.inputs,e.perm),n.compute(Ee(n.inputs[0],e.perm))},os=n=>J({perm:n.perm})}),bm,ym,_m,wm,vm,$m,xm,Sm,Tm,Im,et,is,as,ss,us,ds,ls,cs,ps,ms,fs,hs=U(()=>{ee(),ne(),ie(),Gr(),st(),bm={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},ym={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},_m={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},wm={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},vm=(n,e)=>{let t=[];for(let s=e-n;s<e;++s)t.push(s);return t},$m=(n,e)=>{let t=[],s=n.length;for(let c=0;c<s;c++)e.indexOf(c)===-1&&t.push(n[c]);let a=e.map(c=>n[c]);return[t,a]},xm=(n,e)=>{let t=n.length+e.length,s=[],a=0;for(let c=0;c<t;c++)e.indexOf(c)===-1?s.push(n[a++]):s.push(1);return s},Sm=(n,e)=>{for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0},Tm=(n,e)=>{let t=[];if(!Sm(n,e)){for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);n.forEach(s=>t.push(s))}return t},Im=(n,e,t,s,a,c,l)=>{let _=t[0].dims,m=k.size(c),d=k.size(l),h=P("_A",t[0].dataType,_),i=M("output",a,c),r=64;m===1&&(r=256);let u=`
          var<workgroup> aBestValues : array<f32, ${r}>;
       `,f=g=>`
        ${g.registerUniform("reduceSize","u32").declareVariables(h,i)}
        ${u}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${g.mainStart(r)}

          let outputIndex = global_idx / ${r};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${_m[s]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${r}) {
           let candidate = f32(${h.getByOffset("offset + k")});
           bestValue = ${bm[s]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${ym[s]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${i.setByOffset("outputIndex",`${s==="mean"?`${i.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${i.type.storage}(${wm[s]})`}`)};
         }
        }`;return{name:n,shaderCache:{hint:`${e};${r}`,inputDependencies:["type"]},getShaderSource:f,getRunData:()=>({outputs:[{dims:c,dataType:a}],dispatchGroup:{x:m},programUniforms:[{type:12,data:d}]})}},et=(n,e,t,s)=>{let a=n.inputs.length===1?t:so(n.inputs,t),c=a.axes;c.length===0&&!a.noopWithEmptyAxes&&(c=n.inputs[0].dims.map((u,f)=>f));let l=k.normalizeAxes(c,n.inputs[0].dims.length),_=l,m=n.inputs[0],d=Tm(_,n.inputs[0].dims.length);d.length>0&&(m=n.compute(Ee(n.inputs[0],d),{inputs:[0],outputs:[-1]})[0],_=vm(_.length,m.dims.length));let[h,i]=$m(m.dims,_),r=h;a.keepDims&&(r=xm(h,l)),n.compute(Im(e,a.cacheKey,[m],s,n.inputs[0].dataType,r,i),{inputs:[m]})},is=(n,e)=>{et(n,"ReduceMeanShared",e,"mean")},as=(n,e)=>{et(n,"ReduceL1Shared",e,"l1")},ss=(n,e)=>{et(n,"ReduceL2Shared",e,"l2")},us=(n,e)=>{et(n,"ReduceLogSumExpShared",e,"logSumExp")},ds=(n,e)=>{et(n,"ReduceMaxShared",e,"max")},ls=(n,e)=>{et(n,"ReduceMinShared",e,"min")},cs=(n,e)=>{et(n,"ReduceProdShared",e,"prod")},ps=(n,e)=>{et(n,"ReduceSumShared",e,"sum")},ms=(n,e)=>{et(n,"ReduceSumSquareShared",e,"sumSquare")},fs=(n,e)=>{et(n,"ReduceLogSumShared",e,"logSum")}}),tt,Cm,Hr,so,rt,Am,Em,km,Pm,zm,Om,Bm,Dm,Mm,Rm,nt,gs,bs,ys,_s,ws,vs,$s,xs,Ss,Ts,Gr=U(()=>{ee(),ne(),Se(),ie(),hs(),tt=n=>{if(!n||n.length===0||n.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(n.length===2&&n[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Cm=n=>["","",`var value = ${n.getByIndices("input_indices")};`,""],Hr=(n,e,t,s,a,c,l=!1,_=!1)=>{let m=[],d=t[0].dims,h=d.length,i=k.normalizeAxes(a,h),r=!_&&i.length===0;d.forEach((g,w)=>{r||i.indexOf(w)>=0?l&&m.push(1):m.push(g)});let u=m.length,f=k.size(m);return{name:n,shaderCache:e,getShaderSource:g=>{let w=[],y=P("_A",t[0].dataType,h),x=M("output",c,u),S=s(y,x,i),T=S[2];for(let E=0,A=0;E<h;E++)r||i.indexOf(E)>=0?(l&&A++,T=`for(var j${E}: u32 = 0; j${E} < ${d[E]}; j${E}++) {
                  ${S[2].includes("last_index")?`let last_index = j${E};`:""}
                  ${y.indicesSet("input_indices",E,`j${E}`)}
                  ${T}
                }`):(w.push(`${y.indicesSet("input_indices",E,x.indicesGet("output_indices",A))};`),A++);return`

        ${g.registerUniform("output_size","u32").declareVariables(y,x)}

        ${g.mainStart()}
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${y.type.indices};
          let output_indices = ${x.offsetToIndices("global_idx")};

          ${w.join(`
`)}
          ${S[0]}       // init ops for reduce max/min
          ${S[1]}
          ${T}
          ${S[3]}
          ${S.length===4?x.setByOffset("global_idx","value"):S.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:m,dataType:c}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...N(d,m)]})}},so=(n,e)=>{let t=[];return n[1].dims[0]>0&&n[1].getBigInt64Array().forEach(s=>t.push(Number(s))),J({axes:t,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},rt=(n,e,t,s)=>{let a=n.inputs,c=a.length===1?t:so(a,t);n.compute(Hr(e,{hint:c.cacheKey,inputDependencies:["rank"]},[a[0]],c.noopWithEmptyAxes&&c.axes.length===0?Cm:s,c.axes,a[0].dataType,c.keepDims,c.noopWithEmptyAxes),{inputs:[0]})},Am=(n,e)=>{tt(n.inputs),rt(n,"ReduceLogSum",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,"value = log(value);"])},Em=(n,e)=>{tt(n.inputs),rt(n,"ReduceL1",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += abs(${t.getByIndices("input_indices")});`,""])},km=(n,e)=>{tt(n.inputs),rt(n,"ReduceL2",e,(t,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Pm=(n,e)=>{tt(n.inputs),rt(n,"ReduceLogSumExp",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += exp(${t.getByIndices("input_indices")});`,"value = log(value);"])},zm=(n,e)=>{tt(n.inputs),rt(n,"ReduceMax",e,(t,s,a)=>{let c=[];for(let l=0;l<t.rank;l++)(a.indexOf(l)>=0||a.length===0)&&c.push(t.indicesSet("input_indices",l,0));return[`${c.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = max(value, ${t.getByIndices("input_indices")});`,""]})},Om=(n,e)=>{tt(n.inputs),rt(n,"ReduceMean",e,(t,s,a)=>{let c=1;for(let l=0;l<t.rank;l++)(a.indexOf(l)>=0||a.length===0)&&(c*=n.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${s.type.value}(sum / ${c});`]})},Bm=(n,e)=>{tt(n.inputs),rt(n,"ReduceMin",e,(t,s,a)=>{let c=[];for(let l=0;l<t.rank;l++)(a.indexOf(l)>=0||a.length===0)&&c.push(`input_indices[${l}] = 0;`);return[`${c.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = min(value, ${t.getByIndices("input_indices")});`,""]})},Dm=(n,e)=>{tt(n.inputs),rt(n,"ReduceProd",e,(t,s)=>[`var value = ${s.type.storage}(1);`,"",`value *= ${t.getByIndices("input_indices")};`,""])},Mm=(n,e)=>{tt(n.inputs),rt(n,"ReduceSum",e,(t,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,""])},Rm=(n,e)=>{tt(n.inputs),rt(n,"ReduceSumSquare",e,(t,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += t * t;`,""])},nt=(n,e,t)=>{if(e.length===0)return t;let s=1,a=1;for(let c=0;c<e.length;c++)e.indexOf(c)===-1?s*=n[c]:a*=n[c];return a<32&&s>1024},gs=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Om(n,e):is(n,e)},bs=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Em(n,e):as(n,e)},ys=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?km(n,e):ss(n,e)},_s=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Pm(n,e):us(n,e)},ws=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?zm(n,e):ds(n,e)},vs=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Bm(n,e):ls(n,e)},$s=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Dm(n,e):cs(n,e)},xs=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Mm(n,e):ps(n,e)},Ss=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Rm(n,e):ms(n,e)},Ts=(n,e)=>{nt(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Am(n,e):fs(n,e)}}),Is,Cs,As,uo,Es=U(()=>{ee(),Se(),Gr(),Is=n=>{if(!n||n.length===0||n.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(n[0].dataType!==1)throw new Error("Invalid input type.")},Cs=(n,e)=>{Is(n.inputs);let t=(s,a,c)=>{let l=[];for(let _=0;_<s.rank;_++)(c.indexOf(_)>=0||c.length===0)&&l.push(`input_indices[${_}] = 0;`);return[`${l.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",a.setByOffset("global_idx","best_index")]};n.compute(Hr("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[n.inputs[0]],t,[e.axis],7,e.keepDims),{inputs:[0]})},As=(n,e)=>{Is(n.inputs);let t=(s,a,c)=>{let l=[];for(let _=0;_<s.rank;_++)(c.indexOf(_)>=0||c.length===0)&&l.push(`input_indices[${_}] = 0;`);return[`${l.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",a.setByOffset("global_idx","best_index")]};n.compute(Hr("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[n.inputs[0]],t,[e.axis],7,e.keepDims),{inputs:[0]})},uo=n=>J(n)}),Um,lo,Nm,Vm,Wm,Rt,Lm,ks,Fr=U(()=>{ee(),ne(),Vr(),ie(),Um=(n,e)=>{let t=n[0],s=n[1],a=n[2],c=n[3],l=n[4],_=n[5];if(l&&_)throw new Error("Attention cannot have both past and attention_bias");if(t.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let m=t.dims[0],d=t.dims[1],h=t.dims[2];if(a.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(s.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(s.dims[0]!==h)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==s.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let i=a.dims[0]/3,r=i,u=r;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let S of e.qkvHiddenSizes)if(S%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");i=e.qkvHiddenSizes[0],r=e.qkvHiddenSizes[1],u=e.qkvHiddenSizes[2]}let f=d;if(i!==r)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==i+r+u)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let g=0;if(l){if(r!==u)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(l.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(l.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(l.dims[1]!==m)throw new Error('Input "past" second dimension must be batch_size');if(l.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(l.dims[4]!==r/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(g=l.dims[3])}let w=f+g,y=-1,x=0;if(c)throw new Error("Mask not supported");if(l)throw new Error("past is not supported");if(_){if(_.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(_.dims[0]!==m||_.dims[1]!==e.numHeads||_.dims[2]!==d||_.dims[3]!==w)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:m,sequenceLength:d,pastSequenceLength:g,kvSequenceLength:f,totalSequenceLength:w,maxSequenceLength:y,inputHiddenSize:h,hiddenSize:i,vHiddenSize:u,headSize:Math.floor(i/e.numHeads),vHeadSize:Math.floor(u/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:x,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},lo=(n,e,t)=>e&&n?`
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${n?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${t?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,Nm=(n,e,t,s,a,c,l,_)=>{let m=ce(l?1:c),d=64,h=c/m;h<d&&(d=32);let i=Math.ceil(c/m/d),r=[{type:12,data:e},{type:12,data:t},{type:12,data:s},{type:12,data:a},{type:12,data:h},{type:12,data:i}],u=be(n.dataType,m),f=Ae(1,m),g=["type"];l&&g.push("type"),_&&g.push("type");let w=y=>{let x=M("x",n.dataType,n.dims,m),S=[x],T=l?P("seq_lens",l.dataType,l.dims):void 0;T&&S.push(T);let E=_?P("total_sequence_length_input",_.dataType,_.dims):void 0;E&&S.push(E);let A=Ae(n.dataType),C=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${d}>;
  var<workgroup> thread_sum: array<f32, ${d}>;
  ${y.registerUniforms(C).declareVariables(...S)}
  ${y.mainStart([d,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${lo(T,E,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${d}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${l?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${f}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(m){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${m}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${d}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(m){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${m}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${d}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${x.type.value}(${A}(1.0) / ${A}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f}(x[offset + i]);
        x[offset + i] = ${x.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${l?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${x.type.value}(${A}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${d};${u};${m}`,inputDependencies:g},getShaderSource:w,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:a,z:e*t},programUniforms:r})}},Vm=(n,e,t,s,a,c,l,_,m)=>{let d=l+c.kvSequenceLength,h=[c.batchSize,c.numHeads,c.sequenceLength,d],i=n>1&&s,r=c.kvNumHeads?c.kvNumHeads:c.numHeads,u=i?[c.batchSize,r,d,c.headSize]:void 0,f=c.nReps?c.nReps:1,g=c.scale===0?1/Math.sqrt(c.headSize):c.scale,w=ce(c.headSize),y=c.headSize/w,x=12,S={x:Math.ceil(d/x),y:Math.ceil(c.sequenceLength/x),z:c.batchSize*c.numHeads},T=[{type:12,data:c.sequenceLength},{type:12,data:y},{type:12,data:d},{type:12,data:c.numHeads},{type:12,data:c.headSize},{type:1,data:g},{type:12,data:l},{type:12,data:c.kvSequenceLength},{type:12,data:f}],E=i&&s&&k.size(s.dims)>0,A=["type","type"];E&&A.push("type"),a&&A.push("type"),_&&A.push("type"),m&&A.push("type");let C=[{dims:h,dataType:e.dataType,gpuDataType:0}];i&&C.push({dims:u,dataType:e.dataType,gpuDataType:0});let I=D=>{let R=P("q",e.dataType,e.dims,w),Y=P("key",t.dataType,t.dims,w),re=[R,Y];if(E){let Ce=P("past_key",s.dataType,s.dims,w);re.push(Ce)}a&&re.push(P("attention_bias",a.dataType,a.dims));let G=_?P("seq_lens",_.dataType,_.dims):void 0;G&&re.push(G);let te=m?P("total_sequence_length_input",m.dataType,m.dims):void 0;te&&re.push(te);let q=M("output",e.dataType,h),z=[q];i&&z.push(M("present_key",e.dataType,u,w));let H=Ae(1,w),he=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${x}u;

  var<workgroup> tileQ: array<${R.type.storage}, ${x*x}>;
  var<workgroup> tileK: array<${R.type.storage}, ${x*x}>;
  ${D.registerUniforms(he).declareVariables(...re,...z)}
  ${D.mainStart([x,x,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${f===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${f===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${lo(G,te,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${E&&i?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${i?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${H}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${E&&i?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${i?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${H}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(w){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${w}`)}})()};
        output[outputIdx] = ${q.type.value} (sum * uniforms.alpha) + ${a?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${w};${a!==void 0};${s!==void 0};${n}`,inputDependencies:A},getRunData:()=>({outputs:C,dispatchGroup:S,programUniforms:T}),getShaderSource:I}},Wm=(n,e,t,s,a,c,l=void 0,_=void 0)=>{let m=c+a.kvSequenceLength,d=a.nReps?a.nReps:1,h=a.vHiddenSize*d,i=n>1&&s,r=a.kvNumHeads?a.kvNumHeads:a.numHeads,u=i?[a.batchSize,r,m,a.headSize]:void 0,f=[a.batchSize,a.sequenceLength,h],g=12,w={x:Math.ceil(a.vHeadSize/g),y:Math.ceil(a.sequenceLength/g),z:a.batchSize*a.numHeads},y=[{type:12,data:a.sequenceLength},{type:12,data:m},{type:12,data:a.vHeadSize},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:12,data:h},{type:12,data:c},{type:12,data:a.kvSequenceLength},{type:12,data:d}],x=i&&s&&k.size(s.dims)>0,S=["type","type"];x&&S.push("type"),l&&S.push("type"),_&&S.push("type");let T=[{dims:f,dataType:e.dataType,gpuDataType:0}];i&&T.push({dims:u,dataType:e.dataType,gpuDataType:0});let E=A=>{let C=P("probs",e.dataType,e.dims),I=P("v",t.dataType,t.dims),D=[C,I];x&&D.push(P("past_value",s.dataType,s.dims));let R=l?P("seq_lens",l.dataType,l.dims):void 0;l&&D.push(R);let Y=_?P("total_sequence_length_input",_.dataType,_.dims):void 0;_&&D.push(Y);let re=[M("output",e.dataType,f)];i&&re.push(M("present_value",e.dataType,u));let G=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${g}u;
  var<workgroup> tileQ: array<${C.type.value}, ${g*g}>;
  var<workgroup> tileV: array<${C.type.value}, ${g*g}>;
  ${A.registerUniforms(G).declareVariables(...D,...re)}
  ${A.mainStart([g,g,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${d===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${d===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${lo(R,Y,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${x&&i?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${i?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${C.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${x&&i?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${i?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${s!==void 0};${n}`,inputDependencies:S},getRunData:()=>({outputs:T,dispatchGroup:w,programUniforms:y}),getShaderSource:E}},Rt=(n,e,t,s,a,c,l,_,m,d,h=void 0,i=void 0)=>{let r=Math.min(n.outputCount,1+(l?1:0)+(_?1:0)),u=r>1?d.pastSequenceLength:0,f=u+d.kvSequenceLength,g=m&&k.size(m.dims)>0?m:void 0,w=[e,t];r>1&&l&&k.size(l.dims)>0&&w.push(l),g&&w.push(g),h&&w.push(h),i&&w.push(i);let y=n.compute(Vm(r,e,t,l,g,d,u,h,i),{inputs:w,outputs:r>1?[-1,1]:[-1]})[0];n.compute(Nm(y,d.batchSize,d.numHeads,u,d.sequenceLength,f,h,i),{inputs:h&&i?[y,h,i]:[y],outputs:[]});let x=[y,s];r>1&&_&&k.size(_.dims)>0&&x.push(_),h&&x.push(h),i&&x.push(i),n.compute(Wm(r,y,s,_,d,u,h,i),{inputs:x,outputs:r>1?[0,2]:[0]})},Lm=(n,e)=>{let t=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],s=e.sequenceLength,a=e.inputHiddenSize,c=e.headSize,l=12,_={x:Math.ceil(e.headSize/l),y:Math.ceil(e.sequenceLength/l),z:e.batchSize*e.numHeads},m=[n.inputs[0],n.inputs[1],n.inputs[2]],d=[{type:12,data:s},{type:12,data:a},{type:12,data:c},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],h=i=>{let r=M("output_q",m[0].dataType,t),u=M("output_k",m[0].dataType,t),f=M("output_v",m[0].dataType,t),g=P("input",m[0].dataType,m[0].dims),w=P("weight",m[1].dataType,m[1].dims),y=P("bias",m[2].dataType,m[2].dims),x=g.type.storage,S=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${l}u;
  var<workgroup> tileInput: array<${x}, ${l*l}>;
  var<workgroup> tileWeightQ: array<${x}, ${l*l}>;
  var<workgroup> tileWeightK: array<${x}, ${l*l}>;
  var<workgroup> tileWeightV: array<${x}, ${l*l}>;
  ${i.registerUniforms(S).declareVariables(g,w,y,r,u,f)}
  ${i.mainStart([l,l,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${x}(0);
    var valueK = ${x}(0);
    var valueV = ${x}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return n.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:t,dataType:n.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:n.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:n.inputs[0].dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:d}),getShaderSource:h},{inputs:m,outputs:[-1,-1,-1]})},ks=(n,e)=>{let t=Um(n.inputs,e),[s,a,c]=Lm(n,t);return Rt(n,s,a,c,n.inputs[4],void 0,void 0,void 0,n.inputs[5],t)}}),Gm,Hm,Fm,Ps,zs=U(()=>{We(),ee(),ne(),Se(),ie(),Gm=(n,e)=>{if(!n||n.length!==5)throw new Error("BatchNormalization requires 5 inputs");let t=(s,a,c)=>{let l=a.length;if(l!==s.length)throw new Error(`${c}: num dimensions != ${l}`);a.forEach((_,m)=>{if(_!==s[m])throw new Error(`${c}: dim[${m}] do not match`)})};if(n[0].dims.length>1){let s=e.format==="NHWC"?e.spatial?n[0].dims.slice(-1):n[0].dims.slice(-1).concat(n[0].dims.slice(1,n[0].dims.length-1)):n[0].dims.slice(1,e.spatial?2:void 0);t(n[1].dims,s,"Invalid input scale"),t(n[2].dims,s,"Invalid input B"),t(n[3].dims,s,"Invalid input mean"),t(n[4].dims,s,"Invalid input var")}else t(n[1].dims,[1],"Invalid input scale"),t(n[2].dims,[1],"Invalid input B"),t(n[3].dims,[1],"Invalid input mean"),t(n[4].dims,[1],"Invalid input var")},Hm=(n,e)=>{let{epsilon:t,spatial:s,format:a}=e,c=n[0].dims,l=s?ce(c[c.length-1]):1,_=a==="NHWC"&&c.length>1?l:1,m=k.size(c)/l,d=s,h=d?c.length:c,i=P("x",n[0].dataType,n[0].dims,l),r=P("scale",n[1].dataType,n[1].dims,_),u=P("bias",n[2].dataType,n[2].dims,_),f=P("inputMean",n[3].dataType,n[3].dims,_),g=P("inputVar",n[4].dataType,n[4].dims,_),w=M("y",n[0].dataType,h,l),y=()=>{let S="";if(s)S=`let cOffset = ${c.length===1?"0u":a==="NHWC"?`outputIndices[${c.length-1}] / ${l}`:"outputIndices[1]"};`;else if(a==="NCHW")S=`
            ${w.indicesSet("outputIndices","0","0")}
            let cOffset = ${w.indicesToOffset("outputIndices")};`;else{S=`var cIndices = ${r.type.indices}(0);
                       cIndices[0] = outputIndices[${c.length-1}];`;for(let T=1;T<r.rank;T++)S+=`cIndices[${T}] = outputIndices[${T}];`;S+=`let cOffset = ${r.indicesToOffset("cIndices")};`}return S},x=S=>`
  const epsilon = ${t};
  ${S.registerUniform("outputSize","u32").declareVariables(i,r,u,f,g,w)}
  ${S.mainStart()}
  ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${w.offsetToIndices(`global_idx * ${l}`)};
    ${y()}
    let scale = ${r.getByOffset("cOffset")};
    let bias = ${u.getByOffset("cOffset")};
    let inputMean = ${f.getByOffset("cOffset")};
    let inputVar = ${g.getByOffset("cOffset")};
    let x = ${i.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${w.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${s}_${l}`,inputDependencies:d?["rank","type","type","type","type"]:void 0},getShaderSource:x,getRunData:()=>({outputs:[{dims:n[0].dims,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:d?[{type:12,data:m},...N(c)]:[{type:12,data:m}]})}},Fm=n=>J(n),Ps=(n,e)=>{let{inputs:t,outputCount:s}=n,a=Fm({...e,outputCount:s});if(ge.webgpu.validateInputContent&&Gm(t,a),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");n.compute(Hm(t,a))}}),qm,jm,Os,Bs=U(()=>{ne(),ie(),qm=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(n[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},jm=n=>{let e=n[0].dims,t=n[0].dims[2],s=k.size(e)/4,a=n[0].dataType,c=P("input",a,e,4),l=P("bias",a,[t],4),_=P("residual",a,e,4),m=M("output",a,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d=>`
  const channels = ${t}u / 4;
  ${d.declareVariables(c,l,_,m)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let value = ${c.getByOffset("global_idx")}
      + ${l.getByOffset("global_idx % channels")} + ${_.getByOffset("global_idx")};
    ${m.setByOffset("global_idx","value")}
  }`}},Os=n=>{qm(n.inputs),n.compute(jm(n.inputs))}}),Km,me,Ds,Ms,Rs,Us,Ns,Vs,Ws,Ls,Gs,Zm,Hs,Fs,qs,js,Yt,Ks,qr,Zs,Qs,Ys,Xs,Js,eu,tu,ru,nu,ou,iu,au,su,uu,du,lu,cu,pu,co,po,mu,fu,hu,Qm,Ym,gu,jr=U(()=>{ee(),ne(),Se(),ie(),Km=(n,e,t,s,a,c,l)=>{let _=Math.ceil(e/4),m="";typeof a=="string"?m=`${a}(a)`:m=a("a");let d=P("inputData",t,[_],4),h=M("outputData",s,[_],4),i=[{name:"vec_size",type:"u32"}];return l&&i.push(...l),`
      ${n.registerUniforms(i).declareVariables(d,h)}

  ${c??""}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${d.getByOffset("global_idx")};
    ${h.setByOffset("global_idx",m)}
  }`},me=(n,e,t,s,a,c=n.dataType,l,_)=>{let m=[{type:12,data:Math.ceil(k.size(n.dims)/4)}];return l&&m.push(...l),{name:e,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:d=>Km(d,k.size(n.dims),n.dataType,c,t,s,_),getRunData:d=>({outputs:[{dims:n.dims,dataType:c}],dispatchGroup:{x:Math.ceil(k.size(d[0].dims)/64/4)},programUniforms:m})}},Ds=n=>{n.compute(me(n.inputs[0],"Abs","abs"))},Ms=n=>{n.compute(me(n.inputs[0],"Acos","acos"))},Rs=n=>{n.compute(me(n.inputs[0],"Acosh","acosh"))},Us=n=>{n.compute(me(n.inputs[0],"Asin","asin"))},Ns=n=>{n.compute(me(n.inputs[0],"Asinh","asinh"))},Vs=n=>{n.compute(me(n.inputs[0],"Atan","atan"))},Ws=n=>{n.compute(me(n.inputs[0],"Atanh","atanh"))},Ls=n=>J(n),Gs=(n,e)=>{let t;switch(e.to){case 10:t="vec4<f16>";break;case 1:t="vec4<f32>";break;case 12:t="vec4<u32>";break;case 6:t="vec4<i32>";break;case 9:t="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}n.compute(me(n.inputs[0],"Cast",t,void 0,e.cacheKey,e.to))},Zm=n=>{let e,t,s=n.length>=2&&n[1].data!==0,a=n.length>=3&&n[2].data!==0;switch(n[0].dataType){case 1:e=s?n[1].getFloat32Array()[0]:-34028234663852886e22,t=a?n[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:e=s?n[1].getUint16Array()[0]:64511,t=a?n[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return J({min:e,max:t})},Hs=(n,e)=>{let t=e||Zm(n.inputs),s=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"Clip",a=>`clamp(${a}, vec4<${s}>(uniforms.min), vec4<${s}>(uniforms.max))`,void 0,t.cacheKey,void 0,[{type:n.inputs[0].dataType,data:t.min},{type:n.inputs[0].dataType,data:t.max}],[{name:"min",type:s},{name:"max",type:s}]),{inputs:[0]})},Fs=n=>{n.compute(me(n.inputs[0],"Ceil","ceil"))},qs=n=>{n.compute(me(n.inputs[0],"Cos","cos"))},js=n=>{n.compute(me(n.inputs[0],"Cosh","cosh"))},Yt=n=>J(n),Ks=(n,e)=>{let t=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"Elu",s=>`elu_vf32(${s})`,`
  const elu_alpha_ = ${t}(${e.alpha});

  fn elu_f32(a: ${t}) -> ${t} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${t}>) -> vec4<${t}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},qr=(n="f32")=>`
const r0: ${n} = 0.3275911;
const r1: ${n} = 0.254829592;
const r2: ${n} = -0.284496736;
const r3: ${n} = 1.421413741;
const r4: ${n} = -1.453152027;
const r5: ${n} = 1.061405429;

fn erf_vf32(v: vec4<${n}>) -> vec4<${n}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Zs=n=>{let e=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"Erf",t=>`erf_vf32(${t})`,qr(e)))},Qs=n=>{n.compute(me(n.inputs[0],"Exp","exp"))},Ys=n=>{n.compute(me(n.inputs[0],"Floor","floor"))},Xs=n=>{let e=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"Gelu",t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`,qr(e)))},Js=(n,e)=>{let t=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"LeakyRelu",s=>`select(leaky_relu_alpha_ * ${s}, ${s}, ${s} >= vec4<${t}>(0.0))`,`const leaky_relu_alpha_ = ${t}(${e.alpha});`,e.cacheKey))},eu=n=>{n.compute(me(n.inputs[0],"Not",e=>`!${e}`))},tu=n=>{n.compute(me(n.inputs[0],"Neg",e=>`-${e}`))},ru=n=>{n.compute(me(n.inputs[0],"Reciprocal",e=>`1.0/${e}`))},nu=n=>{let e=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"Relu",t=>`select(vec4<${e}>(0.0), ${t}, ${t} > vec4<${e}>(0.0))`))},ou=n=>{n.compute(me(n.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},iu=n=>J(n),au=(n,e)=>{let t=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"HardSigmoid",s=>`max(vec4<${t}>(0.0), min(vec4<${t}>(1.0), ${e.alpha} * ${s} + vec4<${t}>(${e.beta})))`,void 0,e.cacheKey))},su=n=>{n.compute(me(n.inputs[0],"Sin","sin"))},uu=n=>{n.compute(me(n.inputs[0],"Sinh","sinh"))},du=n=>{n.compute(me(n.inputs[0],"Sqrt","sqrt"))},lu=n=>{n.compute(me(n.inputs[0],"Tan","tan"))},cu=n=>`sign(${n}) * (1 - exp(-2 * abs(${n}))) / (1 + exp(-2 * abs(${n})))`,pu=n=>{n.compute(me(n.inputs[0],"Tanh",cu))},co=(n="f32")=>`
const fast_gelu_a: ${n} = 0.5;
const fast_gelu_b: ${n} = 0.7978845608028654;
const fast_gelu_c: ${n} = 0.035677408136300125;

fn tanh_v(v: vec4<${n}>) -> vec4<${n}> {
  return ${cu("v")};
}
`,po=n=>`(fast_gelu_a + fast_gelu_a * tanh_v(${n} * (fast_gelu_c * ${n} * ${n} + fast_gelu_b))) * ${n}`,mu=n=>{let e=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"FastGelu",po,co(e),void 0,n.inputs[0].dataType))},fu=(n,e)=>{let t=Ae(n.inputs[0].dataType);return n.compute(me(n.inputs[0],"ThresholdedRelu",s=>`select(vec4<${t}>(0.0), ${s}, ${s} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${t}>(${e.alpha});`,e.cacheKey)),0},hu=n=>{n.compute(me(n.inputs[0],"Log","log"))},Qm=(n,e)=>`
const alpha = vec4<${n}>(${e});
const one = ${n}(1.0);
const zero = ${n}(0.0);

fn quick_gelu_impl(x: vec4<${n}>) -> vec4<${n}> {
  let v = x *alpha;
  var x1 : vec4<${n}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Ym=n=>`quick_gelu_impl(${n})`,gu=(n,e)=>{let t=Ae(n.inputs[0].dataType);n.compute(me(n.inputs[0],"QuickGelu",Ym,Qm(t,e.alpha),e.cacheKey,n.inputs[0].dataType))}}),Xm,Jm,yu,_u=U(()=>{ne(),ie(),jr(),Xm=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(n[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Jm=n=>{let e=n[0].dims.slice();e[2]=e[2]/2;let t=P("input",n[0].dataType,n[0].dims,4),s=P("bias",n[0].dataType,[n[0].dims[2]],4),a=M("output",n[0].dataType,e,4),c=k.size(e)/4,l=be(n[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:_=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${n[0].dims[2]/4/2}u;

  ${_.declareVariables(t,s,a)}

  ${qr(l)}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes(c)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${a.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},yu=n=>{Xm(n.inputs),n.compute(Jm(n.inputs))}}),ef,tf,ot,wu,vu,$u,xu,Su,Tu,Iu,Cu,Au,Eu,ku=U(()=>{ee(),ne(),ie(),ef=(n,e,t,s,a,c,l,_,m,d,h,i)=>{let r,u;typeof _=="string"?r=u=(x,S)=>`${_}((${x}),(${S}))`:typeof _=="function"?r=u=_:(r=_.scalar,u=_.vector);let f=M("outputData",h,s.length,4),g=P("aData",m,e.length,4),w=P("bData",d,t.length,4),y;if(a)if(c){let x=k.size(e)===1,S=k.size(t)===1,T=e.length>0&&e[e.length-1]%4===0,E=t.length>0&&t[t.length-1]%4===0;x||S?y=f.setByOffset("global_idx",u(x?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"),S?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"))):y=`
            let outputIndices = ${f.offsetToIndices("global_idx * 4u")};
            let offsetA = ${g.broadcastedIndicesToOffset("outputIndices",f)};
            let offsetB = ${w.broadcastedIndicesToOffset("outputIndices",f)};
            ${f.setByOffset("global_idx",u(l||T?g.getByOffset("offsetA / 4u"):`${g.type.value}(${g.getByOffset("offsetA / 4u")}[offsetA % 4u])`,l||E?w.getByOffset("offsetB / 4u"):`${w.type.value}(${w.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else y=f.setByOffset("global_idx",u(g.getByOffset("global_idx"),w.getByOffset("global_idx")));else{if(!c)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let x=(S,T,E="")=>{let A=`aData[indexA${T}][componentA${T}]`,C=`bData[indexB${T}][componentB${T}]`;return`
            let outputIndices${T} = ${f.offsetToIndices(`global_idx * 4u + ${T}u`)};
            let offsetA${T} = ${g.broadcastedIndicesToOffset(`outputIndices${T}`,f)};
            let offsetB${T} = ${w.broadcastedIndicesToOffset(`outputIndices${T}`,f)};
            let indexA${T} = offsetA${T} / 4u;
            let indexB${T} = offsetB${T} / 4u;
            let componentA${T} = offsetA${T} % 4u;
            let componentB${T} = offsetB${T} % 4u;
            ${S}[${T}] = ${E}(${r(A,C)});
          `};h===9?y=`
            var data = vec4<u32>(0);
            ${x("data",0,"u32")}
            ${x("data",1,"u32")}
            ${x("data",2,"u32")}
            ${x("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:y=`
            ${x("outputData[global_idx]",0)}
            ${x("outputData[global_idx]",1)}
            ${x("outputData[global_idx]",2)}
            ${x("outputData[global_idx]",3)}
          `}return`
        ${n.registerUniform("vec_size","u32").declareVariables(g,w,f)}

        ${i??""}

        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${y}
      }`},tf=(n,e,t,s,a,c,l=t.dataType)=>{let _=t.dims.map(g=>Number(g)??1),m=s.dims.map(g=>Number(g)??1),d=!k.areEqual(_,m),h=_,i=k.size(_),r=!1,u=!1,f=[d];if(d){let g=Je.calcShape(_,m,!1);if(!g)throw new Error("Can't perform binary op on the given tensors");h=g.slice(),i=k.size(h);let w=k.size(_)===1,y=k.size(m)===1,x=_.length>0&&_[_.length-1]%4===0,S=m.length>0&&m[m.length-1]%4===0;f.push(w),f.push(y),f.push(x),f.push(S);let T=1;for(let E=1;E<h.length;E++){let A=_[_.length-E],C=m[m.length-E];if(A===C)T*=A;else break}T%4===0?(u=!0,r=!0):(w||y||x||S)&&(r=!0)}else r=!0;return f.push(r),{name:n,shaderCache:{hint:e+f.map(g=>g.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:g=>ef(g,_,m,h,r,d,u,a,t.dataType,s.dataType,l,c),getRunData:()=>({outputs:[{dims:h,dataType:l}],dispatchGroup:{x:Math.ceil(i/64/4)},programUniforms:[{type:12,data:Math.ceil(k.size(h)/4)},...N(_,m,h)]})}},ot=(n,e,t,s,a,c)=>{n.compute(tf(e,a??"",n.inputs[0],n.inputs[1],t,s,c))},wu=n=>{ot(n,"Add",(e,t)=>`${e}+${t}`)},vu=n=>{ot(n,"Div",(e,t)=>`${e}/${t}`)},$u=n=>{ot(n,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},xu=n=>{ot(n,"Mul",(e,t)=>`${e}*${t}`)},Su=n=>{let e=P("input",n.inputs[0].dataType,n.inputs[0].dims).type.value;ot(n,"Pow",{scalar:(t,s)=>`pow_custom(${t},${s})`,vector:(t,s)=>`pow_vector_custom(${t},${s})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Tu=n=>{ot(n,"Sub",(e,t)=>`${e}-${t}`)},Iu=n=>{ot(n,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Cu=n=>{ot(n,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},Au=n=>{ot(n,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Eu=n=>{ot(n,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}}),nf,of,af,sf,Pu,zu,Ou=U(()=>{ee(),ne(),Se(),ie(),nf=(n,e)=>{if(!n||n.length<1)throw new Error("too few inputs");let t=0,s=n[t],a=s.dataType,c=s.dims.length;n.forEach((l,_)=>{if(_!==t){if(l.dataType!==a)throw new Error("input tensors should be one type");if(l.dims.length!==c)throw new Error("input tensors should have the same shape");l.dims.forEach((m,d)=>{if(d!==e&&m!==s.dims[d])throw new Error("non concat dimensions must match")})}})},of=(n,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${n}u>(${e});
    for (var i: u32 = 0u; i < ${n}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${n}u;
  }`,af=(n,e)=>{let t=n.length,s=[];for(let a=0;a<t;++a){let c=e.setByOffset("global_idx",n[a].getByIndices("indices"));t===1?s.push(c):a===0?s.push(`if (inputIndex == ${a}u) { ${c} }`):a===t-1?s.push(`else { ${c} }`):s.push(`else if (inputIndex == ${a}) { ${c} }`)}return s.join(`
`)},sf=(n,e,t,s)=>{let a=k.size(t),c=new Array(n.length),l=new Array(n.length),_=0,m=[],d=[],h=[{type:12,data:a}];for(let g=0;g<n.length;++g)_+=n[g].dims[e],c[g]=_,d.push(n[g].dims.length),l[g]=P(`input${g}`,s,d[g]),m.push("rank"),h.push({type:12,data:c[g]});for(let g=0;g<n.length;++g)h.push(...N(n[g].dims));h.push(...N(t));let i=M("output",s,t.length),r=i.indicesGet("indices",e),u=Array.from(Array(c.length).keys()).map(g=>`uniforms.sizeInConcatAxis${g}`).join(","),f=g=>`

  ${(()=>{g.registerUniform("outputSize","u32");for(let w=0;w<n.length;w++)g.registerUniform(`sizeInConcatAxis${w}`,"u32");return g.declareVariables(...l,i)})()}

  ${of(c.length,u)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${i.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${r});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${c.length}u>(${u});
      ${r} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${af(l,i)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:t,dataType:s}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:h}),getShaderSource:f}},Pu=(n,e)=>{let t=n.inputs,s=t[0].dims,a=k.normalizeAxis(e.axis,s.length);nf(t,a);let c=s.slice();c[a]=t.reduce((_,m)=>_+(m.dims.length>a?m.dims[a]:0),0);let l=t.filter(_=>k.size(_.dims)>0);n.compute(sf(l,a,c,t[0].dataType),{inputs:l})},zu=n=>J({axis:n.axis})}),Fe,qe,je,Kr,bt=U(()=>{ee(),ne(),Fe=(n,e,t="f32")=>{switch(n.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${t}(uniforms.clip_min)), ${e}(${t}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${t}(uniforms.alpha) * value + ${t}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${t}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${n.activation}`)}},qe=(n,e)=>{n.activation==="Clip"?e.push({type:1,data:n.clipMax},{type:1,data:n.clipMin}):n.activation==="HardSigmoid"?e.push({type:1,data:n.alpha},{type:1,data:n.beta}):n.activation==="LeakyRelu"&&e.push({type:1,data:n.alpha})},je=(n,e)=>{n.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):n.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):n.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},Kr=n=>{let e=n?.activation||"";if(e==="HardSigmoid"){let[t,s]=n?.activation_params||[.2,.5];return{activation:e,alpha:t,beta:s}}else if(e==="Clip"){let[t,s]=n?.activation_params||[Wa,La];return{activation:e,clipMax:s,clipMin:t}}else if(e==="LeakyRelu"){let[t]=n?.activation_params||[.01];return{activation:e,alpha:t}}return{activation:e}}}),Ie,Bu,Zr=U(()=>{Ie=(n,e)=>{switch(n){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component is not supported.`)}},Bu=n=>`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Du,Mu=U(()=>{Du=n=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${n}.x), i32(${n}.y), i32(${n}.z), 1));
}
`}),Xt,Qr,Yr=U(()=>{ee(),ne(),ie(),bt(),Xt=(n,e,t,s,a)=>{let c=s-t;return`
      ${Array.from({length:t}).map((l,_)=>`
      if (${F(e.shape,_,e.rank)} != 1) {
        ${e.indicesSet(n,_,F(a,_+c,s))}
      } else {
        ${e.indicesSet(n,_,0)}
      }`).join("")}
`},Qr=(n,e,t,s,a=!1,c)=>{let l=n[0].dims,_=n[1].dims,m=l[l.length-2],d=_[_.length-1],h=l[l.length-1],i=ce(d),r=ce(h),u=ce(m),f=k.size(t)/i/u,g=n.length>2,w=s?s.slice(0,-2):t.slice(0,-2),y=[k.size(w),m,d],x=[{type:12,data:f},{type:12,data:m},{type:12,data:d},{type:12,data:h}];qe(e,x),x.push(...N(w,l,_)),g&&x.push(...N(n[2].dims)),x.push(...N(y));let S=T=>{let E=Lr("batch_dims",n[0].dataType,w.length),A=P("a",n[0].dataType,l.length,r),C=P("b",n[1].dataType,_.length,i),I=M("output",n[0].dataType,y.length,i),D=be(I.type.tensor),R=Fe(e,I.type.value,D),Y=[A,C],re="";if(g){let q=a?i:1;Y.push(P("bias",n[2].dataType,n[2].dims.length,q)),re=`${a?`value += bias[col / ${q}];`:`value += ${I.type.value}(bias[row + i]);`}`}let G=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];je(e,G);let te=()=>{let q=`var a_data: ${A.type.value};`;for(let z=0;z<r;z++)q+=`
              let b_data${z} = b[(b_offset + (k + ${z}) * uniforms.N + col) / ${i}];`;for(let z=0;z<u;z++){q+=`a_data = a[(a_offset + (row + ${z}) * uniforms.K + k) / ${r}];`;for(let H=0;H<r;H++)q+=`
            values[${z}] = fma(${C.type.value}(a_data${r===1?"":`[${H}]`}), b_data${H}, values[${z}]);
`}return q};return`
  ${T.registerUniforms(G).registerInternalVariables(E).declareVariables(...Y,I)}
  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${i})) * ${i};
    var index1 = global_idx / (uniforms.N / ${i});
    let stride1 = uniforms.M / ${u};
    let row = (index1 % stride1) * ${u};
    let batch = index1 / stride1;

    ${t.length===2?"":`let batch_indices = ${E.offsetToIndices("batch")};`}

    var a_indices: ${A.type.indices};
    ${Xt("a_indices",A,A.rank-2,E.rank,"batch_indices")}
    ${A.indicesSet("a_indices",A.rank-2,0)}
    ${A.indicesSet("a_indices",A.rank-1,0)}
    let a_offset = ${A.indicesToOffset("a_indices")};

    var b_indices: ${C.type.indices};
    ${Xt("b_indices",C,C.rank-2,E.rank,"batch_indices")}
    ${C.indicesSet("b_indices",C.rank-2,0)}
    ${C.indicesSet("b_indices",C.rank-1,0)}
    let b_offset = ${C.indicesToOffset("b_indices")};
    var values: array<${I.type.value}, ${u}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${r}) {
      ${te()}
    }
    for (var i = 0u; i < ${u}u; i++) {
      var value = values[i];
      ${re}
      ${R}
      let cur_indices = ${I.type.indices}(batch, row + i, col);
      let offset = ${I.indicesToOffset("cur_indices")};
      ${I.setByOffset(`offset / ${i}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${i};${r};${u};${a}`,inputDependencies:g?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:c?c(t):t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:x}),getShaderSource:S}}}),uf,df,mo,Ru,lf,fo,cf,Jt,Xr=U(()=>{ee(),ne(),ie(),bt(),Yr(),Zr(),uf=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,df=(n,e)=>n?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,mo=(n,e,t="f32",s,a=!1,c=32,l=!1,_=32)=>{let m=e[1]*n[1],d=e[0]*n[0],h=a?m:c,i=a?c:m,r=h/e[0],u=c/e[1];if(!((a&&r===4&&n[1]===4||!a&&(r===3||r===4))&&h%e[0]===0&&c%e[1]===0&&n[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${r} and workPerThread[1] ${n[1]} must be 4.
      Otherwise, innerElementSize ${r} must be 3 or 4.
  tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}. tileInner ${c} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${r}<${t}>, ${h/r}>, ${i}>;
var<workgroup> mm_Bsub: array<array<vec4<${t}>, ${d/n[0]}>, ${c}>;

const rowPerThread = ${n[1]};
const colPerThread = ${n[0]};
const innerElementSize = ${r};
const tileInner = ${c};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${l?"0":"i32(globalId.z)"};
  ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${m};

  let num_tiles = ${l?`${Math.ceil(_/c)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${l?`i32(globalId.z) * ${_}`:"0"};

  var acc: array<vec4<${t}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${u};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${uf(a,s)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${u}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${s?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${r===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${df(a,r)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Ru=(n,e)=>n?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,lf=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",fo=(n,e,t="f32",s,a=!1,c=32,l=!1,_=32,m=!1)=>{let d=n[1]*e[1],h=n[0]*e[0],i=a?d:c,r=a?c:d;if(!(r%e[1]===0&&i%e[0]===0&&c%e[1]===0))throw new Error(`tileAHight ${r} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${i} must be divisible by workgroupSize[0]${e[0]}, tileInner ${c} must be divisible by workgroupSize[1]${e[1]}`);let u=r/e[1],f=i/e[0],g=c/e[1],w=m?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${d};
    let globalColStart = i32(workgroupId.x) * ${h};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${e[0]}) {
          ${Ru(a,s)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${s?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${t}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${d};

let tileRowA = i32(localId.y) * ${u};
let tileColA = i32(localId.x) * ${f};
let tileRowB = i32(localId.y) * ${g};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${u}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Ru(a,s)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${s?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${t}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${lf(a)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${t}, ${i}>, ${r}>;
  var<workgroup> mm_Bsub : array<array<${t}, ${h}>, ${c}>;
  const rowPerThread = ${n[1]};
  const colPerThread = ${n[0]};
  const tileInner = ${c};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${l?"0":"i32(globalId.z)"};
    ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${l?`${Math.ceil(_/c)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${l?`i32(globalId.z) * ${_}`:"0"};

    var acc : array<array<${t}, colPerThread>, rowPerThread>;
    ${w}
  }
`},cf=(n,e,t,s,a=!1)=>{let[c,l,_,m]=s,d=be(s[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${c.type.indices}) -> ${Ie(n,d)} {
      var value = ${Ie(n,d)}(0.0);
      let col = colIn * ${n};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${l.type.indices};
        ${Xt("aIndices",l,l.rank-2,c.rank,"batchIndices")}
        ${l.indicesSet("aIndices",l.rank-2,"u32(row)")}
        ${l.indicesSet("aIndices",l.rank-1,"u32(colIn)")}
        value = ${l.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${c.type.indices}) -> ${Ie(n,d)} {
      var value = ${Ie(n,d)}(0.0);
      let col = colIn * ${n};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${_.type.indices};
        ${Xt("bIndices",_,_.rank-2,c.rank,"batchIndices")}
        ${_.indicesSet("bIndices",_.rank-2,"u32(row)")}
        ${_.indicesSet("bIndices",_.rank-1,"u32(colIn)")}
        value = ${_.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ie(n,d)}) {
      let col = colIn * ${n};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${a?"bias[colIn]":`${Ie(n,d)}(bias[row])`};`:""}
        ${t}
        ${m.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Jt=(n,e,t,s,a=!1,c)=>{let l=n[0].dims,_=n[1].dims,m=l.slice(0,-2),d=_.slice(0,-2),h=s?s.slice(0,-2):t.slice(0,-2),i=k.size(h),r=l[l.length-2],u=l[l.length-1],f=_[_.length-1],g=u%4===0&&f%4===0,w=r<=8?[4,1,1]:[4,4,1],y=[8,8,1],x=[Math.ceil(f/y[0]/w[0]),Math.ceil(r/y[1]/w[1]),Math.ceil(i/y[2]/w[2])],S=g?4:1,T=[...m,r,u/S],E=T.length,A=[...d,u,f/S],C=A.length,I=[i,r,f/S],D=[{type:6,data:r},{type:6,data:f},{type:6,data:u}];qe(e,D),D.push(...N(h,T,A));let R=["rank","rank"],Y=n.length>2;Y&&(D.push(...N(n[2].dims)),R.push("rank")),D.push(...N(I));let re=G=>{let te=h.length,q=Lr("batchDims",n[0].dataType,te,1),z=be(n[0].dataType),H=P("a",n[0].dataType,E,S),he=P("b",n[1].dataType,C,S),Ce=M("result",n[0].dataType,I.length,S),oe=[H,he];if(Y){let Ze=a?S:1;oe.push(P("bias",n[2].dataType,n[2].dims.length,Ze))}let K=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];je(e,K);let Q=be(Ce.type.tensor),de=Fe(e,Ce.type.value,Q),ue=cf(S,Y,de,[q,H,he,Ce],a);return`
  ${G.registerUniforms(K).registerInternalVariables(q).declareVariables(...oe,Ce)}
  ${ue}
  ${g?mo(w,y,z,q):fo(w,y,z,q)}
                   `};return{name:"MatMul",shaderCache:{hint:`${w};${e.activation};${g};${a}`,inputDependencies:R},getRunData:()=>({outputs:[{dims:c?c(t):t,dataType:n[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]},programUniforms:D}),getShaderSource:re}}}),pf,Uu,Nu=U(()=>{ee(),Xe(),ie(),bt(),Zr(),Mu(),Xr(),pf=(n,e,t,s,a=!1,c,l=4,_=4,m=4,d="f32")=>{let h=D=>{switch(D){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},i=D=>{switch(D){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},r=n?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,u=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,f=n?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",g=n?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",w=n?"row":"col",y=n?"col":"row",x=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${w} / outWidth;
    let outCol = ${w} % outWidth;

    let WRow = ${y} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${y} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${y} % inChannels;
    var resData = ${Ie(l,d)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${g}) {
      ${r}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${h(l)}
    }
    return resData;`,S=n?e&&s?`
    let col = colIn * ${l};
    ${x}`:`
    let col = colIn * ${l};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${x}
    }
    return ${Ie(l,d)}(0.0);`:s&&t?`
    let col = colIn * ${l};
    ${x}`:`
    let col = colIn * ${l};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${x}
    }
    return ${Ie(l,d)}(0.0);`,T=n?s&&t?i(_):`
    let col = colIn * ${_};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${i(_)}
    }
    return ${Ie(_,d)}(0.0);`:`
    let col = colIn * ${_};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${i(_)}
    }
    return ${Ie(_,d)}(0.0);`,E=Ie(m,d),A=Ie(n?l:_,d),C=Ie(n?_:l,d),I=Fe(c,E,d);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${A} {
      ${n?S:T}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${C} {
      ${n?T:S}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${E}) {
      let col = colIn * ${m};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${u}
      ${Bu(a)}
      ${I}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Uu=(n,e,t,s,a,c,l,_,m)=>{let d=e.format==="NHWC",h=d?n[0].dims[3]:n[0].dims[1],i=t[0],r=d?t[2]:t[3],u=d?t[1]:t[2],f=d?t[3]:t[1],g=d&&(h%4===0||h%3===0)&&f%4===0,w=d?f:r*u,y=d?r*u:f,x=[8,8,1],S=s<=8?[4,1,1]:[4,4,1],T=[Math.ceil(w/x[0]/S[0]),Math.ceil(y/x[1]/S[1]),Math.ceil(i/x[2]/S[2])];se("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${T}`);let E=g?d&&h%4!==0?3:4:1,A=x[1]*S[1],C=x[0]*S[0],I=Math.max(x[0]*E,x[1]),D=s%A===0,R=a%C===0,Y=c%I===0,re=g?[E,4,4]:[1,1,1],G=[{type:6,data:s},{type:6,data:a},{type:6,data:c},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];qe(e,G),G.push(...N(n[0].dims,n[1].dims));let te=["rank","rank"];l&&(G.push(...N(n[2].dims)),te.push("rank")),G.push(...N(t));let q=z=>{let H=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];je(e,H);let he=g?4:1,Ce=be(n[0].dataType),oe=`
      fn setOutputAtIndex(flatIndex : i32, value : ${g?`vec4<${Ce}>`:Ce}) {
        result[flatIndex] = ${g?`vec4<${Ce}>`:Ce}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${g?`vec4<${Ce}>`:Ce}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${g?"/ 4":""}, value);
      }`,K=P("x",n[0].dataType,n[0].dims.length,E===3?1:E),Q=P("w",n[1].dataType,n[1].dims.length,he),de=[K,Q],ue=M("result",n[0].dataType,t.length,he);if(l){let Ze=P("bias",n[2].dataType,n[2].dims.length,he);de.push(Ze),oe+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${g?`vec4<${Ce}>`:Ce} {
          return bias[coords.${d?"w":"y"}${g?"/ 4":""}];
        }`}return`
        ${Du("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${z.registerUniforms(H).declareVariables(...de,ue)}
        ${oe}
        ${pf(d,D,R,Y,l,e,re[0],re[1],re[2],Ce)}
        ${g?mo(S,x,Ce,void 0,!d,I):fo(S,x,Ce,void 0,!d,I,!1,void 0,_)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${E};${g};${D};${R};${Y};${A};${C};${I}`,inputDependencies:te},getRunData:()=>({outputs:[{dims:m?m(t):t,dataType:n[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:G}),getShaderSource:q}}}),mf,Vu,Jr,ff,Wu,hf,Lu,Gu,Hu=U(()=>{ee(),Xe(),ne(),ie(),bt(),Zr(),mf=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e},Vu=n=>typeof n=="number"?[n,n,n]:n,Jr=(n,e)=>e<=1?n:n+(n-1)*(e-1),ff=(n,e,t,s=1)=>{let a=Jr(e,s);return Math.floor((n[0]*(t-1)-t+a)/2)},Wu=(n,e,t,s,a)=>{a==null&&(a=ff(n,e[0],s[0]));let c=[0,0,0,t];for(let l=0;l<3;l++)n[l]+2*a>=e[l]&&(c[l]=Math.trunc((n[l]-e[l]+2*a)/s[l]+1));return c},hf=(n,e,t,s,a,c,l,_,m,d)=>{let h,i,r,u;if(n==="VALID"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n};let f=Wu([e,t,s,1],[_,m,d],1,[a,c,l],n);i=f[0],r=f[1],u=f[2]}else if(Array.isArray(n)){if(!n.every((g,w,y)=>g===y[0]))throw Error(`Unsupported padding parameter: ${n}`);h={top:n[0],bottom:n[1],left:n[2],right:n[3],front:n[4],back:n[5]};let f=Wu([e,t,s,1],[_,m,d],1,[a,c,l],n[0]);i=f[0],r=f[1],u=f[2]}else if(n==="SAME_UPPER"){i=Math.ceil(e/a),r=Math.ceil(t/c),u=Math.ceil(s/l);let f=(i-1)*a+_-e,g=(r-1)*c+m-t,w=(u-1)*l+d-s,y=Math.floor(f/2),x=f-y,S=Math.floor(g/2),T=g-S,E=Math.floor(w/2),A=w-E;h={top:S,bottom:T,left:E,right:A,front:y,back:x}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:i,outHeight:r,outWidth:u}},Lu=(n,e,t,s,a,c=!1,l="channelsLast")=>{let _,m,d,h,i;if(l==="channelsLast")[_,m,d,h,i]=n;else if(l==="channelsFirst")[_,i,m,d,h]=n;else throw new Error(`Unknown dataFormat ${l}`);let[r,,u,f,g]=e,[w,y,x]=Vu(t),[S,T,E]=Vu(s),A=Jr(u,S),C=Jr(f,T),I=Jr(g,E),{padInfo:D,outDepth:R,outHeight:Y,outWidth:re}=hf(a,m,d,h,w,y,x,A,C,I),G=c?r*i:r,te=[0,0,0,0,0];return l==="channelsFirst"?te=[_,G,R,Y,re]:l==="channelsLast"&&(te=[_,R,Y,re,G]),{batchSize:_,dataFormat:l,inDepth:m,inHeight:d,inWidth:h,inChannels:i,outDepth:R,outHeight:Y,outWidth:re,outChannels:G,padInfo:D,strideDepth:w,strideHeight:y,strideWidth:x,filterDepth:u,filterHeight:f,filterWidth:g,effectiveFilterDepth:A,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:S,dilationHeight:T,dilationWidth:E,inShape:n,outShape:te,filterShape:e}},Gu=(n,e,t,s,a,c)=>{let l=c==="channelsLast";l?n[0].dims[3]:n[0].dims[1];let _=[64,1,1],m={x:t.map((w,y)=>y)},d=[Math.ceil(mf(m.x.map(w=>t[w]))/_[0]),1,1];se("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${d}`);let h=1,i=k.size(t),r=[{type:12,data:i},{type:12,data:s},{type:12,data:a},{type:12,data:e.strides},{type:12,data:e.dilations}];qe(e,r),r.push(...N(n[0].dims,n[1].dims));let u=["rank","rank"],f=n.length===3;f&&(r.push(...N(n[2].dims)),u.push("rank")),r.push(...N(t));let g=w=>{let y=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:s.length},{name:"pads",type:"u32",length:a.length},{name:"strides",type:"u32",length:e.strides.length},{name:"dilations",type:"u32",length:e.dilations.length}];je(e,y);let x=1,S=be(n[0].dataType),T=P("x",n[0].dataType,n[0].dims.length,h),E=P("W",n[1].dataType,n[1].dims.length,x),A=[T,E],C=M("result",n[0].dataType,t.length,x),I="";if(f){let Y=P("bias",n[2].dataType,n[2].dims.length,x);A.push(Y),I+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${S} {
          return bias[${l?F("coords",4,5):F("coords",1,5)}];
        }`}let D=Ie(h,S),R=Fe(e,D,S);return`
            ${I}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${T.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${E.getByIndices("aIndices")};
            }
          ${w.registerUniforms(y).declareVariables(...A,C)}
          ${w.mainStart()}
          ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${C.offsetToIndices("global_idx")};
              let batch = ${F("coords",0,T.rank)};
              let d2 = ${l?F("coords",T.rank-1,T.rank):F("coords",1,T.rank)};
              let xFRCCorner = vec3<u32>(${l?F("coords",1,T.rank):F("coords",2,T.rank)},
              ${l?F("coords",2,T.rank):F("coords",3,T.rank)},
              ${l?F("coords",3,T.rank):F("coords",4,T.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${l?F("uniforms.x_shape",1,T.rank):F("uniforms.x_shape",2,T.rank)};
              let xShapeZ = ${l?F("uniforms.x_shape",2,T.rank):F("uniforms.x_shape",3,T.rank)};
              let xShapeW = ${l?F("uniforms.x_shape",3,T.rank):F("uniforms.x_shape",4,T.rank)};
              let xShapeU = ${l?F("uniforms.x_shape",4,T.rank):F("uniforms.x_shape",1,T.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${l?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${l?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${l?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${l?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${f?"value = value + getBiasByOutputCoords(coords)":""};
              ${R}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${e.cacheKey};${l};${h};${f}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:d[0],y:d[1],z:d[2]},programUniforms:r}),getShaderSource:g}}}),Fu,qu,ju=U(()=>{ee(),ne(),ie(),bt(),Fu=(n,e,t,s)=>{let a=n.length>2,c=a?"value += b[output_channel];":"",l=n[0].dims,_=n[1].dims,m=e.format==="NHWC",d=m?t[3]:t[1],h=d/e.group,i=m&&h>=4?ce(d):1,r=k.size(t)/i,u=[{type:12,data:r},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:h}];qe(e,u),u.push(...N(l,[_[0],_[1],_[2],_[3]/i]));let f=a?["rank","rank","rank"]:["rank","rank"];u.push(...N([t[0],t[1],t[2],t[3]/i]));let g=w=>{let y=M("output",n[0].dataType,t.length,i),x=be(y.type.tensor),S=Fe(e,y.type.value,x),T=P("x",n[0].dataType,l.length),E=P("w",n[1].dataType,_.length,i),A=[T,E];a&&A.push(P("b",n[2].dataType,n[2].dims,i));let C=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];je(e,C);let I=m?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${T.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${E.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${T.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${E.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${w.registerUniforms(C).declareVariables(...A,y)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${y.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${m?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${m?1:2}], outputIndices[${m?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${i} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${m?2:1}];

    var value: ${y.type.value} = ${y.type.value}(0);
    ${I}
    ${c}
    ${S}
    ${y.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${e.cacheKey}_${i}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:s?s(t):t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:u}),getShaderSource:g}},qu=(n,e,t,s)=>{let a=n.length>2,c=ce(t[3]),l=ce(t[2]),_=k.size(t)/c/l,m=[n[0].dims[0],n[0].dims[1],n[0].dims[2],n[0].dims[3]/c],d=[n[1].dims[0],n[1].dims[1],n[1].dims[2],n[1].dims[3]/c],h=[t[0],t[1],t[2],t[3]/c],i=[{type:12,data:_},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];qe(e,i),i.push(...N(m,d,h));let r=(l-1)*e.strides[1]+d[1],u=f=>{let g=M("output",n[0].dataType,h.length,c),w=be(g.type.tensor),y=Fe(e,g.type.value,w),x=P("x",n[0].dataType,m.length,c),S=P("w",n[1].dataType,d.length,c),T=[x,S];a&&T.push(P("b",n[2].dataType,n[2].dims,c));let E=a?"value += b[output_channel];":"",A=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return je(e,A),`
  ${f.registerUniforms(A).declareVariables(...T,g)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${l}u;
    let col = (index1 % width1) * ${l}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${r}>;
    var values: array<${g.type.value}, ${l}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${d[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${r}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${d[1]}; w_width++) {
          let w_val = ${S.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${l}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${l}u; i++) {
      var value = values[i];
      ${E}
      ${y}
      ${g.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${c};${l};${r};${d[0]};${d[1]}`,inputDependencies:a?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(t):t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:i}),getShaderSource:u}}}),gf,ho,bf,go,bo,Ku,yf,_f,yo,Zu=U(()=>{ne(),Nu(),Hu(),Xr(),ju(),bt(),Yr(),st(),gf=(n,e,t,s,a,c)=>{let l=n[0],_=n.slice(c?1:2,c?3:4),m=_.length,d=e[0],h=e.slice(2).map((r,u)=>r+(r-1)*(t[u]-1)),i=_.map((r,u)=>r+s[u]+s[u+m]).map((r,u)=>Math.floor((r-h[u]+a[u])/a[u]));return i.splice(0,0,l),i.splice(c?3:1,0,d),i},ho=[2,3,1,0],bf=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length>5)throw new Error("greater than 5D is not supported");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let t=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],s=n[1].dims[1]*e.group;if(t!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let a=n[0].dims.length-2;if(e.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(e.strides.length!==a)throw new Error(`strides should be ${a}D`);if(e.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape")},go=(n,e)=>{let t=n.kernelShape.slice();t.length<e[1].dims.length-2&&t.push(...Array(e[1].dims.length-2-t.length).fill(0));for(let c=2;c<e[1].dims.length;++c)t[c-2]===0&&(t[c-2]=e[1].dims[c]);let s=n.pads.slice();Tt.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,t,s,n.format==="NHWC",n.autoPad);let a=Object.assign({},n);return Object.assign(a,{kernelShape:t,pads:s}),a},bo=n=>{let e=Kr(n),t=n.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],a=n.dilations,c=n.group,l=n.kernel_shape,_=n.pads,m=n.strides,d=n.w_is_const();return{autoPad:s,format:t,dilations:a,group:c,kernelShape:l,pads:_,strides:m,wIsConst:d,...e,cacheKey:`${n.format};${e.activation};`}},Ku=(n,e,t,s)=>{let a=t.format==="NHWC",c=gf(e[0].dims,e[1].dims,t.dilations,t.pads,t.strides,a);if(t.group!==1){let A=[e[0]];if(a){let C=n.kernelCustomData.wT??n.compute(Ee(e[1],ho),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=C),A.push(C)}else A.push(e[1]);e.length===3&&A.push(e[2]),!n.adapterInfo.isArchitecture("ampere")&&a&&e[1].dims[0]===t.group&&e[1].dims[1]===1&&t.dilations[0]===1&&t.dilations[1]===1?n.compute(qu(A,t,c,s),{inputs:A}):n.compute(Fu(A,t,c,s),{inputs:A});return}let l=e.length===3,_=e[0].dims[a?1:2],m=e[0].dims[a?2:3],d=e[0].dims[a?3:1],h=e[1].dims[2],i=e[1].dims[3],r=c[a?1:2],u=c[a?2:3],f=c[a?3:1],g=a&&h===_&&i===m&&t.pads[0]===0&&t.pads[1]===0;if(g||h===1&&i===1&&t.dilations[0]===1&&t.dilations[1]===1&&t.strides[0]===1&&t.strides[1]===1&&t.pads[0]===0&&t.pads[1]===0){let A=c[0],C,I,D,R=[];if(a){let G=n.kernelCustomData.wT??n.compute(Ee(e[1],ho),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];if(t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=G),g){let te=_*m*d;C=e[0].reshape([1,A,te]),I=G.reshape([1,te,f]),D=[1,A,f]}else C=e[0].reshape([A,_*m,d]),I=G.reshape([1,d,f]),D=[A,r*u,f];R.push(C),R.push(I)}else C=e[0].reshape([A,d,_*m]),I=e[1].reshape([1,f,d]),D=[A,f,r*u],R.push(I),R.push(C);l&&R.push(e[2]);let Y=D[2],re=R[0].dims[R[0].dims.length-1];Y<8&&re<8?n.compute(Qr(R,t,c,D,a,s),{inputs:R}):n.compute(Jt(R,t,c,D,a,s),{inputs:R});return}let w=!0,y=n.kernelCustomData.wT??n.compute(Ee(e[1],ho),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=y);let x=[e[0],y];l&&x.push(e[2]);let S=a?r*u:f,T=a?f:r*u,E=h*i*d;n.compute(Uu(x,t,c,S,T,E,l,w,s),{inputs:x})},yf=(n,e)=>{let t=e.format==="NHWC",s=[n.inputs[0].reshape(t?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&s.push(n.inputs[2]);let a=[0,e.pads[0],0,e.pads[1]],c=[1].concat(e.strides),l=[1].concat(e.dilations),_=[1].concat(e.kernelShape),m=go({...e,pads:a,strides:c,dilations:l,kernelShape:_},s);Ku(n,s,m,d=>t?[d[0],d[2],d[3]]:[d[0],d[1],d[3]])},_f=(n,e,t)=>{let s=t.format==="NHWC"?"channelsLast":"channelsFirst",a=go(t,e),c=t.autoPad==="NOTSET"?t.pads:t.autoPad,l=Lu(e[0].dims,e[1].dims,t.strides,t.dilations,c,!1,s);n.compute(Gu(e,a,l.outShape,[l.filterDepth,l.filterHeight,l.filterWidth],[l.padInfo.front,l.padInfo.top,l.padInfo.left],s))},yo=(n,e)=>{if(bf(n.inputs,e),n.inputs[0].dims.length===3)yf(n,e);else if(n.inputs[0].dims.length===5)_f(n,n.inputs,e);else{let t=go(e,n.inputs);Ku(n,n.inputs,t)}}}),Qu,Yu=U(()=>{ee(),Xe(),ne(),ie(),Qu=(n,e,t)=>{let s=n.length>2,a=e.outputShape,c=e.format==="NHWC",l=e.group,_=n[1].dims,m=_[2]/l,d=_[3],h=c?ce(m):1,i=c&&d===1&&m>=4,r=i?Math.floor(m/4)*4:Math.floor(m/h)*h,u=m-r,f=c?ce(d):1,g=c?d===1?h:f:1,w=k.size(a)/f,y=[Math.ceil(w/64),1,1];se("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let x=["rank","rank"],S=[e.strides[0],e.strides[1]],T=[e.kernelShape[c?1:2],e.kernelShape[c?2:3]],E=[e.dilations[0],e.dilations[1]],A=[T[0]+(e.dilations[0]<=1?0:(e.kernelShape[c?1:2]-1)*(e.dilations[0]-1)),T[1]+(e.dilations[1]<=1?0:(e.kernelShape[c?2:3]-1)*(e.dilations[1]-1))],C=[A[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),A[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],I=[{type:12,data:w},{type:12,data:S},{type:12,data:T},{type:12,data:E},{type:12,data:A},{type:6,data:C},{type:12,data:r},{type:12,data:m},{type:12,data:d},...N(n[0].dims,n[1].dims)];s&&(I.push(...N(n[2].dims)),x.push("rank")),I.push(...N(a));let D=R=>{let Y=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:S.length},{name:"filter_dims",type:"u32",length:T.length},{name:"dilations",type:"u32",length:T.length},{name:"effective_filter_dims",type:"u32",length:A.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],re=be(n[0].dataType),G=c?1:2,te=c?2:3,q=c?3:1,z=P("W",n[1].dataType,n[1].dims.length,g),H=P("Dy",n[0].dataType,n[0].dims.length,h),he=[H,z];s&&he.push(P("bias",n[2].dataType,[a[q]].length,f));let Ce=M("result",n[0].dataType,a.length,f),oe=()=>{let de="";if(i)h===4?de+=`
        let xValue = ${H.getByOffset("x_offset")};
        let wValue = ${z.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:h===2?de+=`
          dotProd = dotProd + dot(vec4<${re}>(${H.getByOffset("x_offset")}, ${H.getByOffset("x_offset + 1u")}), vec4<${re}>(${z.getByOffset("w_offset")}, ${z.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:h===1&&(de+=`
          dotProd = dotProd + dot(vec4<${re}>(${H.getByOffset("x_offset")}, ${H.getByOffset("x_offset + 1u")}, ${H.getByOffset("x_offset + 2u")}, ${H.getByOffset("x_offset + 3u")}), vec4<${re}>(${z.getByOffset("w_offset")}, ${z.getByOffset("w_offset + 1u")}, ${z.getByOffset("w_offset + 2u")}, ${z.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(de+=`
                  let xValue = ${c?H.getByOffset(`${H.indicesToOffset(`${H.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${h}`):H.get("batch","inputChannel","idyR","idyC")};
        `,h===1)de+=`
          let w_offset = ${z.indicesToOffset(`${z.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${z.getByOffset(`w_offset / ${g}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let ue=0;ue<h;ue++)de+=`
            let wValue${ue} = ${z.getByOffset(`${z.indicesToOffset(`${z.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${ue}, wOutChannel)`)} / ${g}`)};
            dotProd = dotProd + xValue[${ue}] * wValue${ue};`;return de},K=()=>{if(u===0)return"";if(!i)throw new Error(`packInputAs4 ${i} is not true.`);let de="";if(h===1){de+="dotProd = dotProd";for(let ue=0;ue<u;ue++)de+=`
            + ${H.getByOffset(`x_offset + ${ue}`)} * ${z.getByOffset(`w_offset + ${ue}`)}`;de+=";"}else if(h===2){if(u!==2)throw new Error(`Invalid inputChannelsRemainder ${u}.`);de+=`
          let xValue = ${H.getByOffset("x_offset")};
          let wValue = ${z.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return de},Q=`
            let outputIndices = ${Ce.offsetToIndices(`global_idx * ${f}`)};
            let batch = ${Ce.indicesGet("outputIndices",0)};
            let d1 = ${Ce.indicesGet("outputIndices",q)};
            let r = ${Ce.indicesGet("outputIndices",G)};
            let c = ${Ce.indicesGet("outputIndices",te)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${Ce.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${re}(dyRCorner) + ${re}(wR)) / ${re}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${re}(uniforms.Dy_shape[${G}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${re}(dyCCorner) + ${re}(wC)) / ${re}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${re}(uniforms.Dy_shape[${te}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${i?`
                var x_offset = ${H.indicesToOffset(`${H.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${h};
                var w_offset = ${z.indicesToOffset(`${z.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${g};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${i?4:h}) {
                  ${oe()}
                  inputChannel = inputChannel + ${i?4:h};
                }
                ${K()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${s?` + bias[d1 / ${f}]`:""};
            ${Ce.setByOffset("global_idx","value")};
          `;return`
    ${R.registerUniforms(Y).declareVariables(...he,Ce)}
      ${R.mainStart()}
      ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${Q}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};${h}${g}${f}${i}${u}`,inputDependencies:x},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:t?t(a):a,dataType:n[0].dataType}],programUniforms:I}),getShaderSource:D}}}),wf,vf,$f,Xu,Ju,xf,ed,Sf,td,rd=U(()=>{Yu(),bt(),st(),wf=(n,e,t,s,a,c)=>(n-1)*e+t+(s-1)*a+1-c,vf=(n,e,t,s,a)=>{let c=Math.floor(n/2);e==="SAME_UPPER"?(t[s]=c,t[a]=n-c):e==="SAME_LOWER"&&(t[s]=n-c,t[a]=c)},$f=(n,e,t,s,a,c,l,_,m,d)=>{let h=n.length-2,i=d.length===0;m.length<h&&m.push(...Array(h-m.length).fill(0));let r=n[0],u=e[_?3:1]*a;for(let f=0,g=n.length-h-(_?1:0);f<h;++f,++g){let w=n[g],y=i?w*l[f]:d[f],x=wf(w,l[f],c[f],e[g],t[f],y);vf(x,s,c,f,f+h),i&&d.push(l[f]*(w-1)+m[f]+(e[g]-1)*t[f]+1-c[f]-c[f+h])}d.splice(0,0,r),d.splice(_?3:1,0,u)},Xu=(n,e)=>{let t=n.kernelShape.slice();if(n.kernelShape.length===0||n.kernelShape.reduce((i,r)=>i*r,1)===0){t.length=0;for(let i=2;i<e[1].dims.length;++i)t.push(e[1].dims[i])}let s=n.format==="NHWC";t.splice(0,0,e[1].dims[0]),t.splice(s?3:1,0,e[1].dims[1]);let a=n.pads.slice(),c=n.outputShape.slice(),l=n.outputPadding.slice(),_=e[0].dims,m=n.dilations.slice();if(m.reduce((i,r)=>i+r,0)===0){let i=e[0].dims.length-2;m=new Array(i).fill(1)}let d=n.strides.slice();if(d.reduce((i,r)=>i+r,0)===0){let i=e[0].dims.length-2;d=new Array(i).fill(1)}$f(_,t,m,n.autoPad,n.group,a,d,s,l,c);let h=Object.assign({},n);return Object.assign(h,{kernelShape:t,pads:a,outputPadding:l,outputShape:c,dilations:m,strides:d}),h},Ju=n=>{let e=Kr(n),t=n.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof n.autoPad>"u"?0:n.autoPad],a=n.dilations,c=n.group,l=n.kernelShape,_=n.pads,m=n.strides,d=n.wIsConst(),h=n.outputPadding,i=n.outputShape;return{autoPad:s,format:t,dilations:a,group:c,kernelShape:l,outputPadding:h,outputShape:i,pads:_,strides:m,wIsConst:d,...e,cacheKey:`${n.format};${e.activation};`}},xf=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let t=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],s=n[1].dims[0];if(t!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=n[1].dims[1]*e.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==a))throw new Error("invalid bias");let c=n[0].dims.length-2;if(e.dilations.reduce((l,_)=>l+_,0)>0&&e.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(e.strides.reduce((l,_)=>l+_,0)>0&&e.strides.length!==c)throw new Error(`strides should be ${c}D`);if(e.pads.reduce((l,_)=>l+_,0)>0&&e.pads.length!==c*2)throw new Error(`pads should be ${c*2}D`);if(e.outputPadding.length!==c&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${c}D`);if(e.kernelShape.reduce((l,_)=>l+_,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape")},ed=(n,e,t,s)=>{let a=n.kernelCustomData.wT??n.compute(Ee(e[1],[2,3,0,1]),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=a);let c=[e[0],a];e.length===3&&c.push(e[2]),n.compute(Qu(c,t,s),{inputs:c})},Sf=(n,e)=>{let t=e.format==="NHWC",s=[n.inputs[0].reshape(t?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&s.push(n.inputs[2]);let a=e.kernelShape;(a.length===0||a[0]===0)&&(a=[n.inputs[1].dims[2]]);let c=e.dilations;(c.length===0||c[0]===0)&&(c=[1]);let l=e.strides;(l.length===0||l[0]===0)&&(l=[1]);let _=e.pads;_.length===0&&(_=[0,0]),_=[0,_[0],0,_[1]],l=[1].concat(l),c=[1].concat(c),a=[1].concat(a);let m=e.outputPadding;m=[0].concat(m);let d=Xu({...e,pads:_,strides:l,dilations:c,kernelShape:a,outputPadding:m},s);ed(n,s,d,h=>t?[h[0],h[2],h[3]]:[h[0],h[1],h[3]])},td=(n,e)=>{if(xf(n.inputs,e),n.inputs[0].dims.length===3)Sf(n,e);else{let t=Xu(e,n.inputs);ed(n,n.inputs,t)}}}),Tf,nd,od,id=U(()=>{ee(),ne(),Se(),ie(),Tf=(n,e,t,s)=>{let a=k.size(e),c=e.length,l=P("input",n,c),_=M("output",n,c),m=t.dataType===6?t.getInt32Array()[0]:Number(t.getBigInt64Array()[0]),d=k.normalizeAxis(m,c),h=i=>{let r=` i32(${l.indicesGet("inputIndices","uniforms.axis")}) `,u=F("uniforms.input_shape","uniforms.axis",c),f=s.reverse?r+(s.exclusive?" + 1":""):"0",g=s.reverse?u:r+(s.exclusive?"":" + 1");return`
                ${i.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(l,_)}
                ${i.mainStart()}
                  ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${_.offsetToIndices("global_idx")};
                  var sum = ${_.type.value}(0);
                  let first : i32 = ${f};
                  let last : i32 = ${g};
                  for (var i : i32 = first; i < last; i++) {
                    ${l.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${l.getByIndices("inputIndices")};
                  }
                  ${_.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:s.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:n}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},{type:12,data:d},...N(e,e)]}),getShaderSource:h}},nd=(n,e)=>{let t=n.inputs[0].dims,s=n.inputs[0].dataType,a=n.inputs[1];n.compute(Tf(s,t,a,e),{inputs:[0]})},od=n=>{let e=n.exclusive===1,t=n.reverse===1;return J({exclusive:e,reverse:t})}}),If$1,Cf,Af,ad,sd,ud=U(()=>{ee(),ne(),Se(),ie(),If$1=n=>{if(!n||n.length!==1)throw new Error("DepthToSpace requires 1 input.");if(n[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Cf=(n,e,t,s)=>{let a=[];a.push(`fn perm(i: ${s.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`);for(let c=0;c<e;++c)a.push(t.indicesSet("a",n[c],`i[${c}]`));return a.push("return a;}"),a.join(`
`)},Af=(n,e)=>{let t,s,a,c,l,_,m=e.format==="NHWC",d=e.blocksize,h=e.mode==="DCR";m?([t,s,a,c]=n.dims,l=h?[t,s,a,d,d,c/d**2]:[t,s,a,c/d**2,d,d],_=h?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([t,s,a,c]=[n.dims[0],n.dims[2],n.dims[3],n.dims[1]],l=h?[t,d,d,c/d**2,s,a]:[t,c/d**2,d,d,s,a],_=h?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let i=n.reshape(l),r=i.dims.length,u=n.dataType,f=P("a",u,r),g=M("output",u,r),w=y=>`
  ${y.registerUniform("output_size","u32").declareVariables(f,g)}

  ${Cf(_,r,f,g)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${g.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${g.setByOffset("global_idx",f.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${n.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:y=>{let x=m?[t,s*d,a*d,c/d**2]:[t,c/d**2,s*d,a*d],S=k.size(x),T=i.dims,E=k.sortBasedOnPerm(T,_);return{outputs:[{dims:x,dataType:y[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:[{type:12,data:S},...N(T,E)]}},getShaderSource:w}},ad=(n,e)=>{If$1(n.inputs),n.compute(Af(n.inputs[0],e))},sd=n=>J({blocksize:n.blocksize,mode:n.mode,format:n.format})}),_o,en,dd,Ef,kf,wo,vo,ld,Pf,cd,pd,md=U(()=>{ee(),ne(),Se(),ie(),_o="[a-zA-Z]|\\.\\.\\.",en="("+_o+")+",dd="^"+en+"$",Ef="("+en+",)*"+en,kf="^"+Ef+"$",wo=class{constructor(n=-1){this.symbolToIndices=new Map,this.inputIndex=n}addSymbol(n,e){let t=this.symbolToIndices.get(n);t===void 0?t=[e]:t.push(e),this.symbolToIndices.set(n,t)}},vo=class{constructor(n,e){this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,s]=e.includes("->")?e.split("->",2):[e,""];if(!t.match(RegExp(kf)))throw new Error("Invalid LHS term");if(t.split(",").forEach((a,c)=>{let l=n[c].dims.slice();if(!a.match(RegExp(dd)))throw new Error("Invalid LHS term");let _=this.processTerm(a,!0,l,c);this.lhs.push(_)}),s==="")s+=[...this.symbolToInfo.entries()].filter(([a,c])=>c.count===1||a==="...").map(([a])=>a).join("");else if(!s.match(RegExp(en)))throw new Error("Invalid RHS");s.match(RegExp(_o,"g"))?.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let c=this.symbolToInfo.get(a);if(c===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(c.dimValue)}}),this.rhs=this.processTerm(s,!1,this.outputDims)}addSymbol(n,e,t){let s=this.symbolToInfo.get(n);if(s!==void 0){if(s.dimValue!==e&&s.count!==1)throw new Error("Dimension mismatch");s.count++,s.inputIndices.push(t)}else s={count:1,dimValue:e,inputIndices:[t]};this.symbolToInfo.set(n,s)}processTerm(n,e,t,s=-1){let a=t.length,c=!1,l=[],_=0;if(!n.match(RegExp(dd))&&!e&&n!=="")throw new Error("Invalid LHS term");let m=n.match(RegExp(_o,"g")),d=new wo(s);return m?.forEach((h,i)=>{if(h==="..."){if(c)throw new Error("Only one ellipsis is allowed per input term");c=!0;let r=a-m.length+1;if(r<0)throw new Error("Ellipsis out of bounds");if(l=t.slice(_,_+r),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let u=0;u<l.length;u++){let f=String.fromCharCode(48+u);d.addSymbol(f,i+u),this.addSymbol(f,t[_++],s)}}else d.addSymbol(h,i+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(h,t[_++],s)}),d}},ld=n=>n+"_max",Pf=(n,e,t,s)=>{let a=n.map(d=>d.length).map((d,h)=>P(`input${h}`,e,d)),c=k.size(s),l=M("output",e,s.length),_=[...t.symbolToInfo.keys()].filter(d=>!t.rhs.symbolToIndices.has(d)),m=d=>{let h=[],i="var prod = 1.0;",r="var sum = 0.0;",u="sum += prod;",f=[],g=[],w=[],y=[],x=t.symbolToInfo.size===t.rhs.symbolToIndices.size;t.symbolToInfo.forEach((T,E)=>{if(t.rhs.symbolToIndices.has(E)){let A=t.rhs.symbolToIndices.get(E)?.[0];A!==void 0&&t.lhs.forEach((C,I)=>{if(T.inputIndices.includes(I)){let D=C.symbolToIndices.get(E);if(D===void 0)throw new Error("Invalid symbol error");D.forEach(R=>{h.push(`${a[I].indicesSet(`input${I}Indices`,R,l.indicesGet("outputIndices",A))}`)})}})}else t.lhs.forEach((A,C)=>{if(T.inputIndices.includes(C)){let I=A.symbolToIndices.get(E);if(I===void 0)throw new Error("Invalid symbol error");I.forEach(D=>{f.push(`${a[C].indicesSet(`input${C}Indices`,D,`${E}`)}`)}),y.push(`prod *= ${a[C].getByIndices(`input${C}Indices`)};`)}}),g.push(`for(var ${E}: u32 = 0; ${E} < uniforms.${ld(E)}; ${E}++) {`),w.push("}")});let S=x?[...h,`let sum = ${a.map((T,E)=>T.getByIndices(`input${E}Indices`)).join(" * ")};`]:[...h,r,...g,...f,i,...y,u,...w];return`
            ${d.registerUniforms(_.map(T=>({name:`${ld(T)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...a,l)}

            ${d.mainStart()}
            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${l.offsetToIndices("global_idx")};
            ${a.map((T,E)=>`var input${E}Indices: ${a[E].type.indices};`).join(`
`)}
            ${S.join(`
`)};
            ${l.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:t.equation,inputDependencies:n.map(()=>"rank")},getRunData:()=>{let d=_.filter(i=>t.symbolToInfo.has(i)).map(i=>({type:12,data:t.symbolToInfo.get(i)?.dimValue||0}));d.push({type:12,data:c});let h=n.map((i,r)=>[...N(i)]).reduce((i,r)=>i.concat(r),d);return h.push(...N(s)),{outputs:[{dims:s,dataType:e}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:h}},getShaderSource:m}},cd=(n,e)=>{let t=new vo(n.inputs,e.equation),s=t.outputDims,a=n.inputs.map((c,l)=>c.dims);n.compute(Pf(a,n.inputs[0].dataType,t,s))},pd=n=>{let e=n.equation.replace(/\s+/g,"");return J({equation:e})}}),zf,fd,Of,Bf,hd,gd=U(()=>{ee(),ne(),ie(),zf=n=>{if(!n||n.length!==2)throw new Error("Expand requires 2 input.");let e=n[0].dims,t=Array.from(n[1].getBigInt64Array(),Number),s=t.length<e.length?0:t.length-e.length,a=e.length<t.length?0:e.length-t.length;for(;s<t.length&&a<e.length;++s,++a)if(t[s]!==e[a]&&t[s]!==1&&e[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},fd=(n,e)=>{let t=n.length-e.length,s=[];for(let a=0;a<t;++a)s.push(n[a]);for(let a=0;a<e.length;++a)s.push(e[a]===1?n[a+t]:e[a]);return s},Of=(n,e)=>n.length>e.length?fd(n,e):fd(e,n),Bf=n=>{let e=n[0].dims,t=Array.from(n[1].getBigInt64Array(),Number),s=Of(e,t),a=n[0].dataType,c=a===9||k.size(e)===1,l=a===9||e.length>0&&e[e.length-1]%4===0?4:1,_=c||s.length>0&&s[s.length-1]%4===0?4:1,m=Math.ceil(k.size(s)/_),d=i=>{let r=P("input",a,e.length,l),u=M("output",a,s.length,_),f;if(a===9){let g=(w,y,x="")=>`
          let outputIndices${y} = ${u.offsetToIndices(`outputOffset + ${y}u`)};
          let offset${y} = ${r.broadcastedIndicesToOffset(`outputIndices${y}`,u)};
          let index${y} = offset${y} / 4u;
          let component${y} = offset${y} % 4u;
          ${w}[${y}] = ${x}(${r.getByOffset(`index${y}`)}[component${y}]);
        `;f=`
        let outputOffset = global_idx * ${_};
        var data = vec4<u32>(0);
        ${g("data",0,"u32")}
        ${g("data",1,"u32")}
        ${g("data",2,"u32")}
        ${g("data",3,"u32")}
        ${u.setByOffset("global_idx","data")}
      }`}else f=`
        let outputIndices = ${u.offsetToIndices(`global_idx * ${_}`)};
        let inputOffset = ${r.broadcastedIndicesToOffset("outputIndices",u)};
        let data = ${u.type.value}(${r.getByOffset(`inputOffset / ${l}`)});
        ${u.setByOffset("global_idx","data")}
      }`;return`
    ${i.registerUniform("vec_size","u32").declareVariables(r,u)}
    ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${f}`},h=[{type:12,data:m},...N(e,s)];return{name:"Expand",shaderCache:{hint:`${s.length};${l}${_}`,inputDependencies:["rank"]},getShaderSource:d,getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:h})}},hd=n=>{zf(n.inputs),n.compute(Bf(n.inputs),{inputs:[0]})}}),Df,bd,yd=U(()=>{ee(),ne(),ie(),jr(),Df=n=>{let e=n[0].dataType,t=k.size(n[0].dims),s=k.size(n[1].dims),a=s%4===0,c=l=>{let _=P("x",e,[1],4),m=P("bias",e,[1],4),d=M("y",e,[1],4),h=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],i=u=>`
      let bias${u}_offset: u32 = (global_idx * 4 + ${u}) % uniforms.bias_size;
      let bias${u} = ${m.getByOffset(`bias${u}_offset / 4`)}[bias${u}_offset % 4];`,r=a?`
      let bias = ${m.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${i(0)}${i(1)}${i(2)}${i(3)}
      let bias = ${_.type.value}(bias0, bias1, bias2, bias3);`;return`${l.registerUniforms(h).declareVariables(_,m,d)}

    ${co(Ae(e))}

    ${l.mainStart(It)}
      ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${_.getByOffset("global_idx")};
      ${r}
      let x_in = x + bias;
      ${d.setByOffset("global_idx",po("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${a}`,inputDependencies:["type","type"]},getShaderSource:c,getRunData:l=>({outputs:[{dims:l[0].dims,dataType:l[0].dataType}],programUniforms:[{type:12,data:Math.ceil(t/4)},{type:12,data:s}],dispatchGroup:{x:Math.ceil(t/It/4)}})}},bd=n=>{n.inputs.length<2||k.size(n.inputs[1].dims)===0?mu(n):n.compute(Df(n.inputs))}}),Mf,Rf,_d,wd,vd=U(()=>{ee(),ne(),Se(),ie(),Mf=n=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.")},Rf=(n,e)=>{let t=n[0].dims,s=n[1].dims,a=t.length,c=k.normalizeAxis(e.axis,a),l=t.slice(0);l.splice(c,1,...s);let _=t[c],m=n[0].dataType===9?4:1,d=Math.ceil(k.size(l)/m),h=[{type:12,data:d},{type:6,data:_},{type:12,data:c},...N(n[0].dims,n[1].dims,l)],i=r=>{let u=P("data",n[0].dataType,n[0].dims.length,m),f=P("inputIndices",n[1].dataType,n[1].dims.length),g=M("output",n[0].dataType,l.length,m),w=x=>{let S=s.length,T=`var indicesIndices${x}  = ${f.type.indices}(0);`;for(let E=0;E<S;E++)T+=`${S>1?`indicesIndices${x}[${E}]`:`indicesIndices${x}`} = ${l.length>1?`outputIndices${x}[uniforms.axis + ${E}]`:`outputIndices${x}`};`;T+=`
          var idx${x} = ${f.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${u.type.indices};
        `;for(let E=0,A=0;E<a;E++)E===c?(T+=`${a>1?`dataIndices${x}[${E}]`:`dataIndices${x}`} = u32(idx${x});`,A+=S):(T+=`${a>1?`dataIndices${x}[${E}]`:`dataIndices${x}`} = ${l.length>1?`outputIndices${x}[${A}]`:`outputIndices${x}`};`,A++);return T},y;if(n[0].dataType===9){let x=(S,T,E="")=>`
          let outputIndices${T} = ${g.offsetToIndices(`outputOffset + ${T}u`)};
          ${w(T)};
          let offset${T} = ${u.indicesToOffset(`dataIndices${T}`)};
          let index${T} = offset${T} / 4u;
          let component${T} = offset${T} % 4u;
          ${S}[${T}] = ${E}(${u.getByOffset(`index${T}`)}[component${T}]);
        `;y=`
        let outputOffset = global_idx * ${m};
        var value = vec4<u32>(0);
        ${x("value",0,"u32")}
        ${x("value",1,"u32")}
        ${x("value",2,"u32")}
        ${x("value",3,"u32")}
        ${g.setByOffset("global_idx","value")}
      `}else y=`
      let outputIndices = ${g.offsetToIndices("global_idx")};
      ${w("")};
      let value = ${u.getByIndices("dataIndices")};
      ${g.setByOffset("global_idx","value")};
      `;return`
      ${r.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(u,f,g)}
      ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${y}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:i}},_d=n=>J({axis:n.axis}),wd=(n,e)=>{let t=n.inputs;Mf(t),n.compute(Rf(n.inputs,e))}}),Uf,$d,xd,Sd=U(()=>{ee(),ne(),ie(),Uf=(n,e,t,s,a,c,l,_,m)=>{let d=[{type:12,data:c},{type:12,data:s},{type:12,data:a},{type:12,data:t},{type:12,data:l},{type:12,data:_},{type:12,data:m}],h=[c];d.push(...N(e.dims,h));let i=r=>{let u=P("indices_data",e.dataType,e.dims.length),f=M("input_slice_offsets_data",12,1,1),g=[u,f],w=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:a.length},{name:"sizes_from_slice_dims_data",type:"u32",length:t.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${r.registerUniforms(w).declareVariables(...g)}
  ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${a.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${t.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return n.compute({name:"computeSliceOffsets",shaderCache:{hint:`${a.length}_${t.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:h,dataType:n.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d}),getShaderSource:i},{inputs:[e],outputs:[-1]})[0]},$d=(n,e)=>{let t=n.inputs,s=t[0].dims,a=t[0].dataType,c=t[1].dims,l=c[c.length-1],_=k.sizeToDimension(c,c.length-1),m=k.sizeFromDimension(s,e.batchDims+l),d=k.sizeToDimension(s,e.batchDims),h=k.sizeFromDimension(s,e.batchDims),i=_/d,r=new Array(l),u=m;for(let T=0;T<l;++T)r[l-1-T]=u,u*=s[e.batchDims+l-1-T];let f=Uf(n,t[1],r,e.batchDims,s,_,i,h,l),g=e.batchDims+l;if(g>s.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let w=c.slice(0,-1).concat(s.slice(g)),y=k.size(w),x=[{type:12,data:y},{type:12,data:m},...N(t[0].dims,f.dims,w)],S=T=>{let E=P("data",t[0].dataType,t[0].dims.length),A=P("slice_offsets",12,f.dims.length),C=M("output",t[0].dataType,w.length);return`
          ${T.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(E,A,C)}
            ${T.mainStart()}
            ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};n.compute({name:"GatherND",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:w,dataType:a}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:x}),getShaderSource:S},{inputs:[t[0],f]})},xd=n=>({batchDims:n.batch_dims,cacheKey:""})}),Nf,Vf,Td,Id,Cd=U(()=>{ee(),ne(),Se(),ie(),Nf=(n,e)=>{if(n.length<3||n.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let t=k.normalizeAxis(e.quantizeAxis,n[0].dims.length),s=e.blockSize,a=n[0],c=n[2],l=n.length===4?n[3]:void 0;if(c.dims.length!==a.dims.length||!a.dims.map((_,m)=>m===t?Math.ceil(_/s)===c.dims[m]:_===c.dims[m]).reduce((_,m)=>_&&m,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(l){if(l.dataType!==a.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(l.dims.length!==c.dims.length||!l.dims.map((_,m)=>_===c.dims[m]).reduce((_,m)=>_&&m,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Vf=(n,e)=>{let t=n[0].dims,s=n[1].dims,a=t.length,c=k.normalizeAxis(e.gatherAxis,a),l=k.normalizeAxis(e.quantizeAxis,a),_=t.slice(0);_.splice(c,1,...s);let m=k.size(_),d=n[2].dataType,h=n[0].dataType===22,i=[{type:12,data:m},{type:12,data:l},{type:12,data:c},{type:12,data:e.blockSize},...N(...n.map((u,f)=>u.dims),_)],r=u=>{let f=P("data",n[0].dataType,n[0].dims.length),g=P("inputIndices",n[1].dataType,n[1].dims.length),w=P("scales",n[2].dataType,n[2].dims.length),y=n.length>3?P("zeroPoint",n[3].dataType,n[3].dims.length):void 0,x=M("output",d,_.length),S=[f,g,w];y&&S.push(y);let T=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${u.registerUniforms(T).declareVariables(...S,x)}
        ${u.mainStart()}
        let output_indices = ${x.offsetToIndices("global_idx")};
        var indices_indices = ${g.type.indices}(0);
        ${s.length>1?`
          for (var i: u32 = 0; i < ${s.length}; i++) {
            let index = ${x.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${g.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${x.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${f.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${x.indicesGet("output_indices","i")};
          ${f.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${g.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${t[c]};
        }
        ${f.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${_.length}; i++) {
          let index = ${x.indicesGet("output_indices",`i + ${s.length} - 1`)};
          ${f.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${f.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${f.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${h?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${w.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${w.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${w.getByIndices("scale_indices")};
        ${y?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${y.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${y.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${h?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Ae(d)}(quantized_data - zero_point) * scale;
        ${x.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${e.cacheKey};${n.filter((u,f)=>f!==1).map(u=>u.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:n.length},(u,f)=>"rank")},getRunData:()=>({outputs:[{dims:_,dataType:d}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:i}),getShaderSource:r}},Td=(n,e)=>{let t=n.inputs;Nf(t,e),n.compute(Vf(n.inputs,e))},Id=n=>J({blockSize:n.blockSize,gatherAxis:n.gatherAxis,quantizeAxis:n.quantizeAxis})}),Wf,Lf,Ad,Ed,kd=U(()=>{ee(),ne(),Se(),ie(),Wf=n=>{if(!n||n.length!==2)throw new Error("GatherElements requires 2 inputs.");if(n[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(n[0].dims.length!==n[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Lf=(n,e)=>{let t=n[0].dims,s=n[0].dataType,a=t.length,c=n[1].dims,l=n[1].dataType,_=k.normalizeAxis(e.axis,a),m=t[_],d=c.slice(0),h=k.size(d),i=P("input",s,a),r=P("indicesInput",l,c.length),u=M("output",s,d.length),f=[{type:12,data:h},{type:6,data:m},{type:12,data:_}];return f.push(...N(t,c,d)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:d,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:f}),getShaderSource:g=>`
      ${g.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(i,r,u)}
      ${g.mainStart()}
      ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${u.offsetToIndices("global_idx")};

      var idx = ${r.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${i.type.indices}(outputIndices);
      ${i.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${i.getByIndices("inputIndices")};

      ${u.setByOffset("global_idx","value")};
  }`}},Ad=n=>J({axis:n.axis}),Ed=(n,e)=>{let t=n.inputs;Wf(t),n.compute(Lf(n.inputs,e))}}),Gf,Hf,Pd,zd,Od=U(()=>{ee(),ne(),ie(),Gf=n=>{if(!n)throw new Error("Input is missing");if(n.length<2||n.length>3)throw new Error("Invaid input number.");if(n.length===3&&n[2].dims.length>2)throw new Error("Invalid input shape of C");if(n[0].dataType!==n[1].dataType||n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("Input types are mismatched")},Hf=(n,e)=>{let t=n[0].dims.slice(),s=n[1].dims.slice(),[a,c,l]=Dr.getShapeOfGemmResult(t,e.transA,s,e.transB,n.length===3?n[2].dims:void 0),_=[a,c];if(!_)throw new Error("Can't use gemm on the given tensors");let m=16,d=Math.ceil(c/m),h=Math.ceil(a/m),i=!0,r=k.size(_),u=[{type:12,data:i?d:r},{type:12,data:a},{type:12,data:c},{type:12,data:l},{type:1,data:e.alpha},{type:1,data:e.beta}],f=["type","type"];n.length===3&&(u.push(...N(n[2].dims)),f.push("rank")),u.push(...N(_));let g=y=>{let x="";e.transA&&e.transB?x="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?x="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?x="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(x="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let S=e.alpha===1?"":"value *= uniforms.alpha;",T=P("a",n[0].dataType,n[0].dims),E=P("b",n[1].dataType,n[1].dims),A=T.type.value,C=null,I=[T,E];n.length===3&&(C=P("c",n[2].dataType,n[2].dims.length),I.push(C));let D=M("output",n[0].dataType,_.length);I.push(D);let R=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${y.registerUniforms(R).declareVariables(...I)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${A}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${x}
    }

    ${S}
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",D)}; value += ${A}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},w=y=>{let x=P("a",n[0].dataType,n[0].dims),S=P("b",n[1].dataType,n[1].dims),T=null,E=[x,S];n.length===3&&(T=P("c",n[2].dataType,n[2].dims.length),E.push(T));let A=M("output",n[0].dataType,_.length);E.push(A);let C=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],I="",D="";e.transA&&e.transB?(D=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,I="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):e.transA&&!e.transB?(D=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,I="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!e.transA&&e.transB?(D=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,I="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!e.transA&&!e.transB&&(D=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${x.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);
      }
      `,I="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let R=e.alpha===1?"":"value *= uniforms.alpha;";return`
  ${y.registerUniforms(C).declareVariables(...E)}
  var<workgroup> tile_a: array<array<${x.type.storage}, ${m}>, ${m}>;
  var<workgroup> tile_b: array<array<${S.type.storage}, ${m}>, ${m}>;
  ${y.mainStart([m,m,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${m};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${m};
    let num_tiles = (uniforms.K - 1) / ${m} + 1;
    var k_start = 0u;
    var value = ${A.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${D}
      k_start = k_start + ${m};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${m}; k++) {
        ${I}
      }
      workgroupBarrier();
    }

    ${R}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${T!=null?`let cOffset = ${T.broadcastedIndicesToOffset("vec2(m, n)",A)}; value += ${A.type.value}(uniforms.beta) * ${T.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return i?{name:"GemmShared",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:_,dataType:n[0].dataType}],dispatchGroup:{x:d*h},programUniforms:u}),getShaderSource:w}:{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:_,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:u}),getShaderSource:g}},Pd=n=>{let e=n.transA,t=n.transB,s=n.alpha,a=n.beta;return{transA:e,transB:t,alpha:s,beta:a,cacheKey:`${n.transA};${n.transB};${n.alpha===1}`}},zd=(n,e)=>{Gf(n.inputs),n.compute(Hf(n.inputs,e))}}),ut,yt,Ut,Nt,Ff,qf,jf,Kf,Zf,Qf,Yf,Xf,Bd,Dd,Md=U(()=>{ee(),ne(),Se(),ie(),[ut,yt,Ut,Nt]=[0,1,2,3],Ff=n=>{if(n[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(n[0].dims.length!==n[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(n[0].dims.length-2!==n[1].dims[n[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${n[0].dims.length-2}`);if(n[0].dims[0]!==n[1].dims[0])throw new Error("grid batch size must match input batch size")},qf=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,jf=n=>`
  fn gs_bicubic_interpolate(p: mat4x4<${n}>, x: f32, y: f32) -> ${n} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${n}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,Kf=n=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${n.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,Zf=n=>`
  ${n.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,Qf=(n,e,t)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${ut}] = batch;
     indices[${yt}] = channel;`+(()=>{switch(t.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Ut}] = u32(r);
            indices[${Nt}] = u32(c);
          } else {
            return ${e}(0);
          }
        `;case"border":return`
          indices[${Ut}] = u32(clamp(r, 0, H - 1));
          indices[${Nt}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${Ut}] = gs_reflect(r, border[1], border[3]);
          indices[${Nt}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${t.paddingMode} is not supported`)}})()+`
    return ${n.getByIndices("indices")};
  }
`,Yf=(n,e,t)=>(()=>{switch(t.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${ut}], indices[${yt}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${ut}], indices[${yt}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${ut}], indices[${yt}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${ut}], indices[${yt}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${ut}], indices[${yt}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${ut}], indices[${yt}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${t.mode} is not supported`)}})()+`${n.setByOffset("global_idx","result")}`,Xf=(n,e)=>{let t=P("x",n[0].dataType,n[0].dims.length),s=[n[1].dims[0],n[1].dims[1],n[1].dims[2]],a=P("grid",n[1].dataType,s.length,2),c=[n[0].dims[0],n[0].dims[1],n[1].dims[1],n[1].dims[2]];e.format==="NHWC"&&(c=[n[0].dims[0],n[1].dims[1],n[1].dims[2],n[0].dims[3]],[ut,yt,Ut,Nt]=[0,3,1,2]);let l=M("output",n[0].dataType,c.length),_=t.type.value,m=k.size(c),d=[{type:12,data:m},...N(n[0].dims,s,c)],h=i=>`
  ${i.registerUniform("output_size","u32").declareVariables(t,a,l)}
  ${qf}
  ${jf(_)}
  ${Kf(e)}
  ${Zf(e)}
  ${Qf(t,_,e)}

  ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Ut}]);
      let W_in = i32(uniforms.x_shape[${Nt}]);

      ${e.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${l.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${ut}], indices[${Ut}], indices[${Nt}]);
      let nxy = ${a.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${Yf(l,_,e)}
  }`;return{name:"GridSample",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:["type","type"]},getRunData:i=>{let r=k.size(c);return{outputs:[{dims:c,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:d}},getShaderSource:h}},Bd=(n,e)=>{Ff(n.inputs),n.compute(Xf(n.inputs,e))},Dd=n=>J({alignCorners:n.align_corners,mode:n.mode,paddingMode:n.padding_mode,format:n.format})}),Be,th,Ud,Rd,rh,er,Nd,$o=U(()=>{ee(),ne(),Se(),Vr(),Fr(),ie(),st(),Be=(n,e)=>n.length>e&&n[e].dims.length>0?n[e]:void 0,th=(n,e)=>{let t=n[0],s=Be(n,1),a=Be(n,2),c=Be(n,3),l=Be(n,4),_=Be(n,5),m=Be(n,6),d=Be(n,7);if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=t.dims[0],i=t.dims[1],r=t.dims.length===3?t.dims[2]:e.numHeads*t.dims[4],u=i,f=0,g=0,w=Math.floor(r/e.numHeads);if(m&&d&&k.size(m.dims)&&k.size(d.dims)){if(m.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(m.dims[0]!==h||m.dims[1]!==e.numHeads||m.dims[3]!==w)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[0]!==h||d.dims[1]!==e.numHeads||d.dims[3]!==w)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(m.dims[2]!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(d.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');f=m.dims[2],g=m.dims[2]}else if(m&&k.size(m.dims)||d&&k.size(d.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let y;if(s&&k.size(s.dims)>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(s.dims[2]!==t.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');y=2,u=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==w)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');y=5,u=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==w)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');y=0,u=s.dims[2]}}else{if(t.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(t.dims[2]!==e.numHeads||t.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');y=3}if(c&&k.size(c.dims)>0){if(c.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(s&&s.dims.length===5&&s.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let x=f+u,S=0;if(l&&k.size(l.dims)>0){S=8;let C=l.dims;throw C.length===1?C[0]===h?S=1:C[0]===3*h+2&&(S=3):C.length===2&&C[0]===h&&C[1]===x&&(S=5),S===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let T=!1,E=r;if(a&&k.size(a.dims)>0){if(a.dims.length!==3&&a.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(a.dims.length===3){if(u!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');E=a.dims[2]}else{if(u!==a.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');E=a.dims[1]*a.dims[3],T=!0}}let A=!1;if(l&&k.size(l.dims)>0)throw new Error("Key padding mask is not supported");if(_&&k.size(_.dims)>0){if(_.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(_.dims[0]!==h||_.dims[1]!==e.numHeads||_.dims[2]!==i||_.dims[3]!==x)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:h,sequenceLength:i,pastSequenceLength:f,kvSequenceLength:u,totalSequenceLength:x,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:r,vHiddenSize:E,headSize:w,vHeadSize:Math.floor(E/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:S,scale:e.scale,broadcastResPosBias:A,passPastInKv:T,qkvFormat:y}},Ud=n=>J({...n}),Rd=J({perm:[0,2,1,3]}),rh=(n,e,t,s,a,c,l)=>{let _=[s,a,c],m=k.size(_),d=[{type:12,data:m},{type:12,data:l},{type:12,data:c}],h=i=>{let r=M("qkv_with_bias",e.dataType,_),u=P("qkv",e.dataType,_),f=P("bias",t.dataType,_),g=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${i.registerUniforms(g).declareVariables(u,f,r)}
  ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return n.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:_,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:d}),getShaderSource:h},{inputs:[e,t],outputs:[-1]})[0]},er=(n,e,t,s,a,c,l,_)=>{let m=c;if(l&&k.size(l.dims)>0){if(s===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return m=rh(n,c,l,e,s,t*a,_),m=m.reshape([e,s,t,a]),t===1||s===1?m:n.compute(Ee(m,Rd.perm),{inputs:[m],outputs:[-1]})[0]}else return c.dims.length===3&&(m=c.reshape([e,s,t,a])),t===1||s===1?m:n.compute(Ee(m,Rd.perm),{inputs:[m],outputs:[-1]})[0]},Nd=(n,e)=>{let t=th(n.inputs,e),s=n.inputs[0],a=Be(n.inputs,1),c=Be(n.inputs,2),l=Be(n.inputs,3),_=Be(n.inputs,4),m=Be(n.inputs,5),d=Be(n.inputs,6),h=Be(n.inputs,7);if(s.dims.length===5)throw new Error("Packed QKV is not implemented");if(a?.dims.length===5)throw new Error("Packed KV is not implemented");let i=a&&c&&a.dims.length===4&&c.dims.length===4,r=er(n,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,s,l,0);if(i)return Rt(n,r,a,c,_,void 0,d,h,m,t);if(!a||!c)throw new Error("key and value must be provided");let u=er(n,t.batchSize,t.numHeads,t.kvSequenceLength,t.headSize,a,l,t.hiddenSize),f=er(n,t.batchSize,t.numHeads,t.kvSequenceLength,t.vHeadSize,c,l,2*t.hiddenSize);Rt(n,r,u,f,_,void 0,d,h,m,t)}}),nh,oh,ih,ah,xo,Vd,Wd,So=U(()=>{ee(),ne(),Se(),ie(),nh=n=>{if(!n||n.length<1)throw new Error("too few inputs")},oh=(n,e)=>{let t=[],s=e.numOutputs;return n[1].dims[0]>0&&(n[1].getBigInt64Array().forEach(a=>t.push(Number(a))),s=t.length),J({numOutputs:s,axis:e.axis,splitSizes:t})},ih=n=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
    if (index < ${F("uniforms.size_in_split_axis","i",n)}) {
        return i;
    }
    }
    return ${n}u;
}`,ah=n=>{let e=n.length,t=[];for(let s=0;s<e;++s){let a=n[s].setByIndices("indices","input[global_idx]");e===1?t.push(a):s===0?t.push(`if (output_number == ${s}u) { ${a} }`):s===e-1?t.push(`else { ${a} }`):t.push(`else if (output_number == ${s}) { ${a} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${n[0].type.indices}, global_idx: u32) {
        ${t.join(`
`)}
      }`},xo=(n,e)=>{let t=n[0].dims,s=k.size(t),a=n[0].dataType,c=k.normalizeAxis(e.axis,t.length),l=new Array(e.numOutputs),_=P("input",a,t.length),m=new Array(e.numOutputs),d=[],h=[],i=0,r=[{type:12,data:s}];for(let f=0;f<e.numOutputs;f++){i+=e.splitSizes[f],m[f]=i;let g=t.slice();g[c]=e.splitSizes[f],h.push(g),l[f]=M(`output${f}`,a,g.length),d.push({dims:h[f],dataType:n[0].dataType})}r.push({type:12,data:m},...N(t,...h));let u=f=>`
  ${f.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",m.length).declareVariables(_,...l)}
  ${ih(m.length)}
  ${ah(l)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${_.offsetToIndices("global_idx")};
    var index = ${_.indicesGet("indices",c)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${F("uniforms.size_in_split_axis","output_number - 1u",m.length)};
      ${_.indicesSet("indices",c,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:d,dispatchGroup:{x:Math.ceil(s/64)},programUniforms:r})}},Vd=(n,e)=>{nh(n.inputs);let t=n.inputs.length===1?e:oh(n.inputs,e);n.compute(xo(n.inputs,t),{inputs:[0]})},Wd=n=>{let e=n.axis,t=n.splitSizes,s=n.numOutputs<0?t.length:n.numOutputs;if(s!==t.length)throw new Error("numOutputs and splitSizes lengh must be equal");return J({axis:e,numOutputs:s,splitSizes:t})}}),sh,tn,Ld,To=U(()=>{ee(),ne(),Se(),ie(),sh=(n,e)=>{let[t,s,a,c]=n,{numHeads:l,rotaryEmbeddingDim:_}=e;if(t.dims.length!==3&&t.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${t.dims.length}`);if(!k.areEqual(s.dims,[])&&!k.areEqual(s.dims,[1])&&s.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${s.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(c.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${c.dims.length}`);if(!k.areEqual(a.dims,c.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(_>0&&l===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let m=t.dims[0],d=t.dims[t.dims.length-2],h=a.dims[0],i=k.sizeFromDimension(t.dims,1)/d,r=_===0?a.dims[1]*2:i/l;if(_>r)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(s.dims.length===2){if(m!==s.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${s.dims[0]}`);if(d!==s.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${s.dims[1]}`)}if(r/2!==a.dims[1]&&_/2!==a.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${a.dims[1]}`);if(d>h)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},tn=(n,e)=>{let{interleaved:t,numHeads:s,rotaryEmbeddingDim:a,scale:c}=e,l=n[0].dims[0],_=k.sizeFromDimension(n[0].dims,1),m=n[0].dims[n[0].dims.length-2],d=_/m,h=n[2].dims[1],i=a===0?h*2:d/s,r=new Array(l,m,d/i,i-h),u=k.computeStrides(r),f=[{type:1,data:c},{type:12,data:r},{type:12,data:u},...n[0].dims.length===3?new Array({type:12,data:[_,d,i,1]}):[],...n[0].dims.length===4?new Array({type:12,data:[_,i,m*i,1]}):[],...N(n[0].dims,n[1].dims,n[2].dims,n[3].dims,n[0].dims)],g=w=>{let y=P("input",n[0].dataType,n[0].dims.length),x=P("position_ids",n[1].dataType,n[1].dims.length),S=P("cos_cache",n[2].dataType,n[2].dims.length),T=P("sin_cache",n[3].dataType,n[3].dims.length),E=M("output",n[0].dataType,n[0].dims.length);return w.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:r.length},{name:"global_strides",type:"u32",length:u.length},{name:"input_output_strides",type:"u32",length:u.length}]),`
        ${w.declareVariables(y,x,S,T,E)}

        ${w.mainStart(It)}
          let half_rotary_emb_dim = uniforms.${S.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${w.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${x.broadcastedIndicesToOffset("bsnh.xy",M("",x.type.tensor,2))};
            let position_id =
                u32(${x.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${t});
            let j = i + select(half_rotary_emb_dim, 1, ${t});
            let re = ${y.getByOffset("i")} * ${S.get("position_id","bsnh[3]")} -
                ${y.getByOffset("j")} * ${T.get("position_id","bsnh[3]")};
            ${E.setByOffset("i","re")}
            let im = ${y.getByOffset("i")} * ${T.get("position_id","bsnh[3]")} +
                ${y.getByOffset("j")} * ${S.get("position_id","bsnh[3]")};
            ${E.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${E.setByOffset("k",y.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:J({interleaved:t}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:n[0].dims,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/It)},programUniforms:f})}},Ld=(n,e)=>{sh(n.inputs,e),n.compute(tn(n.inputs,e))}}),uh,dh,Gd,lh,Hd,Fd=U(()=>{Se(),ee(),Fr(),$o(),So(),st(),To(),ie(),uh=(n,e)=>{if(e.doRotary&&n.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let t=n[0],s=n[1],a=n[2],c=n[3],l=n[4];if(e.doRotary!==0&&n.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(e.localWindowSize!==-1)throw new Error("Local attention is not supported");if(e.softcap!==0)throw new Error("Softcap is not supported");if(e.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(e.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let _=!1,m=t.dims[0],d=t.dims[1],h=t.dims.length===3?_?t.dims[2]/3:t.dims[2]:e.numHeads*t.dims[4],i=d,r=0,u=!s||s.dims.length===0,f=Math.floor(u?h/(e.numHeads+2*e.kvNumHeads):h/e.numHeads);u&&(h=f*e.numHeads);let g=c&&c.dims.length!==0,w=l&&l.dims.length!==0;if(g&&c.dims.length===4&&c.dims[0]===m&&c.dims[1]!==e.kvNumHeads&&c.dims[2]===e.kvNumHeads&&c.dims[3]===f)throw new Error("BSNH pastKey/pastValue is not supported");if(g&&w){if(c.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');r=c.dims[2]}else if(g||w)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let y=1;if(s&&s.dims.length>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(t.dims[2]%s.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');i=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==f)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');i=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==f)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');i=s.dims[2]}}else{if(t.dims.length!==3&&t.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(t.dims.length===5&&(t.dims[2]!==e.numHeads||t.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');y=3}let x=0,S=!1,T=e.kvNumHeads?f*e.kvNumHeads:h;if(a&&a.dims.length>0){if(a.dims.length!==3&&a.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(a.dims.length===3){if(i!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');T=a.dims[2]}else{if(i!==a.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');T=a.dims[1]*a.dims[3],S=!0}}let E=n.length>4?n[5]:void 0;if(E&&E.dims.length!==1&&E.dims[0]!==m)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:m,sequenceLength:d,pastSequenceLength:r,kvSequenceLength:i,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:h,vHiddenSize:T,headSize:f,vHeadSize:Math.floor(T/e.kvNumHeads),numHeads:e.numHeads,kvNumHeads:e.kvNumHeads,nReps:e.numHeads/e.kvNumHeads,pastPresentShareBuffer:!1,maskType:x,scale:e.scale,broadcastResPosBias:!1,passPastInKv:S,qkvFormat:y}},dh=J({perm:[0,2,1,3]}),Gd=(n,e,t)=>{let s=e,a=t.kvNumHeads;return e.dims.length===3&&t.kvSequenceLength!==0&&(s=e.reshape([t.batchSize,t.kvSequenceLength,a,t.headSize]),s=n.compute(Ee(s,dh.perm),{inputs:[s],outputs:[-1]})[0]),s},lh=(n,e,t,s)=>{let a=7,c=["type","type"],l=[n*e],_=n*e,m=[{type:12,data:_},{type:12,data:e},{type:12,data:n}],d=h=>{let i=P("seq_lens",t.dataType,t.dims),r=P("total_seq_lens",s.dataType,s.dims),u=M("pos_ids",a,l),f=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${h.registerUniforms(f).declareVariables(i,r,u)}
  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${r.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${i.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${u.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${u.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${u.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${n};${e}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:m}),getShaderSource:d}},Hd=(n,e)=>{let t=uh(n.inputs,e);if(n.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(n.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let s=n.inputs[0],a=n.inputs[1]&&n.inputs[1].dims.length>0?n.inputs[1]:void 0,c=n.inputs[2]&&n.inputs[2].dims.length>0?n.inputs[2]:void 0,l=n.inputs[3]&&n.inputs[3].dims.length!==0?n.inputs[3]:void 0,_=n.inputs[4]&&n.inputs[4].dims.length!==0?n.inputs[4]:void 0,m=n.inputs.length>4?n.inputs[5]:void 0,d=n.inputs.length>5?n.inputs[6]:void 0,h=t.kvNumHeads?t.kvNumHeads:t.numHeads,i=J({axis:2,numOutputs:3,splitSizes:[t.numHeads*t.headSize,h*t.headSize,h*t.headSize]}),[r,u,f]=!a&&!c?n.compute(xo([s],i),{inputs:[s],outputs:[-1,-1,-1]}):[s,a,c],g,w;if(e.doRotary){let T=n.compute(lh(t.batchSize,t.sequenceLength,m,d),{inputs:[m,d],outputs:[-1]})[0],E=n.inputs[7],A=n.inputs[8],C=J({interleaved:e.rotaryInterleaved!==0,numHeads:t.numHeads,rotaryEmbeddingDim:0,scale:e.scale}),I=[r,T,E,A],D=[-1];g=n.compute(tn(I,C),{inputs:I,outputs:D})[0],I.splice(0,1,u);let R=J({interleaved:e.rotaryInterleaved!==0,numHeads:t.kvNumHeads,rotaryEmbeddingDim:0,scale:e.scale});w=n.compute(tn(I,R),{inputs:I,outputs:D})[0]}let y=er(n,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,e.doRotary?g:r,void 0,0),x=Gd(n,e.doRotary?w:u,t),S=Gd(n,f,t);Rt(n,y,x,S,void 0,void 0,l,_,void 0,t,m,d)}}),qd,ch,ph,jd,Kd=U(()=>{ee(),ne(),st(),ie(),qd=(n,e,t,s,a,c,l,_)=>{let m=ce(c),d=m===1?"f32":`vec${m}f`,h=m===1?"vec2f":`mat2x${m}f`,i=a*l,r=64;i===1&&(r=256);let u=[a,l,c/m],f=[a,l,2],g=["rank","type","type"],w=[];w.push(...N(u,f));let y=x=>{let S=P("x",e.dataType,3,m),T=P("scale",t.dataType,t.dims),E=P("bias",s.dataType,s.dims),A=M("output",1,3,2),C=[S,T,E,A];return`
  var<workgroup> workgroup_shared : array<${h}, ${r}>;
  const workgroup_size = ${r}u;
  ${x.declareVariables(...C)}
  ${x.mainStart(r)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${d}(0);
    var squared_sum = ${d}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${d}(${S.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${h}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${He("workgroup_shared[0][0]",m)} / f32(hight * ${m});
      let squared_sum_final = ${He("workgroup_shared[0][1]",m)} / f32(hight * ${m});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${_}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return n.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${m};${_};${r}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:i},programUniforms:w}),getShaderSource:y},{inputs:[e,t,s],outputs:[-1]})[0]},ch=(n,e,t)=>{let s=e[0].dims,a=s,c=2,l=s[0],_=s[1],m=k.sizeFromDimension(s,c),d=ce(m),h=k.size(a)/d,i=qd(n,e[0],e[1],e[2],l,m,_,t.epsilon),r=[l,_,m/d],u=[l,_],f=["type","none"],g=w=>{let y=P("x",e[0].dataType,r.length,d),x=P("scale_shift",1,u.length,2),S=M("output",e[0].dataType,r.length,d),T=[y,x,S];return`
  ${w.registerUniform("output_size","u32").declareVariables(...T)}
  ${w.mainStart()}
  ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${S.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${x.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${y.getByOffset("global_idx")} * ${S.type.value}(scale_shift.x) + ${S.type.value}(scale_shift.y);
      ${S.setByOffset("global_idx","value")};
  }`};n.compute({name:"InstanceNormalization",shaderCache:{hint:`${d}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},...N(r,u,r)]}),getShaderSource:g},{inputs:[e[0],i]})},ph=(n,e,t)=>{let s=e[0].dims,a=s,c=s[0],l=s[s.length-1],_=k.sizeFromDimension(s,1)/l,m=ce(l),d=k.size(a)/m,h=[{type:12,data:_},{type:12,data:Math.floor(l/m)}],i=["type","type"],r=!1,u=[0,s.length-1];for(let y=0;y<s.length-2;y++)r=r||s[y+1]!==1,u.push(y+1);r=r&&s[s.length-1]!==1;let f=r?n.compute(Ee(n.inputs[0],u),{inputs:[n.inputs[0]],outputs:[-1]})[0]:n.inputs[0].reshape(Array.from({length:s.length},(y,x)=>s[u[x]])),g=qd(n,f,e[1],e[2],c,_,l,t.epsilon),w=y=>{let x=be(e[0].dataType),S=m===1?"vec2f":`mat${m}x2f`,T=C=>{let I=C===0?"x":"y",D=m===1?"f32":`vec${m}f`;switch(m){case 1:return`${x}(${D}(scale.${I}))`;case 2:return`vec2<${x}>(${D}(scale[0].${I}, scale[1].${I}))`;case 4:return`vec4<${x}>(${D}(scale[0].${I}, scale[1].${I}, scale[2].${I}, scale[3].${I}))`;default:throw new Error(`Not supported compoents ${m}`)}},E=P("input",e[0].dataType,e[0].dims,m),A=M("output",e[0].dataType,a,m);return`
  @group(0) @binding(0) var<storage, read> input : array<${E.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${S}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${A.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${y.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${T(0)}, ${T(1)});
  }`};n.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${m}`,inputDependencies:i},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:w},{inputs:[e[0],g]})},jd=(n,e)=>{e.format==="NHWC"?ph(n,n.inputs,e):ch(n,n.inputs,e)}}),mh,fh,Zd,Qd=U(()=>{ee(),ne(),ie(),mh=n=>{if(!n||n.length<2)throw new Error("layerNorm requires at least 2 inputs.")},fh=(n,e,t)=>{let s=e.simplified,a=n[0].dims,c=n[1],l=!s&&n[2],_=a,m=k.normalizeAxis(e.axis,a.length),d=k.sizeToDimension(a,m),h=k.sizeFromDimension(a,m),i=k.size(c.dims),r=l?k.size(l.dims):0;if(i!==h||l&&r!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${i} and bias size of ${r}`);let u=[];for(let E=0;E<a.length;++E)E<m?u.push(a[E]):u.push(1);let f=ce(h),g=["type","type"],w=[{type:12,data:d},{type:1,data:h},{type:12,data:Math.floor(h/f)},{type:1,data:e.epsilon}];l&&g.push("type");let y=t>1,x=t>2,S=E=>{let A=be(n[0].dataType),C=[P("x",n[0].dataType,n[0].dims,f),P("scale",c.dataType,c.dims,f)];l&&C.push(P("bias",l.dataType,l.dims,f)),C.push(M("output",n[0].dataType,_,f)),y&&C.push(M("mean_data_output",1,u)),x&&C.push(M("inv_std_output",1,u));let I=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${E.registerUniforms(I).declareVariables(...C)}
  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${ao("f32",f)};
    var mean_square_vector = ${ao("f32",f)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Ct(A,f,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${He("mean_vector",f)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${He("mean_square_vector",f)} / uniforms.norm_size ${s?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Ct(A,f,"x[j + offset]")};
      let f32scale = ${Ct(A,f,"scale[j]")};
      output[j + offset] = ${C[0].type.value}((f32input ${s?"":"- mean"}) * inv_std_dev * f32scale
        ${l?`+ ${Ct(A,f,"bias[j]")}`:""}
      );
    }

    ${y?"mean_data_output[global_idx] = mean":""};
    ${x?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},T=[{dims:_,dataType:n[0].dataType}];return y&&T.push({dims:u,dataType:1}),x&&T.push({dims:u,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${t};${s}`,inputDependencies:g},getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(d/64)},programUniforms:w}),getShaderSource:S}},Zd=(n,e)=>{mh(n.inputs),n.compute(fh(n.inputs,e,n.outputCount))}}),hh,Yd,Xd=U(()=>{ne(),Yr(),Xr(),hh=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.")},Yd=n=>{hh(n.inputs);let e=Je.calcShape(n.inputs[0].dims,n.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let t=e[e.length-1],s=n.inputs[0].dims[n.inputs[0].dims.length-1];if(t<8&&s<8)n.compute(Qr(n.inputs,{activation:""},e));else{let a=e[e.length-2],c=k.size(n.inputs[0].dims.slice(0,-2)),l=k.size(n.inputs[1].dims.slice(0,-2));if(c!==1&&a===1&&l===1){let _=n.inputs[0].reshape([1,c,s]),m=n.inputs[1].reshape([1,s,t]),d=[1,c,t],h=[_,m];n.compute(Jt(h,{activation:""},e,d),{inputs:h})}else n.compute(Jt(n.inputs,{activation:""},e))}}}),gh,bh,yh,Jd,el,tl=U(()=>{ee(),ne(),Se(),ie(),gh=(n,e)=>{if(n.length<3||n.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let t=n[0],s=t.dims.length;if(t.dims[s-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let a=Math.floor((e.k+e.blockSize-1)/e.blockSize),c=e.blockSize/8*e.bits,l=n[1];if(!k.areEqual(l.dims,[e.n,a,c]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let _=n[2].dims;if(k.size(_)!==e.n*a)throw new Error("scales input size error.");if(n.length===4){let m=n[3].dims,d=e.bits>4?e.n*a:e.n*Math.floor((a+1)/2);if(k.size(m)!==d)throw new Error("zeroPoints input size error.")}},bh=(n,e)=>{let t=n[0].dims,s=t.length,a=t[s-2],c=e.k,l=e.n,_=t.slice(0,s-2),m=k.size(_),d=n[1].dims[2]/4,h=n[0].dataType,i=ce(e.k),r=ce(d),u=ce(l),f=_.concat([a,l]),g=a>1&&l/u%2===0?2:1,w=k.size(f)/u/g,y=64,x=[],S=[m,a,c/i],T=k.convertShape(n[1].dims).slice();T.splice(-1,1,d/r),x.push(...N(S)),x.push(...N(T)),x.push(...N(n[2].dims)),n.length===4&&x.push(...N(k.convertShape(n[3].dims)));let E=[m,a,l/u];x.push(...N(E));let A=C=>{let I=S.length,D=P("a",n[0].dataType,I,i),R=P("b",12,T.length,r),Y=P("scales",n[2].dataType,n[2].dims.length),re=[D,R,Y],G=n.length===4?P("zero_points",12,n[3].dims.length):void 0;G&&re.push(G);let te=E.length,q=M("output",n[0].dataType,te,u),z=be(n[0].dataType),H=(()=>{switch(i){case 1:return`array<${z}, 8>`;case 2:return`mat4x2<${z}>`;case 4:return`mat2x4<${z}>`;default:throw new Error(`${i}-component is not supported.`)}})(),he=()=>{let K=`
          // reuse a data
            var input_offset = ${D.indicesToOffset(`${D.type.indices}(batch, row, word_offset)`)};
            var a_data: ${H};
            for (var j: u32 = 0; j < ${8/i}; j++) {
              a_data[j] = ${D.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let Q=0;Q<u*g;Q++)K+=`
            b_value = ${r===1?`b${Q}_data`:`b${Q}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${H}(${Array.from({length:4},(de,ue)=>`${z}(b_value_lower[${ue}]), ${z}(b_value_upper[${ue}])`).join(", ")});
            b_dequantized_values = ${i===1?`${H}(${Array.from({length:8},(de,ue)=>`(b_quantized_values[${ue}] - ${G?`zero_point${Q}`:"zero_point"}) * scale${Q}`).join(", ")});`:`(b_quantized_values - ${H}(${Array(8).fill(`${G?`zero_point${Q}`:"zero_point"}`).join(",")})) * scale${Q};`};
            workgroup_shared[local_id.x * ${g} + ${Math.floor(Q/u)}]${u>1?`[${Q%u}]`:""} += ${Array.from({length:8/i},(de,ue)=>`${i===1?`a_data[${ue}] * b_dequantized_values[${ue}]`:`dot(a_data[${ue}], b_dequantized_values[${ue}])`}`).join(" + ")};
          `;return K},Ce=()=>{let K=`
            var col_index = col * ${u};
            ${G?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${z}(8);`}
            `;for(let Q=0;Q<u*g;Q++)K+=`
            let scale${Q} = ${Y.getByOffset("col_index * nBlocksPerCol + block")};
            ${G?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${G.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${Q} = ${z}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return K},oe=()=>{let K=`col_index = col * ${u};`;for(let Q=0;Q<u*g;Q++)K+=`
            let b${Q}_data = ${R.getByIndices(`${R.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return K+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${H};
            var b_dequantized_values: ${H};`,K};return`
        var<workgroup> workgroup_shared: array<${q.type.value}, ${g*y}>;
        ${C.declareVariables(...re,q)}
        ${C.mainStart([y,1,1])}
          let output_indices = ${q.offsetToIndices(`(global_idx / ${y}) * ${g}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${y}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize/i};
            ${Ce()}
            for (var word: u32 = 0; word < ${d}; word += ${r}) {
              ${oe()}
              for (var i: u32 = 0; i < ${r}; i++) {
                ${he()}
                word_offset += ${8/i};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${g}) {
            var output_value: ${q.type.value} = ${q.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${y}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${g};
            }
            ${q.setByIndices(`${q.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.blockSize};${e.bits};${i};${r};${u};${g};${y}`,inputDependencies:Array(n.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:h}],dispatchGroup:{x:w},programUniforms:x}),getShaderSource:A}},yh=(n,e)=>{let t=n[0].dims,s=t.length,a=t[s-2],c=e.k,l=e.n,_=t.slice(0,s-2),m=k.size(_),d=n[1].dims[2]/4,h=n[0].dataType,i=ce(e.k),r=ce(d),u=_.concat([a,l]),f=128,g=l%8===0?8:l%4===0?4:1,w=f/g,y=w*r*8,x=y/i,S=y/e.blockSize,T=k.size(u)/g,E=[],A=[m,a,c/i],C=k.convertShape(n[1].dims).slice();C.splice(-1,1,d/r),E.push(...N(A)),E.push(...N(C)),E.push(...N(n[2].dims)),n.length===4&&E.push(...N(k.convertShape(n[3].dims)));let I=[m,a,l];E.push(...N(I));let D=R=>{let Y=A.length,re=P("a",n[0].dataType,Y,i),G=P("b",12,C.length,r),te=P("scales",n[2].dataType,n[2].dims.length),q=[re,G,te],z=n.length===4?P("zero_points",12,n[3].dims.length):void 0;z&&q.push(z);let H=I.length,he=M("output",n[0].dataType,H),Ce=be(n[0].dataType),oe=()=>{switch(i){case 1:return`
          let a_data0 = vec4<${Ce}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${Ce}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${Ce}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${Ce}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${i}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${re.type.value}, ${x}>;
        var<workgroup> inter_results: array<array<${he.type.value}, ${w}>, ${g}>;
        ${R.declareVariables(...q,he)}
        ${R.mainStart([w,g,1])}
          let output_indices = ${he.offsetToIndices(`workgroup_index * ${g}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${S} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${x};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${x}; a_offset += ${f})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${re.getByIndices(`${re.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${re.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${S} + local_id.x;
            ${z?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${z.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${Ce}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Ce}(8);`}
            let scale = ${te.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${G.getByIndices(`${G.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize/i};
            for (var i: u32 = 0; i < ${r}; i++) {
              ${oe()}
              let b_value = ${r===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${Ce}>(${Array.from({length:4},(K,Q)=>`${Ce}(b_value_lower[${Q}]), ${Ce}(b_value_upper[${Q}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${Ce}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(K,Q)=>`${`dot(a_data${Q}, b_dequantized_values[${Q}])`}`).join(" + ")};
              word_offset += ${8/i};
            }
            workgroupBarrier();
          }

          if (local_idx < ${g}) {
            var output_value: ${he.type.value} = ${he.type.value}(0);
            for (var b = 0u; b < ${w}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${he.setByIndices(`${he.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${e.blockSize};${i};${r};${w};${g}`,inputDependencies:Array(n.length).fill("rank")},getRunData:()=>({outputs:[{dims:u,dataType:h}],dispatchGroup:{x:T},programUniforms:E}),getShaderSource:D}},Jd=(n,e)=>{gh(n.inputs,e),e.blockSize===32&&n.adapterInfo.isVendor("intel")&&n.adapterInfo.isArchitecture("gen-12lp")?n.compute(yh(n.inputs,e)):n.compute(bh(n.inputs,e))},el=n=>J(n)}),_h,wh,vh,$h,xh,Sh,Th,Ih,rl,nl=U(()=>{ee(),ne(),ie(),_h=n=>{if(!n||n.length<1)throw new Error("Too few inputs");if(n[0].dataType!==1&&n[0].dataType!==10)throw new Error("Input type must be float or float16.");if(n.length>=2){let e=n[0].dims.length*2===n[1].dims[0];if(n.length===4&&(e=n[3].dims[0]*2===n[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},wh=(n,e,t)=>{let s="";for(let a=e-1;a>=0;--a)s+=`
            k = i32(${n.indicesGet("indices",a)}) - ${F("uniforms.pads",a,t)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${F("uniforms.x_shape",a,e)})) {
              break;
            }
            offset += k * i32(${F("uniforms.x_strides",a,e)});
        `;return`
          value = ${n.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${s}
            value = x[offset];
          }
      `},vh=(n,e,t)=>{let s="";for(let a=e-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${F("uniforms.pads",a,t)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${F("uniforms.x_shape",a,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${F("uniforms.x_shape",a,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${F("uniforms.x_strides",a,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},$h=(n,e,t)=>{let s="";for(let a=e-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${F("uniforms.pads",a,t)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${F("uniforms.x_shape",a,e)})) {
                  k = i32(${F("uniforms.x_shape",a,e)}) - 1;
                }
                offset += k * i32(${F("uniforms.x_strides",a,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},xh=(n,e,t)=>{let s="";for(let a=e-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${F("uniforms.pads",a,t)};
                if (k < 0)  {
                  k += i32(${F("uniforms.x_shape",a,e)}]);
                }
                if (k >= i32(${F("uniforms.x_shape",a,e)})) {
                  k -= i32(${F("uniforms.x_shape",a,e)});
                }
                offset += k * i32(${F("uniforms.x_strides",a,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},Sh=(n,e,t)=>{switch(t.mode){case 0:return wh(n,e,t.pads.length);case 1:return vh(n,e,t.pads.length);case 2:return $h(n,e,t.pads.length);case 3:return xh(n,e,t.pads.length);default:throw new Error("Invalid mode")}},Th=(n,e)=>{let t=k.padShape(n[0].dims.slice(),e.pads),s=n[0].dims,a=k.size(t),c=[{type:12,data:a},{type:6,data:e.pads}],l=n.length>=3&&n[2].data;e.mode===0&&c.push({type:l?n[2].dataType:1,data:e.value}),c.push(...N(n[0].dims,t));let _=["rank"],m=d=>{let h=M("output",n[0].dataType,t.length),i=P("x",n[0].dataType,s.length),r=i.type.value,u=Sh(h,s.length,e),f=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&f.push({name:"constant_value",type:l?r:"f32"}),`
            ${d.registerUniforms(f).declareVariables(i,h)}
            ${d.mainStart()}
            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${h.offsetToIndices("global_idx")};

            var value = ${r}(0);
            ${u}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}${l}`,inputDependencies:_},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(t)/64)},programUniforms:c}),getShaderSource:m}},Ih=(n,e)=>{if(n.length>1){let t=n[1].getBigInt64Array(),s=n.length>=3&&n[2].data?n[2].dataType===10?n[2].getUint16Array()[0]:n[2].getFloat32Array()[0]:0,a=n[0].dims.length,c=new Int32Array(2*a).fill(0);if(n.length>=4){let _=n[3].getBigInt64Array();for(let m=0;m<_.length;m++)c[Number(_[m])]=Number(t[m]),c[Number(_[m])+a]=Number(t[m+_.length])}else t.forEach((_,m)=>c[Number(m)]=Number(_));let l=[];return c.forEach(_=>l.push(_)),{mode:e.mode,value:s,pads:l}}else return e},rl=(n,e)=>{_h(n.inputs);let t=Ih(n.inputs,e);n.compute(Th(n.inputs,t),{inputs:[0]})}}),rn,ol,il,al,sl,Ch,Ah,ul,dl,ll,cl,pl,ml,fl,hl,gl,bl,yl,_l,wl=U(()=>{We(),ee(),ne(),ie(),rn=n=>{if(ge.webgpu.validateInputContent&&(!n||n.length!==1))throw new Error("Pool ops requires 1 input.")},ol=(n,e,t)=>{let s=e.format==="NHWC",a=n.dims.slice();s&&a.splice(1,0,a.pop());let c=Object.hasOwnProperty.call(e,"dilations"),l=e.kernelShape.slice(),_=e.strides.slice(),m=c?e.dilations.slice():[],d=e.pads.slice();Tt.adjustPoolAttributes(t,a,l,_,m,d);let h=Tt.computePoolOutputShape(t,a,_,m,l,d,e.autoPad),i=Object.assign({},e);c?Object.assign(i,{kernelShape:l,strides:_,pads:d,dilations:m,cacheKey:e.cacheKey}):Object.assign(i,{kernelShape:l,strides:_,pads:d,cacheKey:e.cacheKey});let r=h.slice();return r.push(r.splice(1,1)[0]),[i,s?r:h]},il=(n,e)=>{let t=e.format==="NHWC",s=k.size(n),a=k.size(e.kernelShape),c=[{type:12,data:s},{type:12,data:a}],l=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let _=e.kernelShape[e.kernelShape.length-1],m=e.strides[e.strides.length-1],d=e.pads[e.pads.length/2-1],h=e.pads[e.pads.length-1],i=!!(d+h);c.push({type:12,data:_},{type:12,data:m},{type:12,data:d},{type:12,data:h}),l.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let r=!1;if(e.kernelShape.length===2){let u=e.kernelShape[e.kernelShape.length-2],f=e.strides[e.strides.length-2],g=e.pads[e.pads.length/2-2],w=e.pads[e.pads.length-2];r=!!(g+w),c.push({type:12,data:u},{type:12,data:f},{type:12,data:g},{type:12,data:w}),l.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[c,l,!0,i,r]}else{if(t)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let _=k.computeStrides(e.kernelShape);c.push({type:12,data:_},{type:12,data:e.pads},{type:12,data:e.strides}),l.push({name:"kernelStrides",type:"u32",length:_.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let m=e.pads.reduce((d,h)=>d+h);return[c,l,!!m,!1,!1]}},al=(n,e,t,s,a,c,l,_,m,d,h,i)=>{let r=a.format==="NHWC",u=e.type.value,f=M("output",e.type.tensor,s);if(a.kernelShape.length<=2){let g="",w="",y="",x=t-(r?2:1);if(h?g=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${x}] < 0 || xIndices[${x}]
                      >= uniforms.x_shape[${x}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${c}
                }`:g=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${c}
                }`,a.kernelShape.length===2){let S=t-(r?3:2);i?w=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${S}] < 0 || xIndices[${S}] >= uniforms.x_shape[${S}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:w=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sh - uniforms.phStart + j;
                `,y=`
              }
            `}return`
            ${n.registerUniforms(m).declareVariables(e,f)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${f.offsetToIndices("global_idx")};
              var xIndices = ${f.offsetToIndices("global_idx")};

              var value = ${u}(${_});
              var pad = 0;
              ${w}
              ${g}
              ${y}
              ${l}

              output[global_idx] = value;
            }`}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let g=a.kernelShape.length,w=a.pads.length,y="";return d?y=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${c}
              }`:y=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${c}
            `,`
            ${n.registerUniforms(m).declareVariables(e,f)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${f.offsetToIndices("global_idx")};
              var xIndices = ${f.offsetToIndices("global_idx")};

              var offsets: array<u32, ${g}>;

              var value = ${u}(${_});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${g-1}u; j++) {
                  offsets[j] = offset / ${F("uniforms.kernelStrides","j",g)};
                  offset -= offsets[j] * ${F("uniforms.kernelStrides","j",g)};
                }
                offsets[${g-1}] = offset;

                isPad = false;
                for (var j = ${t-g}u; j < ${t}u; j++) {
                  xIndices[j] = indices[j] * ${F("uniforms.strides",`j - ${t-g}u`,g)}
                    + offsets[j - ${t-g}u] - ${F("uniforms.pads","j - 2u",w)};
                  ${y}
              }
              ${l}

              output[global_idx] = value;
            }`}},sl=n=>`${n.format};${n.ceilMode};${n.autoPad};${n.kernelShape.length}`,Ch=n=>`${sl(n)};${n.countIncludePad}`,Ah=n=>`${sl(n)};${n.storageOrder};${n.dilations}`,ul=n=>({format:n.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],ceilMode:n.ceil_mode,kernelShape:n.kernel_shape,strides:n.strides,pads:n.pads}),dl=(n,e,t,s)=>{let[a,c]=ol(e,s,t),l=P("x",e.dataType,e.dims.length),_=l.type.value,m="value += x_val;",d="";a.countIncludePad?d+=`value /= ${_}(uniforms.kernelSize);`:d+=`value /= ${_}(i32(uniforms.kernelSize) - pad);`;let[h,i,r,u,f]=il(c,a);h.push(...N(e.dims,c));let g=["rank"];return{name:n,shaderCache:{hint:`${s.cacheKey};${r};${u};${f}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(k.size(c)/64)},programUniforms:h}),getShaderSource:w=>al(w,l,e.dims.length,c.length,a,m,d,0,i,r,u,f)}},ll=n=>{let e=n.count_include_pad!==0,t=ul(n);if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let s={countIncludePad:e,...t,cacheKey:""};return{...s,cacheKey:Ch(s)}},cl=(n,e)=>{rn(n.inputs),n.compute(dl("AveragePool",n.inputs[0],!1,e))},pl={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},ml=n=>{let e=n.format;return{format:e,...pl,cacheKey:e}},fl=(n,e)=>{rn(n.inputs),n.compute(dl("GlobalAveragePool",n.inputs[0],!0,e))},hl=(n,e,t,s)=>{let[a,c]=ol(e,s,t),l=`
      value = max(x_val, value);
    `,_="",m=P("x",e.dataType,e.dims.length),d=["rank"],[h,i,r,u,f]=il(c,a);return h.push(...N(e.dims,c)),{name:n,shaderCache:{hint:`${s.cacheKey};${r};${u};${f}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(k.size(c)/64)},programUniforms:h}),getShaderSource:g=>al(g,m,e.dims.length,c.length,a,l,_,e.dataType===10?-65504:-1e5,i,r,u,f)}},gl=(n,e)=>{rn(n.inputs),n.compute(hl("MaxPool",n.inputs[0],!1,e))},bl=n=>{let e=n.storage_order,t=n.dilations,s=ul(n);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let a={storageOrder:e,dilations:t,...s,cacheKey:""};return{...a,cacheKey:Ah(a)}},yl=n=>{let e=n.format;return{format:e,...pl,cacheKey:e}},_l=(n,e)=>{rn(n.inputs),n.compute(hl("GlobalMaxPool",n.inputs[0],!0,e))}}),kh,Ph,vl,$l,xl=U(()=>{ee(),ne(),Se(),ie(),kh=(n,e)=>{if(n.length<2||n.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(n.length===3&&n[1].dims===n[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(n[0].dataType===6&&n.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(n[1].dims.length!==0&&n[1].dims.length!==1&&n[1].dims.length!==n[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(n.length>2){if(n[0].dataType!==n[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(n[1].dims.length!==n[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!n[1].dims.map((t,s)=>t===n[2].dims[s]).reduce((t,s)=>t&&s,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(e.blockSize>0){if(n[1].dims.length===0||n[1].dims.length===1&&n[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!n[1].dims.map((a,c)=>c===e.axis||a===n[0].dims[c]).reduce((a,c)=>a&&c,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(n[1].dims.length!==n[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let t=n[0].dims[e.axis],s=n[1].dims[e.axis];if(e.blockSize<Math.ceil(t/s)||e.blockSize>Math.ceil(t/(s-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Ph=(n,e)=>{let t=k.normalizeAxis(e.axis,n[0].dims.length),s=n[0].dataType,a=s===3,c=n[0].dims,l=n[1].dataType,_=k.size(c),m=s===3||s===2,d=m?[Math.ceil(k.size(n[0].dims)/4)]:n[0].dims,h=n[1].dims,i=n.length>2?n[2]:void 0,r=i?m?[Math.ceil(k.size(i.dims)/4)]:i.dims:void 0,u=h.length===0||h.length===1&&h[0]===1,f=u===!1&&h.length===1,g=ce(_),w=u&&(!m||g===4),y=w?g:1,x=w&&!m?g:1,S=P("input",m?12:s,d.length,x),T=P("scale",l,h.length),E=i?P("zero_point",m?12:s,r.length):void 0,A=M("output",l,c.length,y),C=[S,T];E&&C.push(E);let I=[d,h];i&&I.push(r);let D=[{type:12,data:_/y},{type:12,data:t},{type:12,data:e.blockSize},...N(...I,c)],R=Y=>{let re=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${Y.registerUniforms(re).declareVariables(...C,A)}
      ${Y.mainStart()}
          ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${A.offsetToIndices("global_idx")};

          // Set input x
          ${m?`
            let input = ${S.getByOffset("global_idx / 4")};
            let x_vec = ${a?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${y===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${S.getByOffset("global_idx")};`};

          // Set scale input
          ${u?`let scale_value= ${T.getByOffset("0")}`:f?`
            let scale_index = ${A.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${T.getByOffset("scale_index")};`:`
            var scale_indices: ${T.type.indices} = output_indices;
            let index = ${T.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${T.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${T.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${E?u?m?`
                let zero_point_input = ${E.getByOffset("0")};
                let zero_point_vec =  ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${E.getByOffset("0")}`:f?m?`
                let zero_point_index = ${A.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${E.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${A.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${E.getByOffset("zero_point_index")};`:m?`
                let zero_point_offset = ${T.indicesToOffset("scale_indices")};
                let zero_point_input = ${E.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${E.getByIndices("scale_indices")};`:`let zero_point_value = ${m?a?"i32":"u32":S.type.value}(0);`};
      // Compute and write output
      ${A.setByOffset("global_idx",`${A.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:e.cacheKey,inputDependencies:E?["rank","rank","rank"]:["rank","rank"]},getShaderSource:R,getRunData:()=>({outputs:[{dims:c,dataType:l}],dispatchGroup:{x:Math.ceil(_/y/64),y:1,z:1},programUniforms:D})}},vl=(n,e)=>{kh(n.inputs,e),n.compute(Ph(n.inputs,e))},$l=n=>J({axis:n.axis,blockSize:n.blockSize})}),zh,Oh,Sl,Tl=U(()=>{We(),ee(),ie(),zh=(n,e,t)=>{let s=n===e,a=n<e&&t<0,c=n>e&&t>0;if(s||a||c)throw new Error("Range these inputs' contents are invalid.")},Oh=(n,e,t,s)=>{let a=Math.abs(Math.ceil((e-n)/t)),c=[a],l=a,_=[{type:12,data:l},{type:s,data:n},{type:s,data:t},...N(c)],m=d=>{let h=M("output",s,c.length),i=h.type.value,r=[{name:"outputSize",type:"u32"},{name:"start",type:i},{name:"delta",type:i}];return`
        ${d.registerUniforms(r).declareVariables(h)}
        ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${i}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${s}`},getShaderSource:m,getRunData:()=>({outputs:[{dims:c,dataType:s}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:_})}},Sl=n=>{let e=0,t=0,s=0;n.inputs[0].dataType===6?(e=n.inputs[0].getInt32Array()[0],t=n.inputs[1].getInt32Array()[0],s=n.inputs[2].getInt32Array()[0]):n.inputs[0].dataType===1&&(e=n.inputs[0].getFloat32Array()[0],t=n.inputs[1].getFloat32Array()[0],s=n.inputs[2].getFloat32Array()[0]),ge.webgpu.validateInputContent&&zh(e,t,s),n.compute(Oh(e,t,s,n.inputs[0].dataType),{inputs:[]})}}),Bh,Il,Cl,Dh,Al,El,kl=U(()=>{ee(),ne(),Se(),ie(),Bh=(n,e,t,s)=>{if(n!=="none"&&s!=="i32"&&s!=="u32"&&s!=="f32")throw new Error(`Input ${s} is not supported with reduction ${n}.`);let a=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,c=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(n){case"none":return`${e}=${t};`;case"add":return s==="i32"||s==="u32"?`atomicAdd(&${e}, bitcast<${s}>(${t}));`:`
              ${a}bitcast<${s}>(oldValue) + (${t})${c}`;case"max":return s==="i32"||s==="u32"?`atomicMax(&${e}, bitcast<${s}>(${t}));`:`
                ${a}max(bitcast<f32>(oldValue), (${t}))${c}`;case"min":return s==="i32"||s==="u32"?`atomicMin(&${e}, bitcast<${s}>(${t}));`:`${a}min(bitcast<${s}>(oldValue), (${t}))${c}`;case"mul":return`${a}(bitcast<${s}>(oldValue) * (${t}))${c}`;default:throw new Error(`Reduction ${n} is not supported.`)}},Il=(n,e)=>`${n===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${e?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${e?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,Cl=(n,e,t)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${t?"global_idx":"idx"} + i];
        ${Bh(n.reduction,"output[data_offset + i]","value",e)}
      }`,Dh=(n,e)=>{let t=n[0].dims,s=n[1].dims,a=t,c=1,l=Math.ceil(k.size(s)/c),_=s[s.length-1],m=k.sizeFromDimension(t,_),d=k.sizeFromDimension(s,0)/_,h=[{type:12,data:l},{type:12,data:_},{type:12,data:m},...N(n[1].dims,n[2].dims,a)],i=r=>{let u=P("indices",n[1].dataType,n[1].dims.length),f=P("updates",n[2].dataType,n[2].dims.length,c),g=e.reduction!=="none"&&e.reduction!==""?es("output",n[0].dataType,a.length):M("output",n[0].dataType,a.length,c);return`
      ${r.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(u,f,g)}
      ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${e.reduction==="none"}) {
    for (var i = 0; i < ${d}; i = i + 1) {
      for (var j = i + 1; j < ${d}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${e.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${d}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${Il(t.length,!1)}
      }
      ${Cl(e,g.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${Il(t.length,!0)}
  }
  ${Cl(e,g.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${e.cacheKey}_${e.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:h}),getShaderSource:i}},Al=n=>J({reduction:n.reduction}),El=(n,e)=>{n.compute(Dh(n.inputs,e),{inputs:[n.inputs[1],n.inputs[2]],outputs:[]})}}),Mh,Rh,Uh,Pl,Nh,Vh,Wh,Lh,Gh,Hh,Fh,qh,zl,jh,Kh,Zh,Qh,Yh,Ol,Bl,Dl=U(()=>{ee(),ne(),Se(),ie(),Mh=(n,e)=>{if(n.every(t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),n.length>0){if(e.mode==="linear"){if(!(n.length===2||n.length===3||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1||n.length===5&&n[0]===1&&n[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Rh=(n,e,t)=>{e.every(a=>a>=0&&a<t||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let s=new Array(t).fill(1);return e.forEach((a,c)=>s[a]=n[c]),s},Uh=(n,e,t,s,a,c)=>{let[l,_,m]=t>10?[1,2,3]:[-1,n.length>1?1:-1,-1],d=n[0].dims.length;if(l>0&&n.length>l&&n[l].dims.length>0)n[l].getFloat32Array().forEach(h=>c.push(h));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(_>0&&n.length>_&&n[_].dims.length===1&&n[_].dims[0]>0){if(n[_].getFloat32Array().forEach(h=>s.push(h)),s.length!==0&&s.length!==d&&t>=18&&s.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Mh(s,e),e.axes.length>0&&Rh(s,e.axes,d).forEach((h,i)=>s[i]=h)}if(m>0&&n.length>m&&n[m].dims.length===1&&n[m].dims[0]>0&&(n[m].getBigInt64Array().forEach(h=>a.push(Number(h))),a.length!==0&&a.length!==d&&t>=18&&a.length!==e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(s.length!==0&&s.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==0&&a.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof s<"u"&&typeof a<"u"&&s.length>0&&a.length>d)throw new Error("Resize requires only of scales or sizes to be specified")},Pl=(n,e,t,s)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${n}) * (${e});
  let whole = ${s}(big / (${t}));
  let fract = ${s}(big % (${t})) / ${s}(${t});
  return whole + fract;
`,Nh=(n,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(n){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${Pl("xResized","lengthOriginal","lengthResized",e)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${Pl("xResized","lengthOriginal - 1","lengthResized - 1",e)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${n} is not supported`)}})()+"}",Vh=(n,e,t)=>`fn getNearestPixelFromOriginal(xOriginal: ${t}, isDownSample: bool) -> ${t} {`+(()=>{switch(n){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${n} is not supported`)}})()+"}",Wh=(n,e,t)=>{let s=new Array(t).fill(0).concat(new Array(t).fill(1)),a=n.length===0?s:n.slice();return e.length>0?(e.forEach((c,l)=>{s[c]=a[l],s[l+t]=a[e.length+l]}),s):a},Lh=(n,e,t,s)=>{let a=[];if(t.length>0)if(s.length>0){if(n.forEach(c=>a.push(c)),Math.max(...s)>n.length)throw new Error("axes is out of bound");s.forEach((c,l)=>a[c]=t[l])}else t.forEach(c=>a.push(c));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");a=n.map((c,l)=>Math.round(c*e[l]))}return a},Gh=(n,e,t)=>{let s=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(c=>e[c]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(c=>e[c]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let a=n.slice();return t.axes.length>0?(t.axes.forEach(c=>e[c]=s),t.axes.forEach(c=>a[c]=Math.round(n[c]*e[c]))):(e.fill(s,0,e.length),a.forEach((c,l)=>a[l]=Math.round(c*e[l]))),a},Hh=(n,e,t,s,a)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${n.type.indices}) -> array<${n.type.value}, ${t.length}> {
      var original_indices: array<${n.type.value}, ${t.length}>;
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var output_index = ${n.indicesGet("output_indices","i")};
        var scale = ${F("uniforms.scales","i",s)};
        var roi_low = ${F("uniforms.roi","i",a)};
        var roi_hi = ${F("uniforms.roi",`i + ${e.length}`,a)};
        if (scale == 1.0) {
          original_indices[i] = ${n.type.value}(output_index);
        } else {
          var input_shape_i = ${F("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${F("uniforms.output_shape","i",t.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Fh=(n,e,t,s,a,c,l)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${n.type.indices} {
      var input_indices: ${n.type.indices};
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${F("uniforms.scales","i",a)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${F("uniforms.roi","i",c)};
          var roi_hi = ${F("uniforms.roi",`i + ${t.length}`,c)};
          var input_shape_i = ${F("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${F("uniforms.output_shape","i",s.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${l} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${n.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,qh=(n,e)=>`
    fn checkInputIndices(input_indices: ${n.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${n.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${F("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,zl=(n,e,t,s)=>n.rank>s?`
    ${n.indicesSet("input_indices",e,"channel")};
    ${n.indicesSet("input_indices",t,"batch")};
`:"",jh=(n,e,t,s,a)=>{let[c,l,_,m]=t.length===2?[-1,0,1,-1]:[0,2,3,1],d=n.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {
      var input_indices: ${n.type.indices};
      ${n.indicesSet("input_indices",l,`max(0, min(row, ${t[l]} - 1))`)};
      ${n.indicesSet("input_indices",_,`max(0, min(col, ${t[_]} - 1))`)};
      ${zl(n,m,c,2)}
      return ${n.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${d} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${d} = originalIndices[${l}];
      var col:${d} = originalIndices[${_}];
      ${s?`if (row < 0 || row > (${t[l]} - 1) || col < 0 || col > (${t[_]} - 1)) {
        return ${a};
      }`:""};
      row = max(0, min(row, ${t[l]} - 1));
      col = max(0, min(col, ${t[_]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${t.length>2?`u32(originalIndices[${m}])`:"0"};
      var batch: u32 =  ${t.length>2?`u32(originalIndices[${c}])`:"0"};
      var x11: ${d} = getInputValue(batch, channel, row1, col1);
      var x12: ${d} = getInputValue(batch, channel, row1, col2);
      var x21: ${d} = getInputValue(batch, channel, row2, col1);
      var x22: ${d} = getInputValue(batch, channel, row2, col2);
      var dx1: ${d} = abs(row - ${d}(row1));
      var dx2: ${d} = abs(${d}(row2) - row);
      var dy1: ${d} = abs(col - ${d}(col1));
      var dy2: ${d} = abs(${d}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Kh=(n,e,t,s,a,c,l,_,m,d)=>{let h=t.length===2,[i,r]=h?[0,1]:[2,3],u=n.type.value,f=g=>{let w=g===i?"row":"col";return`
      fn ${w}CubicInterpolation(input_indices: ${n.type.indices}, output_indices: ${e.type.indices}) -> ${u} {
        var output_index = ${e.indicesGet("output_indices",g)};
        var originalIdx: ${u} = getOriginalCoordinateFromResizedCoordinate(output_index, ${a[g]},
        ${s[g]}, ${t[g]}, ${c[g]}, ${c[g]} + ${t.length});
        var fractOriginalIdx: ${u} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${_} && (originalIdx < 0 || originalIdx > (${t[g]} - 1))) {
          return ${m};
        }
        var data: array<${u}, 4> = array<${u}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${w}: ${u} = originalIdx + ${u}(i);
          if (${w} < 0 || ${w} >= ${t[g]}) {
            ${d?`coefs[i + 1] = 0.0;
                        continue;`:_?`return ${m};`:`${w} = max(0, min(${w}, ${t[g]} - 1));`};
          }
        var input_indices_copy: ${n.type.indices} = input_indices;
          ${n.indicesSet("input_indices_copy",g,`u32(${w})`)};
          data[i + 1] = ${g===i?n.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${f(i)};
    ${f(r)};
  fn getCubicInterpolationCoefs(s: ${u}) -> array<${u}, 4> {
    var absS = abs(s);
    var coeffs: array<${u}, 4> = array<${u}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${u} = 1.0 - absS;
    var twoMinusAbsS: ${u} = 2.0 - absS;
    var onePlusAbsS: ${u} = 1.0 + absS;
    coeffs[0] = ((${l} * onePlusAbsS - 5 * ${l}) * onePlusAbsS + 8 * ${l}) * onePlusAbsS - 4 * ${l};
    coeffs[1] = ((${l} + 2) * absS - (${l} + 3)) * absS * absS + 1;
    coeffs[2] = ((${l} + 2) * oneMinusAbsS - (${l} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${l} * twoMinusAbsS - 5 * ${l}) * twoMinusAbsS + 8 * ${l}) * twoMinusAbsS - 4 * ${l};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${u}, 4>, coefs: array<${u}, 4>) -> ${u} {
    var coefsSum: ${u} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${u} {
    var input_indices: ${n.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Zh=(n,e,t,s,a)=>{let[c,l,_,m,d]=t.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],h=n.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${h} {
      var input_indices: ${n.type.indices};
      ${n.indicesSet("input_indices",l,`max(0, min(depth, ${t[l]} - 1))`)};
      ${n.indicesSet("input_indices",_,`max(0, min(height, ${t[_]} - 1))`)};
      ${n.indicesSet("input_indices",m,`max(0, min(width, ${t[m]} - 1))`)};
      ${zl(n,d,c,3)}
      return ${n.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${h} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${h} = originalIndices[${l}];
      var height:${h} = originalIndices[${_}];
      var width:${h} = originalIndices[${m}];
      ${s?`if (depth < 0 || depth > (${t[l]} - 1) || height < 0 || height > (${t[_]} - 1) || width < 0 || (width > ${t[m]} - 1)) {
      return ${a};
        }`:""};

    depth = max(0, min(depth, ${t[l]} - 1));
      height = max(0, min(height, ${t[_]} - 1));
      width = max(0, min(width, ${t[m]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${t.length>3?`u32(originalIndices[${d}])`:"0"};
      var batch: u32 =  ${t.length>3?`u32(originalIndices[${c}])`:"0"};

      var x111: ${h} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${h} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${h} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${h} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${h} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${h} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${h} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${h} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${h} = abs(depth - ${h}(depth1));
      var dx2: ${h} = abs(${h}(depth2) - depth);
      var dy1: ${h} = abs(height - ${h}(height1));
      var dy2: ${h} = abs(${h}(height2) - height);
      var dz1: ${h} = abs(width - ${h}(width1));
      var dz2: ${h} = abs(${h}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Qh=(n,e,t,s,a,c)=>{let l=n.dims,_=Wh(c,e.axes,l.length),m=Lh(l,s,a,e.axes),d=s.slice();s.length===0&&(d=l.map((x,S)=>x===0?1:m[S]/x),e.keepAspectRatioPolicy!=="stretch"&&(m=Gh(l,d,e)));let h=M("output",n.dataType,m.length),i=P("input",n.dataType,l.length),r=k.size(m),u=l.length===m.length&&l.every((x,S)=>x===m[S]),f=e.coordinateTransformMode==="tf_crop_and_resize",g=e.extrapolationValue,w=i.type.value,y=x=>`
      ${u?"":`
      ${Nh(e.coordinateTransformMode,w)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${qh(i,l)};
              ${Vh(e.nearestMode,t,w)};
              ${Fh(i,h,l,m,d.length,_.length,f)};
              `;case"linear":return`
              ${Hh(h,l,m,d.length,_.length)};
              ${(()=>{if(l.length===2||l.length===4)return`${jh(i,h,l,f,g)}`;if(l.length===3||l.length===5)return`${Zh(i,h,l,f,g)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(l.length===2||l.length===4)return`${Kh(i,h,l,m,d,_,e.cubicCoeffA,f,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",d.length).registerUniform("roi","f32",_.length).declareVariables(i,h)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${u?"output[global_idx] = input[global_idx];":`
        let output_indices = ${h.offsetToIndices("global_idx")};
        var input_indices: ${i.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${i.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${l.length===2||l.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${t}|${d.length>0?e.mode==="cubic"?d:d.length:""}|${a.length>0?a:""}|${_.length>0?_:""}|${u}|${e.mode==="nearest"?l.length:l}`,inputDependencies:["rank"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:m,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:1,data:d},{type:1,data:_},...N(l,m)]})}},Yh=n=>{let e=n.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},Ol=(n,e)=>{let t=[],s=[],a=[],c=Yh(n);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Uh(n.inputs,e,c,t,s,a),n.compute(Qh(n.inputs[0],e,c,t,s,a),{inputs:[0]})},Bl=n=>{let e=n.antialias,t=n.axes,s=n.coordinateTransformMode,a=n.cubicCoeffA,c=n.excludeOutside!==0,l=n.extrapolationValue,_=n.keepAspectRatioPolicy,m=n.mode,d=n.nearestMode===""?"simple":n.nearestMode;return J({antialias:e,axes:t,coordinateTransformMode:s,cubicCoeffA:a,excludeOutside:c,extrapolationValue:l,keepAspectRatioPolicy:_,mode:m,nearestMode:d})}}),Xh,Jh,Ml,Rl=U(()=>{ee(),ne(),ie(),Xh=n=>{if(!n||n.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=n[0],t=n[1],s=n[2];if(e.dataType!==t.dataType||e.dataType!==s.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=e.dims[e.dims.length-1],c=e.dims[e.dims.length-2];if(t.dims[t.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(t.dims[t.dims.length-2]!==c)throw new Error("Skip must have the same sequence length as input");if(s.dims.length!==1)throw new Error("Gamma must be 1D");if(s.dims[s.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(n.length>3){let l=n[3];if(l.dims.length!==1)throw new Error("Beta must be 1D");if(l.dims[l.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(n.length>4){let l=n[4];if(l.dims.length!==1)throw new Error("Bias must be 1D");if(l.dims[l.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Jh=(n,e,t,s)=>{let a=e.simplified,c=n[0].dims,l=k.size(c),_=c,m=l,d=c.slice(-1)[0],h=s?c.slice(0,-1).concat(1):[],i=!a&&n.length>3,r=n.length>4,u=s&&t>1,f=s&&t>2,g=t>3,w=64,y=ce(d),x=[{type:12,data:m},{type:12,data:y},{type:12,data:d},{type:1,data:e.epsilon}],S=E=>{let A=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],C=[P("x",n[0].dataType,n[0].dims,y),P("skip",n[1].dataType,n[1].dims,y),P("gamma",n[2].dataType,n[2].dims,y)];i&&C.push(P("beta",n[3].dataType,n[3].dims,y)),r&&C.push(P("bias",n[4].dataType,n[4].dims,y)),C.push(M("output",n[0].dataType,_,y)),u&&C.push(M("mean_output",1,h)),f&&C.push(M("inv_std_output",1,h)),g&&C.push(M("input_skip_bias_sum",n[0].dataType,_,y));let I=be(n[0].dataType),D=be(1,y);return`

      ${E.registerUniforms(A).declareVariables(...C)}
      var<workgroup> sum_shared : array<${D}, ${w}>;
      var<workgroup> sum_squared_shared : array<${D}, ${w}>;

      ${E.mainStart([w,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${w};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${w};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${w-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${r?"bias[offset1d + i]":I+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${g?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Ct(I,y,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${w};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${He("sum",y)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${He("square_sum",y)} / f32(uniforms.hidden_size) ${a?"":"- mean * mean"} + uniforms.epsilon);
        ${u?"mean_output[global_idx] = mean;":""}
        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${a?"":`- ${I}(mean)`}) *
            ${I}(inv_std_dev) * gamma[offset1d + i]
            ${i?"+ beta[offset1d + i]":""};
        }
      }`},T=[{dims:_,dataType:n[0].dataType}];return t>1&&T.push({dims:h,dataType:1}),t>2&&T.push({dims:h,dataType:1}),t>3&&T.push({dims:c,dataType:n[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${y};${u};${f};${g}`,inputDependencies:n.map((E,A)=>"type")},getShaderSource:S,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(m/d)},programUniforms:x})}},Ml=(n,e)=>{Xh(n.inputs);let t=[0];n.outputCount>1&&t.push(-3),n.outputCount>2&&t.push(-3),n.outputCount>3&&t.push(3),n.compute(Jh(n.inputs,e,n.outputCount,!1),{outputs:t})}}),eg,nn,tg,Ul,rg,ng,Nl,Vl,Wl=U(()=>{ee(),ne(),Se(),ie(),eg=(n,e)=>{if(!n||n.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");n.slice(1).forEach((t,s)=>{if(n[s+1].dataType!==6&&n[s+1].dataType!==7)throw new Error(`Input ${s} must be an array of int32 or int64`)})},nn=(n,e)=>{let t=[];if(n.length>e)if(n[e].dataType===7)n[e].getBigInt64Array().forEach(s=>t.push(Number(s)));else if(n[e].dataType===6)n[e].getInt32Array().forEach(s=>t.push(Number(s)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return t},tg=(n,e)=>{if(n.length>1){let t=nn(n,1),s=nn(n,2),a=nn(n,3);return a.length===0&&(a=[...Array(n[0].dims.length).keys()]),J({starts:t,ends:s,axes:a})}else return e},Ul=(n,e,t,s,a)=>{let c=n;return n<0&&(c+=t[s[e]]),a[e]<0?Math.max(0,Math.min(c,t[s[e]]-1)):Math.max(0,Math.min(c,t[s[e]]))},rg=(n,e,t)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${n.type.indices} {
          var input_indices: ${n.type.indices};
          var carry = 0u;
          for (var i = ${t.length}; i >= 0; i--) {
            let input_shape_i = ${F("uniforms.input_shape","i",t.length)};
            let steps_i = ${F("uniforms.steps","i",t.length)};
            let signs_i = ${F("uniforms.signs","i",t.length)};
            let starts_i = ${F("uniforms.starts","i",t.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${n.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,ng=(n,e)=>{let t=n[0].dims,s=k.size(t),a=e.axes.length>0?k.normalizeAxes(e.axes,t.length):[...Array(t.length).keys()],c=nn(n,4);c.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),c.length===0&&(c=Array(a.length).fill(1));let l=e.starts.map((y,x)=>Ul(y,x,t,a,c)),_=e.ends.map((y,x)=>Ul(y,x,t,a,c));if(a.length!==l.length||a.length!==_.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==t.length)for(let y=0;y<t.length;++y)a.includes(y)||(l.splice(y,0,0),_.splice(y,0,t[y]),c.splice(y,0,1));let m=c.map(y=>Math.sign(y));c.forEach((y,x,S)=>{if(y<0){let T=(_[x]-l[x])/y,E=l[x],A=E+T*c[x];l[x]=A,_[x]=E,S[x]=-y}});let d=t.slice(0);a.forEach((y,x)=>{d[y]=Math.ceil((_[y]-l[y])/c[y])});let h={dims:d,dataType:n[0].dataType},i=M("output",n[0].dataType,d.length),r=P("input",n[0].dataType,n[0].dims.length),u=k.size(d),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:l.length},{name:"signs",type:"i32",length:m.length},{name:"steps",type:"u32",length:c.length}],g=[{type:12,data:u},{type:12,data:l},{type:6,data:m},{type:12,data:c},...N(n[0].dims,d)],w=y=>`
      ${y.registerUniforms(f).declareVariables(r,i)}
        ${rg(r,i,t)}
        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${i.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${i.setByOffset("global_idx",r.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${m.length}_${l.length}_${c.length}`,inputDependencies:["rank"]},getShaderSource:w,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:g})}},Nl=(n,e)=>{eg(n.inputs,e);let t=tg(n.inputs,e);n.compute(ng(n.inputs,t),{inputs:[0]})},Vl=n=>{let e=n.starts,t=n.ends,s=n.axes;return J({starts:e,ends:t,axes:s})}}),og,ig,Ll,Gl,Hl=U(()=>{ee(),ne(),Se(),st(),ie(),og=n=>{if(!n||n.length!==1)throw new Error("Softmax op requires 1 input.")},ig=(n,e)=>{let t=n.inputs[0],s=t.dims,a=k.size(s),c=s.length,l=k.normalizeAxis(e.axis,c),_=l<s.length-1,m,d=[];_?(d=Array.from({length:c},(C,I)=>I),d[l]=c-1,d[c-1]=l,m=n.compute(Ee(t,d),{inputs:[t],outputs:[-1]})[0]):m=t;let h=m.dims,i=h[c-1],r=a/i,u=ce(i),f=i/u,g=64;r===1&&(g=256);let w=(C,I)=>I===4?`max(max(${C}.x, ${C}.y), max(${C}.z, ${C}.w))`:I===2?`max(${C}.x, ${C}.y)`:I===3?`max(max(${C}.x, ${C}.y), ${C}.z)`:C,y=P("x",m.dataType,m.dims,u),x=M("result",m.dataType,m.dims,u),S=y.type.value,T=be(m.dataType)==="f32"?`var threadMax = ${S}(-3.402823e+38f);`:`var threadMax = ${S}(-65504.0h);`,E=C=>`
      var<workgroup> rowMaxShared : ${S};
      var<workgroup> rowSumShared : ${S};
      var<workgroup> threadShared : array<${S}, ${g}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${S} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${S}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${C.registerUniform("packedCols","i32").declareVariables(y,x)}
      ${C.mainStart(g)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${g};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${T}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${S}(${w("threadShared[0]",u)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${S}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${S}(${He("threadShared[0]",u)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,A=n.compute({name:"Softmax",shaderCache:{hint:`${u};${g}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:h,dataType:m.dataType}],dispatchGroup:{x:r},programUniforms:[{type:6,data:f}]}),getShaderSource:E},{inputs:[m],outputs:[_?-1:0]})[0];_&&n.compute(Ee(A,d),{inputs:[A]})},Ll=(n,e)=>{og(n.inputs),ig(n,e)},Gl=n=>J({axis:n.axis})}),Fl,ag,sg,ug,ql,jl=U(()=>{ee(),ne(),ie(),Fl=n=>Array.from(n.getBigInt64Array(),Number),ag=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 inputs.");if(n[0].dataType!==1&&n[0].dataType!==10&&n[0].dataType!==6&&n[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(n[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(n[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Fl(n[1]).length!==n[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},sg=(n,e)=>{let t=[];for(let s=0;s<n.length;++s)t.push(n[s]*e[s]);return t},ug=(n,e)=>{let t=n[0].dims,s=e??Fl(n[1]),a=sg(t,s),c=k.size(a),l=n[0].dataType,_=P("input",l,t.length),m=M("output",l,a.length),d=h=>`
      const inputShape = ${_.indices(...t)};
      ${h.registerUniform("output_size","u32").declareVariables(_,m)}
      ${h.mainStart()}
      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${m.offsetToIndices("global_idx")};
      var input_indices: ${_.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let input_dim_i = ${_.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${m.indicesGet("output_indices","i")}  % input_dim_i;

        ${_.indicesSet("input_indices","i","input_dim_value")}
      }
      ${m.setByOffset("global_idx",_.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${s}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...N(n[0].dims,a)]}),getShaderSource:d}},ql=n=>{ag(n.inputs),n.compute(ug(n.inputs),{inputs:[0]})}}),dg,lg,Kl,Zl=U(()=>{ee(),ne(),ie(),dg=(n,e,t,s,a)=>{let c=M("output_data",a,t.length,4),l=P("a_data",e[1].dataType,e[1].dims.length,4),_=P("b_data",e[2].dataType,e[2].dims.length,4),m=P("c_data",e[0].dataType,e[0].dims.length,4),d,h=(i,r,u)=>`select(${r}, ${i}, ${u})`;if(!s)d=c.setByOffset("global_idx",h(l.getByOffset("global_idx"),_.getByOffset("global_idx"),m.getByOffset("global_idx")));else{let i=(r,u,f="")=>{let g=`a_data[index_a${u}][component_a${u}]`,w=`b_data[index_b${u}][component_b${u}]`,y=`bool(c_data[index_c${u}] & (0xffu << (component_c${u} * 8)))`;return`
            let output_indices${u} = ${c.offsetToIndices(`global_idx * 4u + ${u}u`)};
            let offset_a${u} = ${l.broadcastedIndicesToOffset(`output_indices${u}`,c)};
            let offset_b${u} = ${_.broadcastedIndicesToOffset(`output_indices${u}`,c)};
            let offset_c${u} = ${m.broadcastedIndicesToOffset(`output_indices${u}`,c)};
            let index_a${u} = offset_a${u} / 4u;
            let index_b${u} = offset_b${u} / 4u;
            let index_c${u} = offset_c${u} / 4u;
            let component_a${u} = offset_a${u} % 4u;
            let component_b${u} = offset_b${u} % 4u;
            let component_c${u} = offset_c${u} % 4u;
            ${r}[${u}] = ${f}(${h(g,w,y)});
          `};a===9?d=`
            var data = vec4<u32>(0);
            ${i("data",0,"u32")}
            ${i("data",1,"u32")}
            ${i("data",2,"u32")}
            ${i("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:d=`
            ${i("output_data[global_idx]",0)}
            ${i("output_data[global_idx]",1)}
            ${i("output_data[global_idx]",2)}
            ${i("output_data[global_idx]",3)}
          `}return`
        ${n.registerUniform("vec_size","u32").declareVariables(m,l,_,c)}
        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${d}
      }`},lg=n=>{let e=n[1].dims,t=n[2].dims,s=n[0].dims,a=n[1].dataType,c=!(k.areEqual(e,t)&&k.areEqual(t,s)),l=e,_=k.size(e);if(c){let d=Je.calcShape(Je.calcShape(e,t,!1),s,!1);if(!d)throw new Error("Can't perform where op on the given tensors");l=d,_=k.size(l)}let m=Math.ceil(_/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:d=>dg(d,n,l,c,a),getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(_/64/4)},programUniforms:[{type:12,data:m},...N(s,e,t,l)]})}},Kl=n=>{n.compute(lg(n.inputs))}}),Ql,Yl=U(()=>{Es(),Fr(),zs(),Bs(),_u(),ku(),Ou(),Zu(),rd(),id(),ud(),md(),gd(),yd(),vd(),Sd(),Cd(),kd(),Od(),Md(),Fd(),Kd(),Qd(),Xd(),tl(),$o(),nl(),wl(),xl(),Tl(),kl(),Gr(),Dl(),To(),Rl(),Wl(),Hl(),So(),jl(),st(),jr(),Zl(),Ql=new Map([["Abs",[Ds]],["Acos",[Ms]],["Acosh",[Rs]],["Add",[wu]],["ArgMax",[As,uo]],["ArgMin",[Cs,uo]],["Asin",[Us]],["Asinh",[Ns]],["Atan",[Vs]],["Atanh",[Ws]],["Attention",[ks]],["AveragePool",[cl,ll]],["BatchNormalization",[Ps]],["BiasAdd",[Os]],["BiasSplitGelu",[yu]],["Cast",[Gs,Ls]],["Ceil",[Fs]],["Clip",[Hs]],["Concat",[Pu,zu]],["Conv",[yo,bo]],["ConvTranspose",[td,Ju]],["Cos",[qs]],["Cosh",[js]],["CumSum",[nd,od]],["DepthToSpace",[ad,sd]],["DequantizeLinear",[vl,$l]],["Div",[vu]],["Einsum",[cd,pd]],["Elu",[Ks,Yt]],["Equal",[$u]],["Erf",[Zs]],["Exp",[Qs]],["Expand",[hd]],["FastGelu",[bd]],["Floor",[Ys]],["FusedConv",[yo,bo]],["Gather",[wd,_d]],["GatherElements",[Ed,Ad]],["GatherBlockQuantized",[Td,Id]],["GatherND",[$d,xd]],["Gelu",[Xs]],["Gemm",[zd,Pd]],["GlobalAveragePool",[fl,ml]],["GlobalMaxPool",[_l,yl]],["Greater",[Iu]],["GreaterOrEqual",[Au]],["GridSample",[Bd,Dd]],["GroupQueryAttention",[Hd]],["HardSigmoid",[au,iu]],["InstanceNormalization",[jd]],["LayerNormalization",[Zd]],["LeakyRelu",[Js,Yt]],["Less",[Cu]],["LessOrEqual",[Eu]],["Log",[hu]],["MatMul",[Yd]],["MatMulNBits",[Jd,el]],["MaxPool",[gl,bl]],["Mul",[xu]],["MultiHeadAttention",[Nd,Ud]],["Neg",[tu]],["Not",[eu]],["Pad",[rl]],["Pow",[Su]],["QuickGelu",[gu,Yt]],["Range",[Sl]],["Reciprocal",[ru]],["ReduceMin",[vs]],["ReduceMean",[gs]],["ReduceMax",[ws]],["ReduceSum",[xs]],["ReduceProd",[$s]],["ReduceL1",[bs]],["ReduceL2",[ys]],["ReduceLogSum",[Ts]],["ReduceLogSumExp",[_s]],["ReduceSumSquare",[Ss]],["Relu",[nu]],["Resize",[Ol,Bl]],["RotaryEmbedding",[Ld]],["ScatterND",[El,Al]],["Sigmoid",[ou]],["Sin",[su]],["Sinh",[uu]],["Slice",[Nl,Vl]],["SkipLayerNormalization",[Ml]],["Split",[Vd,Wd]],["Sqrt",[du]],["Softmax",[Ll,Gl]],["Sub",[Tu]],["Tan",[lu]],["Tanh",[pu]],["ThresholdedRelu",[fu,Yt]],["Tile",[ql]],["Transpose",[ns,os]],["Where",[Kl]]])}),on,Xl=U(()=>{We(),Xe(),ie(),on=class{constructor(n){this.backend=n,this.repo=new Map,this.attributesBound=!1}getArtifact(n){return this.repo.get(n)}setArtifact(n,e){this.repo.set(n,e)}run(n,e,t,s,a){Re(n.programInfo.name);let c=this.backend.device,l=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let _=[];for(let d of e)_.push({binding:_.length,resource:{buffer:d.buffer}});for(let d of t)_.push({binding:_.length,resource:{buffer:d.buffer}});a&&_.push({binding:_.length,resource:a});let m=c.createBindGroup({layout:n.computePipeline.getBindGroupLayout(0),entries:_,label:n.programInfo.name});if(this.backend.sessionStatus==="capturing"){let d={kernelId:this.backend.currentKernelId,computePipeline:n.computePipeline,bindGroup:m,dispatchGroup:s};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(d)}l.setPipeline(n.computePipeline),l.setBindGroup(0,m),l.dispatchWorkgroups(...s),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Oe(n.programInfo.name)}dispose(){}build(n,e){Re(n.name);let t=this.backend.device,s=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(d=>{t.features.has(d.feature)&&s.push(`enable ${d.extension};`)});let a=ts(e,this.backend.device.limits),c=n.getShaderSource(a),l=`${s.join(`
`)}
${a.additionalImplementations}
${c}`,_=t.createShaderModule({code:l,label:n.name});se("verbose",()=>`[WebGPU] ${n.name} shader code: ${l}`);let m=t.createComputePipeline({compute:{module:_,entryPoint:"main"},layout:"auto",label:n.name});return Oe(n.name),{programInfo:n,computePipeline:m,uniformVariablesInfo:a.variablesInfo}}normalizeDispatchGroupSize(n){let e=typeof n=="number"?n:n.x,t=typeof n=="number"?1:n.y||1,s=typeof n=="number"?1:n.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=a&&t<=a&&s<=a)return[e,t,s];let c=e*t*s,l=Math.ceil(Math.sqrt(c));if(l>a){if(l=Math.ceil(Math.cbrt(c)),l>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}}),Jl={};Dt(Jl,{WebGpuBackend:()=>Co});var cg,pg,Io,Co,ec=U(()=>{We(),ee(),Xe(),Zn(),Ja(),Yl(),Xl(),cg=(n,e)=>{if(e.length!==n.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${n.length}.`);let t=[];for(let s=0;s<n.length;++s){let a=n[s].dataType;switch(e[s]){case"none":{t.push("");break}case"type":{t.push(`${a}`);break}case"rank":{let c=n[s].dims.length;t.push(`${a};${c}`);break}case"dims":{let c=n[s].dims.join(",");t.push(`${a};${c}`);break}default:throw new Error(`unsupported input dependency: ${e[s]}`)}}return t.join("|")},pg=(n,e,t)=>{let s=n.name;return n.shaderCache?.hint&&(s+="["+n.shaderCache.hint+"]"),s+=":"+t+`:${cg(e,n.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,s},Io=class{constructor(n){n&&(this.architecture=n.architecture,this.vendor=n.vendor)}isArchitecture(n){return this.architecture===n}isVendor(n){return this.vendor===n}},Co=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let n=this.kernelCustomData.get(this.currentKernelId);return n||(n={},this.kernelCustomData.set(this.currentKernelId,n)),n}async initialize(n,e){this.env=n;let t=[],s={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t},a=c=>e.features.has(c)&&t.push(c)&&!0;a("chromium-experimental-timestamp-query-inside-passes")||a("timestamp-query"),a("shader-f16"),a("subgroups"),this.device=await e.requestDevice(s),this.adapterInfo=new Io(e.info||await e.requestAdapterInfo()),this.gpuDataManager=Xa(this),this.programManager=new on(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Br(n.logLevel,!!n.debug),this.device.onuncapturederror=c=>{c.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${c.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let n=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=n.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Re(),this.endComputePass();let n;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),n=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(n,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,n,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&n.mapAsync(GPUMapMode.READ).then(()=>{let e=new BigUint64Array(n.getMappedRange()),t=this.pendingQueries.get(n);for(let s=0;s<e.length/2;s++){let a=t[s],c=a.kernelId,l=this.kernels.get(c),_=l.kernelType,m=l.kernelName,d=a.programName,h=a.inputTensorViews,i=a.outputTensorViews,r=e[s*2],u=e[s*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=r);let f=Number(r-this.queryTimeBase),g=Number(u-this.queryTimeBase);if(!Number.isSafeInteger(f)||!Number.isSafeInteger(g))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:h.map(w=>({dims:w.dims,dataType:Ye(w.dataType)})),outputsMetadata:i.map(w=>({dims:w.dims,dataType:Ye(w.dataType)})),kernelId:c,kernelType:_,kernelName:m,programName:d,startTime:f,endTime:g});else{let w="";h.forEach((x,S)=>{w+=`input[${S}]: [${x.dims}] | ${Ye(x.dataType)}, `});let y="";i.forEach((x,S)=>{y+=`output[${S}]: [${x.dims}] | ${Ye(x.dataType)}, `}),console.log(`[profiling] kernel "${c}|${_}|${m}|${d}" ${w}${y}execution time: ${g-f} ns`)}gr("GPU",`${d}::${r}::${u}`)}n.unmap(),this.pendingQueries.delete(n)}),Oe()}run(n,e,t,s,a,c){Re(n.name);let l=[];for(let x=0;x<e.length;++x){let S=e[x].data;if(S===0)continue;let T=this.gpuDataManager.get(S);if(!T)throw new Error(`no GPU data for input: ${S}`);l.push(T)}let{outputs:_,dispatchGroup:m,programUniforms:d}=n.getRunData(e),h=t.length===0?_.map((x,S)=>S):t;if(h.length!==_.length)throw new Error(`Output size ${h.length} must be equal to ${_.length}.`);let i=[],r=[];for(let x=0;x<_.length;++x){if(!Number.isInteger(h[x])||h[x]<-3||h[x]>=c)throw new Error(`Invalid output index: ${h[x]}`);if(h[x]===-3)continue;let S=h[x]===-1,T=h[x]===-2,E=S||T?a(_[x].dataType,_[x].dims):s(h[x],_[x].dataType,_[x].dims);if(i.push(E),E.data===0)continue;let A=this.gpuDataManager.get(E.data);if(!A)throw new Error(`no GPU data for output: ${E.data}`);if(S&&this.temporaryData.push(A),T){let C=this.kernelPersistentData.get(this.currentKernelId);C||(C=[],this.kernelPersistentData.set(this.currentKernelId,C)),C.push(A)}r.push(A)}if(l.length!==e.length||r.length!==i.length){if(r.length===0)return Oe(n.name),i;throw new Error(`Program ${n.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let u;if(d){let x=0,S=[];d.forEach(C=>{let I=typeof C.data=="number"?[C.data]:C.data;if(I.length===0)return;let D=C.type===10?2:4,R,Y;C.type===10?(Y=I.length>4?16:I.length>2?8:I.length*D,R=I.length>4?16:D*I.length):(Y=I.length<=2?I.length*D:16,R=16),x=Math.ceil(x/Y)*Y,S.push(x);let re=C.type===10?8:4;x+=I.length>4?Math.ceil(I.length/re)*R:I.length*D});let T=16;x=Math.ceil(x/T)*T;let E=new ArrayBuffer(x);d.forEach((C,I)=>{let D=S[I],R=typeof C.data=="number"?[C.data]:C.data;if(C.type===6)new Int32Array(E,D,R.length).set(R);else if(C.type===12)new Uint32Array(E,D,R.length).set(R);else if(C.type===10)new Uint16Array(E,D,R.length).set(R);else if(C.type===1)new Float32Array(E,D,R.length).set(R);else throw new Error(`Unsupported uniform type: ${Ye(C.type)}`)});let A=this.gpuDataManager.create(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(A.buffer,0,E,0,x),this.gpuDataManager.release(A.id),u={offset:0,size:x,buffer:A.buffer}}let f=this.programManager.normalizeDispatchGroupSize(m),g=f[1]===1&&f[2]===1,w=pg(n,e,g),y=this.programManager.getArtifact(w);if(y||(y=this.programManager.build(n,f),this.programManager.setArtifact(w,y),se("info",()=>`[artifact] key: ${w}, programName: ${n.name}`)),d&&y.uniformVariablesInfo){if(d.length!==y.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${y.uniformVariablesInfo.length}, got ${d.length} in program "${y.programInfo.name}".`);for(let x=0;x<d.length;x++){let S=d[x],T=S.type,E=typeof S.data=="number"?1:S.data.length,[A,C]=y.uniformVariablesInfo[x];if(T!==A||E!==C)throw new Error(`Uniform variable ${x} mismatch: expect type ${A} with size ${C}, got type ${T} with size ${E} in program "${y.programInfo.name}".`)}}if(se("info",()=>`[ProgramManager] run "${n.name}" (key=${w}) with ${f[0]}x${f[1]}x${f[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let x={kernelId:this.currentKernelId,programName:y.programInfo.name,inputTensorViews:e,outputTensorViews:i};this.pendingKernels.push(x),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(x)}return this.programManager.run(y,l,r,f,u),Oe(n.name),i}upload(n,e){this.gpuDataManager.upload(n,e)}memcpy(n,e){this.gpuDataManager.memcpy(n,e)}async download(n,e){await this.gpuDataManager.download(n,e)}alloc(n){return this.gpuDataManager.create(n).id}free(n){return this.gpuDataManager.release(n)}createKernel(n,e,t,s){let a=Ql.get(n);if(!a)throw new Error(`kernel not implemented: ${n}`);let c={kernelType:n,kernelName:s,kernelEntry:a[0],attributes:[a[1],t]};this.kernels.set(e,c)}releaseKernel(n){let e=this.kernelPersistentData.get(n);if(e){for(let t of e)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(n)}this.kernelCustomData.delete(n),this.kernels.delete(n)}computeKernel(n,e,t){let s=this.kernels.get(n);if(!s)throw new Error(`kernel not created: ${n}`);let a=s.kernelType,c=s.kernelName,l=s.kernelEntry,_=s.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${a}] ${c}" is not allowed to be called recursively`);this.currentKernelId=n,_[0]&&(_[1]=_[0](_[1]),_[0]=void 0),se("info",()=>`[WebGPU] Start to run kernel "[${a}] ${c}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),l(e,_[1]),0}catch(d){return t.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${c}" failed. ${d}`)),1}finally{m&&t.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${a}] ${c}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(n,e,t,s){let a=this.sessionExternalDataMapping.get(n);a||(a=new Map,this.sessionExternalDataMapping.set(n,a));let c=a.get(e),l=this.gpuDataManager.registerExternalBuffer(t,s,c);return a.set(e,[l,t]),l}unregisterBuffers(n){let e=this.sessionExternalDataMapping.get(n);e&&(e.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[0])),this.sessionExternalDataMapping.delete(n))}getBuffer(n){let e=this.gpuDataManager.get(n);if(!e)throw new Error(`no GPU data for buffer: ${n}`);return e.buffer}createDownloader(n,e,t){return async()=>{let s=await ro(this,n,e);return Mr(s.buffer,t)}}writeTimestamp(n){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,n)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){se("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){se("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){se("info","replay"),this.sessionStatus="replaying";let n=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),t=n.length;this.pendingKernels=[];for(let s=0;s<t;s++){let a=this.getComputePassEncoder(),c=n[s];this.writeTimestamp(this.pendingDispatchNumber*2),a.setPipeline(c.computePipeline),a.setBindGroup(0,c.bindGroup),a.dispatchWorkgroups(...c.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[s]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(n){this.unregisterBuffers(n),this.capturedCommandList.has(n)&&this.capturedCommandList.delete(n),this.capturedPendingKernels.has(n)&&this.capturedPendingKernels.delete(n),this.gpuDataManager.onReleaseSession(n)}onRunStart(n){this.currentSessionId=n,this.setQueryType()}}}),tc={};Dt(tc,{init:()=>mg});var tr,Ao,mg,rc=U(()=>{ee(),Xe(),ne(),Ka(),tr=class oT{constructor(e,t,s,a){this.module=e,this.dataType=t,this.data=s,this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=k.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=k.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=k.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let e=k.size(this.dims);return e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(k.size(e)!==k.size(this.dims))throw new Error("Invalid new shape");return new oT(this.module,this.dataType,this.data,e)}},Ao=class{constructor(n,e,t){this.module=n,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let s=n.PTR_SIZE,a=t/n.PTR_SIZE,c=s===4?"i32":"i64";this.opKernelContext=Number(n.getValue(s*a++,c));let l=Number(n.getValue(s*a++,c));this.outputCount=Number(n.getValue(s*a++,c)),this.customDataOffset=Number(n.getValue(s*a++,"*")),this.customDataSize=Number(n.getValue(s*a++,c));let _=[];for(let m=0;m<l;m++){let d=Number(n.getValue(s*a++,c)),h=Number(n.getValue(s*a++,"*")),i=Number(n.getValue(s*a++,c)),r=[];for(let u=0;u<i;u++)r.push(Number(n.getValue(s*a++,c)));_.push(new tr(n,d,h,r))}this.inputs=_}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(n,e){let t=e?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,s=e?.outputs??[],a=(l,_,m)=>new tr(this.module,_,this.output(l,m),m),c=(l,_)=>{let m=gt(l,_);if(!m)throw new Error(`Unsupported data type: ${l}`);let d=m>0?this.backend.gpuDataManager.create(m).id:0;return new tr(this.module,l,d,_)};return this.backend.run(n,t,s,a,c,this.outputCount)}output(n,e){let t=this.module.stackSave();try{let s=this.module.PTR_SIZE,a=s===4?"i32":"i64",c=this.module.stackAlloc((1+e.length)*s);this.module.setValue(c,e.length,a);for(let l=0;l<e.length;l++)this.module.setValue(c+s*(l+1),e[l],a);return this.module._JsepOutput(this.opKernelContext,n,c)}catch(s){throw new Error(`Failed to generate kernel's output[${n}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${s}`)}finally{this.module.stackRestore(t)}}},mg=async(n,e,t,s)=>{let a=e.jsepInit;if(!a)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(n==="webgpu"){let c=(ec(),Ft(Jl)).WebGpuBackend,l=new c;await l.initialize(t,s),a("webgpu",[l,_=>l.alloc(Number(_)),_=>l.free(_),(_,m,d,h=!1)=>{if(h)se("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(_)}, dst=${Number(m)}, size=${Number(d)}`),l.memcpy(Number(_),Number(m));else{se("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(_)}, gpuDataId=${Number(m)}, size=${Number(d)}`);let i=e.HEAPU8.subarray(Number(_>>>0),Number(_>>>0)+Number(d));l.upload(Number(m),i)}},async(_,m,d)=>{se("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${_}, dataOffset=${m}, size=${d}`),await l.download(Number(_),()=>e.HEAPU8.subarray(Number(m)>>>0,Number(m+d)>>>0))},(_,m,d)=>l.createKernel(_,Number(m),d,e.UTF8ToString(e._JsepGetNodeName(Number(m)))),_=>l.releaseKernel(_),(_,m,d,h)=>{se("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${d}, kernel=${_}, contextDataOffset=${m}`);let i=new Ao(e,l,Number(m));return l.computeKernel(Number(_),i,h)},()=>l.captureBegin(),()=>l.captureEnd(),()=>l.replay()])}else{let c=new Nr(t);a("webnn",[c,()=>c.reserveTensorId(),l=>c.releaseTensorId(l),async(l,_,m,d,h)=>c.ensureTensor(l,_,m,d,h),(l,_)=>{c.uploadTensor(l,_)},async(l,_)=>c.downloadTensor(l,_)])}}}),fg,vr,$r,At,hg,nc,jt,xr,Sr,oc,Tr,Ir,Cr,Vn=U(()=>{Ma(),Ua(),ee(),ht(),Er(),jn(),fg=(n,e)=>{fe()._OrtInit(n,e)!==0&&pe("Can't initialize onnxruntime.")},vr=async n=>{fg(n.wasm.numThreads,Zt(n.logLevel))},$r=async(n,e)=>{fe().asyncInit?.();{let t=(rc(),Ft(tc)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let s=n.webgpu.adapter;if(s){if(typeof s.limits!="object"||typeof s.features!="object"||typeof s.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let a=n.webgpu.powerPreference;if(a!==void 0&&a!=="low-power"&&a!=="high-performance")throw new Error(`Invalid powerPreference setting: "${a}"`);let c=n.webgpu.forceFallbackAdapter;if(c!==void 0&&typeof c!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${c}"`);if(s=await navigator.gpu.requestAdapter({powerPreference:a,forceFallbackAdapter:c}),!s)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await t("webgpu",fe(),n,s)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await t("webnn",fe(),n)}}},At=new Map,hg=n=>{let e=fe(),t=e.stackSave();try{let s=e.PTR_SIZE,a=e.stackAlloc(2*s);e._OrtGetInputOutputCount(n,a,a+s)!==0&&pe("Can't get session input/output count.");let c=s===4?"i32":"i64";return[Number(e.getValue(a,c)),Number(e.getValue(a+s,c))]}finally{e.stackRestore(t)}},nc=(n,e)=>{let t=fe(),s=t.stackSave(),a=0;try{let c=t.PTR_SIZE,l=t.stackAlloc(2*c);t._OrtGetInputOutputMetadata(n,e,l,l+c)!==0&&pe("Can't get session input/output metadata.");let _=Number(t.getValue(l,"*"));a=Number(t.getValue(l+c,"*"));let m=t.HEAP32[a/4];if(m===0)return[_,0];let d=t.HEAPU32[a/4+1],h=[];for(let i=0;i<d;i++){let r=Number(t.getValue(a+8+i*c,"*"));h.push(r!==0?t.UTF8ToString(r):Number(t.getValue(a+8+(i+d)*c,"*")))}return[_,m,h]}finally{t.stackRestore(s),a!==0&&t._OrtFree(a)}},jt=n=>{let e=fe(),t=e._malloc(n.byteLength);if(t===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${n.byteLength}.`);return e.HEAPU8.set(n,t),[t,n.byteLength]},xr=async(n,e)=>{let t,s,a=fe();Array.isArray(n)?[t,s]=n:n.buffer===a.HEAPU8.buffer?[t,s]=[n.byteOffset,n.byteLength]:[t,s]=jt(n);let c=0,l=0,_=0,m=[],d=[],h=[];try{if([l,m]=await Ra(e),e?.externalData&&a.mountExternalData){let T=[];for(let E of e.externalData){let A=typeof E=="string"?E:E.path;T.push(Qt(typeof E=="string"?E:E.data).then(C=>{a.mountExternalData(A,C)}))}await Promise.all(T)}for(let T of e?.executionProviders??[])if((typeof T=="string"?T:T.name)==="webnn"){if(a.shouldTransferToMLTensor=!1,typeof T!="string"){let E=T,A=E?.context,C=E?.gpuDevice,I=E?.deviceType,D=E?.powerPreference;A?a.currentContext=A:C?a.currentContext=await a.webnnCreateMLContext(C):a.currentContext=await a.webnnCreateMLContext({deviceType:I,powerPreference:D})}else a.currentContext=await a.webnnCreateMLContext();break}c=await a._OrtCreateSession(t,s,l),a.webgpuOnCreateSession?.(c),c===0&&pe("Can't create a session."),a.jsepOnCreateSession?.(),a.currentContext&&(a.webnnRegisterMLContext(c,a.currentContext),a.currentContext=void 0,a.shouldTransferToMLTensor=!0);let[i,r]=hg(c),u=!!e?.enableGraphCapture,f=[],g=[],w=[],y=[],x=[];for(let T=0;T<i;T++){let[E,A,C]=nc(c,T);E===0&&pe("Can't get an input name."),d.push(E);let I=a.UTF8ToString(E);f.push(I),w.push(A===0?{name:I,isTensor:!1}:{name:I,isTensor:!0,type:Ye(A),shape:C})}for(let T=0;T<r;T++){let[E,A,C]=nc(c,T+i);E===0&&pe("Can't get an output name."),h.push(E);let I=a.UTF8ToString(E);g.push(I),y.push(A===0?{name:I,isTensor:!1}:{name:I,isTensor:!0,type:Ye(A),shape:C});{if(u&&e?.preferredOutputLocation===void 0){x.push("gpu-buffer");continue}let D=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[I]??"cpu";if(D!=="cpu"&&D!=="cpu-pinned"&&D!=="gpu-buffer"&&D!=="ml-tensor")throw new Error(`Not supported preferred output location: ${D}.`);if(u&&D!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${D}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);x.push(D)}}let S=null;return x.some(T=>T==="gpu-buffer"||T==="ml-tensor")&&(_=a._OrtCreateBinding(c),_===0&&pe("Can't create IO binding."),S={handle:_,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(T=>qn(T))}),At.set(c,[c,d,h,S,u,!1]),[c,f,g,w,y]}catch(i){throw d.forEach(r=>a._OrtFree(r)),h.forEach(r=>a._OrtFree(r)),_!==0&&a._OrtReleaseBinding(_)!==0&&pe("Can't release IO binding."),c!==0&&a._OrtReleaseSession(c)!==0&&pe("Can't release session."),i}finally{a._free(t),l!==0&&a._OrtReleaseSessionOptions(l)!==0&&pe("Can't release session options."),m.forEach(i=>a._free(i)),a.unmountExternalData?.()}},Sr=n=>{let e=fe(),t=At.get(n);if(!t)throw new Error(`cannot release session. invalid session id: ${n}`);let[s,a,c,l,_]=t;l&&(_&&e._OrtClearBoundOutputs(l.handle)!==0&&pe("Can't clear bound outputs."),e._OrtReleaseBinding(l.handle)!==0&&pe("Can't release IO binding.")),e.jsepOnReleaseSession?.(n),e.webnnOnReleaseSession?.(n),e.webgpuOnReleaseSession?.(n),a.forEach(m=>e._OrtFree(m)),c.forEach(m=>e._OrtFree(m)),e._OrtReleaseSession(s)!==0&&pe("Can't release session."),At.delete(n)},oc=async(n,e,t,s,a,c,l=!1)=>{if(!n){e.push(0);return}let _=fe(),m=_.PTR_SIZE,d=n[0],h=n[1],i=n[3],r=i,u,f;if(d==="string"&&(i==="gpu-buffer"||i==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(l&&i!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${c} when enableGraphCapture is true.`);if(i==="gpu-buffer"){let y=n[2].gpuBuffer;f=gt(Mt(d),h);{let x=_.jsepRegisterBuffer;if(!x)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=x(s,c,y,f)}}else if(i==="ml-tensor"){let y=n[2].mlTensor;f=gt(Mt(d),h);let x=_.webnnRegisterMLTensor;if(!x)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=x(s,y,Mt(d),h)}else{let y=n[2];if(Array.isArray(y)){f=m*y.length,u=_._malloc(f),t.push(u);for(let x=0;x<y.length;x++){if(typeof y[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);_.setValue(u+x*m,Ne(y[x],t),"*")}}else{let x=_.webnnIsGraphInput;if(d!=="string"&&x){let S=_.UTF8ToString(a);if(x(s,S)){let T=Mt(d);f=gt(T,h),r="ml-tensor";let E=_.webnnCreateTemporaryTensor,A=_.webnnUploadTensor;if(!E||!A)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let C=await E(s,T,h);A(C,new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),u=C}else f=y.byteLength,u=_._malloc(f),t.push(u),_.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,f),u)}else f=y.byteLength,u=_._malloc(f),t.push(u),_.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,f),u)}}let g=_.stackSave(),w=_.stackAlloc(4*h.length);try{h.forEach((x,S)=>_.setValue(w+S*m,x,m===4?"i32":"i64"));let y=_._OrtCreateTensor(Mt(d),u,f,w,h.length,qn(r));y===0&&pe(`Can't create tensor for input/output. session=${s}, index=${c}.`),e.push(y)}finally{_.stackRestore(g)}},Tr=async(n,e,t,s,a,c)=>{let l=fe(),_=l.PTR_SIZE,m=At.get(n);if(!m)throw new Error(`cannot run inference. invalid session id: ${n}`);let d=m[0],h=m[1],i=m[2],r=m[3],u=m[4],f=m[5],g=e.length,w=s.length,y=0,x=[],S=[],T=[],E=[],A=l.stackSave(),C=l.stackAlloc(g*_),I=l.stackAlloc(g*_),D=l.stackAlloc(w*_),R=l.stackAlloc(w*_);try{[y,x]=Da(c);for(let G=0;G<g;G++)await oc(t[G],S,E,n,h[e[G]],e[G],u);for(let G=0;G<w;G++)await oc(a[G],T,E,n,i[s[G]],g+s[G],u);for(let G=0;G<g;G++)l.setValue(C+G*_,S[G],"*"),l.setValue(I+G*_,h[e[G]],"*");for(let G=0;G<w;G++)l.setValue(D+G*_,T[G],"*"),l.setValue(R+G*_,i[s[G]],"*");if(r&&!f){let{handle:G,outputPreferredLocations:te,outputPreferredLocationsEncoded:q}=r;if(h.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${h.length}).`);for(let z=0;z<g;z++){let H=e[z];await l._OrtBindInput(G,h[H],S[z])!==0&&pe(`Can't bind input[${z}] for session=${n}.`)}for(let z=0;z<w;z++){let H=s[z];a[z]?.[3]?l._OrtBindOutput(G,i[H],T[z],0)!==0&&pe(`Can't bind pre-allocated output[${z}] for session=${n}.`):l._OrtBindOutput(G,i[H],0,q[H])!==0&&pe(`Can't bind output[${z}] to ${te[z]} for session=${n}.`)}At.set(n,[d,h,i,r,u,!0])}l.jsepOnRunStart?.(d),l.webnnOnRunStart?.(d);let Y;r?Y=await l._OrtRunWithBinding(d,r.handle,w,D,y):Y=await l._OrtRun(d,I,C,g,R,w,D,y),Y!==0&&pe("failed to call OrtRun().");let re=[];for(let G=0;G<w;G++){let te=Number(l.getValue(D+G*_,"*"));if(te===T[G]){re.push(a[G]);continue}let q=l.stackSave(),z=l.stackAlloc(4*_),H=!1,he,Ce=0;try{l._OrtGetTensorData(te,z,z+_,z+2*_,z+3*_)!==0&&pe(`Can't access output tensor data on index ${G}.`);let oe=_===4?"i32":"i64",K=Number(l.getValue(z,oe));Ce=l.getValue(z+_,"*");let Q=l.getValue(z+_*2,"*"),de=Number(l.getValue(z+_*3,oe)),ue=[];for(let Gt=0;Gt<de;Gt++)ue.push(Number(l.getValue(Q+Gt*_,oe)));l._OrtFree(Q)!==0&&pe("Can't free memory for tensor dims.");let Ze=ue.reduce((Gt,bn)=>Gt*bn,1);he=Ye(K);let Pt=r?.outputPreferredLocations[s[G]];if(he==="string"){if(Pt==="gpu-buffer"||Pt==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Gt=[];for(let bn=0;bn<Ze;bn++){let ri=l.getValue(Ce+bn*_,"*"),hn=l.getValue(Ce+(bn+1)*_,"*"),ze=bn===Ze-1?void 0:hn-ri;Gt.push(l.UTF8ToString(ri,ze))}re.push([he,ue,Gt,"cpu"])}else if(Pt==="gpu-buffer"&&Ze>0){let Gt=l.jsepGetBuffer;if(!Gt)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let bn=Gt(Ce),ri=gt(K,Ze);if(ri===void 0||!zr(he))throw new Error(`Unsupported data type: ${he}`);H=!0,re.push([he,ue,{gpuBuffer:bn,download:l.jsepCreateDownloader(bn,ri,he),dispose:()=>{l._OrtReleaseTensor(te)!==0&&pe("Can't release tensor.")}},"gpu-buffer"])}else if(Pt==="ml-tensor"&&Ze>0){let Gt=l.webnnEnsureTensor,bn=l.webnnIsInt64Supported;if(!Gt||!bn)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(gt(K,Ze)===void 0||!Or(he))throw new Error(`Unsupported data type: ${he}`);if(he==="int64"&&!bn(n))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let ri=await Gt(n,Ce,K,ue,!1);H=!0,re.push([he,ue,{mlTensor:ri,download:l.webnnCreateMLTensorDownloader(Ce,he),dispose:()=>{l.webnnReleaseTensorId(Ce),l._OrtReleaseTensor(te)}},"ml-tensor"])}else{let Gt=Pr(he),bn=new Gt(Ze);new Uint8Array(bn.buffer,bn.byteOffset,bn.byteLength).set(l.HEAPU8.subarray(Ce,Ce+bn.byteLength)),re.push([he,ue,bn,"cpu"])}}finally{l.stackRestore(q),he==="string"&&Ce&&l._free(Ce),H||l._OrtReleaseTensor(te),l.webnnOnRunEnd?.(d)}}return r&&!u&&(l._OrtClearBoundOutputs(r.handle)!==0&&pe("Can't clear bound outputs."),At.set(n,[d,h,i,r,u,!1])),re}finally{l.stackRestore(A),S.forEach(Y=>l._OrtReleaseTensor(Y)),T.forEach(Y=>l._OrtReleaseTensor(Y)),E.forEach(Y=>l._free(Y)),y!==0&&l._OrtReleaseRunOptions(y),x.forEach(Y=>l._free(Y))}},Ir=n=>{let e=fe(),t=At.get(n);if(!t)throw new Error("invalid session id");let s=t[0],a=e._OrtEndProfiling(s);a===0&&pe("Can't get an profile file name."),e._OrtFree(a)},Cr=n=>{let e=[];for(let t of n){let s=t[2];!Array.isArray(s)&&"buffer"in s&&e.push(s.buffer)}return e}}),Et,Le,rr,sn,un,an,Eo,ko,Vt,Wt,bg,ic,ac,sc,uc,dc,lc,cc,Po=U(()=>{We(),Vn(),ht(),_r(),Et=()=>!!ge.wasm.proxy&&typeof document<"u",rr=!1,sn=!1,un=!1,ko=new Map,Vt=(n,e)=>{let t=ko.get(n);t?t.push(e):ko.set(n,[e])},Wt=()=>{if(rr||!sn||un||!Le)throw new Error("worker not ready")},bg=n=>{switch(n.data.type){case"init-wasm":rr=!1,n.data.err?(un=!0,Eo[1](n.data.err)):(sn=!0,Eo[0]()),an&&(URL.revokeObjectURL(an),an=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=ko.get(n.data.type);n.data.err?e.shift()[1](n.data.err):e.shift()[0](n.data.out);break}}},ic=async()=>{if(!sn){if(rr)throw new Error("multiple calls to 'initWasm()' detected.");if(un)throw new Error("previous call to 'initWasm()' failed.");if(rr=!0,Et())return new Promise((n,e)=>{Le?.terminate(),za().then(([t,s])=>{try{Le=s,Le.onerror=c=>e(c),Le.onmessage=bg,Eo=[n,e];let a={type:"init-wasm",in:ge};!a.in.wasm.wasmPaths&&(t||Gn)&&(a.in.wasm.wasmPaths={wasm:new URL("/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href}),Le.postMessage(a),an=t}catch(a){e(a)}},e)});try{await wr(ge.wasm),await vr(ge),sn=!0}catch(n){throw un=!0,n}finally{rr=!1}}},ac=async n=>{if(Et())return Wt(),new Promise((e,t)=>{Vt("init-ep",[e,t]);let s={type:"init-ep",in:{epName:n,env:ge}};Le.postMessage(s)});await $r(ge,n)},sc=async n=>Et()?(Wt(),new Promise((e,t)=>{Vt("copy-from",[e,t]);let s={type:"copy-from",in:{buffer:n}};Le.postMessage(s,[n.buffer])})):jt(n),uc=async(n,e)=>{if(Et()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Wt(),new Promise((t,s)=>{Vt("create",[t,s]);let a={type:"create",in:{model:n,options:{...e}}},c=[];n instanceof Uint8Array&&c.push(n.buffer),Le.postMessage(a,c)})}else return xr(n,e)},dc=async n=>{if(Et())return Wt(),new Promise((e,t)=>{Vt("release",[e,t]);let s={type:"release",in:n};Le.postMessage(s)});Sr(n)},lc=async(n,e,t,s,a,c)=>{if(Et()){if(t.some(l=>l[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some(l=>l))throw new Error("pre-allocated output tensor is not supported for proxy.");return Wt(),new Promise((l,_)=>{Vt("run",[l,_]);let m=t,d={type:"run",in:{sessionId:n,inputIndices:e,inputs:m,outputIndices:s,options:c}};Le.postMessage(d,Cr(m))})}else return Tr(n,e,t,s,a,c)},cc=async n=>{if(Et())return Wt(),new Promise((e,t)=>{Vt("end-profiling",[e,t]);let s={type:"end-profiling",in:n};Le.postMessage(s)});Ir(n)}}),pc,yg,dn,mc=U(()=>{We(),Po(),ee(),yr(),jn(),pc=(n,e)=>{switch(n.location){case"cpu":return[n.type,n.dims,n.data,"cpu"];case"gpu-buffer":return[n.type,n.dims,{gpuBuffer:n.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[n.type,n.dims,{mlTensor:n.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${n.location} for ${e()}`)}},yg=n=>{switch(n[3]){case"cpu":return new Ge(n[0],n[2],n[1]);case"gpu-buffer":{let e=n[0];if(!zr(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:t,download:s,dispose:a}=n[2];return Ge.fromGpuBuffer(t,{dataType:e,dims:n[1],download:s,dispose:a})}case"ml-tensor":{let e=n[0];if(!Or(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:t,download:s,dispose:a}=n[2];return Ge.fromMLTensor(t,{dataType:e,dims:n[1],download:s,dispose:a})}default:throw new Error(`invalid data location: ${n[3]}`)}},dn=class{async fetchModelAndCopyToWasmMemory(n){return sc(await Qt(n))}async loadModel(n,e){Re();let t;typeof n=="string"?t=await this.fetchModelAndCopyToWasmMemory(n):t=n,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await uc(t,e),Oe()}async dispose(){return dc(this.sessionId)}async run(n,e,t){Re();let s=[],a=[];Object.entries(n).forEach(i=>{let r=i[0],u=i[1],f=this.inputNames.indexOf(r);if(f===-1)throw new Error(`invalid input '${r}'`);s.push(u),a.push(f)});let c=[],l=[];Object.entries(e).forEach(i=>{let r=i[0],u=i[1],f=this.outputNames.indexOf(r);if(f===-1)throw new Error(`invalid output '${r}'`);c.push(u),l.push(f)});let _=s.map((i,r)=>pc(i,()=>`input "${this.inputNames[a[r]]}"`)),m=c.map((i,r)=>i?pc(i,()=>`output "${this.outputNames[l[r]]}"`):null),d=await lc(this.sessionId,a,_,l,m,t),h={};for(let i=0;i<d.length;i++)h[this.outputNames[l[i]]]=c[i]??yg(d[i]);return Oe(),h}startProfiling(){}endProfiling(){cc(this.sessionId)}}}),hc={};Dt(hc,{OnnxruntimeWebAssemblyBackend:()=>ln,initializeFlags:()=>fc,wasmBackend:()=>_g});var fc,ln,_g,gc=U(()=>{We(),Po(),mc(),fc=()=>{(typeof ge.wasm.initTimeout!="number"||ge.wasm.initTimeout<0)&&(ge.wasm.initTimeout=0);let n=ge.wasm.simd;if(typeof n!="boolean"&&n!==void 0&&n!=="fixed"&&n!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${n}". Reset it to \`false\` and ignore SIMD feature checking.`),ge.wasm.simd=!1),typeof ge.wasm.proxy!="boolean"&&(ge.wasm.proxy=!1),typeof ge.wasm.trace!="boolean"&&(ge.wasm.trace=!1),typeof ge.wasm.numThreads!="number"||!Number.isInteger(ge.wasm.numThreads)||ge.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)ge.wasm.numThreads=1;else{let e=typeof navigator>"u"?On("node:os").cpus().length:navigator.hardwareConcurrency;ge.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},ln=class{async init(n){fc(),await ic(),await ac(n)}async createInferenceSessionHandler(n,e){let t=new dn;return await t.loadModel(n,e),t}},_g=new ln});We();We();We();var _a="1.22.0-dev.20250409-89f8206ba4",IS=Nn;{let n=(gc(),Ft(hc)).wasmBackend;$t("webgpu",n,5),$t("webnn",n,5),$t("cpu",n,10),$t("wasm",n,10)}Object.defineProperty(ge.versions,"web",{value:_a,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const __WEBPACK_EXTERNAL_MODULE_onnxruntime_web_74d14b94__=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return Gp},get TRACE(){return gr},get TRACE_FUNC_BEGIN(){return Re},get TRACE_FUNC_END(){return Oe},get Tensor(){return Ge},default:IS,get env(){return ge},get registerBackend(){return $t}},Symbol.toStringTag,{value:"Module"}));var define_process_env_default$1={},__webpack_modules__={"onnxruntime-common":(n=>{n.exports=__WEBPACK_EXTERNAL_MODULE_onnxruntime_common_82b39e9f__}),"onnxruntime-web":(n=>{n.exports=__WEBPACK_EXTERNAL_MODULE_onnxruntime_web_74d14b94__}),"?2ce3":(()=>{}),"?7992":(()=>{}),"?5af5":(()=>{}),"?2b25":(()=>{}),"?db59":(()=>{}),"?383f":(()=>{}),"?fa4b":(()=>{}),"./node_modules/@huggingface/jinja/dist/index.js":((n,e,t)=>{t.r(e),t.d(e,{Environment:()=>fi,Interpreter:()=>wi,Template:()=>Rp,parse:()=>Pt,tokenize:()=>h});var s=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Comment:"Comment"}),a=class{constructor(W,Qe){this.value=W,this.type=Qe}};function c(W){return/\w/.test(W)}function l(W){return/[0-9]/.test(W)}var _=[["{%",s.OpenStatement],["%}",s.CloseStatement],["{{",s.OpenExpression],["}}",s.CloseExpression],["(",s.OpenParen],[")",s.CloseParen],["{",s.OpenCurlyBracket],["}",s.CloseCurlyBracket],["[",s.OpenSquareBracket],["]",s.CloseSquareBracket],[",",s.Comma],[".",s.Dot],[":",s.Colon],["|",s.Pipe],["<=",s.ComparisonBinaryOperator],[">=",s.ComparisonBinaryOperator],["==",s.ComparisonBinaryOperator],["!=",s.ComparisonBinaryOperator],["<",s.ComparisonBinaryOperator],[">",s.ComparisonBinaryOperator],["+",s.AdditiveBinaryOperator],["-",s.AdditiveBinaryOperator],["~",s.AdditiveBinaryOperator],["*",s.MultiplicativeBinaryOperator],["/",s.MultiplicativeBinaryOperator],["%",s.MultiplicativeBinaryOperator],["=",s.Equals]],m=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function d(W,Qe={}){return W.endsWith(`
`)&&(W=W.slice(0,-1)),Qe.lstrip_blocks&&(W=W.replace(/^[ \t]*({[#%-])/gm,"$1")),Qe.trim_blocks&&(W=W.replace(/([#%-]})\n/g,"$1")),W.replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{").replace(/-#}\s*/g,"#}").replace(/\s*{#-/g,"{#").replace(/{%\s*(end)?generation\s*%}/gs,"")}function h(W,Qe={}){const ve=[],Ke=d(W,Qe);let lt=0,_n=0;const ar=vi=>{let Pi="";for(;vi(Ke[lt]);){if(Ke[lt]==="\\"){if(++lt,lt>=Ke.length)throw new SyntaxError("Unexpected end of input");const hi=Ke[lt++],Oo=m.get(hi);if(Oo===void 0)throw new SyntaxError(`Unexpected escaped character: ${hi}`);Pi+=Oo;continue}if(Pi+=Ke[lt++],lt>=Ke.length)throw new SyntaxError("Unexpected end of input")}return Pi};e:for(;lt<Ke.length;){const vi=ve.at(-1)?.type;if(vi===void 0||vi===s.CloseStatement||vi===s.CloseExpression||vi===s.Comment){let hi="";for(;lt<Ke.length&&!(Ke[lt]==="{"&&(Ke[lt+1]==="%"||Ke[lt+1]==="{"||Ke[lt+1]==="#"));)hi+=Ke[lt++];if(hi.length>0){ve.push(new a(hi,s.Text));continue}}if(Ke[lt]==="{"&&Ke[lt+1]==="#"){lt+=2;let hi="";for(;Ke[lt]!=="#"||Ke[lt+1]!=="}";){if(lt+2>=Ke.length)throw new SyntaxError("Missing end of comment tag");hi+=Ke[lt++]}ve.push(new a(hi,s.Comment)),lt+=2;continue}ar(hi=>/\s/.test(hi));const Pi=Ke[lt];if(Pi==="-"||Pi==="+"){const hi=ve.at(-1)?.type;if(hi===s.Text||hi===void 0)throw new SyntaxError(`Unexpected character: ${Pi}`);switch(hi){case s.Identifier:case s.NumericLiteral:case s.StringLiteral:case s.CloseParen:case s.CloseSquareBracket:break;default:{++lt;const Oo=ar(l);ve.push(new a(`${Pi}${Oo}`,Oo.length>0?s.NumericLiteral:s.UnaryOperator));continue}}}for(const[hi,Oo]of _){if(hi==="}}"&&_n>0)continue;if(Ke.slice(lt,lt+hi.length)===hi){ve.push(new a(hi,Oo)),Oo===s.OpenExpression?_n=0:Oo===s.OpenCurlyBracket?++_n:Oo===s.CloseCurlyBracket&&--_n,lt+=hi.length;continue e}}if(Pi==="'"||Pi==='"'){++lt;const hi=ar(Oo=>Oo!==Pi);ve.push(new a(hi,s.StringLiteral)),++lt;continue}if(l(Pi)){let hi=ar(l);if(Ke[lt]==="."&&l(Ke[lt+1])){++lt;const Oo=ar(l);hi=`${hi}.${Oo}`}ve.push(new a(hi,s.NumericLiteral));continue}if(c(Pi)){const hi=ar(c);ve.push(new a(hi,s.Identifier));continue}throw new SyntaxError(`Unexpected character: ${Pi}`)}return ve}var i=class{type="Statement"},r=class extends i{constructor(W){super(),this.body=W}type="Program"},u=class extends i{constructor(W,Qe,ve){super(),this.test=W,this.body=Qe,this.alternate=ve}type="If"},f=class extends i{constructor(W,Qe,ve,Ke){super(),this.loopvar=W,this.iterable=Qe,this.body=ve,this.defaultBlock=Ke}type="For"},g=class extends i{type="Break"},w=class extends i{type="Continue"},y=class extends i{constructor(W,Qe,ve){super(),this.assignee=W,this.value=Qe,this.body=ve}type="Set"},x=class extends i{constructor(W,Qe,ve){super(),this.name=W,this.args=Qe,this.body=ve}type="Macro"},S=class extends i{constructor(W){super(),this.value=W}type="Comment"},T=class extends i{type="Expression"},E=class extends T{constructor(W,Qe,ve){super(),this.object=W,this.property=Qe,this.computed=ve}type="MemberExpression"},A=class extends T{constructor(W,Qe){super(),this.callee=W,this.args=Qe}type="CallExpression"},C=class extends T{constructor(W){super(),this.value=W}type="Identifier"},I=class extends T{constructor(W){super(),this.value=W}type="Literal"},D=class extends I{type="IntegerLiteral"},R=class extends I{type="FloatLiteral"},Y=class extends I{type="StringLiteral"},re=class extends I{type="ArrayLiteral"},G=class extends I{type="TupleLiteral"},te=class extends I{type="ObjectLiteral"},q=class extends T{constructor(W,Qe,ve){super(),this.operator=W,this.left=Qe,this.right=ve}type="BinaryExpression"},z=class extends T{constructor(W,Qe){super(),this.operand=W,this.filter=Qe}type="FilterExpression"},H=class extends i{constructor(W,Qe){super(),this.filter=W,this.body=Qe}type="FilterStatement"},he=class extends T{constructor(W,Qe){super(),this.lhs=W,this.test=Qe}type="SelectExpression"},Ce=class extends T{constructor(W,Qe,ve){super(),this.operand=W,this.negate=Qe,this.test=ve}type="TestExpression"},oe=class extends T{constructor(W,Qe){super(),this.operator=W,this.argument=Qe}type="UnaryExpression"},K=class extends T{constructor(W=void 0,Qe=void 0,ve=void 0){super(),this.start=W,this.stop=Qe,this.step=ve}type="SliceExpression"},Q=class extends T{constructor(W,Qe){super(),this.key=W,this.value=Qe}type="KeywordArgumentExpression"},de=class extends T{constructor(W){super(),this.argument=W}type="SpreadExpression"},ue=class extends i{constructor(W,Qe,ve){super(),this.call=W,this.callerArgs=Qe,this.body=ve}type="CallStatement"},Ze=class extends T{constructor(W,Qe,ve){super(),this.condition=W,this.trueExpr=Qe,this.falseExpr=ve}type="Ternary"};function Pt(W){const Qe=new r([]);let ve=0;function Ke(mr,ci){const Mi=W[ve++];if(!Mi||Mi.type!==mr)throw new Error(`Parser Error: ${ci}. ${Mi.type} !== ${mr}.`);return Mi}function lt(mr){if(!Pi(mr))throw new SyntaxError(`Expected ${mr}`);++ve}function _n(){switch(W[ve].type){case s.Comment:return new S(W[ve++].value);case s.Text:return hi();case s.OpenStatement:return Oo();case s.OpenExpression:return we();default:throw new SyntaxError(`Unexpected token type: ${W[ve].type}`)}}function ar(...mr){return ve+mr.length<=W.length&&mr.every((ci,Mi)=>ci===W[ve+Mi].type)}function vi(...mr){return W[ve]?.type===s.OpenStatement&&W[ve+1]?.type===s.Identifier&&mr.includes(W[ve+1]?.value)}function Pi(...mr){return ve+mr.length<=W.length&&mr.every((ci,Mi)=>W[ve+Mi].type==="Identifier"&&ci===W[ve+Mi].value)}function hi(){return new Y(Ke(s.Text,"Expected text token").value)}function Oo(){if(Ke(s.OpenStatement,"Expected opening statement token"),W[ve].type!==s.Identifier)throw new SyntaxError(`Unknown statement, got ${W[ve].type}`);const mr=W[ve].value;let ci;switch(mr){case"set":++ve,ci=it();break;case"if":++ve,ci=pt(),Ke(s.OpenStatement,"Expected {% token"),lt("endif"),Ke(s.CloseStatement,"Expected %} token");break;case"macro":++ve,ci=Ot(),Ke(s.OpenStatement,"Expected {% token"),lt("endmacro"),Ke(s.CloseStatement,"Expected %} token");break;case"for":++ve,ci=mn(),Ke(s.OpenStatement,"Expected {% token"),lt("endfor"),Ke(s.CloseStatement,"Expected %} token");break;case"call":{++ve;let Mi=null;ar(s.OpenParen)&&(Mi=Ro());const Ac=sp();if(Ac.type!=="Identifier")throw new SyntaxError("Expected identifier following call statement");const m_=Ro();Ke(s.CloseStatement,"Expected closing statement token");const Op=[];for(;!vi("endcall");)Op.push(_n());Ke(s.OpenStatement,"Expected '{%'"),lt("endcall"),Ke(s.CloseStatement,"Expected closing statement token");const p_=new A(Ac,m_);ci=new ue(p_,Mi,Op);break}case"break":++ve,Ke(s.CloseStatement,"Expected closing statement token"),ci=new g;break;case"continue":++ve,Ke(s.CloseStatement,"Expected closing statement token"),ci=new w;break;case"filter":{++ve;let Mi=sp();Mi instanceof C&&ar(s.OpenParen)&&(Mi=Oi(Mi)),Ke(s.CloseStatement,"Expected closing statement token");const Ac=[];for(;!vi("endfilter");)Ac.push(_n());Ke(s.OpenStatement,"Expected '{%'"),lt("endfilter"),Ke(s.CloseStatement,"Expected '%}'"),ci=new H(Mi,Ac);break}default:throw new SyntaxError(`Unknown statement type: ${mr}`)}return ci}function we(){Ke(s.OpenExpression,"Expected opening expression token");const mr=ii();return Ke(s.CloseExpression,"Expected closing expression token"),mr}function it(){const mr=Ht();let ci=null;const Mi=[];if(ar(s.Equals))++ve,ci=Ht();else{for(Ke(s.CloseStatement,"Expected %} token");!vi("endset");)Mi.push(_n());Ke(s.OpenStatement,"Expected {% token"),lt("endset")}return Ke(s.CloseStatement,"Expected closing statement token"),new y(mr,ci,Mi)}function pt(){const mr=ii();Ke(s.CloseStatement,"Expected closing statement token");const ci=[],Mi=[];for(;!vi("elif","else","endif");)ci.push(_n());if(vi("elif")){++ve,++ve;const Ac=pt();Mi.push(Ac)}else if(vi("else"))for(++ve,++ve,Ke(s.CloseStatement,"Expected closing statement token");!vi("endif");)Mi.push(_n());return new u(mr,ci,Mi)}function Ot(){const mr=sp();if(mr.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const ci=Ro();Ke(s.CloseStatement,"Expected closing statement token");const Mi=[];for(;!vi("endmacro");)Mi.push(_n());return new x(mr,ci,Mi)}function Ht(mr=!1){const ci=mr?sp:ii,Mi=[ci()],Ac=ar(s.Comma);for(;Ac&&(++ve,Mi.push(ci()),!!ar(s.Comma)););return Ac?new G(Mi):Mi[0]}function mn(){const mr=Ht(!0);if(!(mr instanceof C||mr instanceof G))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${mr.type} instead`);if(!Pi("in"))throw new SyntaxError("Expected `in` keyword following loop variable");++ve;const ci=ii();Ke(s.CloseStatement,"Expected closing statement token");const Mi=[];for(;!vi("endfor","else");)Mi.push(_n());const Ac=[];if(vi("else"))for(++ve,++ve,Ke(s.CloseStatement,"Expected closing statement token");!vi("endfor");)Ac.push(_n());return new f(mr,ci,Mi,Ac)}function ii(){return Ti()}function Ti(){const mr=pi();if(Pi("if")){++ve;const ci=pi();if(Pi("else")){++ve;const Mi=Ti();return new Ze(ci,mr,Mi)}else return new he(mr,ci)}return mr}function pi(){let mr=Do();for(;Pi("or");){const ci=W[ve];++ve;const Mi=Do();mr=new q(ci,mr,Mi)}return mr}function Do(){let mr=Ko();for(;Pi("and");){const ci=W[ve];++ve;const Mi=Ko();mr=new q(ci,mr,Mi)}return mr}function Ko(){let mr;for(;Pi("not");){const ci=W[ve];++ve;const Mi=Ko();mr=new oe(ci,Mi)}return mr??yc()}function yc(){let mr=Dc();for(;;){let ci;if(Pi("not","in"))ci=new a("not in",s.Identifier),ve+=2;else if(Pi("in"))ci=W[ve++];else if(ar(s.ComparisonBinaryOperator))ci=W[ve++];else break;const Mi=Dc();mr=new q(ci,mr,Mi)}return mr}function Dc(){let mr=Jf();for(;ar(s.AdditiveBinaryOperator);){const ci=W[ve];++ve;const Mi=Jf();mr=new q(ci,mr,Mi)}return mr}function En(){const mr=dp(sp());return ar(s.OpenParen)?Oi(mr):mr}function Oi(mr){let ci=new A(mr,Ro());return ci=dp(ci),ar(s.OpenParen)&&(ci=Oi(ci)),ci}function Ro(){Ke(s.OpenParen,"Expected opening parenthesis for arguments list");const mr=bc();return Ke(s.CloseParen,"Expected closing parenthesis for arguments list"),mr}function bc(){const mr=[];for(;!ar(s.CloseParen);){let ci;if(W[ve].type===s.MultiplicativeBinaryOperator&&W[ve].value==="*"){++ve;const Mi=ii();ci=new de(Mi)}else if(ci=ii(),ar(s.Equals)){if(++ve,!(ci instanceof C))throw new SyntaxError("Expected identifier for keyword argument");const Mi=ii();ci=new Q(ci,Mi)}mr.push(ci),ar(s.Comma)&&++ve}return mr}function Oc(){const mr=[];let ci=!1;for(;!ar(s.CloseSquareBracket);)ar(s.Colon)?(mr.push(void 0),++ve,ci=!0):(mr.push(ii()),ar(s.Colon)&&(++ve,ci=!0));if(mr.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(ci){if(mr.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new K(...mr)}return mr[0]}function dp(mr){for(;ar(s.Dot)||ar(s.OpenSquareBracket);){const ci=W[ve];++ve;let Mi;const Ac=ci.type===s.OpenSquareBracket;if(Ac)Mi=Oc(),Ke(s.CloseSquareBracket,"Expected closing square bracket");else if(Mi=sp(),Mi.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");mr=new E(mr,Mi,Ac)}return mr}function Jf(){let mr=kp();for(;ar(s.MultiplicativeBinaryOperator);){const ci=W[ve++],Mi=kp();mr=new q(ci,mr,Mi)}return mr}function kp(){let mr=Qc();for(;Pi("is");){++ve;const ci=Pi("not");ci&&++ve;const Mi=sp();if(!(Mi instanceof C))throw new SyntaxError("Expected identifier for the test");mr=new Ce(mr,ci,Mi)}return mr}function Qc(){let mr=En();for(;ar(s.Pipe);){++ve;let ci=sp();if(!(ci instanceof C))throw new SyntaxError("Expected identifier for the filter");ar(s.OpenParen)&&(ci=Oi(ci)),mr=new z(mr,ci)}return mr}function sp(){const mr=W[ve++];switch(mr.type){case s.NumericLiteral:{const ci=mr.value;return ci.includes(".")?new R(Number(ci)):new D(Number(ci))}case s.StringLiteral:{let ci=mr.value;for(;ar(s.StringLiteral);)ci+=W[ve++].value;return new Y(ci)}case s.Identifier:return new C(mr.value);case s.OpenParen:{const ci=Ht();return Ke(s.CloseParen,"Expected closing parenthesis, got ${tokens[current].type} instead."),ci}case s.OpenSquareBracket:{const ci=[];for(;!ar(s.CloseSquareBracket);)ci.push(ii()),ar(s.Comma)&&++ve;return++ve,new re(ci)}case s.OpenCurlyBracket:{const ci=new Map;for(;!ar(s.CloseCurlyBracket);){const Mi=ii();Ke(s.Colon,"Expected colon between key and value in object literal");const Ac=ii();ci.set(Mi,Ac),ar(s.Comma)&&++ve}return++ve,new te(ci)}default:throw new SyntaxError(`Unexpected token: ${mr.type}`)}}for(;ve<W.length;)Qe.body.push(_n());return Qe}function Gt(W,Qe,ve=1){Qe===void 0&&(Qe=W,W=0);const Ke=[];for(let lt=W;lt<Qe;lt+=ve)Ke.push(lt);return Ke}function bn(W,Qe,ve,Ke=1){const lt=Math.sign(Ke);lt>=0?(Qe=(Qe??=0)<0?Math.max(W.length+Qe,0):Math.min(Qe,W.length),ve=(ve??=W.length)<0?Math.max(W.length+ve,0):Math.min(ve,W.length)):(Qe=(Qe??=W.length-1)<0?Math.max(W.length+Qe,-1):Math.min(Qe,W.length-1),ve=(ve??=-1)<-1?Math.max(W.length+ve,-1):Math.min(ve,W.length-1));const _n=[];for(let ar=Qe;lt*ar<lt*ve;ar+=Ke)_n.push(W[ar]);return _n}function ri(W){return W.replace(/\b\w/g,Qe=>Qe.toUpperCase())}function hn(W){return ze(new Date,W)}function ze(W,Qe){const ve=new Intl.DateTimeFormat(void 0,{month:"long"}),Ke=new Intl.DateTimeFormat(void 0,{month:"short"}),lt=_n=>_n<10?"0"+_n:_n.toString();return Qe.replace(/%[YmdbBHM%]/g,_n=>{switch(_n){case"%Y":return W.getFullYear().toString();case"%m":return lt(W.getMonth()+1);case"%d":return lt(W.getDate());case"%b":return Ke.format(W);case"%B":return ve.format(W);case"%H":return lt(W.getHours());case"%M":return lt(W.getMinutes());case"%%":return"%";default:return _n}})}function wt(W){return W.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function ke(W,Qe,ve,Ke){if(Ke===0)return W;let lt=Ke==null||Ke<0?1/0:Ke;const _n=Qe.length===0?new RegExp("(?=)","gu"):new RegExp(wt(Qe),"gu");return W.replaceAll(_n,ar=>lt>0?(--lt,ve):ar)}var Bt=class extends Error{},In=class extends Error{},Tn=class{type="RuntimeValue";value;builtins=new Map;constructor(W=void 0){this.value=W}__bool__(){return new $n(!!this.value)}toString(){return String(this.value)}},cn=class extends Tn{type="IntegerValue"},kn=class extends Tn{type="FloatValue";toString(){return this.value%1===0?this.value.toFixed(1):this.value.toString()}},yn=class extends Tn{type="StringValue";builtins=new Map([["upper",new ir(()=>new yn(this.value.toUpperCase()))],["lower",new ir(()=>new yn(this.value.toLowerCase()))],["strip",new ir(()=>new yn(this.value.trim()))],["title",new ir(()=>new yn(ri(this.value)))],["capitalize",new ir(()=>new yn(this.value.charAt(0).toUpperCase()+this.value.slice(1)))],["length",new cn(this.value.length)],["rstrip",new ir(()=>new yn(this.value.trimEnd()))],["lstrip",new ir(()=>new yn(this.value.trimStart()))],["startswith",new ir(W=>{if(W.length===0)throw new Error("startswith() requires at least one argument");const Qe=W[0];if(Qe instanceof yn)return new $n(this.value.startsWith(Qe.value));if(Qe instanceof vn){for(const ve of Qe.value){if(!(ve instanceof yn))throw new Error("startswith() tuple elements must be strings");if(this.value.startsWith(ve.value))return new $n(!0)}return new $n(!1)}throw new Error("startswith() argument must be a string or tuple of strings")})],["endswith",new ir(W=>{if(W.length===0)throw new Error("endswith() requires at least one argument");const Qe=W[0];if(Qe instanceof yn)return new $n(this.value.endsWith(Qe.value));if(Qe instanceof vn){for(const ve of Qe.value){if(!(ve instanceof yn))throw new Error("endswith() tuple elements must be strings");if(this.value.endsWith(ve.value))return new $n(!0)}return new $n(!1)}throw new Error("endswith() argument must be a string or tuple of strings")})],["split",new ir(W=>{const Qe=W[0]??new ai;if(!(Qe instanceof yn||Qe instanceof ai))throw new Error("sep argument must be a string or null");const ve=W[1]??new cn(-1);if(!(ve instanceof cn))throw new Error("maxsplit argument must be a number");let Ke=[];if(Qe instanceof ai){const lt=this.value.trimStart();for(const{0:_n,index:ar}of lt.matchAll(/\S+/g)){if(ve.value!==-1&&Ke.length>=ve.value&&ar!==void 0){Ke.push(_n+lt.slice(ar+_n.length));break}Ke.push(_n)}}else{if(Qe.value==="")throw new Error("empty separator");Ke=this.value.split(Qe.value),ve.value!==-1&&Ke.length>ve.value&&Ke.push(Ke.splice(ve.value).join(Qe.value))}return new vn(Ke.map(lt=>new yn(lt)))})],["replace",new ir(W=>{if(W.length<2)throw new Error("replace() requires at least two arguments");const Qe=W[0],ve=W[1];if(!(Qe instanceof yn&&ve instanceof yn))throw new Error("replace() arguments must be strings");let Ke;if(W.length>2?W[2].type==="KeywordArgumentsValue"?Ke=W[2].value.get("count")??new ai:Ke=W[2]:Ke=new ai,!(Ke instanceof cn||Ke instanceof ai))throw new Error("replace() count argument must be a number or null");return new yn(ke(this.value,Qe.value,ve.value,Ke.value))})]])},$n=class extends Tn{type="BooleanValue"},cr=class extends Tn{type="ObjectValue";__bool__(){return new $n(this.value.size>0)}builtins=new Map([["get",new ir(([W,Qe])=>{if(!(W instanceof yn))throw new Error(`Object key must be a string: got ${W.type}`);return this.value.get(W.value)??Qe??new ai})],["items",new ir(()=>this.items())],["keys",new ir(()=>this.keys())],["values",new ir(()=>this.values())]]);items(){return new vn(Array.from(this.value.entries()).map(([W,Qe])=>new vn([new yn(W),Qe])))}keys(){return new vn(Array.from(this.value.keys()).map(W=>new yn(W)))}values(){return new vn(Array.from(this.value.values()))}},ti=class extends cr{type="KeywordArgumentsValue"},vn=class extends Tn{type="ArrayValue";builtins=new Map([["length",new cn(this.value.length)]]);__bool__(){return new $n(this.value.length>0)}},xi=class extends vn{type="TupleValue"},ir=class extends Tn{type="FunctionValue"},ai=class extends Tn{type="NullValue"},mi=class extends Tn{type="UndefinedValue"},fi=class{constructor(W){this.parent=W}variables=new Map([["namespace",new ir(W=>{if(W.length===0)return new cr(new Map);if(W.length!==1||!(W[0]instanceof cr))throw new Error("`namespace` expects either zero arguments or a single object argument");return W[0]})]]);tests=new Map([["boolean",W=>W.type==="BooleanValue"],["callable",W=>W instanceof ir],["odd",W=>{if(!(W instanceof cn))throw new Error(`cannot odd on ${W.type}`);return W.value%2!==0}],["even",W=>{if(!(W instanceof cn))throw new Error(`cannot even on ${W.type}`);return W.value%2===0}],["false",W=>W.type==="BooleanValue"&&!W.value],["true",W=>W.type==="BooleanValue"&&W.value],["none",W=>W.type==="NullValue"],["string",W=>W.type==="StringValue"],["number",W=>W instanceof cn||W instanceof kn],["integer",W=>W instanceof cn],["iterable",W=>W.type==="ArrayValue"||W.type==="StringValue"],["mapping",W=>W.type==="ObjectValue"],["lower",W=>{const Qe=W.value;return W.type==="StringValue"&&Qe===Qe.toLowerCase()}],["upper",W=>{const Qe=W.value;return W.type==="StringValue"&&Qe===Qe.toUpperCase()}],["none",W=>W.type==="NullValue"],["defined",W=>W.type!=="UndefinedValue"],["undefined",W=>W.type==="UndefinedValue"],["equalto",(W,Qe)=>W.value===Qe.value],["eq",(W,Qe)=>W.value===Qe.value]]);set(W,Qe){return this.declareVariable(W,Lo(Qe))}declareVariable(W,Qe){if(this.variables.has(W))throw new SyntaxError(`Variable already declared: ${W}`);return this.variables.set(W,Qe),Qe}setVariable(W,Qe){return this.variables.set(W,Qe),Qe}resolve(W){if(this.variables.has(W))return this;if(this.parent)return this.parent.resolve(W);throw new Error(`Unknown variable: ${W}`)}lookupVariable(W){try{return this.resolve(W).variables.get(W)??new mi}catch{return new mi}}};function ui(W){W.set("false",!1),W.set("true",!0),W.set("none",null),W.set("raise_exception",Qe=>{throw new Error(Qe)}),W.set("range",Gt),W.set("strftime_now",hn),W.set("True",!0),W.set("False",!1),W.set("None",null)}var wi=class{global;constructor(W){this.global=W??new fi}run(W){return this.evaluate(W,this.global)}evaluateBinaryExpression(W,Qe){const ve=this.evaluate(W.left,Qe);switch(W.operator.value){case"and":return ve.__bool__().value?this.evaluate(W.right,Qe):ve;case"or":return ve.__bool__().value?ve:this.evaluate(W.right,Qe)}const Ke=this.evaluate(W.right,Qe);switch(W.operator.value){case"==":return new $n(ve.value==Ke.value);case"!=":return new $n(ve.value!=Ke.value)}if(ve instanceof mi||Ke instanceof mi){if(Ke instanceof mi&&["in","not in"].includes(W.operator.value))return new $n(W.operator.value==="not in");throw new Error(`Cannot perform operation ${W.operator.value} on undefined values`)}else{if(ve instanceof ai||Ke instanceof ai)throw new Error("Cannot perform operation on null values");if(W.operator.value==="~")return new yn(ve.value.toString()+Ke.value.toString());if((ve instanceof cn||ve instanceof kn)&&(Ke instanceof cn||Ke instanceof kn)){const lt=ve.value,_n=Ke.value;switch(W.operator.value){case"+":case"-":case"*":{const ar=W.operator.value==="+"?lt+_n:W.operator.value==="-"?lt-_n:lt*_n;return ve instanceof kn||Ke instanceof kn?new kn(ar):new cn(ar)}case"/":return new kn(lt/_n);case"%":{const ar=lt%_n;return ve instanceof kn||Ke instanceof kn?new kn(ar):new cn(ar)}case"<":return new $n(lt<_n);case">":return new $n(lt>_n);case">=":return new $n(lt>=_n);case"<=":return new $n(lt<=_n)}}else if(ve instanceof vn&&Ke instanceof vn)switch(W.operator.value){case"+":return new vn(ve.value.concat(Ke.value))}else if(Ke instanceof vn){const lt=Ke.value.find(_n=>_n.value===ve.value)!==void 0;switch(W.operator.value){case"in":return new $n(lt);case"not in":return new $n(!lt)}}}if(ve instanceof yn||Ke instanceof yn)switch(W.operator.value){case"+":return new yn(ve.value.toString()+Ke.value.toString())}if(ve instanceof yn&&Ke instanceof yn)switch(W.operator.value){case"in":return new $n(Ke.value.includes(ve.value));case"not in":return new $n(!Ke.value.includes(ve.value))}if(ve instanceof yn&&Ke instanceof cr)switch(W.operator.value){case"in":return new $n(Ke.value.has(ve.value));case"not in":return new $n(!Ke.value.has(ve.value))}throw new SyntaxError(`Unknown operator "${W.operator.value}" between ${ve.type} and ${Ke.type}`)}evaluateArguments(W,Qe){const ve=[],Ke=new Map;for(const lt of W)if(lt.type==="SpreadExpression"){const _n=lt,ar=this.evaluate(_n.argument,Qe);if(!(ar instanceof vn))throw new Error(`Cannot unpack non-iterable type: ${ar.type}`);for(const vi of ar.value)ve.push(vi)}else if(lt.type==="KeywordArgumentExpression"){const _n=lt;Ke.set(_n.key.value,this.evaluate(_n.value,Qe))}else{if(Ke.size>0)throw new Error("Positional arguments must come before keyword arguments");ve.push(this.evaluate(lt,Qe))}return[ve,Ke]}applyFilter(W,Qe,ve){if(Qe.type==="Identifier"){const Ke=Qe;if(Ke.value==="tojson")return new yn(zi(W));if(W instanceof vn)switch(Ke.value){case"list":return W;case"first":return W.value[0];case"last":return W.value[W.value.length-1];case"length":return new cn(W.value.length);case"reverse":return new vn(W.value.reverse());case"sort":return new vn(W.value.sort((lt,_n)=>{if(lt.type!==_n.type)throw new Error(`Cannot compare different types: ${lt.type} and ${_n.type}`);switch(lt.type){case"IntegerValue":case"FloatValue":return lt.value-_n.value;case"StringValue":return lt.value.localeCompare(_n.value);default:throw new Error(`Cannot compare type: ${lt.type}`)}}));case"join":return new yn(W.value.map(lt=>lt.value).join(""));case"string":return new yn(zi(W));case"unique":{const lt=new Set,_n=[];for(const ar of W.value)lt.has(ar.value)||(lt.add(ar.value),_n.push(ar));return new vn(_n)}default:throw new Error(`Unknown ArrayValue filter: ${Ke.value}`)}else if(W instanceof yn)switch(Ke.value){case"length":case"upper":case"lower":case"title":case"capitalize":{const lt=W.builtins.get(Ke.value);if(lt instanceof ir)return lt.value([],ve);if(lt instanceof cn)return lt;throw new Error(`Unknown StringValue filter: ${Ke.value}`)}case"trim":return new yn(W.value.trim());case"indent":return new yn(W.value.split(`
`).map((lt,_n)=>_n===0||lt.length===0?lt:"    "+lt).join(`
`));case"join":case"string":return W;case"int":{const lt=parseInt(W.value,10);return new cn(isNaN(lt)?0:lt)}case"float":{const lt=parseFloat(W.value);return new kn(isNaN(lt)?0:lt)}default:throw new Error(`Unknown StringValue filter: ${Ke.value}`)}else if(W instanceof cn||W instanceof kn)switch(Ke.value){case"abs":return W instanceof cn?new cn(Math.abs(W.value)):new kn(Math.abs(W.value));case"int":return new cn(Math.floor(W.value));case"float":return new kn(W.value);default:throw new Error(`Unknown NumericValue filter: ${Ke.value}`)}else if(W instanceof cr)switch(Ke.value){case"items":return new vn(Array.from(W.value.entries()).map(([lt,_n])=>new vn([new yn(lt),_n])));case"length":return new cn(W.value.size);default:throw new Error(`Unknown ObjectValue filter: ${Ke.value}`)}else if(W instanceof $n)switch(Ke.value){case"bool":return new $n(W.value);case"int":return new cn(W.value?1:0);case"float":return new kn(W.value?1:0);case"string":return new yn(W.value?"true":"false");default:throw new Error(`Unknown BooleanValue filter: ${Ke.value}`)}throw new Error(`Cannot apply filter "${Ke.value}" to type: ${W.type}`)}else if(Qe.type==="CallExpression"){const Ke=Qe;if(Ke.callee.type!=="Identifier")throw new Error(`Unknown filter: ${Ke.callee.type}`);const lt=Ke.callee.value;if(lt==="tojson"){const[,_n]=this.evaluateArguments(Ke.args,ve),ar=_n.get("indent")??new ai;if(!(ar instanceof cn||ar instanceof ai))throw new Error("If set, indent must be a number");return new yn(zi(W,ar.value))}else if(lt==="join"){let _n;if(W instanceof yn)_n=Array.from(W.value);else if(W instanceof vn)_n=W.value.map(hi=>hi.value);else throw new Error(`Cannot apply filter "${lt}" to type: ${W.type}`);const[ar,vi]=this.evaluateArguments(Ke.args,ve),Pi=ar.at(0)??vi.get("separator")??new yn("");if(!(Pi instanceof yn))throw new Error("separator must be a string");return new yn(_n.join(Pi.value))}else if(lt==="int"||lt==="float"){const[_n,ar]=this.evaluateArguments(Ke.args,ve),vi=_n.at(0)??ar.get("default")??(lt==="int"?new cn(0):new kn(0));if(W instanceof yn){const Pi=lt==="int"?parseInt(W.value,10):parseFloat(W.value);return isNaN(Pi)?vi:lt==="int"?new cn(Pi):new kn(Pi)}else{if(W instanceof cn||W instanceof kn)return W;if(W instanceof $n)return lt==="int"?new cn(W.value?1:0):new kn(W.value?1:0);throw new Error(`Cannot apply filter "${lt}" to type: ${W.type}`)}}else if(lt==="default"){const[_n,ar]=this.evaluateArguments(Ke.args,ve),vi=_n[0]??new yn(""),Pi=_n[1]??ar.get("boolean")??new $n(!1);if(!(Pi instanceof $n))throw new Error("`default` filter flag must be a boolean");return W instanceof mi||Pi.value&&!W.__bool__().value?vi:W}if(W instanceof vn){switch(lt){case"selectattr":case"rejectattr":{const _n=lt==="selectattr";if(W.value.some(we=>!(we instanceof cr)))throw new Error(`\`${lt}\` can only be applied to array of objects`);if(Ke.args.some(we=>we.type!=="StringLiteral"))throw new Error(`arguments of \`${lt}\` must be strings`);const[ar,vi,Pi]=Ke.args.map(we=>this.evaluate(we,ve));let hi;if(vi){const we=ve.tests.get(vi.value);if(!we)throw new Error(`Unknown test: ${vi.value}`);hi=we}else hi=(...we)=>we[0].__bool__().value;const Oo=W.value.filter(we=>{const it=we.value.get(ar.value),pt=it?hi(it,Pi):!1;return _n?pt:!pt});return new vn(Oo)}case"map":{const[,_n]=this.evaluateArguments(Ke.args,ve);if(_n.has("attribute")){const ar=_n.get("attribute");if(!(ar instanceof yn))throw new Error("attribute must be a string");const vi=_n.get("default"),Pi=W.value.map(hi=>{if(!(hi instanceof cr))throw new Error("items in map must be an object");return hi.value.get(ar.value)??vi??new mi});return new vn(Pi)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${lt}`)}else if(W instanceof yn){switch(lt){case"indent":{const[_n,ar]=this.evaluateArguments(Ke.args,ve),vi=_n.at(0)??ar.get("width")??new cn(4);if(!(vi instanceof cn))throw new Error("width must be a number");const Pi=_n.at(1)??ar.get("first")??new $n(!1),hi=_n.at(2)??ar.get("blank")??new $n(!1),Oo=W.value.split(`
`),we=" ".repeat(vi.value),it=Oo.map((pt,Ot)=>!Pi.value&&Ot===0||!hi.value&&pt.length===0?pt:we+pt);return new yn(it.join(`
`))}case"replace":{const _n=W.builtins.get("replace");if(!(_n instanceof ir))throw new Error("replace filter not available");const[ar,vi]=this.evaluateArguments(Ke.args,ve);return _n.value([...ar,new ti(vi)],ve)}}throw new Error(`Unknown StringValue filter: ${lt}`)}else throw new Error(`Cannot apply filter "${lt}" to type: ${W.type}`)}throw new Error(`Unknown filter: ${Qe.type}`)}evaluateFilterExpression(W,Qe){const ve=this.evaluate(W.operand,Qe);return this.applyFilter(ve,W.filter,Qe)}evaluateTestExpression(W,Qe){const ve=this.evaluate(W.operand,Qe),Ke=Qe.tests.get(W.test.value);if(!Ke)throw new Error(`Unknown test: ${W.test.value}`);const lt=Ke(ve);return new $n(W.negate?!lt:lt)}evaluateSelectExpression(W,Qe){return this.evaluate(W.test,Qe).__bool__().value?this.evaluate(W.lhs,Qe):new mi}evaluateUnaryExpression(W,Qe){const ve=this.evaluate(W.argument,Qe);switch(W.operator.value){case"not":return new $n(!ve.value);default:throw new SyntaxError(`Unknown operator: ${W.operator.value}`)}}evaluateTernaryExpression(W,Qe){return this.evaluate(W.condition,Qe).__bool__().value?this.evaluate(W.trueExpr,Qe):this.evaluate(W.falseExpr,Qe)}evalProgram(W,Qe){return this.evaluateBlock(W.body,Qe)}evaluateBlock(W,Qe){let ve="";for(const Ke of W){const lt=this.evaluate(Ke,Qe);lt.type!=="NullValue"&&lt.type!=="UndefinedValue"&&(ve+=lt.toString())}return new yn(ve)}evaluateIdentifier(W,Qe){return Qe.lookupVariable(W.value)}evaluateCallExpression(W,Qe){const[ve,Ke]=this.evaluateArguments(W.args,Qe);Ke.size>0&&ve.push(new ti(Ke));const lt=this.evaluate(W.callee,Qe);if(lt.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${lt.type}`);return lt.value(ve,Qe)}evaluateSliceExpression(W,Qe,ve){if(!(W instanceof vn||W instanceof yn))throw new Error("Slice object must be an array or string");const Ke=this.evaluate(Qe.start,ve),lt=this.evaluate(Qe.stop,ve),_n=this.evaluate(Qe.step,ve);if(!(Ke instanceof cn||Ke instanceof mi))throw new Error("Slice start must be numeric or undefined");if(!(lt instanceof cn||lt instanceof mi))throw new Error("Slice stop must be numeric or undefined");if(!(_n instanceof cn||_n instanceof mi))throw new Error("Slice step must be numeric or undefined");return W instanceof vn?new vn(bn(W.value,Ke.value,lt.value,_n.value)):new yn(bn(Array.from(W.value),Ke.value,lt.value,_n.value).join(""))}evaluateMemberExpression(W,Qe){const ve=this.evaluate(W.object,Qe);let Ke;if(W.computed){if(W.property.type==="SliceExpression")return this.evaluateSliceExpression(ve,W.property,Qe);Ke=this.evaluate(W.property,Qe)}else Ke=new yn(W.property.value);let lt;if(ve instanceof cr){if(!(Ke instanceof yn))throw new Error(`Cannot access property with non-string: got ${Ke.type}`);lt=ve.value.get(Ke.value)??ve.builtins.get(Ke.value)}else if(ve instanceof vn||ve instanceof yn)if(Ke instanceof cn)lt=ve.value.at(Ke.value),ve instanceof yn&&(lt=new yn(ve.value.at(Ke.value)));else if(Ke instanceof yn)lt=ve.builtins.get(Ke.value);else throw new Error(`Cannot access property with non-string/non-number: got ${Ke.type}`);else{if(!(Ke instanceof yn))throw new Error(`Cannot access property with non-string: got ${Ke.type}`);lt=ve.builtins.get(Ke.value)}return lt instanceof Tn?lt:new mi}evaluateSet(W,Qe){const ve=W.value?this.evaluate(W.value,Qe):this.evaluateBlock(W.body,Qe);if(W.assignee.type==="Identifier"){const Ke=W.assignee.value;Qe.setVariable(Ke,ve)}else if(W.assignee.type==="TupleLiteral"){const Ke=W.assignee;if(!(ve instanceof vn))throw new Error(`Cannot unpack non-iterable type in set: ${ve.type}`);const lt=ve.value;if(lt.length!==Ke.value.length)throw new Error(`Too ${Ke.value.length>lt.length?"few":"many"} items to unpack in set`);for(let _n=0;_n<Ke.value.length;++_n){const ar=Ke.value[_n];if(ar.type!=="Identifier")throw new Error(`Cannot unpack to non-identifier in set: ${ar.type}`);Qe.setVariable(ar.value,lt[_n])}}else if(W.assignee.type==="MemberExpression"){const Ke=W.assignee,lt=this.evaluate(Ke.object,Qe);if(!(lt instanceof cr))throw new Error("Cannot assign to member of non-object");if(Ke.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");lt.value.set(Ke.property.value,ve)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(W.assignee)}`);return new ai}evaluateIf(W,Qe){const ve=this.evaluate(W.test,Qe);return this.evaluateBlock(ve.__bool__().value?W.body:W.alternate,Qe)}evaluateFor(W,Qe){const ve=new fi(Qe);let Ke,lt;if(W.iterable.type==="SelectExpression"){const hi=W.iterable;lt=this.evaluate(hi.lhs,ve),Ke=hi.test}else lt=this.evaluate(W.iterable,ve);if(!(lt instanceof vn||lt instanceof cr))throw new Error(`Expected iterable or object type in for loop: got ${lt.type}`);lt instanceof cr&&(lt=lt.keys());const _n=[],ar=[];for(let hi=0;hi<lt.value.length;++hi){const Oo=new fi(ve),we=lt.value[hi];let it;if(W.loopvar.type==="Identifier")it=pt=>pt.setVariable(W.loopvar.value,we);else if(W.loopvar.type==="TupleLiteral"){const pt=W.loopvar;if(we.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${we.type}`);const Ot=we;if(pt.value.length!==Ot.value.length)throw new Error(`Too ${pt.value.length>Ot.value.length?"few":"many"} items to unpack`);it=Ht=>{for(let mn=0;mn<pt.value.length;++mn){if(pt.value[mn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${pt.value[mn].type}`);Ht.setVariable(pt.value[mn].value,Ot.value[mn])}}}else throw new Error(`Invalid loop variable(s): ${W.loopvar.type}`);Ke&&(it(Oo),!this.evaluate(Ke,Oo).__bool__().value)||(_n.push(we),ar.push(it))}let vi="",Pi=!0;for(let hi=0;hi<_n.length;++hi){const Oo=new Map([["index",new cn(hi+1)],["index0",new cn(hi)],["revindex",new cn(_n.length-hi)],["revindex0",new cn(_n.length-hi-1)],["first",new $n(hi===0)],["last",new $n(hi===_n.length-1)],["length",new cn(_n.length)],["previtem",hi>0?_n[hi-1]:new mi],["nextitem",hi<_n.length-1?_n[hi+1]:new mi]]);ve.setVariable("loop",new cr(Oo)),ar[hi](ve);try{const we=this.evaluateBlock(W.body,ve);vi+=we.value}catch(we){if(we instanceof In)continue;if(we instanceof Bt)break;throw we}Pi=!1}if(Pi){const hi=this.evaluateBlock(W.defaultBlock,ve);vi+=hi.value}return new yn(vi)}evaluateMacro(W,Qe){return Qe.setVariable(W.name.value,new ir((ve,Ke)=>{const lt=new fi(Ke);ve=ve.slice();let _n;ve.at(-1)?.type==="KeywordArgumentsValue"&&(_n=ve.pop());for(let ar=0;ar<W.args.length;++ar){const vi=W.args[ar],Pi=ve[ar];if(vi.type==="Identifier"){const hi=vi;if(!Pi)throw new Error(`Missing positional argument: ${hi.value}`);lt.setVariable(hi.value,Pi)}else if(vi.type==="KeywordArgumentExpression"){const hi=vi,Oo=Pi??_n?.value.get(hi.key.value)??this.evaluate(hi.value,lt);lt.setVariable(hi.key.value,Oo)}else throw new Error(`Unknown argument type: ${vi.type}`)}return this.evaluateBlock(W.body,lt)})),new ai}evaluateCallStatement(W,Qe){const ve=new ir((vi,Pi)=>{const hi=new fi(Pi);if(W.callerArgs)for(let Oo=0;Oo<W.callerArgs.length;++Oo){const we=W.callerArgs[Oo];if(we.type!=="Identifier")throw new Error(`Caller parameter must be an identifier, got ${we.type}`);hi.setVariable(we.value,vi[Oo]??new mi)}return this.evaluateBlock(W.body,hi)}),[Ke,lt]=this.evaluateArguments(W.call.args,Qe);Ke.push(new ti(lt));const _n=this.evaluate(W.call.callee,Qe);if(_n.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${_n.type}`);const ar=new fi(Qe);return ar.setVariable("caller",ve),_n.value(Ke,ar)}evaluateFilterStatement(W,Qe){const ve=this.evaluateBlock(W.body,Qe);return this.applyFilter(ve,W.filter,Qe)}evaluate(W,Qe){if(!W)return new mi;switch(W.type){case"Program":return this.evalProgram(W,Qe);case"Set":return this.evaluateSet(W,Qe);case"If":return this.evaluateIf(W,Qe);case"For":return this.evaluateFor(W,Qe);case"Macro":return this.evaluateMacro(W,Qe);case"CallStatement":return this.evaluateCallStatement(W,Qe);case"Break":throw new Bt;case"Continue":throw new In;case"IntegerLiteral":return new cn(W.value);case"FloatLiteral":return new kn(W.value);case"StringLiteral":return new yn(W.value);case"ArrayLiteral":return new vn(W.value.map(ve=>this.evaluate(ve,Qe)));case"TupleLiteral":return new xi(W.value.map(ve=>this.evaluate(ve,Qe)));case"ObjectLiteral":{const ve=new Map;for(const[Ke,lt]of W.value){const _n=this.evaluate(Ke,Qe);if(!(_n instanceof yn))throw new Error(`Object keys must be strings: got ${_n.type}`);ve.set(_n.value,this.evaluate(lt,Qe))}return new cr(ve)}case"Identifier":return this.evaluateIdentifier(W,Qe);case"CallExpression":return this.evaluateCallExpression(W,Qe);case"MemberExpression":return this.evaluateMemberExpression(W,Qe);case"UnaryExpression":return this.evaluateUnaryExpression(W,Qe);case"BinaryExpression":return this.evaluateBinaryExpression(W,Qe);case"FilterExpression":return this.evaluateFilterExpression(W,Qe);case"FilterStatement":return this.evaluateFilterStatement(W,Qe);case"TestExpression":return this.evaluateTestExpression(W,Qe);case"SelectExpression":return this.evaluateSelectExpression(W,Qe);case"Ternary":return this.evaluateTernaryExpression(W,Qe);case"Comment":return new ai;default:throw new SyntaxError(`Unknown node type: ${W.type}`)}}};function Lo(W){switch(typeof W){case"number":return Number.isInteger(W)?new cn(W):new kn(W);case"string":return new yn(W);case"boolean":return new $n(W);case"undefined":return new mi;case"object":return W===null?new ai:Array.isArray(W)?new vn(W.map(Lo)):new cr(new Map(Object.entries(W).map(([Qe,ve])=>[Qe,Lo(ve)])));case"function":return new ir((Qe,ve)=>{const Ke=W(...Qe.map(lt=>lt.value))??null;return Lo(Ke)});default:throw new Error(`Cannot convert to runtime value: ${W}`)}}function zi(W,Qe,ve){const Ke=ve??0;switch(W.type){case"NullValue":case"UndefinedValue":return"null";case"IntegerValue":case"FloatValue":case"StringValue":case"BooleanValue":return JSON.stringify(W.value);case"ArrayValue":case"ObjectValue":{const lt=Qe?" ".repeat(Qe):"",_n=`
`+lt.repeat(Ke),ar=_n+lt;if(W.type==="ArrayValue"){const vi=W.value.map(Pi=>zi(Pi,Qe,Ke+1));return Qe?`[${ar}${vi.join(`,${ar}`)}${_n}]`:`[${vi.join(", ")}]`}else{const vi=Array.from(W.value.entries()).map(([Pi,hi])=>{const Oo=`"${Pi}": ${zi(hi,Qe,Ke+1)}`;return Qe?`${ar}${Oo}`:Oo});return Qe?`{${vi.join(",")}${_n}}`:`{${vi.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${W.type}`)}}var Ci=`
`,Si="{%- ",zc=" -%}";function Xc(W){switch(W.operator.type){case"MultiplicativeBinaryOperator":return 4;case"AdditiveBinaryOperator":return 3;case"ComparisonBinaryOperator":return 2;case"Identifier":return W.operator.value==="and"?1:W.operator.value==="in"||W.operator.value==="not in"?2:0}return 0}function up(W,Qe="	"){const ve=typeof Qe=="number"?" ".repeat(Qe):Qe;return Mo(W.body,0,ve).replace(/\n$/,"")}function Jo(...W){return Si+W.join(" ")+zc}function Mo(W,Qe,ve){return W.map(Ke=>$p(Ke,Qe,ve)).join(Ci)}function $p(W,Qe,ve){const Ke=ve.repeat(Qe);switch(W.type){case"Program":return Mo(W.body,Qe,ve);case"If":return rf(W,Qe,ve);case"For":return cp(W,Qe,ve);case"Set":return Wi(W,Qe,ve);case"Macro":return si(W,Qe,ve);case"Break":return Ke+Jo("break");case"Continue":return Ke+Jo("continue");case"CallStatement":return Ri(W,Qe,ve);case"FilterStatement":return _c(W,Qe,ve);case"Comment":return Ke+"{# "+W.value+" #}";default:return Ke+"{{- "+Ui(W)+" -}}"}}function rf(W,Qe,ve){const Ke=ve.repeat(Qe),lt=[];let _n=W;for(;_n&&(lt.push({test:_n.test,body:_n.body}),_n.alternate.length===1&&_n.alternate[0].type==="If");)_n=_n.alternate[0];let ar=Ke+Jo("if",Ui(lt[0].test))+Ci+Mo(lt[0].body,Qe+1,ve);for(let vi=1;vi<lt.length;++vi)ar+=Ci+Ke+Jo("elif",Ui(lt[vi].test))+Ci+Mo(lt[vi].body,Qe+1,ve);return _n&&_n.alternate.length>0&&(ar+=Ci+Ke+Jo("else")+Ci+Mo(_n.alternate,Qe+1,ve)),ar+=Ci+Ke+Jo("endif"),ar}function cp(W,Qe,ve){const Ke=ve.repeat(Qe);let lt="";if(W.iterable.type==="SelectExpression"){const ar=W.iterable;lt=`${Ui(ar.lhs)} if ${Ui(ar.test)}`}else lt=Ui(W.iterable);let _n=Ke+Jo("for",Ui(W.loopvar),"in",lt)+Ci+Mo(W.body,Qe+1,ve);return W.defaultBlock.length>0&&(_n+=Ci+Ke+Jo("else")+Ci+Mo(W.defaultBlock,Qe+1,ve)),_n+=Ci+Ke+Jo("endfor"),_n}function Wi(W,Qe,ve){const Ke=ve.repeat(Qe),lt=Ui(W.assignee),_n=W.value?Ui(W.value):"",ar=Ke+Jo("set",`${lt}${W.value?" = "+_n:""}`);return W.body.length===0?ar:ar+Ci+Mo(W.body,Qe+1,ve)+Ci+Ke+Jo("endset")}function si(W,Qe,ve){const Ke=ve.repeat(Qe),lt=W.args.map(Ui).join(", ");return Ke+Jo("macro",`${W.name.value}(${lt})`)+Ci+Mo(W.body,Qe+1,ve)+Ci+Ke+Jo("endmacro")}function Ri(W,Qe,ve){const Ke=ve.repeat(Qe),lt=W.callerArgs&&W.callerArgs.length>0?`(${W.callerArgs.map(Ui).join(", ")})`:"",_n=Ui(W.call);let ar=Ke+Jo(`call${lt}`,_n)+Ci;return ar+=Mo(W.body,Qe+1,ve)+Ci,ar+=Ke+Jo("endcall"),ar}function _c(W,Qe,ve){const Ke=ve.repeat(Qe),lt=W.filter.type==="Identifier"?W.filter.value:Ui(W.filter);let _n=Ke+Jo("filter",lt)+Ci;return _n+=Mo(W.body,Qe+1,ve)+Ci,_n+=Ke+Jo("endfilter"),_n}function Ui(W,Qe=-1){switch(W.type){case"SpreadExpression":return`*${Ui(W.argument)}`;case"Identifier":return W.value;case"IntegerLiteral":return`${W.value}`;case"FloatLiteral":return`${W.value}`;case"StringLiteral":return JSON.stringify(W.value);case"BinaryExpression":{const ve=W,Ke=Xc(ve),lt=Ui(ve.left,Ke),_n=Ui(ve.right,Ke+1),ar=`${lt} ${ve.operator.value} ${_n}`;return Ke<Qe?`(${ar})`:ar}case"UnaryExpression":{const ve=W;return ve.operator.value+(ve.operator.value==="not"?" ":"")+Ui(ve.argument,1/0)}case"CallExpression":{const ve=W,Ke=ve.args.map(Ui).join(", ");return`${Ui(ve.callee)}(${Ke})`}case"MemberExpression":{const ve=W;let Ke=Ui(ve.object);["Identifier","MemberExpression","CallExpression","StringLiteral","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral"].includes(ve.object.type)||(Ke=`(${Ke})`);let lt=Ui(ve.property);return!ve.computed&&ve.property.type!=="Identifier"&&(lt=`(${lt})`),ve.computed?`${Ke}[${lt}]`:`${Ke}.${lt}`}case"FilterExpression":{const ve=W,Ke=Ui(ve.operand,1/0);return ve.filter.type==="CallExpression"?`${Ke} | ${Ui(ve.filter)}`:`${Ke} | ${ve.filter.value}`}case"SelectExpression":{const ve=W;return`${Ui(ve.lhs)} if ${Ui(ve.test)}`}case"TestExpression":{const ve=W;return`${Ui(ve.operand)} is${ve.negate?" not":""} ${ve.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const ve=W.value.map(Ui),Ke=W.type==="ArrayLiteral"?"[]":"()";return`${Ke[0]}${ve.join(", ")}${Ke[1]}`}case"ObjectLiteral":return`{${Array.from(W.value.entries()).map(([Ke,lt])=>`${Ui(Ke)}: ${Ui(lt)}`).join(", ")}}`;case"SliceExpression":{const ve=W,Ke=ve.start?Ui(ve.start):"",lt=ve.stop?Ui(ve.stop):"",_n=ve.step?`:${Ui(ve.step)}`:"";return`${Ke}:${lt}${_n}`}case"KeywordArgumentExpression":{const ve=W;return`${ve.key.value}=${Ui(ve.value)}`}case"Ternary":{const ve=W,Ke=`${Ui(ve.trueExpr)} if ${Ui(ve.condition,0)} else ${Ui(ve.falseExpr)}`;return Qe>-1?`(${Ke})`:Ke}default:throw new Error(`Unknown expression type: ${W.type}`)}}var Rp=class{parsed;constructor(W){const Qe=h(W,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Pt(Qe)}render(W){const Qe=new fi;if(ui(Qe),W)for(const[lt,_n]of Object.entries(W))Qe.set(lt,_n);return new wi(Qe).run(this.parsed).value}format(W){return up(this.parsed,W?.indent||"	")}}}),"./src/backends/onnx.js":((n,e,t)=>{var s;t.r(e),t.d(e,{Tensor:()=>_.Tensor,createInferenceSession:()=>w,deviceToExecutionProviders:()=>f,isONNXProxy:()=>S,isONNXTensor:()=>y});var a=t("./src/env.js"),c=t("?2ce3"),l=t("onnxruntime-web"),_=t("onnxruntime-common");const m=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),d=[];let h,i;const r=Symbol.for("onnxruntime");if(r in globalThis)i=globalThis[r];else if(a.apis.IS_NODE_ENV){switch(i=c??(s||(s=t.t(c,2))),process.platform){case"win32":d.push("dml");break;case"linux":process.arch==="x64"&&d.push("cuda");break}d.push("cpu"),h=["cpu"]}else i=l,a.apis.IS_WEBNN_AVAILABLE&&d.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),a.apis.IS_WEBGPU_AVAILABLE&&d.push("webgpu"),d.push("wasm"),h=["wasm"];const u=i.InferenceSession;function f(T=null){if(!T)return h;switch(T){case"auto":return d;case"gpu":return d.filter(E=>["webgpu","cuda","dml","webnn-gpu"].includes(E))}if(d.includes(T))return[m[T]??T];throw new Error(`Unsupported device: "${T}". Should be one of: ${d.join(", ")}.`)}let g=null;async function w(T,E,A){g&&await g;const C=u.create(T,E);g??=C;const I=await C;return I.config=A,I}function y(T){return T instanceof i.Tensor}const x=i?.env;x?.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!x.wasm.wasmPaths&&(x.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${a.env.version}/dist/`),x.wasm.proxy=!1),x?.webgpu&&(x.webgpu.powerPreference="high-performance");function S(){return x?.wasm?.proxy}a.env.backends.onnx=x}),"./src/base/feature_extraction_utils.js":((n,e,t)=>{t.r(e),t.d(e,{FeatureExtractor:()=>l,validate_audio_inputs:()=>_});var s=t("./src/utils/constants.js"),a=t("./src/utils/generic.js"),c=t("./src/utils/hub.js");class l extends a.Callable{constructor(d){super(),this.config=d}static async from_pretrained(d,h={}){const i=await(0,c.getModelJSON)(d,s.FEATURE_EXTRACTOR_NAME,!0,h);return new this(i)}}function _(m,d){if(!(m instanceof Float32Array||m instanceof Float64Array))throw new Error(`${d} expects input to be a Float32Array or a Float64Array, but got ${m?.constructor?.name??typeof m} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}}),"./src/base/image_processors_utils.js":((n,e,t)=>{t.r(e),t.d(e,{ImageProcessor:()=>T,center_to_corners_format:()=>i,post_process_instance_segmentation:()=>S,post_process_object_detection:()=>r,post_process_panoptic_segmentation:()=>x,post_process_semantic_segmentation:()=>u});var s=t("./src/utils/generic.js"),a=t("./src/utils/tensor.js"),c=t("./src/utils/maths.js");t("./src/utils/image.js");var l=t("./src/utils/core.js"),_=t("./src/utils/hub.js"),m=t("./src/utils/constants.js");function d(E,A,C=0,I=null){const D=E/A;let R=(0,c.bankers_round)(D)*A;return I!==null&&R>I&&(R=Math.floor(D)*A),R<C&&(R=Math.ceil(D)*A),R}function h([E,A],C){return[Math.max(Math.floor(E/C),1)*C,Math.max(Math.floor(A/C),1)*C]}function i([E,A,C,I]){return[E-C/2,A-I/2,E+C/2,A+I/2]}function r(E,A=.5,C=null,I=!1){const D=E.logits,R=E.pred_boxes,[Y,re,G]=D.dims;if(C!==null&&C.length!==Y)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let te=[];for(let q=0;q<Y;++q){let z=C!==null?C[q]:null,H={boxes:[],classes:[],scores:[]},he=D[q],Ce=R[q];for(let oe=0;oe<re;++oe){let K=he[oe],Q=[],de;if(I){de=K.sigmoid().data;for(let ue=0;ue<de.length;++ue)de[ue]>A&&Q.push(ue)}else{let ue=(0,c.max)(K.data)[1];if(ue===G-1||(de=(0,c.softmax)(K.data),de[ue]<A))continue;Q.push(ue)}for(const ue of Q){let Ze=Ce[oe].data;Ze=i(Ze),z!==null&&(Ze=Ze.map((Pt,Gt)=>Pt*z[(Gt+1)%2])),H.boxes.push(Ze),H.classes.push(ue),H.scores.push(de[ue])}}te.push(H)}return te}function u(E,A=null){const C=E.logits,I=C.dims[0];if(A!==null&&A.length!==I)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const D=[];for(let R=0;R<I;++R){const Y=A!==null?A[R]:null;let re=C[R];Y!==null&&(re=(0,a.interpolate)(re,Y,"bilinear",!1));const[G,te]=Y??re.dims.slice(-2),q=new a.Tensor("int32",new Int32Array(G*te),[G,te]),z=re[0].data,H=q.data;for(let oe=1;oe<re.dims[0];++oe){const K=re[oe].data;for(let Q=0;Q<K.length;++Q)K[Q]>z[Q]&&(z[Q]=K[Q],H[Q]=oe)}const he=new Array(re.dims[0]);for(let oe=0;oe<H.length;++oe){const K=H[oe];he[K]=K}const Ce=he.filter(oe=>oe!==void 0);D.push({segmentation:q,labels:Ce})}return D}function f(E,A,C,I){const D=[],R=[],Y=[];for(let re=0;re<E.dims[0];++re){const G=E[re],te=A[re],q=(0,c.max)(G.data)[1];if(q===I)continue;const H=(0,c.softmax)(G.data)[q];H>C&&(D.push(te),R.push(H),Y.push(q))}return[D,R,Y]}function g(E,A,C,I=.5,D=.8){const R=[];let Y=0,re=0;const G=A[C].data;for(let q=0;q<E.length;++q)E[q]===C&&(R.push(q),++Y),G[q]>=I&&++re;let te=Y>0&&re>0;return te&&(te=Y/re>D),[te,R]}function w(E,A,C,I,D,R=null,Y=null){const[re,G]=Y??E[0].dims,te=new a.Tensor("int32",new Int32Array(re*G),[re,G]),q=[];if(Y!==null)for(let oe=0;oe<E.length;++oe)E[oe]=(0,a.interpolate)(E[oe],Y,"bilinear",!1);const z=new Int32Array(E[0].data.length),H=new Float32Array(E[0].data.length);for(let oe=0;oe<E.length;++oe){let K=A[oe];const Q=E[oe].data;for(let de=0;de<Q.length;++de)Q[de]*=K,Q[de]>H[de]&&(z[de]=oe,H[de]=Q[de])}let he=0;const Ce=te.data;for(let oe=0;oe<C.length;++oe){const K=C[oe],[Q,de]=g(z,E,oe,I,D);if(Q){++he;for(const ue of de)Ce[ue]=he;q.push({id:he,label_id:K,score:A[oe]})}}return[te,q]}function y(E,A,C=28,I=3136,D=784*1280){if(E<C||A<C)throw new Error(`height:${E} or width:${A} must be larger than factor:${C}`);if(Math.max(E,A)/Math.min(E,A)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(E,A)/Math.min(E,A)}`);let R=Math.round(E/C)*C,Y=Math.round(A/C)*C;if(R*Y>D){const re=Math.sqrt(E*A/D);R=Math.floor(E/re/C)*C,Y=Math.floor(A/re/C)*C}else if(R*Y<I){const re=Math.sqrt(I/(E*A));R=Math.ceil(E*re/C)*C,Y=Math.ceil(A*re/C)*C}return[R,Y]}function x(E,A=.5,C=.5,I=.8,D=null,R=null){D===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),D=new Set);const Y=E.class_queries_logits??E.logits,G=(E.masks_queries_logits??E.pred_masks).sigmoid();let[te,q,z]=Y.dims;if(z-=1,R!==null&&R.length!==te)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let H=[];for(let he=0;he<te;++he){let Ce=R!==null?R[he]:null,oe=Y[he],K=G[he],[Q,de,ue]=f(oe,K,A,z);if(ue.length===0){let[Gt,bn]=Ce??K.dims.slice(-2),ri=new a.Tensor("int32",new Int32Array(Gt*bn).fill(-1),[Gt,bn]);H.push({segmentation:ri,segments_info:[]});continue}let[Ze,Pt]=w(Q,de,ue,C,I,D,Ce);H.push({segmentation:Ze,segments_info:Pt})}return H}function S(E,A=.5,C=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class T extends s.Callable{constructor(A){super(),this.image_mean=A.image_mean??A.mean,this.image_std=A.image_std??A.std,this.resample=A.resample??2,this.do_rescale=A.do_rescale??!0,this.rescale_factor=A.rescale_factor??1/255,this.do_normalize=A.do_normalize,this.do_thumbnail=A.do_thumbnail,this.size=A.size??A.image_size,this.do_resize=A.do_resize??this.size!==void 0,this.size_divisibility=A.size_divisibility??A.size_divisor,this.do_center_crop=A.do_center_crop,this.crop_size=A.crop_size,this.do_convert_rgb=A.do_convert_rgb??!0,this.do_crop_margin=A.do_crop_margin,this.pad_size=A.pad_size,this.do_pad=A.do_pad,this.min_pixels=A.min_pixels,this.max_pixels=A.max_pixels,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=A.do_flip_channel_order??!1,this.config=A}async thumbnail(A,C,I=2){const D=A.height,R=A.width,Y=C.height,re=C.width;let G=Math.min(D,Y),te=Math.min(R,re);return G===D&&te===R?A:(D>R?te=Math.floor(R*G/D):R>D&&(G=Math.floor(D*te/R)),await A.resize(te,G,{resample:I}))}async crop_margin(A,C=200){const I=A.clone().grayscale(),D=(0,c.min)(I.data)[0],Y=(0,c.max)(I.data)[0]-D;if(Y===0)return A;const re=C/255;let G=I.width,te=I.height,q=0,z=0;const H=I.data;for(let he=0;he<I.height;++he){const Ce=he*I.width;for(let oe=0;oe<I.width;++oe)(H[Ce+oe]-D)/Y<re&&(G=Math.min(G,oe),te=Math.min(te,he),q=Math.max(q,oe),z=Math.max(z,he))}return A=await A.crop([G,te,q,z]),A}pad_image(A,C,I,{mode:D="constant",center:R=!1,constant_values:Y=0}={}){const[re,G,te]=C;let q,z;if(typeof I=="number"?(q=I,z=I):I==="square"?q=z=Math.max(re,G):(q=I.width,z=I.height),q!==G||z!==re){const H=new Float32Array(q*z*te);if(Array.isArray(Y))for(let oe=0;oe<H.length;++oe)H[oe]=Y[oe%te];else Y!==0&&H.fill(Y);const[he,Ce]=R?[Math.floor((q-G)/2),Math.floor((z-re)/2)]:[0,0];for(let oe=0;oe<re;++oe){const K=(oe+Ce)*q,Q=oe*G;for(let de=0;de<G;++de){const ue=(K+de+he)*te,Ze=(Q+de)*te;for(let Pt=0;Pt<te;++Pt)H[ue+Pt]=A[Ze+Pt]}}if(D==="symmetric"){if(R)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const oe=re-1,K=G-1;for(let Q=0;Q<z;++Q){const de=Q*q,ue=(0,l.calculateReflectOffset)(Q,oe)*G;for(let Ze=0;Ze<q;++Ze){if(Q<re&&Ze<G)continue;const Pt=(de+Ze)*te,Gt=(ue+(0,l.calculateReflectOffset)(Ze,K))*te;for(let bn=0;bn<te;++bn)H[Pt+bn]=A[Gt+bn]}}}A=H,C=[z,q,te]}return[A,C]}rescale(A){for(let C=0;C<A.length;++C)A[C]=this.rescale_factor*A[C]}get_resize_output_image_size(A,C){const[I,D]=A.size;let R,Y;if(this.do_thumbnail){const{height:re,width:G}=C;R=Math.min(re,G)}else Number.isInteger(C)?(R=C,Y=this.config.max_size??R):C!==void 0&&(R=C.shortest_edge,Y=C.longest_edge);if(R!==void 0||Y!==void 0){const re=R===void 0?1:Math.max(R/I,R/D),G=I*re,te=D*re,q=Y===void 0?1:Math.min(Y/G,Y/te);let z=Math.floor(Number((G*q).toFixed(2))),H=Math.floor(Number((te*q).toFixed(2)));return this.size_divisibility!==void 0&&([z,H]=h([z,H],this.size_divisibility)),[z,H]}else if(C!==void 0&&C.width!==void 0&&C.height!==void 0){let re=C.width,G=C.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let te=G/D,q=re/I;Math.abs(1-q)<Math.abs(1-te)?te=q:q=te,G=d(te*D,this.config.ensure_multiple_of),re=d(q*I,this.config.ensure_multiple_of)}return[re,G]}else{if(this.size_divisibility!==void 0)return h([I,D],this.size_divisibility);if(this.min_pixels!==void 0&&this.max_pixels!==void 0){const re=this.config.patch_size*this.config.merge_size;return y(D,I,re,this.min_pixels,this.max_pixels)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(C)}`)}}async resize(A){const[C,I]=this.get_resize_output_image_size(A,this.size);return await A.resize(C,I,{resample:this.resample})}async preprocess(A,{do_normalize:C=null,do_pad:I=null,do_convert_rgb:D=null,do_convert_grayscale:R=null,do_flip_channel_order:Y=null}={}){this.do_crop_margin&&(A=await this.crop_margin(A));const[re,G]=A.size;if(D??this.do_convert_rgb?A=A.rgb():R&&(A=A.grayscale()),this.do_resize&&(A=await this.resize(A)),this.do_thumbnail&&(A=await this.thumbnail(A,this.size,this.resample)),this.do_center_crop){let he,Ce;Number.isInteger(this.crop_size)?(he=this.crop_size,Ce=this.crop_size):(he=this.crop_size.width,Ce=this.crop_size.height),A=await A.center_crop(he,Ce)}const te=[A.height,A.width];let q=Float32Array.from(A.data),z=[A.height,A.width,A.channels];if(this.do_rescale&&this.rescale(q),C??this.do_normalize){let he=this.image_mean;Array.isArray(this.image_mean)||(he=new Array(A.channels).fill(he));let Ce=this.image_std;if(Array.isArray(this.image_std)||(Ce=new Array(A.channels).fill(he)),he.length!==A.channels||Ce.length!==A.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${he.length}) and \`image_std\` (${Ce.length}) must match the number of channels in the image (${A.channels}).`);for(let oe=0;oe<q.length;oe+=A.channels)for(let K=0;K<A.channels;++K)q[oe+K]=(q[oe+K]-he[K])/Ce[K]}if(I??this.do_pad){if(this.pad_size)[q,z]=this.pad_image(q,[A.height,A.width,A.channels],this.pad_size);else if(this.size_divisibility){const[he,Ce]=h([z[1],z[0]],this.size_divisibility);[q,z]=this.pad_image(q,z,{width:he,height:Ce})}}if(Y??this.do_flip_channel_order){if(z[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let he=0;he<q.length;he+=3){const Ce=q[he];q[he]=q[he+2],q[he+2]=Ce}}const H=new a.Tensor("float32",q,z).permute(2,0,1);return{original_size:[G,re],reshaped_input_size:te,pixel_values:H}}async _call(A,...C){Array.isArray(A)||(A=[A]);const I=await Promise.all(A.map(R=>this.preprocess(R)));return{pixel_values:(0,a.stack)(I.map(R=>R.pixel_values),0),original_sizes:I.map(R=>R.original_size),reshaped_input_sizes:I.map(R=>R.reshaped_input_size)}}static async from_pretrained(A,C={}){const I=await(0,_.getModelJSON)(A,m.IMAGE_PROCESSOR_NAME,!0,C);return new this(I)}}}),"./src/base/processing_utils.js":((n,e,t)=>{t.r(e),t.d(e,{Processor:()=>l});var s=t("./src/utils/constants.js"),a=t("./src/utils/generic.js"),c=t("./src/utils/hub.js");class l extends a.Callable{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;static uses_chat_template_file=!1;constructor(m,d,h){super(),this.config=m,this.components=d,this.chat_template=h}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(m,d={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(m,{tokenize:!1,chat_template:this.chat_template??void 0,...d})}batch_decode(...m){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...m)}decode(...m){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...m)}async _call(m,...d){for(const h of[this.image_processor,this.feature_extractor,this.tokenizer])if(h)return h(m,...d);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(m,d={}){const[h,i,r]=await Promise.all([this.uses_processor_config?(0,c.getModelJSON)(m,s.PROCESSOR_NAME,!0,d):{},Promise.all(this.classes.filter(u=>u in this).map(async u=>{const f=await this[u].from_pretrained(m,d);return[u.replace(/_class$/,""),f]})).then(Object.fromEntries),this.uses_chat_template_file?(0,c.getModelText)(m,s.CHAT_TEMPLATE_NAME,!0,d):null]);return new this(h,i,r)}}}),"./src/configs.js":((n,e,t)=>{t.r(e),t.d(e,{AutoConfig:()=>h,PretrainedConfig:()=>d,getCacheShapes:()=>_});var s=t("./src/utils/core.js"),a=t("./src/utils/hub.js");async function c(i,r){return await(0,a.getModelJSON)(i,"config.json",!0,r)}function l(i){const r={};let u={};switch(i.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"voxtral":case"smolvlm":case"gemma3n":u=l(i.text_config);break;case"moondream1":u=l(i.phi_config);break;case"musicgen":u=l(i.decoder);break;case"multi_modality":u=l(i.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":r.num_heads="n_head",r.num_layers="n_layer",r.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":case"modernbert-decoder":r.num_heads="num_attention_heads",r.num_layers="num_hidden_layers",r.hidden_size="hidden_size";break;case"llama":case"arcee":case"lfm2":case"smollm3":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":r.num_heads="num_key_value_heads",r.num_layers="num_hidden_layers",r.hidden_size="hidden_size",r.num_attention_heads="num_attention_heads",r.dim_kv="head_dim";break;case"qwen3":case"gemma":case"gemma2":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":case"ernie4_5":r.num_heads="num_key_value_heads",r.num_layers="num_hidden_layers",r.dim_kv="head_dim";break;case"openelm":r.num_heads="num_kv_heads",r.num_layers="num_transformer_layers",r.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":r.num_heads="num_heads",r.num_layers="num_layers",r.hidden_size="hidden_size";break;case"bloom":r.num_heads="n_head",r.num_layers="n_layer",r.hidden_size="hidden_size";break;case"mpt":r.num_heads="n_heads",r.num_layers="n_layers",r.hidden_size="d_model";break;case"exaone":r.num_heads="num_key_value_heads",r.num_layers="num_layers",r.dim_kv="head_dim",r.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":r.num_decoder_layers="num_decoder_layers",r.num_decoder_heads="num_heads",r.decoder_dim_kv="d_kv",r.num_encoder_layers="num_layers",r.num_encoder_heads="num_heads",r.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":r.num_decoder_layers="decoder_layers",r.num_decoder_heads="decoder_attention_heads",r.decoder_hidden_size="d_model",r.num_encoder_layers="encoder_layers",r.num_encoder_heads="encoder_attention_heads",r.encoder_hidden_size="d_model";break;case"speecht5":r.num_decoder_layers="decoder_layers",r.num_decoder_heads="decoder_attention_heads",r.decoder_hidden_size="hidden_size",r.num_encoder_layers="encoder_layers",r.num_encoder_heads="encoder_attention_heads",r.encoder_hidden_size="hidden_size";break;case"trocr":r.num_encoder_layers=r.num_decoder_layers="decoder_layers",r.num_encoder_heads=r.num_decoder_heads="decoder_attention_heads",r.encoder_hidden_size=r.decoder_hidden_size="d_model";break;case"musicgen_decoder":r.num_encoder_layers=r.num_decoder_layers="num_hidden_layers",r.num_encoder_heads=r.num_decoder_heads="num_attention_heads",r.encoder_hidden_size=r.decoder_hidden_size="hidden_size";break;case"moonshine":r.num_decoder_layers="decoder_num_hidden_layers",r.num_decoder_heads="decoder_num_key_value_heads",r.num_encoder_layers="encoder_num_hidden_layers",r.num_encoder_heads="encoder_num_key_value_heads",r.encoder_hidden_size=r.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const g=l(i.decoder),w="num_decoder_layers"in g,y=(0,s.pick)(i,["model_type","is_encoder_decoder"]);return w?(y.num_decoder_layers=g.num_decoder_layers,y.num_decoder_heads=g.num_decoder_heads,y.decoder_hidden_size=g.decoder_hidden_size,y.num_encoder_layers=g.num_encoder_layers,y.num_encoder_heads=g.num_encoder_heads,y.encoder_hidden_size=g.encoder_hidden_size):(y.num_layers=g.num_layers,y.num_heads=g.num_heads,y.hidden_size=g.hidden_size),y}const f={...u,...(0,s.pick)(i,["model_type","multi_query","is_encoder_decoder"])};for(const g in r)f[g]=i[r[g]];return f}function _(i,r){if(i.model_type==="lfm2"){const u=r?.prefix??"past_key_values",f=u==="present"?"present":"past",g={},{layer_types:w,num_attention_heads:y,num_key_value_heads:x,hidden_size:S,conv_L_cache:T}=i,E=S/y,A=r?.batch_size??1;for(let C=0;C<w.length;++C)if(w[C]==="full_attention")for(const I of["key","value"])g[`${u}.${C}.${I}`]=[A,x,0,E];else if(w[C]==="conv")g[`${f}_conv.${C}`]=[A,S,T];else throw new Error(`Unsupported layer type: ${w[C]}`);return g}return m(i,r)}function m(i,{prefix:r="past_key_values",batch_size:u=1}={}){const f={},g=i.normalized_config;if(g.is_encoder_decoder&&"num_encoder_heads"in g&&"num_decoder_heads"in g){const w=g.encoder_dim_kv??g.encoder_hidden_size/g.num_encoder_heads,y=g.decoder_dim_kv??g.decoder_hidden_size/g.num_decoder_heads,x=[u,g.num_encoder_heads,0,w],S=[u,g.num_decoder_heads,0,y];for(let T=0;T<g.num_decoder_layers;++T)f[`${r}.${T}.encoder.key`]=x,f[`${r}.${T}.encoder.value`]=x,f[`${r}.${T}.decoder.key`]=S,f[`${r}.${T}.decoder.value`]=S}else{const w=g.num_heads,y=g.num_layers,x=g.dim_kv??g.hidden_size/(g.num_attention_heads??w);if(g.model_type==="falcon"){const S=[u*w,0,x];for(let T=0;T<y;++T)f[`${r}.${T}.key`]=S,f[`${r}.${T}.value`]=S}else if(g.multi_query){const S=[u*w,0,2*x];for(let T=0;T<y;++T)f[`${r}.${T}.key_value`]=S}else if(g.model_type==="bloom"){const S=[u*w,x,0],T=[u*w,0,x];for(let E=0;E<y;++E)f[`${r}.${E}.key`]=S,f[`${r}.${E}.value`]=T}else if(g.model_type==="openelm")for(let S=0;S<y;++S){const T=[u,w[S],0,x];f[`${r}.${S}.key`]=T,f[`${r}.${S}.value`]=T}else{const S=[u,w,0,x];for(let T=0;T<y;++T)f[`${r}.${T}.key`]=S,f[`${r}.${T}.value`]=S}}return f}class d{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(r){Object.assign(this,r),this.normalized_config=l(this)}static async from_pretrained(r,{progress_callback:u=null,config:f=null,cache_dir:g=null,local_files_only:w=!1,revision:y="main"}={}){f&&!(f instanceof d)&&(f=new d(f));const x=f??await c(r,{progress_callback:u,config:f,cache_dir:g,local_files_only:w,revision:y});return new this(x)}}class h{static async from_pretrained(...r){return d.from_pretrained(...r)}}}),"./src/env.js":((n,e,t)=>{t.r(e),t.d(e,{apis:()=>y,env:()=>C});var s=t("?db59"),a=t("?383f"),c=t("?fa4b");const l="3.7.2",_=typeof window<"u"&&typeof window.document<"u",m=typeof self<"u"&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes(self.constructor?.name),d=typeof self<"u"&&"caches"in self,h=typeof navigator<"u"&&"gpu"in navigator,i=typeof navigator<"u"&&"ml"in navigator,r=typeof process<"u",u=r&&process?.release?.name==="node",f=!I(s),g=!I(a),w=typeof globalThis.Deno<"u",y=Object.freeze({IS_BROWSER_ENV:_,IS_WEBWORKER_ENV:m,IS_WEB_CACHE_AVAILABLE:d,IS_WEBGPU_AVAILABLE:h,IS_WEBNN_AVAILABLE:i,IS_PROCESS_AVAILABLE:r,IS_NODE_ENV:u,IS_FS_AVAILABLE:f,IS_PATH_AVAILABLE:g}),x=f&&g;let S="./";if(x){const D=Object(import.meta).url;D?S=a.dirname(a.dirname(c.fileURLToPath(D))):typeof __dirname<"u"&&(S=a.dirname(__dirname))}const T=x?a.join(S,"/.cache/"):null,E="/models/",A=x?a.join(S,E):E,C={version:l,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(_||m),localModelPath:A,useFS:f,useBrowserCache:d&&!w,useFSCache:f,cacheDir:T,useCustomCache:!1,customCache:null};function I(D){return Object.keys(D).length===0}}),"./src/generation/configuration_utils.js":((n,e,t)=>{t.r(e),t.d(e,{GenerationConfig:()=>a});var s=t("./src/utils/core.js");class a{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(l){Object.assign(this,(0,s.pick)(l,Object.getOwnPropertyNames(this)))}}}),"./src/generation/logits_process.js":((n,e,t)=>{t.r(e),t.d(e,{ClassifierFreeGuidanceLogitsProcessor:()=>y,ForcedBOSTokenLogitsProcessor:()=>m,ForcedEOSTokenLogitsProcessor:()=>d,LogitsProcessor:()=>c,LogitsProcessorList:()=>_,LogitsWarper:()=>l,MinLengthLogitsProcessor:()=>f,MinNewTokensLengthLogitsProcessor:()=>g,NoBadWordsLogitsProcessor:()=>w,NoRepeatNGramLogitsProcessor:()=>r,RepetitionPenaltyLogitsProcessor:()=>u,SuppressTokensAtBeginLogitsProcessor:()=>h,TemperatureLogitsWarper:()=>x,TopKLogitsWarper:()=>T,TopPLogitsWarper:()=>S,WhisperTimeStampLogitsProcessor:()=>i});var s=t("./src/utils/generic.js");t("./src/utils/tensor.js");var a=t("./src/utils/maths.js");class c extends s.Callable{_call(A,C){throw Error("`_call` should be implemented in a subclass")}}class l extends s.Callable{_call(A,C){throw Error("`_call` should be implemented in a subclass")}}class _ extends s.Callable{constructor(){super(),this.processors=[]}push(A){this.processors.push(A)}extend(A){this.processors.push(...A)}_call(A,C){let I=C;for(const D of this.processors)I=D(A,I);return I}[Symbol.iterator](){return this.processors.values()}}class m extends c{constructor(A){super(),this.bos_token_id=A}_call(A,C){for(let I=0;I<A.length;++I)if(A[I].length===1){const D=C[I].data;D.fill(-1/0),D[this.bos_token_id]=0}return C}}class d extends c{constructor(A,C){super(),this.max_length=A,this.eos_token_id=Array.isArray(C)?C:[C]}_call(A,C){for(let I=0;I<A.length;++I)if(A[I].length===this.max_length-1){const D=C[I].data;D.fill(-1/0);for(const R of this.eos_token_id)D[R]=0}return C}}class h extends c{constructor(A,C){super(),this.begin_suppress_tokens=A,this.begin_index=C}_call(A,C){for(let I=0;I<A.length;++I)if(A[I].length===this.begin_index){const D=C[I].data;for(const R of this.begin_suppress_tokens)D[R]=-1/0}return C}}class i extends c{constructor(A,C){super(),this.eos_token_id=Array.isArray(A.eos_token_id)?A.eos_token_id[0]:A.eos_token_id,this.no_timestamps_token_id=A.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=C.length,C.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=A.max_initial_timestamp_index}_call(A,C){for(let I=0;I<A.length;++I){const D=C[I].data;if(D[this.no_timestamps_token_id]=-1/0,A[I].length===this.begin_index-1){D.fill(-1/0),D[this.timestamp_begin]=0;continue}const R=A[I].slice(this.begin_index),Y=R.length>=1&&R[R.length-1]>=this.timestamp_begin,re=R.length<2||R[R.length-2]>=this.timestamp_begin;if(Y&&(re?D.subarray(this.timestamp_begin).fill(-1/0):D.subarray(0,this.eos_token_id).fill(-1/0)),A[I].length===this.begin_index&&this.max_initial_timestamp_index!==null){const z=this.timestamp_begin+this.max_initial_timestamp_index;D.subarray(z+1).fill(-1/0)}const G=(0,a.log_softmax)(D),te=Math.log(G.subarray(this.timestamp_begin).map(Math.exp).reduce((z,H)=>z+H)),q=(0,a.max)(G.subarray(0,this.timestamp_begin))[0];te>q&&D.subarray(0,this.timestamp_begin).fill(-1/0)}return C}}class r extends c{constructor(A){super(),this.no_repeat_ngram_size=A}getNgrams(A){const C=A.length,I=[];for(let R=0;R<C+1-this.no_repeat_ngram_size;++R){const Y=[];for(let re=0;re<this.no_repeat_ngram_size;++re)Y.push(A[R+re]);I.push(Y.map(Number))}const D=new Map;for(const R of I){const Y=R.slice(0,R.length-1),re=JSON.stringify(Y),G=D.get(re)??[];G.push(R[R.length-1]),D.set(re,G)}return D}getGeneratedNgrams(A,C){const I=C.slice(C.length+1-this.no_repeat_ngram_size,C.length);return A.get(JSON.stringify(I.map(Number)))??[]}calcBannedNgramTokens(A){const C=[];if(A.length+1<this.no_repeat_ngram_size)return C;{const I=this.getNgrams(A);return this.getGeneratedNgrams(I,A)}}_call(A,C){for(let I=0;I<A.length;++I){const D=C[I].data,R=this.calcBannedNgramTokens(A[I]);for(const Y of R)D[Y]=-1/0}return C}}class u extends c{constructor(A){super(),this.penalty=A}_call(A,C){for(let I=0;I<A.length;++I){const D=C[I].data;for(const R of new Set(A[I])){const Y=Number(R);D[Y]<0?D[Y]*=this.penalty:D[Y]/=this.penalty}}return C}}class f extends c{constructor(A,C){super(),this.min_length=A,this.eos_token_id=Array.isArray(C)?C:[C]}_call(A,C){for(let I=0;I<A.length;++I)if(A[I].length<this.min_length){const D=C[I].data;for(const R of this.eos_token_id)D[R]=-1/0}return C}}class g extends c{constructor(A,C,I){super(),this.prompt_length_to_skip=A,this.min_new_tokens=C,this.eos_token_id=Array.isArray(I)?I:[I]}_call(A,C){for(let I=0;I<A.length;++I)if(A[I].length-this.prompt_length_to_skip<this.min_new_tokens){const R=C[I].data;for(const Y of this.eos_token_id)R[Y]=-1/0}return C}}class w extends c{constructor(A,C){super(),this.bad_words_ids=A,this.eos_token_id=Array.isArray(C)?C:[C]}_call(A,C){for(let I=0;I<A.length;++I){const D=C[I].data,R=A[I];for(const Y of this.bad_words_ids){if(R.length<Y.length-1)continue;let re=!0;for(let G=1;G<=Y.length-1;++G)if(Y.at(-G-1)!=R.at(-G)){re=!1;break}re&&(D[Y.at(-1)]=-1/0)}}return C}}class y extends c{constructor(A){if(super(),A<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${A}.`);this.guidance_scale=A}_call(A,C){if(C.dims[0]!==2*A.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${C.dims[0]} for the logits and ${A.length} for the input ids.`);const I=A.length,D=C.slice([0,I],null),R=C.slice([I,C.dims[0]],null);for(let Y=0;Y<R.data.length;++Y)R.data[Y]+=(D.data[Y]-R.data[Y])*this.guidance_scale;return R}}class x extends l{constructor(A){super(),this.temperature=A}_call(A,C){const I=C.data;for(let D=0;D<I.length;++D)I[D]/=this.temperature;return C}}class S extends l{constructor(A,{filter_value:C=-1/0,min_tokens_to_keep:I=1}={}){if(super(),A<0||A>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${A}`);if(!Number.isInteger(I)||I<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${I}`);this.top_p=A,this.filter_value=C,this.min_tokens_to_keep=I}}class T extends l{constructor(A,{filter_value:C=-1/0,min_tokens_to_keep:I=1}={}){if(super(),!Number.isInteger(A)||A<0)throw new Error(`\`top_k\` must be a positive integer, but is ${A}`);this.top_k=Math.max(A,I),this.filter_value=C}}}),"./src/generation/logits_sampler.js":((n,e,t)=>{t.r(e),t.d(e,{LogitsSampler:()=>l});var s=t("./src/utils/generic.js"),a=t("./src/utils/tensor.js"),c=t("./src/utils/maths.js");t("./src/generation/configuration_utils.js");class l extends s.Callable{constructor(i){super(),this.generation_config=i}async _call(i){return this.sample(i)}async sample(i){throw Error("sample should be implemented in subclasses.")}getLogits(i,r){let u=i.dims.at(-1),f=i.data;if(r===-1)f=f.slice(-u);else{let g=r*u;f=f.slice(g,g+u)}return f}randomSelect(i){let r=0;for(let f=0;f<i.length;++f)r+=i[f];let u=Math.random()*r;for(let f=0;f<i.length;++f)if(u-=i[f],u<=0)return f;return 0}static getSampler(i){if(i.do_sample)return new m(i);if(i.num_beams>1)return new d(i);if(i.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${i.num_return_sequences}.`);return new _(i)}}class _ extends l{async sample(i){const r=(0,c.max)(i.data)[1];return[[BigInt(r),0]]}}class m extends l{async sample(i){let r=i.dims.at(-1);this.generation_config.top_k>0&&(r=Math.min(this.generation_config.top_k,r));const[u,f]=await(0,a.topk)(i,r),g=(0,c.softmax)(u.data);return Array.from({length:this.generation_config.num_beams},()=>{const w=this.randomSelect(g);return[f.data[w],Math.log(g[w])]})}}class d extends l{async sample(i){let r=i.dims.at(-1);this.generation_config.top_k>0&&(r=Math.min(this.generation_config.top_k,r));const[u,f]=await(0,a.topk)(i,r),g=(0,c.softmax)(u.data);return Array.from({length:this.generation_config.num_beams},(w,y)=>[f.data[y],Math.log(g[y])])}}}),"./src/generation/stopping_criteria.js":((n,e,t)=>{t.r(e),t.d(e,{EosTokenCriteria:()=>_,InterruptableStoppingCriteria:()=>m,MaxLengthCriteria:()=>l,StoppingCriteria:()=>a,StoppingCriteriaList:()=>c});var s=t("./src/utils/generic.js");class a extends s.Callable{_call(h,i){throw Error("StoppingCriteria needs to be subclassed")}}class c extends s.Callable{constructor(){super(),this.criteria=[]}push(h){this.criteria.push(h)}extend(h){h instanceof c?h=h.criteria:h instanceof a&&(h=[h]),this.criteria.push(...h)}_call(h,i){const r=new Array(h.length).fill(!1);for(const u of this.criteria){const f=u(h,i);for(let g=0;g<r.length;++g)r[g]||=f[g]}return r}[Symbol.iterator](){return this.criteria.values()}}class l extends a{constructor(h,i=null){super(),this.max_length=h,this.max_position_embeddings=i}_call(h){return h.map(i=>i.length>=this.max_length)}}class _ extends a{constructor(h){super(),Array.isArray(h)||(h=[h]),this.eos_token_id=h}_call(h,i){return h.map(r=>{const u=r.at(-1);return this.eos_token_id.some(f=>u==f)})}}class m extends a{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(h,i){return new Array(h.length).fill(this.interrupted)}}}),"./src/generation/streamers.js":((n,e,t)=>{t.r(e),t.d(e,{BaseStreamer:()=>l,TextStreamer:()=>m,WhisperTextStreamer:()=>d});var s=t("./src/utils/core.js"),a=t("./src/tokenizers.js"),c=t("./src/env.js");class l{put(i){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const _=c.apis.IS_PROCESS_AVAILABLE?h=>process.stdout.write(h):h=>console.log(h);class m extends l{constructor(i,{skip_prompt:r=!1,callback_function:u=null,token_callback_function:f=null,skip_special_tokens:g=!0,decode_kwargs:w={},...y}={}){super(),this.tokenizer=i,this.skip_prompt=r,this.callback_function=u??_,this.token_callback_function=f,this.decode_kwargs={skip_special_tokens:g,...w,...y},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(i){if(i.length>1)throw Error("TextStreamer only supports batch size of 1");const r=this.next_tokens_are_prompt;if(r&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const u=i[0];this.token_callback_function?.(u),this.token_cache=(0,s.mergeArrays)(this.token_cache,u);const f=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let g;r||f.endsWith(`
`)?(g=f.slice(this.print_len),this.token_cache=[],this.print_len=0):f.length>0&&(0,a.is_chinese_char)(f.charCodeAt(f.length-1))?(g=f.slice(this.print_len),this.print_len+=g.length):(g=f.slice(this.print_len,f.lastIndexOf(" ")+1),this.print_len+=g.length),this.on_finalized_text(g,!1)}end(){let i;this.token_cache.length>0?(i=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):i="",this.next_tokens_are_prompt=!0,this.on_finalized_text(i,!0)}on_finalized_text(i,r){i.length>0&&this.callback_function?.(i),r&&this.callback_function===_&&c.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.(`
`)}}class d extends m{constructor(i,{skip_prompt:r=!1,callback_function:u=null,token_callback_function:f=null,on_chunk_start:g=null,on_chunk_end:w=null,on_finalize:y=null,time_precision:x=.02,skip_special_tokens:S=!0,decode_kwargs:T={}}={}){super(i,{skip_prompt:r,skip_special_tokens:S,callback_function:u,token_callback_function:f,decode_kwargs:T}),this.timestamp_begin=i.timestamp_begin,this.on_chunk_start=g,this.on_chunk_end=w,this.on_finalize=y,this.time_precision=x,this.waiting_for_timestamp=!1}put(i){if(i.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const r=i[0];if(r.length===1){const u=Number(r[0])-this.timestamp_begin;if(u>=0){const f=u*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.(f):this.on_chunk_start?.(f),this.waiting_for_timestamp=!this.waiting_for_timestamp,this.token_callback_function?.(r);return}}return super.put(i)}end(){super.end(),this.on_finalize?.()}}}),"./src/models.js":((n,e,t)=>{t.r(e),t.d(e,{ASTForAudioClassification:()=>zg,ASTModel:()=>G0,ASTPreTrainedModel:()=>H1,AlbertForMaskedLM:()=>zo,AlbertForQuestionAnswering:()=>di,AlbertForSequenceClassification:()=>yi,AlbertModel:()=>lr,AlbertPreTrainedModel:()=>or,ArceeForCausalLM:()=>Ic,ArceeModel:()=>Ec,ArceePreTrainedModel:()=>jo,AutoModel:()=>A0,AutoModelForAudioClassification:()=>C0,AutoModelForAudioFrameClassification:()=>Aw,AutoModelForAudioTextToText:()=>lv,AutoModelForCTC:()=>Pw,AutoModelForCausalLM:()=>tv,AutoModelForDepthEstimation:()=>ry,AutoModelForDocumentQuestionAnswering:()=>fx,AutoModelForImageClassification:()=>Gc,AutoModelForImageFeatureExtraction:()=>av,AutoModelForImageMatting:()=>V1,AutoModelForImageSegmentation:()=>dx,AutoModelForImageTextToText:()=>ov,AutoModelForImageToImage:()=>Q_,AutoModelForMaskGeneration:()=>Sv,AutoModelForMaskedLM:()=>Sw,AutoModelForNormalEstimation:()=>Pv,AutoModelForObjectDetection:()=>Mv,AutoModelForPoseEstimation:()=>iv,AutoModelForQuestionAnswering:()=>nv,AutoModelForSemanticSegmentation:()=>Tv,AutoModelForSeq2SeqLM:()=>Qx,AutoModelForSequenceClassification:()=>Ew,AutoModelForSpeechSeq2Seq:()=>Zx,AutoModelForTextToSpectrogram:()=>Jx,AutoModelForTextToWaveform:()=>ev,AutoModelForTokenClassification:()=>Xx,AutoModelForUniversalSegmentation:()=>sv,AutoModelForVision2Seq:()=>rv,AutoModelForXVector:()=>px,AutoModelForZeroShotObjectDetection:()=>Ev,BartForConditionalGeneration:()=>Z,BartForSequenceClassification:()=>xe,BartModel:()=>wc,BartPretrainedModel:()=>yp,BaseModelOutput:()=>In,BeitForImageClassification:()=>Dy,BeitModel:()=>Iy,BeitPreTrainedModel:()=>Oy,BertForMaskedLM:()=>kn,BertForQuestionAnswering:()=>cr,BertForSequenceClassification:()=>yn,BertForTokenClassification:()=>$n,BertModel:()=>cn,BertPreTrainedModel:()=>Tn,BlenderbotForConditionalGeneration:()=>ki,BlenderbotModel:()=>Ii,BlenderbotPreTrainedModel:()=>gi,BlenderbotSmallForConditionalGeneration:()=>fp,BlenderbotSmallModel:()=>pp,BlenderbotSmallPreTrainedModel:()=>Zo,BloomForCausalLM:()=>Px,BloomModel:()=>Nw,BloomPreTrainedModel:()=>o0,CLIPModel:()=>wg,CLIPPreTrainedModel:()=>i_,CLIPSegForImageSegmentation:()=>Z1,CLIPSegModel:()=>xg,CLIPSegPreTrainedModel:()=>Tp,CLIPTextModel:()=>by,CLIPTextModelWithProjection:()=>Ug,CLIPVisionModel:()=>tb,CLIPVisionModelWithProjection:()=>nb,CamembertForMaskedLM:()=>hi,CamembertForQuestionAnswering:()=>it,CamembertForSequenceClassification:()=>Oo,CamembertForTokenClassification:()=>we,CamembertModel:()=>Pi,CamembertPreTrainedModel:()=>vi,CausalLMOutput:()=>Ng,CausalLMOutputWithPast:()=>Cv,ChineseCLIPModel:()=>sb,ChineseCLIPPreTrainedModel:()=>rb,ClapAudioModelWithProjection:()=>H2,ClapModel:()=>Nx,ClapPreTrainedModel:()=>Wc,ClapTextModelWithProjection:()=>Rx,CodeGenForCausalLM:()=>li,CodeGenModel:()=>nr,CodeGenPreTrainedModel:()=>mt,CohereForCausalLM:()=>Lw,CohereModel:()=>Qg,CoherePreTrainedModel:()=>A_,ConvBertForMaskedLM:()=>_c,ConvBertForQuestionAnswering:()=>W,ConvBertForSequenceClassification:()=>Ui,ConvBertForTokenClassification:()=>Rp,ConvBertModel:()=>Ri,ConvBertPreTrainedModel:()=>si,ConvNextForImageClassification:()=>b2,ConvNextModel:()=>g2,ConvNextPreTrainedModel:()=>Ob,ConvNextV2ForImageClassification:()=>w2,ConvNextV2Model:()=>Ky,ConvNextV2PreTrainedModel:()=>y2,DFineForObjectDetection:()=>n_,DFineModel:()=>Ry,DFinePreTrainedModel:()=>vb,DINOv3ConvNextModel:()=>Ib,DINOv3ConvNextPreTrainedModel:()=>Zy,DINOv3ViTModel:()=>g0,DINOv3ViTPreTrainedModel:()=>v2,DPTForDepthEstimation:()=>i2,DPTModel:()=>Gy,DPTPreTrainedModel:()=>Vy,DacDecoderModel:()=>z1,DacDecoderOutput:()=>Fc,DacEncoderModel:()=>Lg,DacEncoderOutput:()=>vc,DacModel:()=>u_,DacPreTrainedModel:()=>Xo,DebertaForMaskedLM:()=>Ht,DebertaForQuestionAnswering:()=>Ti,DebertaForSequenceClassification:()=>mn,DebertaForTokenClassification:()=>ii,DebertaModel:()=>Ot,DebertaPreTrainedModel:()=>pt,DebertaV2ForMaskedLM:()=>Ko,DebertaV2ForQuestionAnswering:()=>En,DebertaV2ForSequenceClassification:()=>yc,DebertaV2ForTokenClassification:()=>Dc,DebertaV2Model:()=>Do,DebertaV2PreTrainedModel:()=>pi,DecisionTransformerModel:()=>Ig,DecisionTransformerPreTrainedModel:()=>Z2,DeiTForImageClassification:()=>Eb,DeiTModel:()=>G_,DeiTPreTrainedModel:()=>Mb,DepthAnythingForDepthEstimation:()=>o2,DepthAnythingPreTrainedModel:()=>a2,DepthProForDepthEstimation:()=>Cb,DepthProPreTrainedModel:()=>C1,DetrForObjectDetection:()=>jc,DetrForSegmentation:()=>ap,DetrModel:()=>Yo,DetrObjectDetectionOutput:()=>f0,DetrPreTrainedModel:()=>C_,DetrSegmentationOutput:()=>A1,Dinov2ForImageClassification:()=>x2,Dinov2Model:()=>Xy,Dinov2PreTrainedModel:()=>Yy,Dinov2WithRegistersForImageClassification:()=>Dx,Dinov2WithRegistersModel:()=>Ix,Dinov2WithRegistersPreTrainedModel:()=>Qy,DistilBertForMaskedLM:()=>Jf,DistilBertForQuestionAnswering:()=>dp,DistilBertForSequenceClassification:()=>bc,DistilBertForTokenClassification:()=>Oc,DistilBertModel:()=>Ro,DistilBertPreTrainedModel:()=>Oi,DonutSwinModel:()=>m2,DonutSwinPreTrainedModel:()=>_2,EfficientNetForImageClassification:()=>qb,EfficientNetModel:()=>pw,EfficientNetPreTrainedModel:()=>Wb,ElectraForMaskedLM:()=>Ke,ElectraForQuestionAnswering:()=>ar,ElectraForSequenceClassification:()=>lt,ElectraForTokenClassification:()=>_n,ElectraModel:()=>ve,ElectraPreTrainedModel:()=>Qe,Ernie4_5_ForCausalLM:()=>lw,Ernie4_5_Model:()=>W_,Ernie4_5_PretrainedModel:()=>ow,EsmForMaskedLM:()=>sp,EsmForSequenceClassification:()=>mr,EsmForTokenClassification:()=>ci,EsmModel:()=>Qc,EsmPreTrainedModel:()=>kp,ExaoneForCausalLM:()=>Dw,ExaoneModel:()=>z_,ExaonePreTrainedModel:()=>lb,FalconForCausalLM:()=>v0,FalconModel:()=>Vb,FalconPreTrainedModel:()=>uw,FastViTForImageClassification:()=>Hw,FastViTModel:()=>qw,FastViTPreTrainedModel:()=>M1,Florence2ForConditionalGeneration:()=>Z0,Florence2PreTrainedModel:()=>my,GLPNForDepthEstimation:()=>Hy,GLPNModel:()=>h2,GLPNPreTrainedModel:()=>qy,GPT2LMHeadModel:()=>J1,GPT2Model:()=>m1,GPT2PreTrainedModel:()=>_1,GPTBigCodeForCausalLM:()=>De,GPTBigCodeModel:()=>_e,GPTBigCodePreTrainedModel:()=>le,GPTJForCausalLM:()=>V,GPTJModel:()=>L,GPTJPreTrainedModel:()=>qg,GPTNeoForCausalLM:()=>g1,GPTNeoModel:()=>N_,GPTNeoPreTrainedModel:()=>vg,GPTNeoXForCausalLM:()=>R_,GPTNeoXModel:()=>P_,GPTNeoXPreTrainedModel:()=>b1,Gemma2ForCausalLM:()=>Zg,Gemma2Model:()=>kc,Gemma2PreTrainedModel:()=>Zc,Gemma3ForCausalLM:()=>Jg,Gemma3Model:()=>Ty,Gemma3PreTrainedModel:()=>y_,Gemma3nForConditionalGeneration:()=>S_,Gemma3nPreTrainedModel:()=>gg,GemmaForCausalLM:()=>eh,GemmaModel:()=>vy,GemmaPreTrainedModel:()=>db,GlmForCausalLM:()=>a_,GlmModel:()=>Sx,GlmPreTrainedModel:()=>Kg,GraniteForCausalLM:()=>B_,GraniteModel:()=>Xg,GranitePreTrainedModel:()=>o_,GroundingDinoForObjectDetection:()=>M2,GroundingDinoPreTrainedModel:()=>T2,GroupViTModel:()=>Ww,GroupViTPreTrainedModel:()=>bb,HeliumForCausalLM:()=>ob,HeliumModel:()=>Iw,HeliumPreTrainedModel:()=>Hg,HieraForImageClassification:()=>Qw,HieraModel:()=>By,HieraPreTrainedModel:()=>Sb,HubertForCTC:()=>Ip,HubertForSequenceClassification:()=>F2,HubertModel:()=>Ep,HubertPreTrainedModel:()=>Fx,IJepaForImageClassification:()=>Cx,IJepaModel:()=>Bw,IJepaPreTrainedModel:()=>zw,Idefics3ForConditionalGeneration:()=>Q1,Idefics3PreTrainedModel:()=>gy,ImageMattingOutput:()=>uv,JAISLMHeadModel:()=>b_,JAISModel:()=>ib,JAISPreTrainedModel:()=>Wg,JinaCLIPModel:()=>f1,JinaCLIPPreTrainedModel:()=>p1,JinaCLIPTextModel:()=>f_,JinaCLIPVisionModel:()=>h1,Lfm2ForCausalLM:()=>yy,Lfm2Model:()=>Tg,Lfm2PreTrainedModel:()=>hp,LiteWhisperForConditionalGeneration:()=>_y,LlamaForCausalLM:()=>Fo,LlamaModel:()=>Ai,LlamaPreTrainedModel:()=>bi,LlavaForConditionalGeneration:()=>Y1,LlavaOnevisionForConditionalGeneration:()=>X1,LlavaPreTrainedModel:()=>Q0,LlavaQwen2ForCausalLM:()=>jg,LongT5ForConditionalGeneration:()=>Mc,LongT5Model:()=>Lc,LongT5PreTrainedModel:()=>Cc,M2M100ForConditionalGeneration:()=>A2,M2M100Model:()=>I1,M2M100PreTrainedModel:()=>Jy,MBartForCausalLM:()=>pr,MBartForConditionalGeneration:()=>zt,MBartForSequenceClassification:()=>Sn,MBartModel:()=>ct,MBartPreTrainedModel:()=>Ve,MPNetForMaskedLM:()=>T_,MPNetForQuestionAnswering:()=>X,MPNetForSequenceClassification:()=>M_,MPNetForTokenClassification:()=>Lt,MPNetModel:()=>g_,MPNetPreTrainedModel:()=>Hc,MT5ForConditionalGeneration:()=>tp,MT5Model:()=>ep,MT5PreTrainedModel:()=>ip,MarianMTModel:()=>P2,MarianModel:()=>Lb,MarianPreTrainedModel:()=>O1,MaskFormerForInstanceSegmentation:()=>f2,MaskFormerModel:()=>p2,MaskFormerPreTrainedModel:()=>Wy,MaskedLMOutput:()=>Ap,Metric3DForDepthEstimation:()=>kb,Metric3DPreTrainedModel:()=>c2,Metric3Dv2ForDepthEstimation:()=>d2,Metric3Dv2PreTrainedModel:()=>m0,MgpstrForSceneTextRecognition:()=>D_,MgpstrModelOutput:()=>_w,MgpstrPreTrainedModel:()=>mw,MimiDecoderModel:()=>Vc,MimiDecoderOutput:()=>Ux,MimiEncoderModel:()=>$c,MimiEncoderOutput:()=>nx,MimiModel:()=>Vx,MimiPreTrainedModel:()=>R1,MistralForCausalLM:()=>aw,MistralModel:()=>G2,MistralPreTrainedModel:()=>Ub,MobileBertForMaskedLM:()=>m_,MobileBertForQuestionAnswering:()=>p_,MobileBertForSequenceClassification:()=>Op,MobileBertModel:()=>Ac,MobileBertPreTrainedModel:()=>Mi,MobileLLMForCausalLM:()=>xy,MobileLLMModel:()=>Yg,MobileLLMPreTrainedModel:()=>t0,MobileNetV1ForImageClassification:()=>Bx,MobileNetV1ForSemanticSegmentation:()=>Y2,MobileNetV1Model:()=>Sp,MobileNetV1PreTrainedModel:()=>Kb,MobileNetV2ForImageClassification:()=>r_,MobileNetV2ForSemanticSegmentation:()=>K_,MobileNetV2Model:()=>Kc,MobileNetV2PreTrainedModel:()=>Yb,MobileNetV3ForImageClassification:()=>jx,MobileNetV3ForSemanticSegmentation:()=>hw,MobileNetV3Model:()=>X2,MobileNetV3PreTrainedModel:()=>Xb,MobileNetV4ForImageClassification:()=>Q2,MobileNetV4ForSemanticSegmentation:()=>l_,MobileNetV4Model:()=>w_,MobileNetV4PreTrainedModel:()=>Eh,MobileViTForImageClassification:()=>Pg,MobileViTModel:()=>Sg,MobileViTPreTrainedModel:()=>yb,MobileViTV2ForImageClassification:()=>Cy,MobileViTV2Model:()=>Ay,MobileViTV2PreTrainedModel:()=>E1,ModelOutput:()=>Bt,ModernBertDecoderForCausalLM:()=>zc,ModernBertDecoderModel:()=>Si,ModernBertDecoderPreTrainedModel:()=>Ci,ModernBertForMaskedLM:()=>wi,ModernBertForSequenceClassification:()=>Lo,ModernBertForTokenClassification:()=>zi,ModernBertModel:()=>ui,ModernBertPreTrainedModel:()=>fi,Moondream1ForConditionalGeneration:()=>Bg,MoonshineForConditionalGeneration:()=>Y0,MoonshineModel:()=>K0,MoonshinePreTrainedModel:()=>H0,MptForCausalLM:()=>wp,MptModel:()=>Ax,MptPreTrainedModel:()=>Rw,MultiModalityCausalLM:()=>Dg,MultiModalityPreTrainedModel:()=>s1,MusicgenForCausalLM:()=>_p,MusicgenForConditionalGeneration:()=>Hb,MusicgenModel:()=>Og,MusicgenPreTrainedModel:()=>fw,NeoBertForMaskedLM:()=>xi,NeoBertForQuestionAnswering:()=>mi,NeoBertForSequenceClassification:()=>ir,NeoBertForTokenClassification:()=>ai,NeoBertModel:()=>vn,NeoBertPreTrainedModel:()=>ti,NomicBertModel:()=>up,NomicBertPreTrainedModel:()=>Xc,OPTForCausalLM:()=>u0,OPTModel:()=>l0,OPTPreTrainedModel:()=>hb,Olmo2ForCausalLM:()=>h_,Olmo2Model:()=>cb,Olmo2PreTrainedModel:()=>n0,OlmoForCausalLM:()=>w1,OlmoModel:()=>y1,OlmoPreTrainedModel:()=>ub,OpenELMForCausalLM:()=>r0,OpenELMModel:()=>$w,OpenELMPreTrainedModel:()=>My,OwlViTForObjectDetection:()=>Kw,OwlViTModel:()=>p0,OwlViTPreTrainedModel:()=>S1,Owlv2ForObjectDetection:()=>wb,Owlv2Model:()=>P1,Owlv2PreTrainedModel:()=>ky,PaliGemmaForConditionalGeneration:()=>eb,PaliGemmaPreTrainedModel:()=>J0,PatchTSMixerForPrediction:()=>J2,PatchTSMixerModel:()=>F1,PatchTSMixerPreTrainedModel:()=>$1,PatchTSTForPrediction:()=>E0,PatchTSTModel:()=>L1,PatchTSTPreTrainedModel:()=>gw,Phi3ForCausalLM:()=>zp,Phi3Model:()=>t1,Phi3PreTrainedModel:()=>a0,Phi3VForCausalLM:()=>c1,Phi3VPreTrainedModel:()=>u1,PhiForCausalLM:()=>i0,PhiModel:()=>Ey,PhiPreTrainedModel:()=>fb,PreTrainedModel:()=>ke,PretrainedMixin:()=>bu,PvtForImageClassification:()=>Uw,PvtModel:()=>gb,PvtPreTrainedModel:()=>mb,PyAnnoteForAudioFrameClassification:()=>$b,PyAnnoteModel:()=>xp,PyAnnotePreTrainedModel:()=>O_,QuestionAnsweringModelOutput:()=>Cp,Qwen2ForCausalLM:()=>s0,Qwen2Model:()=>Fw,Qwen2PreTrainedModel:()=>x1,Qwen2VLForConditionalGeneration:()=>U_,Qwen2VLPreTrainedModel:()=>Mg,Qwen3ForCausalLM:()=>j_,Qwen3Model:()=>e1,Qwen3PreTrainedModel:()=>pb,RFDetrForObjectDetection:()=>kx,RFDetrModel:()=>Xw,RFDetrObjectDetectionOutput:()=>Ny,RFDetrPreTrainedModel:()=>Fy,RTDetrForObjectDetection:()=>h0,RTDetrModel:()=>xb,RTDetrObjectDetectionOutput:()=>V_,RTDetrPreTrainedModel:()=>Ag,RTDetrV2ForObjectDetection:()=>Ly,RTDetrV2Model:()=>op,RTDetrV2ObjectDetectionOutput:()=>$y,RTDetrV2PreTrainedModel:()=>Yw,ResNetForImageClassification:()=>Jw,ResNetModel:()=>Zw,ResNetPreTrainedModel:()=>jy,RoFormerForMaskedLM:()=>$p,RoFormerForQuestionAnswering:()=>Wi,RoFormerForSequenceClassification:()=>rf,RoFormerForTokenClassification:()=>cp,RoFormerModel:()=>Mo,RoFormerPreTrainedModel:()=>Jo,RobertaForMaskedLM:()=>Bc,RobertaForQuestionAnswering:()=>ly,RobertaForSequenceClassification:()=>s_,RobertaForTokenClassification:()=>E_,RobertaModel:()=>Ho,RobertaPreTrainedModel:()=>An,SamImageSegmentationOutput:()=>Db,SamModel:()=>y0,SamPreTrainedModel:()=>k1,SapiensForDepthEstimation:()=>Ox,SapiensForNormalEstimation:()=>u2,SapiensForSemanticSegmentation:()=>l2,SapiensPreTrainedModel:()=>Ab,SegformerForImageClassification:()=>M0,SegformerForSemanticSegmentation:()=>I_,SegformerModel:()=>zx,SegformerPreTrainedModel:()=>Gb,Seq2SeqLMOutput:()=>Av,SequenceClassifierOutput:()=>No,SiglipModel:()=>d1,SiglipPreTrainedModel:()=>Vg,SiglipTextModel:()=>Gg,SiglipVisionModel:()=>Li,SmolLM3ForCausalLM:()=>wy,SmolLM3Model:()=>ab,SmolLM3PreTrainedModel:()=>e0,SmolVLMForConditionalGeneration:()=>l1,SnacDecoderModel:()=>$g,SnacEncoderModel:()=>np,SnacModel:()=>Y_,SnacPreTrainedModel:()=>S0,SpeechT5ForSpeechToText:()=>rw,SpeechT5ForTextToSpeech:()=>sw,SpeechT5HifiGan:()=>V2,SpeechT5Model:()=>U2,SpeechT5PreTrainedModel:()=>Bb,SqueezeBertForMaskedLM:()=>ft,SqueezeBertForQuestionAnswering:()=>sr,SqueezeBertForSequenceClassification:()=>kt,SqueezeBertModel:()=>at,SqueezeBertPreTrainedModel:()=>$e,StableLmForCausalLM:()=>K2,StableLmModel:()=>dw,StableLmPreTrainedModel:()=>cw,Starcoder2ForCausalLM:()=>q_,Starcoder2Model:()=>q2,Starcoder2PreTrainedModel:()=>W2,StyleTextToSpeech2Model:()=>j2,StyleTextToSpeech2PreTrainedModel:()=>B2,Swin2SRForImageSuperResolution:()=>s2,Swin2SRModel:()=>r2,Swin2SRPreTrainedModel:()=>n2,SwinForImageClassification:()=>Uy,SwinForSemanticSegmentation:()=>t2,SwinModel:()=>e2,SwinPreTrainedModel:()=>Pb,T5ForConditionalGeneration:()=>Uc,T5Model:()=>Tc,T5PreTrainedModel:()=>Hi,TableTransformerForObjectDetection:()=>_0,TableTransformerModel:()=>zy,TableTransformerObjectDetectionOutput:()=>Tb,TableTransformerPreTrainedModel:()=>lp,TokenClassifierOutput:()=>mp,TrOCRForCausalLM:()=>jb,TrOCRPreTrainedModel:()=>iw,UltravoxModel:()=>N1,UltravoxPreTrainedModel:()=>ex,UniSpeechForCTC:()=>r1,UniSpeechForSequenceClassification:()=>Nb,UniSpeechModel:()=>k2,UniSpeechPreTrainedModel:()=>Fb,UniSpeechSatForAudioFrameClassification:()=>D2,UniSpeechSatForCTC:()=>I2,UniSpeechSatForSequenceClassification:()=>Rb,UniSpeechSatModel:()=>O2,UniSpeechSatPreTrainedModel:()=>w0,ViTForImageClassification:()=>T1,ViTMAEModel:()=>Vw,ViTMAEPreTrainedModel:()=>c0,ViTMSNForImageClassification:()=>Gw,ViTMSNModel:()=>Sy,ViTMSNPreTrainedModel:()=>d0,ViTModel:()=>v1,ViTPreTrainedModel:()=>_b,VisionEncoderDecoderModel:()=>X0,VitMatteForImageMatting:()=>Py,VitMattePreTrainedModel:()=>Eg,VitPoseForPoseEstimation:()=>n1,VitPosePreTrainedModel:()=>jw,VitsModel:()=>H_,VitsModelOutput:()=>k0,VitsPreTrainedModel:()=>T0,VoxtralForConditionalGeneration:()=>tx,Wav2Vec2BertForCTC:()=>$2,Wav2Vec2BertForSequenceClassification:()=>$x,Wav2Vec2BertModel:()=>L2,Wav2Vec2BertPreTrainedModel:()=>x0,Wav2Vec2ForAudioFrameClassification:()=>kg,Wav2Vec2ForCTC:()=>Cg,Wav2Vec2ForSequenceClassification:()=>C2,Wav2Vec2Model:()=>k_,Wav2Vec2PreTrainedModel:()=>Mp,WavLMForAudioFrameClassification:()=>nw,WavLMForCTC:()=>R2,WavLMForSequenceClassification:()=>z2,WavLMForXVector:()=>zb,WavLMModel:()=>N2,WavLMPreTrainedModel:()=>D1,WeSpeakerResNetModel:()=>tw,WeSpeakerResNetPreTrainedModel:()=>ew,WhisperForConditionalGeneration:()=>q0,WhisperModel:()=>W0,WhisperPreTrainedModel:()=>K1,XLMForQuestionAnswering:()=>fy,XLMForSequenceClassification:()=>dy,XLMForTokenClassification:()=>py,XLMModel:()=>uy,XLMPreTrainedModel:()=>F_,XLMRobertaForMaskedLM:()=>U0,XLMRobertaForQuestionAnswering:()=>q1,XLMRobertaForSequenceClassification:()=>V0,XLMRobertaForTokenClassification:()=>hy,XLMRobertaModel:()=>j0,XLMRobertaPreTrainedModel:()=>J_,XLMWithLMHeadModel:()=>cy,XVectorOutput:()=>hx,YolosForObjectDetection:()=>S2,YolosModel:()=>E2,YolosObjectDetectionOutput:()=>Lx,YolosPreTrainedModel:()=>b0});var s=t("./src/configs.js"),a=t("./src/backends/onnx.js"),c=t("./src/utils/dtypes.js"),l=t("./src/utils/generic.js"),_=t("./src/utils/core.js"),m=t("./src/utils/hub.js"),d=t("./src/utils/constants.js"),h=t("./src/generation/logits_process.js"),i=t("./src/generation/configuration_utils.js"),r=t("./src/utils/tensor.js"),u=t("./src/utils/image.js"),f=t("./src/utils/maths.js"),g=t("./src/generation/stopping_criteria.js"),w=t("./src/generation/logits_sampler.js"),y=t("./src/env.js"),x=t("./src/models/whisper/generation_whisper.js"),S=t("./src/models/whisper/common_whisper.js");const T={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11,ImageAudioTextToText:12},E=new Map,A=new Map,C=new Map;async function I(B,j,ye){let _t=ye.config?.["transformers.js_config"]??{},fn=ye.device??_t.device;fn&&typeof fn!="string"&&(fn.hasOwnProperty(j)?fn=fn[j]:(console.warn(`device not specified for "${j}". Using the default device.`),fn=null));const xn=fn??(y.apis.IS_NODE_ENV?"cpu":"wasm"),ur=(0,a.deviceToExecutionProviders)(xn),oi=_t.device_config??{};oi.hasOwnProperty(xn)&&(_t={..._t,...oi[xn]});let _i=ye.dtype??_t.dtype;if(typeof _i!="string"&&(_i&&_i.hasOwnProperty(j)?_i=_i[j]:(_i=c.DEFAULT_DEVICE_DTYPE_MAPPING[xn]??c.DATA_TYPES.fp32,console.warn(`dtype not specified for "${j}". Using the default dtype (${_i}) for this device (${xn}).`))),_i===c.DATA_TYPES.auto){let qo=_t.dtype;typeof qo!="string"&&(qo=qo?.[j]),qo&&qo!==c.DATA_TYPES.auto&&c.DATA_TYPES.hasOwnProperty(qo)?_i=qo:_i=c.DEFAULT_DEVICE_DTYPE_MAPPING[xn]??c.DATA_TYPES.fp32}const Ei=_i;if(c.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(Ei)){if(Ei===c.DATA_TYPES.fp16&&xn==="webgpu"&&!await(0,c.isWebGpuFp16Supported)())throw new Error(`The device (${xn}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${Ei}. Should be one of: ${Object.keys(c.DATA_TYPES).join(", ")}`);const Ya=_t.kv_cache_dtype,Vo=Ya?typeof Ya=="string"?Ya:Ya[Ei]??"float32":void 0;if(Vo&&!["float32","float16"].includes(Vo))throw new Error(`Invalid kv_cache_dtype: ${Vo}. Should be one of: float32, float16`);const Wo={dtype:Ei,kv_cache_dtype:Vo,device:xn},Bi=c.DEFAULT_DTYPE_SUFFIX_MAPPING[Ei],Sc=`${j}${Bi}.onnx`,Gi=`${ye.subfolder??""}/${Sc}`,Ni={...ye.session_options};Ni.executionProviders??=ur;const Di=_t.free_dimension_overrides;Di?Ni.freeDimensionOverrides??=Di:xn.startsWith("webnn")&&!Ni.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${xn}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const Nc=y.apis.IS_NODE_ENV&&y.env.useFSCache,Qo=(0,m.getModelFile)(B,Gi,!0,ye,Nc),gp=ye.use_external_data_format??_t.use_external_data_format;let rp=[];if(gp){let qo;typeof gp=="object"?gp.hasOwnProperty(Sc)?qo=gp[Sc]:gp.hasOwnProperty(j)?qo=gp[j]:qo=!1:qo=gp;const Yc=+qo;if(Yc>m.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${Yc}) exceeds the maximum allowed value (${m.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let vp=0;vp<Yc;++vp){const Rg=`${Sc}_data${vp===0?"":"_"+vp}`,Bp=`${ye.subfolder??""}/${Rg}`;rp.push(new Promise(async(L_,G1)=>{const O0=await(0,m.getModelFile)(B,Bp,!0,ye,Nc);L_(O0 instanceof Uint8Array?{path:Rg,data:O0}:Rg)}))}}else Ni.externalData!==void 0&&(rp=Ni.externalData.map(async qo=>{if(typeof qo.data=="string"){const Yc=await(0,m.getModelFile)(B,qo.data,!0,ye);return{...qo,data:Yc}}return qo}));if(rp.length>0){const qo=await Promise.all(rp);y.apis.IS_NODE_ENV||(Ni.externalData=qo)}if(xn==="webgpu"){const qo=(0,s.getCacheShapes)(ye.config,{prefix:"present"});if(Object.keys(qo).length>0&&!(0,a.isONNXProxy)()){const Yc={};for(const vp in qo)Yc[vp]="gpu-buffer";Ni.preferredOutputLocation=Yc}}return{buffer_or_path:await Qo,session_options:Ni,session_config:Wo}}async function D(B,j,ye){return Object.fromEntries(await Promise.all(Object.keys(j).map(async _t=>{const{buffer_or_path:fn,session_options:xn,session_config:ur}=await I(B,j[_t],ye),oi=await(0,a.createInferenceSession)(fn,xn,ur);return[_t,oi]})))}async function R(B,j,ye){return Object.fromEntries(await Promise.all(Object.keys(j).map(async _t=>{const fn=await(0,m.getModelJSON)(B,j[_t],!1,ye);return[_t,fn]})))}function Y(B,j){const ye=Object.create(null),_t=[];for(const ur of B.inputNames){const oi=j[ur];if(!(oi instanceof r.Tensor)){_t.push(ur);continue}ye[ur]=(0,a.isONNXProxy)()?oi.clone():oi}if(_t.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${_t.join(", ")}.`);const fn=Object.keys(j).length,xn=B.inputNames.length;if(fn>xn){let ur=Object.keys(j).filter(oi=>!B.inputNames.includes(oi));console.warn(`WARNING: Too many inputs were provided (${fn} > ${xn}). The following inputs will be ignored: "${ur.join(", ")}".`)}return ye}let re=Promise.resolve();async function G(B,j){const ye=Y(B,j);try{const _t=Object.fromEntries(Object.entries(ye).map(([ur,oi])=>[ur,oi.ort_tensor])),fn=()=>B.run(_t),xn=await(y.apis.IS_BROWSER_ENV||y.apis.IS_WEBWORKER_ENV?re=re.then(fn):fn());return te(xn)}catch(_t){const fn=Object.fromEntries(Object.entries(ye).map(([xn,ur])=>{const oi={type:ur.type,dims:ur.dims,location:ur.location};return oi.location!=="gpu-buffer"&&(oi.data=ur.data),[xn,oi]}));throw console.error(`An error occurred during model execution: "${_t}".`),console.error("Inputs given to model:",fn),_t}}function te(B){for(let j in B)(0,a.isONNXTensor)(B[j])?B[j]=new r.Tensor(B[j]):typeof B[j]=="object"&&te(B[j]);return B}function q(B){if(B instanceof r.Tensor)return B;if(B.length===0)throw Error("items must be non-empty");if(Array.isArray(B[0])){if(B.some(j=>j.length!==B[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new r.Tensor("int64",BigInt64Array.from(B.flat().map(j=>BigInt(j))),[B.length,B[0].length])}else return new r.Tensor("int64",BigInt64Array.from(B.map(j=>BigInt(j))),[1,B.length])}function z(B){return new r.Tensor("bool",[B],[1])}async function H(B,j){let{encoder_outputs:ye,input_ids:_t,decoder_input_ids:fn,...xn}=j;if(!ye){const oi=(0,_.pick)(j,B.sessions.model.inputNames);ye=(await he(B,oi)).last_hidden_state}return xn.input_ids=fn,xn.encoder_hidden_states=ye,B.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(xn.encoder_attention_mask=j.attention_mask),await oe(B,xn,!0)}async function he(B,j){const ye=B.sessions.model,_t=(0,_.pick)(j,ye.inputNames);if(ye.inputNames.includes("inputs_embeds")&&!_t.inputs_embeds){if(!j.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");_t.inputs_embeds=await B.encode_text({input_ids:j.input_ids})}if(ye.inputNames.includes("token_type_ids")&&!_t.token_type_ids){if(!_t.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");_t.token_type_ids=(0,r.zeros_like)(_t.input_ids)}if(ye.inputNames.includes("pixel_mask")&&!_t.pixel_mask){if(!_t.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const fn=_t.pixel_values.dims;_t.pixel_mask=(0,r.ones)([fn[0],fn[2],fn[3]])}return await G(ye,_t)}async function Ce(B,j){const ye=await B.encode(j);return await B.decode(ye)}async function oe(B,j,ye=!1){const _t=B.sessions[ye?"decoder_model_merged":"model"],{past_key_values:fn,...xn}=j;if(_t.inputNames.includes("use_cache_branch")&&(xn.use_cache_branch=z(!!fn)),_t.inputNames.includes("position_ids")&&xn.attention_mask&&!xn.position_ids){const oi=["paligemma","gemma3_text","gemma3"].includes(B.config.model_type)?1:0;xn.position_ids=bn(xn,fn,oi)}B.addPastKeyValues(xn,fn);const ur=(0,_.pick)(xn,_t.inputNames);return await G(_t,ur)}function K({modality_token_id:B,inputs_embeds:j,modality_features:ye,input_ids:_t,attention_mask:fn}){const xn=_t.tolist().map(Ei=>Ei.reduce((Ya,Vo,Wo)=>(Vo==B&&Ya.push(Wo),Ya),[])),ur=xn.reduce((Ei,Ya)=>Ei+Ya.length,0),oi=ye.dims[0];if(ur!==oi)throw new Error(`Number of tokens and features do not match: tokens: ${ur}, features ${oi}`);let _i=0;for(let Ei=0;Ei<xn.length;++Ei){const Ya=xn[Ei],Vo=j[Ei];for(let Wo=0;Wo<Ya.length;++Wo)Vo[Ya[Wo]].data.set(ye[_i++].data)}return{inputs_embeds:j,attention_mask:fn}}function Q({image_token_id:B,inputs_embeds:j,image_features:ye,input_ids:_t,attention_mask:fn}){return K({modality_token_id:B,inputs_embeds:j,modality_features:ye,input_ids:_t,attention_mask:fn})}function de({audio_token_id:B,inputs_embeds:j,audio_features:ye,input_ids:_t,attention_mask:fn}){return K({modality_token_id:B,inputs_embeds:j,modality_features:ye,input_ids:_t,attention_mask:fn})}async function ue(B,{encode_function:j,merge_function:ye,modality_input_name:_t,modality_output_name:fn,input_ids:xn=null,attention_mask:ur=null,position_ids:oi=null,inputs_embeds:_i=null,past_key_values:Ei=null,generation_config:Ya=null,logits_processor:Vo=null,...Wo}){const Bi=Wo[_t];if(!_i){if(_i=await B.encode_text({input_ids:xn,...Wo}),Bi&&xn.dims[1]!==1){const Gi=await j({[_t]:Bi,...Wo});({inputs_embeds:_i,attention_mask:ur}=ye({[fn]:Gi,inputs_embeds:_i,input_ids:xn,attention_mask:ur}))}else if(Ei&&Bi&&xn.dims[1]===1){const Gi=xn.dims[1],Ni=Object.values(Ei)[0].dims.at(-2);ur=(0,r.cat)([(0,r.ones)([xn.dims[0],Ni]),ur.slice(null,[ur.dims[1]-Gi,ur.dims[1]])],1)}}if(!oi&&B.config.model_type==="qwen2_vl"){const{image_grid_thw:Gi,video_grid_thw:Ni}=Wo;[oi]=B.get_rope_index(xn,Gi,Ni,ur)}return await oe(B,{inputs_embeds:_i,past_key_values:Ei,attention_mask:ur,position_ids:oi,generation_config:Ya,logits_processor:Vo},!0)}async function Ze(B,j){return await ue(B,{...j,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:B.encode_audio.bind(B),merge_function:B._merge_input_ids_with_audio_features.bind(B)})}async function Pt(B,j){return await ue(B,{...j,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:B.encode_image.bind(B),merge_function:B._merge_input_ids_with_image_features.bind(B)})}function Gt(B,j=0){const[ye,_t]=B.dims,fn=B.data,xn=new BigInt64Array(fn.length);for(let ur=0;ur<ye;++ur){const oi=ur*_t;let _i=BigInt(j);for(let Ei=0;Ei<_t;++Ei){const Ya=oi+Ei;fn[Ya]===0n?xn[Ya]=BigInt(1):(xn[Ya]=_i,_i+=fn[Ya])}}return{data:xn,dims:B.dims}}function bn(B,j=null,ye=0){const{input_ids:_t,inputs_embeds:fn,attention_mask:xn}=B,{data:ur,dims:oi}=Gt(xn,ye);let _i=new r.Tensor("int64",ur,oi);if(j){const Ei=-(_t??fn).dims.at(1);_i=_i.slice(null,[Ei,null])}return _i}function ri(B,j,ye,_t){const fn=ye.past_key_values?Object.values(ye.past_key_values)[0].dims.at(-2):0;if(!ye.attention_mask){let xn;for(const ur of["input_ids","inputs_embeds","position_ids"])if(ye[ur]){xn=ye[ur].dims;break}if(!xn)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");ye.attention_mask=(0,r.ones)([xn[0],fn+xn[1]])}if(ye.past_key_values){const{input_ids:xn,attention_mask:ur}=ye;ur&&ur.dims[1]>xn.dims[1]||fn<xn.dims[1]&&(ye.input_ids=xn.slice(null,[fn,null]))}return ye}function hn(B,j,ye,_t){return ye.past_key_values&&(j=j.map(fn=>[fn.at(-1)])),{...ye,decoder_input_ids:q(j)}}function ze(B,...j){return B.config.is_encoder_decoder?hn(B,...j):ri(B,...j)}function wt(B,j,ye,_t){const fn=!!ye.past_key_values;return _t.guidance_scale!==null&&_t.guidance_scale>1&&(fn?ye.input_ids=(0,r.cat)([ye.input_ids,ye.input_ids],0):(ye.input_ids=(0,r.cat)([ye.input_ids,(0,r.full_like)(ye.input_ids,BigInt(_t.pad_token_id))],0),ye.attention_mask=(0,r.cat)([ye.attention_mask,(0,r.full_like)(ye.attention_mask,0n)],0))),(fn||!ye.pixel_values)&&(ye.pixel_values=(0,r.full)([0,0,3,384,384],1)),fn&&(ye.images_seq_mask=new r.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),ye.images_emb_mask=new r.Tensor("bool",new Array(0).fill(!1),[1,1,0])),ye}class ke extends l.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(j,ye,_t){super(),this.config=j,this.sessions=ye,this.configs=_t;const fn=C.get(this.constructor),xn=E.get(fn);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,xn){case T.DecoderOnly:this.can_generate=!0,this._forward=oe,this._prepare_inputs_for_generation=ri;break;case T.Seq2Seq:case T.Vision2Seq:case T.Musicgen:this.can_generate=!0,this._forward=H,this._prepare_inputs_for_generation=hn;break;case T.EncoderDecoder:this._forward=H;break;case T.ImageTextToText:this.can_generate=!0,this._forward=Pt,this._prepare_inputs_for_generation=ze;break;case T.AudioTextToText:this.can_generate=!0,this._forward=Ze,this._prepare_inputs_for_generation=ze;break;case T.Phi3V:case T.ImageAudioTextToText:this.can_generate=!0,this._prepare_inputs_for_generation=ze;break;case T.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=wt;break;case T.AutoEncoder:this._forward=Ce;break;default:this._forward=he;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const j=[];for(const ye of Object.values(this.sessions))ye?.handler?.dispose&&j.push(ye.handler.dispose());return await Promise.all(j)}static async from_pretrained(j,{progress_callback:ye=null,config:_t=null,cache_dir:fn=null,local_files_only:xn=!1,revision:ur="main",model_file_name:oi=null,subfolder:_i="onnx",device:Ei=null,dtype:Ya=null,use_external_data_format:Vo=null,session_options:Wo={}}={}){let Bi={progress_callback:ye,config:_t,cache_dir:fn,local_files_only:xn,revision:ur,model_file_name:oi,subfolder:_i,device:Ei,dtype:Ya,use_external_data_format:Vo,session_options:Wo};const Sc=C.get(this),Gi=E.get(Sc);_t=Bi.config=await s.AutoConfig.from_pretrained(j,Bi);let Ni;if(Gi===T.DecoderOnly)Ni=await Promise.all([D(j,{model:Bi.model_file_name??"model"},Bi),R(j,{generation_config:"generation_config.json"},Bi)]);else if(Gi===T.Seq2Seq||Gi===T.Vision2Seq)Ni=await Promise.all([D(j,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},Bi),R(j,{generation_config:"generation_config.json"},Bi)]);else if(Gi===T.MaskGeneration)Ni=await Promise.all([D(j,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},Bi)]);else if(Gi===T.EncoderDecoder)Ni=await Promise.all([D(j,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},Bi)]);else if(Gi===T.ImageTextToText){const Di={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};_t.is_encoder_decoder&&(Di.model="encoder_model"),Ni=await Promise.all([D(j,Di,Bi),R(j,{generation_config:"generation_config.json"},Bi)])}else if(Gi===T.AudioTextToText){const Di={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};Ni=await Promise.all([D(j,Di,Bi),R(j,{generation_config:"generation_config.json"},Bi)])}else if(Gi===T.ImageAudioTextToText){const Di={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Ni=await Promise.all([D(j,Di,Bi),R(j,{generation_config:"generation_config.json"},Bi)])}else if(Gi===T.Musicgen)Ni=await Promise.all([D(j,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},Bi),R(j,{generation_config:"generation_config.json"},Bi)]);else if(Gi===T.MultiModality)Ni=await Promise.all([D(j,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},Bi),R(j,{generation_config:"generation_config.json"},Bi)]);else if(Gi===T.Phi3V)Ni=await Promise.all([D(j,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},Bi),R(j,{generation_config:"generation_config.json"},Bi)]);else if(Gi===T.AutoEncoder)Ni=await Promise.all([D(j,{encoder_model:"encoder_model",decoder_model:"decoder_model"},Bi)]);else{if(Gi!==T.EncoderOnly){const Di=Sc??_t?.model_type;Di!=="custom"&&console.warn(`Model type for '${Di}' not found, assuming encoder-only architecture. Please report this at ${d.GITHUB_ISSUE_URL}.`)}Ni=await Promise.all([D(j,{model:Bi.model_file_name??"model"},Bi)])}return new this(_t,...Ni)}async _call(j){return await this.forward(j)}async forward(j){return await this._forward(this,j)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(j){const ye=new h.LogitsProcessorList;return j.temperature!==null&&j.temperature!==1&&ye.push(new h.TemperatureLogitsWarper(j.temperature)),j.top_k!==null&&j.top_k!==0&&ye.push(new h.TopKLogitsWarper(j.top_k)),j.top_p!==null&&j.top_p<1&&ye.push(new h.TopPLogitsWarper(j.top_p)),ye}_get_logits_processor(j,ye,_t=null){const fn=new h.LogitsProcessorList;if(j.repetition_penalty!==null&&j.repetition_penalty!==1&&fn.push(new h.RepetitionPenaltyLogitsProcessor(j.repetition_penalty)),j.no_repeat_ngram_size!==null&&j.no_repeat_ngram_size>0&&fn.push(new h.NoRepeatNGramLogitsProcessor(j.no_repeat_ngram_size)),j.bad_words_ids!==null&&fn.push(new h.NoBadWordsLogitsProcessor(j.bad_words_ids,j.eos_token_id)),j.min_length!==null&&j.eos_token_id!==null&&j.min_length>0&&fn.push(new h.MinLengthLogitsProcessor(j.min_length,j.eos_token_id)),j.min_new_tokens!==null&&j.eos_token_id!==null&&j.min_new_tokens>0&&fn.push(new h.MinNewTokensLengthLogitsProcessor(ye,j.min_new_tokens,j.eos_token_id)),j.forced_bos_token_id!==null&&fn.push(new h.ForcedBOSTokenLogitsProcessor(j.forced_bos_token_id)),j.forced_eos_token_id!==null&&fn.push(new h.ForcedEOSTokenLogitsProcessor(j.max_length,j.forced_eos_token_id)),j.begin_suppress_tokens!==null){const xn=ye>1||j.forced_bos_token_id===null?ye:ye+1;fn.push(new h.SuppressTokensAtBeginLogitsProcessor(j.begin_suppress_tokens,xn))}return j.guidance_scale!==null&&j.guidance_scale>1&&fn.push(new h.ClassifierFreeGuidanceLogitsProcessor(j.guidance_scale)),_t!==null&&fn.extend(_t),fn}_prepare_generation_config(j,ye,_t=i.GenerationConfig){const fn={...this.config};for(const ur of["decoder","generator","text_config"])ur in fn&&Object.assign(fn,fn[ur]);const xn=new _t(fn);return Object.assign(xn,this.generation_config??{}),j&&Object.assign(xn,j),ye&&Object.assign(xn,(0,_.pick)(ye,Object.getOwnPropertyNames(xn))),xn}_get_stopping_criteria(j,ye=null){const _t=new g.StoppingCriteriaList;return j.max_length!==null&&_t.push(new g.MaxLengthCriteria(j.max_length,this.config.max_position_embeddings??null)),j.eos_token_id!==null&&_t.push(new g.EosTokenCriteria(j.eos_token_id)),ye&&_t.extend(ye),_t}_validate_model_class(){if(!this.can_generate){const j=[Pp,ey,X_,e_],ye=C.get(this.constructor),_t=new Set,fn=this.config.model_type;for(const ur of j){const oi=ur.get(fn);oi&&_t.add(oi[0])}let xn=`The current model class (${ye}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw _t.size>0&&(xn+=` Please use the following class instead: ${[..._t].join(", ")}`),Error(xn)}}prepare_inputs_for_generation(...j){return this._prepare_inputs_for_generation(this,...j)}_update_model_kwargs_for_generation({generated_input_ids:j,outputs:ye,model_inputs:_t,is_encoder_decoder:fn}){return _t.past_key_values=this.getPastKeyValues(ye,_t.past_key_values),_t.input_ids=new r.Tensor("int64",j.flat(),[j.length,1]),fn||(_t.attention_mask=(0,r.cat)([_t.attention_mask,(0,r.ones)([_t.attention_mask.dims[0],1])],1)),_t.position_ids=null,_t}_prepare_model_inputs({inputs:j,bos_token_id:ye,model_kwargs:_t}){const fn=(0,_.pick)(_t,this.forward_params),xn=this.main_input_name;if(xn in fn){if(j)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else fn[xn]=j;return{inputs_tensor:fn[xn],model_inputs:fn,model_input_name:xn}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:j,model_inputs:ye,model_input_name:_t,generation_config:fn}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ye.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:ur,pixel_values:oi,attention_mask:_i,...Ei}=ye,Ya=await this._prepare_inputs_embeds(ye);ye={...Ei,...(0,_.pick)(Ya,["inputs_embeds","attention_mask"])}}let{last_hidden_state:xn}=await he(this,ye);if(fn.guidance_scale!==null&&fn.guidance_scale>1)xn=(0,r.cat)([xn,(0,r.full_like)(xn,0)],0),"attention_mask"in ye&&(ye.attention_mask=(0,r.cat)([ye.attention_mask,(0,r.zeros_like)(ye.attention_mask)],0));else if(ye.decoder_input_ids){const ur=q(ye.decoder_input_ids).dims[0];if(ur!==xn.dims[0]){if(xn.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${xn.dims[0]}) than the decoder inputs (${ur}).`);xn=(0,r.cat)(Array.from({length:ur},()=>xn),0)}}return ye.encoder_outputs=xn,ye}_prepare_decoder_input_ids_for_generation({batch_size:j,model_input_name:ye,model_kwargs:_t,decoder_start_token_id:fn,bos_token_id:xn,generation_config:ur}){let{decoder_input_ids:oi,..._i}=_t;if(!(oi instanceof r.Tensor)){if(oi)Array.isArray(oi[0])||(oi=Array.from({length:j},()=>oi));else if(fn??=xn,this.config.model_type==="musicgen")oi=Array.from({length:j*this.config.decoder.num_codebooks},()=>[fn]);else if(Array.isArray(fn)){if(fn.length!==j)throw new Error(`\`decoder_start_token_id\` expcted to have length ${j} but got ${fn.length}`);oi=fn}else oi=Array.from({length:j},()=>[fn]);oi=q(oi)}return _t.decoder_attention_mask=(0,r.ones_like)(oi),{input_ids:oi,model_inputs:_i}}async generate({inputs:j=null,generation_config:ye=null,logits_processor:_t=null,stopping_criteria:fn=null,streamer:xn=null,...ur}){this._validate_model_class(),ye=this._prepare_generation_config(ye,ur);let{inputs_tensor:oi,model_inputs:_i,model_input_name:Ei}=this._prepare_model_inputs({inputs:j,model_kwargs:ur});const Ya=this.config.is_encoder_decoder;Ya&&("encoder_outputs"in _i||(_i=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:oi,model_inputs:_i,model_input_name:Ei,generation_config:ye})));let Vo;Ya?{input_ids:Vo,model_inputs:_i}=this._prepare_decoder_input_ids_for_generation({batch_size:_i[Ei].dims.at(0),model_input_name:Ei,model_kwargs:_i,decoder_start_token_id:ye.decoder_start_token_id,bos_token_id:ye.bos_token_id,generation_config:ye}):Vo=_i[Ei];let Wo=Vo.dims.at(-1);ye.max_new_tokens!==null&&(ye.max_length=Wo+ye.max_new_tokens);const Bi=this._get_logits_processor(ye,Wo,_t),Sc=this._get_stopping_criteria(ye,fn),Gi=_i[Ei].dims.at(0),Ni=w.LogitsSampler.getSampler(ye),Di=new Array(Gi).fill(0),Nc=Vo.tolist();xn&&xn.put(Nc);let Qo,gp={};for(;;){if(_i=this.prepare_inputs_for_generation(Nc,_i,ye),Qo=await this.forward(_i),ye.output_attentions&&ye.return_dict_in_generate){const Bp=this.getAttentions(Qo);for(const L_ in Bp)L_ in gp||(gp[L_]=[]),gp[L_].push(Bp[L_])}const qo=Qo.logits.slice(null,-1,null),Yc=Bi(Nc,qo),vp=[];for(let Bp=0;Bp<Yc.dims.at(0);++Bp){const L_=Yc[Bp],G1=await Ni(L_);for(const[O0,sy]of G1){const iy=BigInt(O0);Di[Bp]+=sy,Nc[Bp].push(iy),vp.push([iy]);break}}if(xn&&xn.put(vp),Sc(Nc).every(Bp=>Bp))break;_i=this._update_model_kwargs_for_generation({generated_input_ids:vp,outputs:Qo,model_inputs:_i,is_encoder_decoder:Ya})}xn&&xn.end();const rp=this.getPastKeyValues(Qo,_i.past_key_values,!0),Jc=new r.Tensor("int64",Nc.flat(),[Nc.length,Nc[0].length]);if(ye.return_dict_in_generate)return{sequences:Jc,past_key_values:rp,...gp};for(const qo of Object.values(Qo))qo.location==="gpu-buffer"&&qo.dispose();return Jc}getPastKeyValues(j,ye,_t=!1){const fn=Object.create(null);for(const xn in j)if(xn.startsWith("present")){const ur=xn.replace("present_conv","past_conv").replace("present","past_key_values"),oi=xn.includes("encoder");if(oi&&ye?fn[ur]=ye[ur]:fn[ur]=j[xn],ye&&(!oi||_t)){const _i=ye[ur];_i.location==="gpu-buffer"&&_i.dispose()}}return fn}getAttentions(j){const ye={};for(const _t of["cross_attentions","encoder_attentions","decoder_attentions"])for(const fn in j)fn.startsWith(_t)&&(_t in ye||(ye[_t]=[]),ye[_t].push(j[fn]));return ye}addPastKeyValues(j,ye){if(ye)Object.assign(j,ye);else{const _t=this.sessions.decoder_model_merged??this.sessions.model,fn=(j[this.main_input_name]??j.attention_mask)?.dims?.[0]??1,xn=_t?.config?.kv_cache_dtype??"float32",ur=xn==="float16"?r.DataTypeMap.float16:r.DataTypeMap.float32,oi=(0,s.getCacheShapes)(this.config,{batch_size:fn});for(const _i in oi){const Ei=oi[_i].reduce((Ya,Vo)=>Ya*Vo,1);j[_i]=new r.Tensor(xn,new ur(Ei),oi[_i])}}}async encode_image({pixel_values:j}){return(await G(this.sessions.vision_encoder,{pixel_values:j})).image_features}async encode_text({input_ids:j}){return(await G(this.sessions.embed_tokens,{input_ids:j})).inputs_embeds}async encode_audio({audio_values:j}){return(await G(this.sessions.audio_encoder,{audio_values:j})).audio_features}}class Bt{}class In extends Bt{constructor({last_hidden_state:j,hidden_states:ye=null,attentions:_t=null}){super(),this.last_hidden_state=j,this.hidden_states=ye,this.attentions=_t}}class Tn extends ke{}class cn extends Tn{}class kn extends Tn{async _call(j){return new Ap(await super._call(j))}}class yn extends Tn{async _call(j){return new No(await super._call(j))}}class $n extends Tn{async _call(j){return new mp(await super._call(j))}}class cr extends Tn{async _call(j){return new Cp(await super._call(j))}}class ti extends ke{}class vn extends ti{}class xi extends ti{async _call(j){return new Ap(await super._call(j))}}class ir extends ti{async _call(j){return new No(await super._call(j))}}class ai extends ti{async _call(j){return new mp(await super._call(j))}}class mi extends ti{async _call(j){return new Cp(await super._call(j))}}class fi extends ke{}class ui extends fi{}class wi extends fi{async _call(j){return new Ap(await super._call(j))}}class Lo extends fi{async _call(j){return new No(await super._call(j))}}class zi extends fi{async _call(j){return new mp(await super._call(j))}}class Ci extends ke{}class Si extends Ci{}class zc extends Ci{}class Xc extends ke{}class up extends Xc{}class Jo extends ke{}class Mo extends Jo{}class $p extends Jo{async _call(j){return new Ap(await super._call(j))}}class rf extends Jo{async _call(j){return new No(await super._call(j))}}class cp extends Jo{async _call(j){return new mp(await super._call(j))}}class Wi extends Jo{async _call(j){return new Cp(await super._call(j))}}class si extends ke{}class Ri extends si{}class _c extends si{async _call(j){return new Ap(await super._call(j))}}class Ui extends si{async _call(j){return new No(await super._call(j))}}class Rp extends si{async _call(j){return new mp(await super._call(j))}}class W extends si{async _call(j){return new Cp(await super._call(j))}}class Qe extends ke{}class ve extends Qe{}class Ke extends Qe{async _call(j){return new Ap(await super._call(j))}}class lt extends Qe{async _call(j){return new No(await super._call(j))}}class _n extends Qe{async _call(j){return new mp(await super._call(j))}}class ar extends Qe{async _call(j){return new Cp(await super._call(j))}}class vi extends ke{}class Pi extends vi{}class hi extends vi{async _call(j){return new Ap(await super._call(j))}}class Oo extends vi{async _call(j){return new No(await super._call(j))}}class we extends vi{async _call(j){return new mp(await super._call(j))}}class it extends vi{async _call(j){return new Cp(await super._call(j))}}class pt extends ke{}class Ot extends pt{}class Ht extends pt{async _call(j){return new Ap(await super._call(j))}}class mn extends pt{async _call(j){return new No(await super._call(j))}}class ii extends pt{async _call(j){return new mp(await super._call(j))}}class Ti extends pt{async _call(j){return new Cp(await super._call(j))}}class pi extends ke{}class Do extends pi{}class Ko extends pi{async _call(j){return new Ap(await super._call(j))}}class yc extends pi{async _call(j){return new No(await super._call(j))}}class Dc extends pi{async _call(j){return new mp(await super._call(j))}}class En extends pi{async _call(j){return new Cp(await super._call(j))}}class Oi extends ke{}class Ro extends Oi{}class bc extends Oi{async _call(j){return new No(await super._call(j))}}class Oc extends Oi{async _call(j){return new mp(await super._call(j))}}class dp extends Oi{async _call(j){return new Cp(await super._call(j))}}class Jf extends Oi{async _call(j){return new Ap(await super._call(j))}}class kp extends ke{}class Qc extends kp{}class sp extends kp{async _call(j){return new Ap(await super._call(j))}}class mr extends kp{async _call(j){return new No(await super._call(j))}}class ci extends kp{async _call(j){return new mp(await super._call(j))}}class Mi extends ke{}class Ac extends Mi{}class m_ extends Mi{async _call(j){return new Ap(await super._call(j))}}class Op extends Mi{async _call(j){return new No(await super._call(j))}}class p_ extends Mi{async _call(j){return new Cp(await super._call(j))}}class Hc extends ke{}class g_ extends Hc{}class T_ extends Hc{async _call(j){return new Ap(await super._call(j))}}class M_ extends Hc{async _call(j){return new No(await super._call(j))}}class Lt extends Hc{async _call(j){return new mp(await super._call(j))}}class X extends Hc{async _call(j){return new Cp(await super._call(j))}}class $e extends ke{}class at extends $e{}class ft extends $e{async _call(j){return new Ap(await super._call(j))}}class kt extends $e{async _call(j){return new No(await super._call(j))}}class sr extends $e{async _call(j){return new Cp(await super._call(j))}}class or extends ke{}class lr extends or{}class yi extends or{async _call(j){return new No(await super._call(j))}}class di extends or{async _call(j){return new Cp(await super._call(j))}}class zo extends or{async _call(j){return new Ap(await super._call(j))}}class Hi extends ke{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Tc extends Hi{}class Uc extends Hi{}class Cc extends ke{}class Lc extends Cc{}class Mc extends Cc{}class ip extends ke{}class ep extends ip{}class tp extends ip{}class yp extends ke{}class wc extends yp{}class Z extends yp{}class xe extends yp{async _call(j){return new No(await super._call(j))}}class Ve extends ke{}class ct extends Ve{}class zt extends Ve{}class Sn extends Ve{async _call(j){return new No(await super._call(j))}}class pr extends Ve{}class gi extends ke{}class Ii extends gi{}class ki extends gi{}class Zo extends ke{}class pp extends Zo{}class fp extends Zo{}class An extends ke{}class Ho extends An{}class Bc extends An{async _call(j){return new Ap(await super._call(j))}}class s_ extends An{async _call(j){return new No(await super._call(j))}}class E_ extends An{async _call(j){return new mp(await super._call(j))}}class ly extends An{async _call(j){return new Cp(await super._call(j))}}class F_ extends ke{}class uy extends F_{}class cy extends F_{async _call(j){return new Ap(await super._call(j))}}class dy extends F_{async _call(j){return new No(await super._call(j))}}class py extends F_{async _call(j){return new mp(await super._call(j))}}class fy extends F_{async _call(j){return new Cp(await super._call(j))}}class J_ extends ke{}class j0 extends J_{}class U0 extends J_{async _call(j){return new Ap(await super._call(j))}}class V0 extends J_{async _call(j){return new No(await super._call(j))}}class hy extends J_{async _call(j){return new mp(await super._call(j))}}class q1 extends J_{async _call(j){return new Cp(await super._call(j))}}class H1 extends ke{}class G0 extends H1{}class zg extends H1{}class K1 extends ke{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class W0 extends K1{}class q0 extends K1{_prepare_generation_config(j,ye){return super._prepare_generation_config(j,ye,x.WhisperGenerationConfig)}_retrieve_init_tokens(j){const ye=[j.decoder_start_token_id];let _t=j.language;const fn=j.task;if(j.is_multilingual){_t||(console.warn("No language specified - defaulting to English (en)."),_t="en");const ur=`<|${(0,S.whisper_language_to_code)(_t)}|>`;ye.push(j.lang_to_id[ur]),ye.push(j.task_to_id[fn??"transcribe"])}else if(_t||fn)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!j.return_timestamps&&j.no_timestamps_token_id&&ye.at(-1)!==j.no_timestamps_token_id?ye.push(j.no_timestamps_token_id):j.return_timestamps&&ye.at(-1)===j.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),ye.pop()),ye.filter(xn=>xn!=null)}async generate({inputs:j=null,generation_config:ye=null,logits_processor:_t=null,stopping_criteria:fn=null,...xn}){ye=this._prepare_generation_config(ye,xn);const ur=xn.decoder_input_ids??this._retrieve_init_tokens(ye);if(ye.return_timestamps&&(_t??=new h.LogitsProcessorList,_t.push(new h.WhisperTimeStampLogitsProcessor(ye,ur))),ye.begin_suppress_tokens&&(_t??=new h.LogitsProcessorList,_t.push(new h.SuppressTokensAtBeginLogitsProcessor(ye.begin_suppress_tokens,ur.length))),ye.return_token_timestamps){if(!ye.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");ye.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),ye.output_attentions=!0,ye.return_dict_in_generate=!0}const oi=await super.generate({inputs:j,generation_config:ye,logits_processor:_t,decoder_input_ids:ur,...xn});return ye.return_token_timestamps&&(oi.token_timestamps=this._extract_token_timestamps(oi,ye.alignment_heads,ye.num_frames)),oi}_extract_token_timestamps(j,ye,_t=null,fn=.02){if(!j.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");_t==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let xn=this.config.median_filter_width;xn===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),xn=7);const ur=j.cross_attentions,oi=Array.from({length:this.config.decoder_layers},(Gi,Ni)=>(0,r.cat)(ur.map(Di=>Di[Ni]),2)),_i=(0,r.stack)(ye.map(([Gi,Ni])=>{if(Gi>=oi.length)throw new Error(`Layer index ${Gi} is out of bounds for cross attentions (length ${oi.length}).`);return _t?oi[Gi].slice(null,Ni,null,[0,_t]):oi[Gi].slice(null,Ni)})).transpose(1,0,2,3),[Ei,Ya]=(0,r.std_mean)(_i,-2,0,!0),Vo=_i.clone();for(let Gi=0;Gi<Vo.dims[0];++Gi){const Ni=Vo[Gi];for(let Di=0;Di<Ni.dims[0];++Di){const Nc=Ni[Di],Qo=Ei[Gi][Di][0].data,gp=Ya[Gi][Di][0].data;for(let rp=0;rp<Nc.dims[0];++rp){let Jc=Nc[rp].data;for(let qo=0;qo<Jc.length;++qo)Jc[qo]=(Jc[qo]-gp[qo])/Qo[qo];Jc.set((0,f.medianFilter)(Jc,xn))}}}const Wo=[(0,r.mean)(Vo,1)],Bi=j.sequences.dims,Sc=new r.Tensor("float32",new Float32Array(Bi[0]*Bi[1]),Bi);for(let Gi=0;Gi<Bi[0];++Gi){const Ni=Wo[Gi].neg().squeeze_(0),[Di,Nc]=(0,f.dynamic_time_warping)(Ni.tolist()),Qo=Array.from({length:Di.length-1},(Jc,qo)=>Di[qo+1]-Di[qo]),gp=(0,_.mergeArrays)([1],Qo).map(Jc=>!!Jc),rp=[];for(let Jc=0;Jc<gp.length;++Jc)gp[Jc]&&rp.push(Nc[Jc]*fn);Sc[Gi].data.set(rp,1)}return Sc}}class _y extends q0{}class H0 extends ke{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class K0 extends H0{}class Y0 extends H0{}class X0 extends ke{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class Q0 extends ke{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Y1 extends Q0{_merge_input_ids_with_image_features(j){const ye=j.image_features.dims.at(-1),_t=j.image_features.view(-1,ye);return Q({image_token_id:this.config.image_token_index,...j,image_features:_t})}}class X1 extends Y1{}class Bg extends Y1{}class my extends ke{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class Z0 extends my{_merge_input_ids_with_image_features({inputs_embeds:j,image_features:ye,input_ids:_t,attention_mask:fn}){return{inputs_embeds:(0,r.cat)([ye,j],1),attention_mask:(0,r.cat)([(0,r.ones)(ye.dims.slice(0,2)),fn],1)}}async _prepare_inputs_embeds({input_ids:j,pixel_values:ye,inputs_embeds:_t,attention_mask:fn}){if(!j&&!ye)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let xn,ur;return j&&(xn=await this.encode_text({input_ids:j})),ye&&(ur=await this.encode_image({pixel_values:ye})),xn&&ur?{inputs_embeds:_t,attention_mask:fn}=this._merge_input_ids_with_image_features({inputs_embeds:xn,image_features:ur,input_ids:j,attention_mask:fn}):_t=xn||ur,{inputs_embeds:_t,attention_mask:fn}}async forward({input_ids:j,pixel_values:ye,attention_mask:_t,decoder_input_ids:fn,decoder_attention_mask:xn,encoder_outputs:ur,past_key_values:oi,inputs_embeds:_i,decoder_inputs_embeds:Ei}){if(_i||({inputs_embeds:_i,attention_mask:_t}=await this._prepare_inputs_embeds({input_ids:j,pixel_values:ye,inputs_embeds:_i,attention_mask:_t})),!ur){let{last_hidden_state:Wo}=await he(this,{inputs_embeds:_i,attention_mask:_t});ur=Wo}if(!Ei){if(!fn)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");Ei=await this.encode_text({input_ids:fn})}return await oe(this,{inputs_embeds:Ei,attention_mask:xn,encoder_attention_mask:_t,encoder_hidden_states:ur,past_key_values:oi},!0)}}class J0 extends ke{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class eb extends J0{_merge_input_ids_with_image_features(j){const ye=j.image_features.dims.at(-1),_t=j.image_features.view(-1,ye);return Q({image_token_id:this.config.image_token_index,...j,image_features:_t})}}class jg extends Q0{_merge_input_ids_with_image_features(j){const ye=j.image_features.dims.at(-1),_t=j.image_features.view(-1,ye);return Q({image_token_id:this.config.image_token_index,...j,image_features:_t})}}class gg extends ke{forward_params=["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"]}class S_ extends gg{async forward({input_ids:j=null,attention_mask:ye=null,pixel_values:_t=null,input_features:fn=null,input_features_mask:xn=null,position_ids:ur=null,inputs_embeds:oi=null,per_layer_inputs:_i=null,past_key_values:Ei=null,generation_config:Ya=null,logits_processor:Vo=null,...Wo}){if((!oi||!_i)&&({inputs_embeds:oi,per_layer_inputs:_i}=await G(this.sessions.embed_tokens,{input_ids:j}),j.dims[1]!==1)){if(_t){const{image_features:Sc}=await G(this.sessions.vision_encoder,{pixel_values:_t});({inputs_embeds:oi,attention_mask:ye}=this._merge_input_ids_with_image_features({image_features:Sc,inputs_embeds:oi,input_ids:j,attention_mask:ye}))}if(fn){const{audio_features:Sc}=await G(this.sessions.audio_encoder,{input_features:fn,input_features_mask:xn});({inputs_embeds:oi,attention_mask:ye}=this._merge_input_ids_with_audio_features({audio_features:Sc,inputs_embeds:oi,input_ids:j,attention_mask:ye}))}}return await oe(this,{inputs_embeds:oi,per_layer_inputs:_i,past_key_values:Ei,attention_mask:ye,position_ids:ur,generation_config:Ya,logits_processor:Vo},!0)}_merge_input_ids_with_image_features(j){const ye=j.image_features.dims.at(-1),_t=j.image_features.view(-1,ye);return Q({image_token_id:this.config.image_token_id,...j,image_features:_t})}_merge_input_ids_with_audio_features(j){const ye=j.audio_features.dims.at(-1),_t=j.audio_features.view(-1,ye);return de({audio_token_id:this.config.audio_token_id,...j,audio_features:_t})}}class gy extends ke{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class Q1 extends gy{async encode_image({pixel_values:j,pixel_attention_mask:ye}){return(await G(this.sessions.vision_encoder,{pixel_values:j,pixel_attention_mask:ye})).image_features}_merge_input_ids_with_image_features(j){const ye=j.image_features.dims.at(-1),_t=j.image_features.view(-1,ye);return Q({image_token_id:this.config.image_token_id,...j,image_features:_t})}}class l1 extends Q1{}class u1 extends ke{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class c1 extends u1{async forward({input_ids:j=null,attention_mask:ye=null,pixel_values:_t=null,image_sizes:fn=null,position_ids:xn=null,inputs_embeds:ur=null,past_key_values:oi=null,generation_config:_i=null,logits_processor:Ei=null,...Ya}){if(!ur){let Wo;if(_t&&j.dims[1]!==1){if(!fn)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:Wo}=await G(this.sessions.vision_encoder,{pixel_values:_t,image_sizes:fn}))}else{const Bi=this.config.normalized_config.hidden_size;Wo=new r.Tensor("float32",[],[0,Bi])}({inputs_embeds:ur}=await G(this.sessions.prepare_inputs_embeds,{input_ids:j,image_features:Wo}))}return await oe(this,{inputs_embeds:ur,past_key_values:oi,attention_mask:ye,position_ids:xn,generation_config:_i,logits_processor:Ei},!1)}}class i_ extends ke{}class wg extends i_{}class by extends i_{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"text_model"})}}class Ug extends i_{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"text_model"})}}class tb extends i_{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"vision_model"})}}class nb extends i_{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"vision_model"})}}class Vg extends ke{}class d1 extends Vg{}class Gg extends Vg{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"text_model"})}}class Li extends i_{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"vision_model"})}}class rb extends ke{}class sb extends rb{}class p1 extends ke{}class f1 extends p1{async forward(j){const ye=!j.input_ids,_t=!j.pixel_values;if(ye&&_t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(ye&&(j.input_ids=(0,r.ones)([j.pixel_values.dims[0],1])),_t){const{image_size:Ei}=this.config.vision_config;j.pixel_values=(0,r.full)([0,3,Ei,Ei],0)}const{text_embeddings:fn,image_embeddings:xn,l2norm_text_embeddings:ur,l2norm_image_embeddings:oi}=await super.forward(j),_i={};return ye||(_i.text_embeddings=fn,_i.l2norm_text_embeddings=ur),_t||(_i.image_embeddings=xn,_i.l2norm_image_embeddings=oi),_i}}class f_ extends p1{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"text_model"})}}class h1 extends p1{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"vision_model"})}}class Tp extends ke{}class xg extends Tp{}class Z1 extends Tp{}class _1 extends ke{}class m1 extends _1{}class J1 extends _1{}class Wg extends ke{}class ib extends Wg{}class b_ extends Wg{}class vg extends ke{}class N_ extends vg{}class g1 extends vg{}class b1 extends ke{}class P_ extends b1{}class R_ extends b1{}class qg extends ke{}class L extends qg{}class V extends qg{}class le extends ke{}class _e extends le{}class De extends le{}class mt extends ke{}class nr extends mt{}class li extends mt{}class bi extends ke{}class Ai extends bi{}class Fo extends bi{}class jo extends ke{}class Ec extends jo{}class Ic extends jo{}class hp extends ke{}class Tg extends hp{}class yy extends hp{}class e0 extends ke{}class ab extends e0{}class wy extends e0{}class Hg extends ke{}class Iw extends Hg{}class ob extends Hg{}class Kg extends ke{}class Sx extends Kg{}class a_ extends Kg{}class lb extends ke{}class z_ extends lb{}class Dw extends lb{}class t0 extends ke{}class Yg extends t0{}class xy extends t0{}class ub extends ke{}class y1 extends ub{}class w1 extends ub{}class n0 extends ke{}class cb extends n0{}class h_ extends n0{}class o_ extends ke{}class Xg extends o_{}class B_ extends o_{}class A_ extends ke{}class Qg extends A_{}class Lw extends A_{}class db extends ke{}class vy extends db{}class eh extends db{}class Zc extends ke{}class kc extends Zc{}class Zg extends Zc{}class y_ extends ke{}class Ty extends y_{}class Jg extends y_{}class My extends ke{}class $w extends My{}class r0 extends My{}class x1 extends ke{}class Fw extends x1{}class s0 extends x1{}class pb extends ke{}class e1 extends pb{}class j_ extends pb{}class Mg extends ke{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class U_ extends Mg{get_rope_index(j,ye,_t,fn){const{vision_config:xn,image_token_id:ur,video_token_id:oi,vision_start_token_id:_i}=this.config,Ei=xn.spatial_merge_size??2,Ya=[];if(ye||_t){let Vo=j.tolist();fn||(fn=(0,r.ones_like)(j));const Wo=fn.tolist(),Bi=Array.from({length:3},Nc=>Array.from({length:j.dims[0]},Qo=>Array.from({length:j.dims[1]},gp=>1))),Sc=ye?ye.tolist():[],Gi=_t?_t.tolist():[];let Ni=0,Di=0;for(let Nc=0;Nc<Vo.length;++Nc){const Qo=Vo[Nc].filter((Pc,bp)=>Wo[Nc][bp]==1),rp=Qo.reduce((Pc,bp,Z_)=>(bp==_i&&Pc.push(Z_),Pc),[]).map(Pc=>Qo[Pc+1]),Jc=rp.filter(Pc=>Pc==ur).length,qo=rp.filter(Pc=>Pc==oi).length;let Yc=[],vp=0,Rg=Jc,Bp=qo;for(let Pc=0;Pc<rp.length;++Pc){const bp=Qo.findIndex((o1,$_)=>$_>vp&&o1==ur),Z_=Qo.findIndex((o1,$_)=>$_>vp&&o1==oi),W1=Rg>0&&bp!==-1?bp:Qo.length+1,I0=Bp>0&&Z_!==-1?Z_:Qo.length+1;let D0,_x,__,ay;W1<I0?([_x,__,ay]=Sc[Ni],++Ni,--Rg,D0=W1):([_x,__,ay]=Gi[Di],++Di,--Bp,D0=I0);const[cv,Cw,a1]=[Number(_x),Math.floor(Number(__)/Ei),Math.floor(Number(ay)/Ei)],d_=D0-vp,mx=Yc.length>0?(0,f.max)(Yc.at(-1))[0]+1:0;Yc.push(Array.from({length:3*d_},(o1,$_)=>mx+$_%d_));const L0=d_+mx,v_=cv*Cw*a1,Ov=Array.from({length:v_},(o1,$_)=>L0+Math.floor($_/(Cw*a1))),Iv=Array.from({length:v_},(o1,$_)=>L0+Math.floor($_/a1)%Cw),$0=Array.from({length:v_},(o1,$_)=>L0+$_%a1);Yc.push([Ov,Iv,$0].flat()),vp=D0+v_}if(vp<Qo.length){const Pc=Yc.length>0?(0,f.max)(Yc.at(-1))[0]+1:0,bp=Qo.length-vp;Yc.push(Array.from({length:3*bp},(Z_,W1)=>Pc+W1%bp))}const L_=Yc.reduce((Pc,bp)=>Pc+bp.length,0),G1=new Array(L_);let O0=0;for(let Pc=0;Pc<3;++Pc)for(let bp=0;bp<Yc.length;++bp){const Z_=Yc[bp],W1=Z_.length/3;for(let I0=Pc*W1;I0<(Pc+1)*W1;++I0)G1[O0++]=Z_[I0]}let sy=0;const iy=Wo[Nc];for(let Pc=0;Pc<iy.length;++Pc)if(iy[Pc]==1){for(let bp=0;bp<3;++bp)Bi[bp][Nc][Pc]=G1[bp*L_/3+sy];++sy}const kv=(0,f.max)(G1)[0];Ya.push(kv+1-Vo[Nc].length)}return[new r.Tensor("int64",Bi.flat(1/0),[3,j.dims[0],j.dims[1]]),new r.Tensor("int64",Ya,[Ya.length,1])]}else if(fn){const{data:Vo,dims:Wo}=Gt(fn),Bi=BigInt64Array.from({length:3*Vo.length},(Gi,Ni)=>Vo[Ni%Vo.length]),Sc=Array.from({length:Wo[0]},(Gi,Ni)=>(0,f.max)(Vo.subarray(Wo[1]*Ni,Wo[1]*(Ni+1)))[0]+1n+BigInt(Wo[1]));return[new r.Tensor("int64",Bi,[3,...Wo]),new r.Tensor("int64",Sc,[Sc.length,1])]}else{const[Vo,Wo]=j.dims,Bi=BigInt64Array.from({length:3*Vo*Wo},(Sc,Gi)=>BigInt(Math.floor(Gi%Wo/Vo)));return[new r.Tensor("int64",Bi,[3,...j.dims]),(0,r.zeros)([Vo,1])]}}async encode_image({pixel_values:j,image_grid_thw:ye}){return(await G(this.sessions.vision_encoder,{pixel_values:j,grid_thw:ye})).image_features}_merge_input_ids_with_image_features(j){return Q({image_token_id:this.config.image_token_id,...j})}prepare_inputs_for_generation(j,ye,_t){if(ye.attention_mask&&!ye.position_ids)if(!ye.past_key_values)[ye.position_ids,ye.rope_deltas]=this.get_rope_index(ye.input_ids,ye.image_grid_thw,ye.video_grid_thw,ye.attention_mask);else{ye.pixel_values=null;const fn=BigInt(Object.values(ye.past_key_values)[0].dims.at(-2)),xn=ye.rope_deltas.map(ur=>fn+ur);ye.position_ids=(0,r.stack)([xn,xn,xn],0)}return ye}}class fb extends ke{}class Ey extends fb{}class i0 extends fb{}class a0 extends ke{}class t1 extends a0{}class zp extends a0{}class o0 extends ke{}class Nw extends o0{}class Px extends o0{}class Rw extends ke{}class Ax extends Rw{}class wp extends Rw{}class hb extends ke{}class l0 extends hb{}class u0 extends hb{}class _b extends ke{}class v1 extends _b{}class T1 extends _b{async _call(j){return new No(await super._call(j))}}class zw extends ke{}class Bw extends zw{}class Cx extends zw{async _call(j){return new No(await super._call(j))}}class jw extends ke{}class n1 extends jw{}class mb extends ke{}class gb extends mb{}class Uw extends mb{async _call(j){return new No(await super._call(j))}}class c0 extends ke{}class Vw extends c0{}class d0 extends ke{}class Sy extends d0{}class Gw extends d0{async _call(j){return new No(await super._call(j))}}class bb extends ke{}class Ww extends bb{}class M1 extends ke{}class qw extends M1{}class Hw extends M1{async _call(j){return new No(await super._call(j))}}class Eg extends ke{}class Py extends Eg{async _call(j){return new uv(await super._call(j))}}class yb extends ke{}class Sg extends yb{}class Pg extends yb{async _call(j){return new No(await super._call(j))}}class E1 extends ke{}class Ay extends E1{}class Cy extends E1{async _call(j){return new No(await super._call(j))}}class S1 extends ke{}class p0 extends S1{}class Kw extends S1{}class ky extends ke{}class P1 extends ky{}class wb extends ky{}class Oy extends ke{}class Iy extends Oy{}class Dy extends Oy{async _call(j){return new No(await super._call(j))}}class C_ extends ke{}class Yo extends C_{}class jc extends C_{async _call(j){return new f0(await super._call(j))}}class ap extends C_{async _call(j){return new A1(await super._call(j))}}class f0 extends Bt{constructor({logits:j,pred_boxes:ye}){super(),this.logits=j,this.pred_boxes=ye}}class A1 extends Bt{constructor({logits:j,pred_boxes:ye,pred_masks:_t}){super(),this.logits=j,this.pred_boxes=ye,this.pred_masks=_t}}class Ag extends ke{}class xb extends Ag{}class h0 extends Ag{async _call(j){return new V_(await super._call(j))}}class V_ extends Bt{constructor({logits:j,pred_boxes:ye}){super(),this.logits=j,this.pred_boxes=ye}}class Yw extends ke{}class op extends Yw{}class Ly extends Yw{async _call(j){return new $y(await super._call(j))}}class $y extends V_{}class Fy extends ke{}class Xw extends Fy{}class kx extends Fy{async _call(j){return new Ny(await super._call(j))}}class Ny extends V_{}class vb extends ke{}class Ry extends vb{}class n_ extends vb{async _call(j){return new V_(await super._call(j))}}class lp extends ke{}class zy extends lp{}class _0 extends lp{async _call(j){return new Tb(await super._call(j))}}class Tb extends f0{}class Mb extends ke{}class G_ extends Mb{}class Eb extends Mb{async _call(j){return new No(await super._call(j))}}class Sb extends ke{}class By extends Sb{}class Qw extends Sb{async _call(j){return new No(await super._call(j))}}class jy extends ke{}class Zw extends jy{}class Jw extends jy{async _call(j){return new No(await super._call(j))}}class Pb extends ke{}class e2 extends Pb{}class Uy extends Pb{async _call(j){return new No(await super._call(j))}}class t2 extends Pb{}class n2 extends ke{}class r2 extends n2{}class s2 extends n2{}class Vy extends ke{}class Gy extends Vy{}class i2 extends Vy{}class a2 extends ke{}class o2 extends a2{}class Ab extends ke{}class l2 extends Ab{}class Ox extends Ab{}class u2 extends Ab{}class C1 extends ke{}class Cb extends C1{}class c2 extends ke{}class kb extends c2{}class m0 extends ke{}class d2 extends m0{}class Wy extends ke{}class p2 extends Wy{}class f2 extends Wy{}class qy extends ke{}class h2 extends qy{}class Hy extends qy{}class _2 extends ke{}class m2 extends _2{}class Ob extends ke{}class g2 extends Ob{}class b2 extends Ob{async _call(j){return new No(await super._call(j))}}class y2 extends ke{}class Ky extends y2{}class w2 extends y2{async _call(j){return new No(await super._call(j))}}class Yy extends ke{}class Xy extends Yy{}class x2 extends Yy{async _call(j){return new No(await super._call(j))}}class Qy extends ke{}class Ix extends Qy{}class Dx extends Qy{async _call(j){return new No(await super._call(j))}}class v2 extends ke{}class g0 extends v2{}class Zy extends ke{}class Ib extends Zy{}class T2 extends ke{}class M2 extends T2{}class b0 extends ke{}class E2 extends b0{}class S2 extends b0{async _call(j){return new Lx(await super._call(j))}}class Lx extends Bt{constructor({logits:j,pred_boxes:ye}){super(),this.logits=j,this.pred_boxes=ye}}class k1 extends ke{}class y0 extends k1{async get_image_embeddings({pixel_values:j}){return await he(this,{pixel_values:j})}async forward(j){if((!j.image_embeddings||!j.image_positional_embeddings)&&(j={...j,...await this.get_image_embeddings(j)}),!j.input_labels&&j.input_points){const _t=j.input_points.dims.slice(0,-1),fn=_t.reduce((xn,ur)=>xn*ur,1);j.input_labels=new r.Tensor("int64",new BigInt64Array(fn).fill(1n),_t)}const ye={image_embeddings:j.image_embeddings,image_positional_embeddings:j.image_positional_embeddings};return j.input_points&&(ye.input_points=j.input_points),j.input_labels&&(ye.input_labels=j.input_labels),j.input_boxes&&(ye.input_boxes=j.input_boxes),await G(this.sessions.prompt_encoder_mask_decoder,ye)}async _call(j){return new Db(await super._call(j))}}class Db extends Bt{constructor({iou_scores:j,pred_masks:ye}){super(),this.iou_scores=j,this.pred_masks=ye}}class O1 extends ke{}class Lb extends O1{}class P2 extends O1{}class Jy extends ke{}class I1 extends Jy{}class A2 extends Jy{}class Mp extends ke{}class k_ extends Mp{}class Cg extends Mp{async _call(j){return new Ng(await super._call(j))}}class C2 extends Mp{async _call(j){return new No(await super._call(j))}}class kg extends Mp{async _call(j){return new mp(await super._call(j))}}class O_ extends ke{}class xp extends O_{}class $b extends O_{async _call(j){return new mp(await super._call(j))}}class ew extends ke{}class tw extends ew{}class Fb extends ke{}class k2 extends Fb{}class r1 extends Fb{async _call(j){return new Ng(await super._call(j))}}class Nb extends Fb{async _call(j){return new No(await super._call(j))}}class w0 extends ke{}class O2 extends w0{}class I2 extends w0{async _call(j){return new Ng(await super._call(j))}}class Rb extends w0{async _call(j){return new No(await super._call(j))}}class D2 extends w0{async _call(j){return new mp(await super._call(j))}}class x0 extends ke{}class L2 extends x0{}class $2 extends x0{async _call(j){return new Ng(await super._call(j))}}class $x extends x0{async _call(j){return new No(await super._call(j))}}class Fx extends ke{}class Ep extends Mp{}class Ip extends Mp{async _call(j){return new Ng(await super._call(j))}}class F2 extends Mp{async _call(j){return new No(await super._call(j))}}class D1 extends ke{}class N2 extends D1{}class R2 extends D1{async _call(j){return new Ng(await super._call(j))}}class z2 extends D1{async _call(j){return new No(await super._call(j))}}class zb extends D1{async _call(j){return new hx(await super._call(j))}}class nw extends D1{async _call(j){return new mp(await super._call(j))}}class B2 extends ke{}class j2 extends B2{}class Bb extends ke{}class U2 extends Bb{}class rw extends Bb{}class sw extends Bb{async generate_speech(j,ye,{threshold:_t=.5,minlenratio:fn=0,maxlenratio:xn=20,vocoder:ur=null}={}){const oi={input_ids:j},{encoder_outputs:_i,encoder_attention_mask:Ei}=await he(this,oi),Ya=_i.dims[1]/this.config.reduction_factor,Vo=Math.floor(Ya*xn),Wo=Math.floor(Ya*fn),Bi=this.config.num_mel_bins;let Sc=[],Gi=null,Ni=null,Di=0;for(;;){++Di;const gp=z(!!Ni);let rp;Ni?rp=Ni.output_sequence_out:rp=new r.Tensor("float32",new Float32Array(Bi),[1,1,Bi]);let Jc={use_cache_branch:gp,output_sequence:rp,encoder_attention_mask:Ei,speaker_embeddings:ye,encoder_hidden_states:_i};this.addPastKeyValues(Jc,Gi),Ni=await G(this.sessions.decoder_model_merged,Jc),Gi=this.getPastKeyValues(Ni,Gi);const{prob:qo,spectrum:Yc}=Ni;if(Sc.push(Yc),Di>=Wo&&(Array.from(qo.data).filter(vp=>vp>=_t).length>0||Di>=Vo))break}const Nc=(0,r.cat)(Sc),{waveform:Qo}=await G(ur.sessions.model,{spectrogram:Nc});return{spectrogram:Nc,waveform:Qo}}}class V2 extends ke{main_input_name="spectrogram"}class iw extends ke{}class jb extends iw{}class Ub extends ke{}class G2 extends Ub{}class aw extends Ub{}class ow extends ke{}class W_ extends ow{}class lw extends ow{}class W2 extends ke{}class q2 extends W2{}class q_ extends W2{}class uw extends ke{}class Vb extends uw{}class v0 extends uw{}class Wc extends ke{}class Nx extends Wc{}class Rx extends Wc{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"text_model"})}}class H2 extends Wc{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"audio_model"})}}class T0 extends ke{}class H_ extends T0{async _call(j){return new k0(await super._call(j))}}class Gb extends ke{}class zx extends Gb{}class M0 extends Gb{}class I_ extends Gb{}class cw extends ke{}class dw extends cw{}class K2 extends cw{}class Wb extends ke{}class pw extends Wb{}class qb extends Wb{async _call(j){return new No(await super._call(j))}}class fw extends ke{}class Og extends fw{}class _p extends fw{}class Hb extends ke{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(j){const[ye,_t]=j.dims,fn=this.config.decoder.num_codebooks,xn=_t-fn;let ur=0;for(let Ei=0;Ei<j.size;++Ei){if(j.data[Ei]===this.config.decoder.pad_token_id)continue;const Ya=Ei%_t,Vo=Math.floor(Ei/_t)%fn,Wo=Ya-Vo;Wo>0&&Wo<=xn&&(j.data[ur++]=j.data[Ei])}const oi=Math.floor(ye/fn),_i=ur/(oi*fn);return new r.Tensor(j.type,j.data.slice(0,ur),[oi,fn,_i])}prepare_inputs_for_generation(j,ye,_t){let fn=structuredClone(j);for(let ur=0;ur<fn.length;++ur)for(let oi=0;oi<fn[ur].length;++oi)ur%this.config.decoder.num_codebooks>=oi&&(fn[ur][oi]=BigInt(this.config.decoder.pad_token_id));return _t.guidance_scale!==null&&_t.guidance_scale>1&&(fn=fn.concat(fn)),super.prepare_inputs_for_generation(fn,ye,_t)}async generate(j){const ye=await super.generate(j),_t=this._apply_and_filter_by_delay_pattern_mask(ye).unsqueeze_(0),{audio_values:fn}=await G(this.sessions.encodec_decode,{audio_codes:_t});return fn}}class Kb extends ke{}class Sp extends Kb{}class Bx extends Kb{async _call(j){return new No(await super._call(j))}}class Y2 extends Kb{}class Yb extends ke{}class Kc extends Yb{}class r_ extends Yb{async _call(j){return new No(await super._call(j))}}class K_ extends Yb{}class Xb extends ke{}class X2 extends Xb{}class jx extends Xb{async _call(j){return new No(await super._call(j))}}class hw extends Xb{}class Eh extends ke{}class w_ extends Eh{}class Q2 extends Eh{async _call(j){return new No(await super._call(j))}}class l_ extends Eh{}class Z2 extends ke{}class Ig extends Z2{}class s1 extends ke{}class Dg extends s1{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...j){super(...j),this._generation_mode="text"}async forward(j){const ye=this._generation_mode??"text";let _t;if(ye==="text"||!j.past_key_values){const _i=this.sessions.prepare_inputs_embeds,Ei=(0,_.pick)(j,_i.inputNames);_t=await G(_i,Ei)}else{const _i=this.sessions.gen_img_embeds,Ei=(0,_.pick)({image_ids:j.input_ids},_i.inputNames);_t=await G(_i,Ei)}const fn={...j,..._t},xn=await oe(this,fn),ur=this.sessions[ye==="text"?"lm_head":"gen_head"];if(!ur)throw new Error(`Unable to find "${ur}" generation head`);const oi=await G(ur,(0,_.pick)(xn,ur.inputNames));return{..._t,...xn,...oi}}async generate(j){return this._generation_mode="text",super.generate(j)}async generate_images(j){this._generation_mode="image";const ye=(j.inputs??j[this.main_input_name]).dims[1],fn=(await super.generate(j)).slice(null,[ye,null]),xn=this.sessions.image_decode,{decoded_image:ur}=await G(xn,{generated_tokens:fn}),oi=ur.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),_i=[];for(const Ei of oi){const Ya=u.RawImage.fromTensor(Ei);_i.push(Ya)}return _i}}class _w extends Bt{constructor({char_logits:j,bpe_logits:ye,wp_logits:_t}){super(),this.char_logits=j,this.bpe_logits=ye,this.wp_logits=_t}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class mw extends ke{}class D_ extends mw{async _call(j){return new _w(await super._call(j))}}class gw extends ke{}class L1 extends gw{}class E0 extends gw{}class $1 extends ke{}class F1 extends $1{}class J2 extends $1{}class ex extends ke{forward_params=["input_ids","attention_mask","position_ids","audio_values","past_key_values"]}class N1 extends ex{_merge_input_ids_with_audio_features(j){const ye=j.audio_features.dims.at(-1),_t=j.audio_features.view(-1,ye);return de({audio_token_id:this.config.ignore_index??this.config.audio_token_id,...j,audio_features:_t})}}class tx extends N1{}class R1 extends ke{main_input_name="input_values";forward_params=["input_values"]}class nx extends Bt{constructor({audio_codes:j}){super(),this.audio_codes=j}}class Ux extends Bt{constructor({audio_values:j}){super(),this.audio_values=j}}class Vx extends R1{async encode(j){return new nx(await G(this.sessions.encoder_model,j))}async decode(j){return new Ux(await G(this.sessions.decoder_model,j))}}class $c extends R1{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"encoder_model"})}}class Vc extends R1{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"decoder_model"})}}class Xo extends ke{main_input_name="input_values";forward_params=["input_values"]}class vc extends Bt{constructor({audio_codes:j}){super(),this.audio_codes=j}}class Fc extends Bt{constructor({audio_values:j}){super(),this.audio_values=j}}class u_ extends Xo{async encode(j){return new vc(await G(this.sessions.encoder_model,j))}async decode(j){return new Fc(await G(this.sessions.decoder_model,j))}}class Lg extends Xo{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"encoder_model"})}}class z1 extends Xo{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"decoder_model"})}}class S0 extends ke{main_input_name="input_values";forward_params=["input_values"]}class Y_ extends S0{async encode(j){return await G(this.sessions.encoder_model,j)}async decode(j){return await G(this.sessions.decoder_model,j)}}class np extends S0{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"encoder_model"})}}class $g extends S0{static async from_pretrained(j,ye={}){return super.from_pretrained(j,{...ye,model_file_name:ye.model_file_name??"decoder_model"})}}class bu{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(j,{progress_callback:ye=null,config:_t=null,cache_dir:fn=null,local_files_only:xn=!1,revision:ur="main",model_file_name:oi=null,subfolder:_i="onnx",device:Ei=null,dtype:Ya=null,use_external_data_format:Vo=null,session_options:Wo={}}={}){const Bi={progress_callback:ye,config:_t,cache_dir:fn,local_files_only:xn,revision:ur,model_file_name:oi,subfolder:_i,device:Ei,dtype:Ya,use_external_data_format:Vo,session_options:Wo};if(Bi.config=await s.AutoConfig.from_pretrained(j,Bi),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const Sc=Bi.config.model_type;for(const Gi of this.MODEL_CLASS_MAPPINGS){let Ni=Gi.get(Sc);if(!Ni){for(const Di of Gi.values())if(Di[0]===Sc){Ni=Di;break}if(!Ni)continue}return await Ni[1].from_pretrained(j,Bi)}if(this.BASE_IF_FAIL)return cx.has(Sc)||console.warn(`Unknown model class "${Sc}", attempting to construct from base class.`),await ke.from_pretrained(j,Bi);throw Error(`Unsupported model type: ${Sc}`)}}const rx=new Map([["bert",["BertModel",cn]],["neobert",["NeoBertModel",vn]],["modernbert",["ModernBertModel",ui]],["nomic_bert",["NomicBertModel",up]],["roformer",["RoFormerModel",Mo]],["electra",["ElectraModel",ve]],["esm",["EsmModel",Qc]],["convbert",["ConvBertModel",Ri]],["camembert",["CamembertModel",Pi]],["deberta",["DebertaModel",Ot]],["deberta-v2",["DebertaV2Model",Do]],["mpnet",["MPNetModel",g_]],["albert",["AlbertModel",lr]],["distilbert",["DistilBertModel",Ro]],["roberta",["RobertaModel",Ho]],["xlm",["XLMModel",uy]],["xlm-roberta",["XLMRobertaModel",j0]],["clap",["ClapModel",Nx]],["clip",["CLIPModel",wg]],["clipseg",["CLIPSegModel",xg]],["chinese_clip",["ChineseCLIPModel",sb]],["siglip",["SiglipModel",d1]],["jina_clip",["JinaCLIPModel",f1]],["mobilebert",["MobileBertModel",Ac]],["squeezebert",["SqueezeBertModel",at]],["wav2vec2",["Wav2Vec2Model",k_]],["wav2vec2-bert",["Wav2Vec2BertModel",L2]],["unispeech",["UniSpeechModel",k2]],["unispeech-sat",["UniSpeechSatModel",O2]],["hubert",["HubertModel",Ep]],["wavlm",["WavLMModel",N2]],["audio-spectrogram-transformer",["ASTModel",G0]],["vits",["VitsModel",H_]],["pyannote",["PyAnnoteModel",xp]],["wespeaker-resnet",["WeSpeakerResNetModel",tw]],["detr",["DetrModel",Yo]],["rt_detr",["RTDetrModel",xb]],["rt_detr_v2",["RTDetrV2Model",op]],["rf_detr",["RFDetrModel",Xw]],["d_fine",["DFineModel",Ry]],["table-transformer",["TableTransformerModel",zy]],["vit",["ViTModel",v1]],["ijepa",["IJepaModel",Bw]],["pvt",["PvtModel",gb]],["vit_msn",["ViTMSNModel",Sy]],["vit_mae",["ViTMAEModel",Vw]],["groupvit",["GroupViTModel",Ww]],["fastvit",["FastViTModel",qw]],["mobilevit",["MobileViTModel",Sg]],["mobilevitv2",["MobileViTV2Model",Ay]],["owlvit",["OwlViTModel",p0]],["owlv2",["Owlv2Model",P1]],["beit",["BeitModel",Iy]],["deit",["DeiTModel",G_]],["hiera",["HieraModel",By]],["convnext",["ConvNextModel",g2]],["convnextv2",["ConvNextV2Model",Ky]],["dinov2",["Dinov2Model",Xy]],["dinov2_with_registers",["Dinov2WithRegistersModel",Ix]],["dinov3_vit",["DINOv3ViTModel",g0]],["dinov3_convnext",["DINOv3ConvNextModel",Ib]],["resnet",["ResNetModel",Zw]],["swin",["SwinModel",e2]],["swin2sr",["Swin2SRModel",r2]],["donut-swin",["DonutSwinModel",m2]],["yolos",["YolosModel",E2]],["dpt",["DPTModel",Gy]],["glpn",["GLPNModel",h2]],["hifigan",["SpeechT5HifiGan",V2]],["efficientnet",["EfficientNetModel",pw]],["decision_transformer",["DecisionTransformerModel",Ig]],["patchtst",["PatchTSTForPrediction",L1]],["patchtsmixer",["PatchTSMixerForPrediction",F1]],["mobilenet_v1",["MobileNetV1Model",Sp]],["mobilenet_v2",["MobileNetV2Model",Kc]],["mobilenet_v3",["MobileNetV3Model",X2]],["mobilenet_v4",["MobileNetV4Model",w_]],["maskformer",["MaskFormerModel",p2]],["mgp-str",["MgpstrForSceneTextRecognition",D_]],["style_text_to_speech_2",["StyleTextToSpeech2Model",j2]]]),x_=new Map([["t5",["T5Model",Tc]],["longt5",["LongT5Model",Lc]],["mt5",["MT5Model",ep]],["bart",["BartModel",wc]],["mbart",["MBartModel",ct]],["marian",["MarianModel",Lb]],["whisper",["WhisperModel",W0]],["m2m_100",["M2M100Model",I1]],["blenderbot",["BlenderbotModel",Ii]],["blenderbot-small",["BlenderbotSmallModel",pp]]]),P0=new Map([["mimi",["MimiModel",Vx]],["dac",["DacModel",u_]],["snac",["SnacModel",Y_]]]),Qb=new Map([["bloom",["BloomModel",Nw]],["jais",["JAISModel",ib]],["gpt2",["GPT2Model",m1]],["gptj",["GPTJModel",L]],["gpt_bigcode",["GPTBigCodeModel",_e]],["gpt_neo",["GPTNeoModel",N_]],["gpt_neox",["GPTNeoXModel",P_]],["codegen",["CodeGenModel",nr]],["llama",["LlamaModel",Ai]],["arcee",["ArceeModel",Ec]],["lfm2",["Lfm2Model",Tg]],["smollm3",["SmolLM3Model",ab]],["exaone",["ExaoneModel",z_]],["olmo",["OlmoModel",y1]],["olmo2",["Olmo2Model",cb]],["mobilellm",["MobileLLMModel",Yg]],["granite",["GraniteModel",Xg]],["cohere",["CohereModel",Qg]],["gemma",["GemmaModel",vy]],["gemma2",["Gemma2Model",kc]],["gemma3_text",["Gemma3Model",Ty]],["helium",["HeliumModel",Iw]],["glm",["GlmModel",Sx]],["openelm",["OpenELMModel",$w]],["qwen2",["Qwen2Model",Fw]],["qwen3",["Qwen3Model",e1]],["phi",["PhiModel",Ey]],["phi3",["Phi3Model",t1]],["mpt",["MptModel",Ax]],["opt",["OPTModel",l0]],["mistral",["MistralModel",G2]],["ernie4_5",["Ernie4_5_Model",W_]],["starcoder2",["Starcoder2Model",q2]],["falcon",["FalconModel",Vb]],["stablelm",["StableLmModel",dw]],["modernbert-decoder",["ModernBertDecoderModel",Si]]]),e_=new Map([["speecht5",["SpeechT5ForSpeechToText",rw]],["whisper",["WhisperForConditionalGeneration",q0]],["lite-whisper",["LiteWhisperForConditionalGeneration",_y]],["moonshine",["MoonshineForConditionalGeneration",Y0]]]),bw=new Map([["speecht5",["SpeechT5ForTextToSpeech",sw]]]),yw=new Map([["vits",["VitsModel",H_]],["musicgen",["MusicgenForConditionalGeneration",Hb]]]),Zb=new Map([["bert",["BertForSequenceClassification",yn]],["neobert",["NeoBertForSequenceClassification",ir]],["modernbert",["ModernBertForSequenceClassification",Lo]],["roformer",["RoFormerForSequenceClassification",rf]],["electra",["ElectraForSequenceClassification",lt]],["esm",["EsmForSequenceClassification",mr]],["convbert",["ConvBertForSequenceClassification",Ui]],["camembert",["CamembertForSequenceClassification",Oo]],["deberta",["DebertaForSequenceClassification",mn]],["deberta-v2",["DebertaV2ForSequenceClassification",yc]],["mpnet",["MPNetForSequenceClassification",M_]],["albert",["AlbertForSequenceClassification",yi]],["distilbert",["DistilBertForSequenceClassification",bc]],["roberta",["RobertaForSequenceClassification",s_]],["xlm",["XLMForSequenceClassification",dy]],["xlm-roberta",["XLMRobertaForSequenceClassification",V0]],["bart",["BartForSequenceClassification",xe]],["mbart",["MBartForSequenceClassification",Sn]],["mobilebert",["MobileBertForSequenceClassification",Op]],["squeezebert",["SqueezeBertForSequenceClassification",kt]]]),Jb=new Map([["bert",["BertForTokenClassification",$n]],["neobert",["NeoBertForTokenClassification",ai]],["modernbert",["ModernBertForTokenClassification",zi]],["roformer",["RoFormerForTokenClassification",cp]],["electra",["ElectraForTokenClassification",_n]],["esm",["EsmForTokenClassification",ci]],["convbert",["ConvBertForTokenClassification",Rp]],["camembert",["CamembertForTokenClassification",we]],["deberta",["DebertaForTokenClassification",ii]],["deberta-v2",["DebertaV2ForTokenClassification",Dc]],["mpnet",["MPNetForTokenClassification",Lt]],["distilbert",["DistilBertForTokenClassification",Oc]],["roberta",["RobertaForTokenClassification",E_]],["xlm",["XLMForTokenClassification",py]],["xlm-roberta",["XLMRobertaForTokenClassification",hy]]]),X_=new Map([["t5",["T5ForConditionalGeneration",Uc]],["longt5",["LongT5ForConditionalGeneration",Mc]],["mt5",["MT5ForConditionalGeneration",tp]],["bart",["BartForConditionalGeneration",Z]],["mbart",["MBartForConditionalGeneration",zt]],["marian",["MarianMTModel",P2]],["m2m_100",["M2M100ForConditionalGeneration",A2]],["blenderbot",["BlenderbotForConditionalGeneration",ki]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",fp]]]),Pp=new Map([["bloom",["BloomForCausalLM",Px]],["gpt2",["GPT2LMHeadModel",J1]],["jais",["JAISLMHeadModel",b_]],["gptj",["GPTJForCausalLM",V]],["gpt_bigcode",["GPTBigCodeForCausalLM",De]],["gpt_neo",["GPTNeoForCausalLM",g1]],["gpt_neox",["GPTNeoXForCausalLM",R_]],["codegen",["CodeGenForCausalLM",li]],["llama",["LlamaForCausalLM",Fo]],["arcee",["ArceeForCausalLM",Ic]],["lfm2",["Lfm2ForCausalLM",yy]],["smollm3",["SmolLM3ForCausalLM",wy]],["exaone",["ExaoneForCausalLM",Dw]],["olmo",["OlmoForCausalLM",w1]],["olmo2",["Olmo2ForCausalLM",h_]],["mobilellm",["MobileLLMForCausalLM",xy]],["granite",["GraniteForCausalLM",B_]],["cohere",["CohereForCausalLM",Lw]],["gemma",["GemmaForCausalLM",eh]],["gemma2",["Gemma2ForCausalLM",Zg]],["gemma3_text",["Gemma3ForCausalLM",Jg]],["helium",["HeliumForCausalLM",ob]],["glm",["GlmForCausalLM",a_]],["openelm",["OpenELMForCausalLM",r0]],["qwen2",["Qwen2ForCausalLM",s0]],["qwen3",["Qwen3ForCausalLM",j_]],["phi",["PhiForCausalLM",i0]],["phi3",["Phi3ForCausalLM",zp]],["mpt",["MptForCausalLM",wp]],["opt",["OPTForCausalLM",u0]],["mbart",["MBartForCausalLM",pr]],["mistral",["MistralForCausalLM",aw]],["ernie4_5",["Ernie4_5_ForCausalLM",lw]],["starcoder2",["Starcoder2ForCausalLM",q_]],["falcon",["FalconForCausalLM",v0]],["trocr",["TrOCRForCausalLM",jb]],["stablelm",["StableLmForCausalLM",K2]],["modernbert-decoder",["ModernBertDecoderForCausalLM",zc]],["phi3_v",["Phi3VForCausalLM",c1]]]),i1=new Map([["multi_modality",["MultiModalityCausalLM",Dg]]]),B1=new Map([["bert",["BertForMaskedLM",kn]],["neobert",["NeoBertForMaskedLM",xi]],["modernbert",["ModernBertForMaskedLM",wi]],["roformer",["RoFormerForMaskedLM",$p]],["electra",["ElectraForMaskedLM",Ke]],["esm",["EsmForMaskedLM",sp]],["convbert",["ConvBertForMaskedLM",_c]],["camembert",["CamembertForMaskedLM",hi]],["deberta",["DebertaForMaskedLM",Ht]],["deberta-v2",["DebertaV2ForMaskedLM",Ko]],["mpnet",["MPNetForMaskedLM",T_]],["albert",["AlbertForMaskedLM",zo]],["distilbert",["DistilBertForMaskedLM",Jf]],["roberta",["RobertaForMaskedLM",Bc]],["xlm",["XLMWithLMHeadModel",cy]],["xlm-roberta",["XLMRobertaForMaskedLM",U0]],["mobilebert",["MobileBertForMaskedLM",m_]],["squeezebert",["SqueezeBertForMaskedLM",ft]]]),j1=new Map([["bert",["BertForQuestionAnswering",cr]],["neobert",["NeoBertForQuestionAnswering",mi]],["roformer",["RoFormerForQuestionAnswering",Wi]],["electra",["ElectraForQuestionAnswering",ar]],["convbert",["ConvBertForQuestionAnswering",W]],["camembert",["CamembertForQuestionAnswering",it]],["deberta",["DebertaForQuestionAnswering",Ti]],["deberta-v2",["DebertaV2ForQuestionAnswering",En]],["mpnet",["MPNetForQuestionAnswering",X]],["albert",["AlbertForQuestionAnswering",di]],["distilbert",["DistilBertForQuestionAnswering",dp]],["roberta",["RobertaForQuestionAnswering",ly]],["xlm",["XLMForQuestionAnswering",fy]],["xlm-roberta",["XLMRobertaForQuestionAnswering",q1]],["mobilebert",["MobileBertForQuestionAnswering",p_]],["squeezebert",["SqueezeBertForQuestionAnswering",sr]]]),ey=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",X0]],["idefics3",["Idefics3ForConditionalGeneration",Q1]],["smolvlm",["SmolVLMForConditionalGeneration",l1]]]),ww=new Map([["llava",["LlavaForConditionalGeneration",Y1]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",X1]],["moondream1",["Moondream1ForConditionalGeneration",Bg]],["florence2",["Florence2ForConditionalGeneration",Z0]],["qwen2-vl",["Qwen2VLForConditionalGeneration",U_]],["idefics3",["Idefics3ForConditionalGeneration",Q1]],["smolvlm",["SmolVLMForConditionalGeneration",l1]],["paligemma",["PaliGemmaForConditionalGeneration",eb]],["llava_qwen2",["LlavaQwen2ForCausalLM",jg]],["gemma3n",["Gemma3nForConditionalGeneration",S_]]]),sx=new Map([["ultravox",["UltravoxModel",N1]],["voxtral",["VoxtralForConditionalGeneration",tx]]]),ty=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",X0]]]),xw=new Map([["vit",["ViTForImageClassification",T1]],["ijepa",["IJepaForImageClassification",Cx]],["pvt",["PvtForImageClassification",Uw]],["vit_msn",["ViTMSNForImageClassification",Gw]],["fastvit",["FastViTForImageClassification",Hw]],["mobilevit",["MobileViTForImageClassification",Pg]],["mobilevitv2",["MobileViTV2ForImageClassification",Cy]],["beit",["BeitForImageClassification",Dy]],["deit",["DeiTForImageClassification",Eb]],["hiera",["HieraForImageClassification",Qw]],["convnext",["ConvNextForImageClassification",b2]],["convnextv2",["ConvNextV2ForImageClassification",w2]],["dinov2",["Dinov2ForImageClassification",x2]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",Dx]],["resnet",["ResNetForImageClassification",Jw]],["swin",["SwinForImageClassification",Uy]],["segformer",["SegformerForImageClassification",M0]],["efficientnet",["EfficientNetForImageClassification",qb]],["mobilenet_v1",["MobileNetV1ForImageClassification",Bx]],["mobilenet_v2",["MobileNetV2ForImageClassification",r_]],["mobilenet_v3",["MobileNetV3ForImageClassification",jx]],["mobilenet_v4",["MobileNetV4ForImageClassification",Q2]]]),c_=new Map([["detr",["DetrForObjectDetection",jc]],["rt_detr",["RTDetrForObjectDetection",h0]],["rt_detr_v2",["RTDetrV2ForObjectDetection",Ly]],["rf_detr",["RFDetrForObjectDetection",kx]],["d_fine",["DFineForObjectDetection",n_]],["table-transformer",["TableTransformerForObjectDetection",_0]],["yolos",["YolosForObjectDetection",S2]]]),ix=new Map([["owlvit",["OwlViTForObjectDetection",Kw]],["owlv2",["Owlv2ForObjectDetection",wb]],["grounding-dino",["GroundingDinoForObjectDetection",M2]]]),Dp=new Map([["detr",["DetrForSegmentation",ap]],["clipseg",["CLIPSegForImageSegmentation",Z1]]]),ax=new Map([["segformer",["SegformerForSemanticSegmentation",I_]],["sapiens",["SapiensForSemanticSegmentation",l2]],["swin",["SwinForSemanticSegmentation",t2]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",Y2]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",K_]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",hw]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",l_]]]),ox=new Map([["detr",["DetrForSegmentation",ap]],["maskformer",["MaskFormerForInstanceSegmentation",f2]]]),Gx=new Map([["sam",["SamModel",y0]]]),Fg=new Map([["wav2vec2",["Wav2Vec2ForCTC",Cg]],["wav2vec2-bert",["Wav2Vec2BertForCTC",$2]],["unispeech",["UniSpeechForCTC",r1]],["unispeech-sat",["UniSpeechSatForCTC",I2]],["wavlm",["WavLMForCTC",R2]],["hubert",["HubertForCTC",Ip]]]),ny=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",C2]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",$x]],["unispeech",["UniSpeechForSequenceClassification",Nb]],["unispeech-sat",["UniSpeechSatForSequenceClassification",Rb]],["wavlm",["WavLMForSequenceClassification",z2]],["hubert",["HubertForSequenceClassification",F2]],["audio-spectrogram-transformer",["ASTForAudioClassification",zg]]]),vw=new Map([["wavlm",["WavLMForXVector",zb]]]),U1=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",D2]],["wavlm",["WavLMForAudioFrameClassification",nw]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",kg]],["pyannote",["PyAnnoteForAudioFrameClassification",$b]]]),lx=new Map([["vitmatte",["VitMatteForImageMatting",Py]]]),Wx=new Map([["patchtst",["PatchTSTForPrediction",E0]],["patchtsmixer",["PatchTSMixerForPrediction",J2]]]),ux=new Map([["swin2sr",["Swin2SRForImageSuperResolution",s2]]]),Tw=new Map([["dpt",["DPTForDepthEstimation",i2]],["depth_anything",["DepthAnythingForDepthEstimation",o2]],["glpn",["GLPNForDepthEstimation",Hy]],["sapiens",["SapiensForDepthEstimation",Ox]],["depth_pro",["DepthProForDepthEstimation",Cb]],["metric3d",["Metric3DForDepthEstimation",kb]],["metric3dv2",["Metric3Dv2ForDepthEstimation",d2]]]),Mw=new Map([["sapiens",["SapiensForNormalEstimation",u2]]]),qx=new Map([["vitpose",["VitPoseForPoseEstimation",n1]]]),Hx=new Map([["clip",["CLIPVisionModelWithProjection",nb]],["siglip",["SiglipVisionModel",Li]],["jina_clip",["JinaCLIPVisionModel",h1]]]),Kx=[[rx,T.EncoderOnly],[x_,T.EncoderDecoder],[Qb,T.DecoderOnly],[P0,T.AutoEncoder],[Zb,T.EncoderOnly],[Jb,T.EncoderOnly],[X_,T.Seq2Seq],[e_,T.Seq2Seq],[Pp,T.DecoderOnly],[i1,T.MultiModality],[B1,T.EncoderOnly],[j1,T.EncoderOnly],[ey,T.Vision2Seq],[ww,T.ImageTextToText],[sx,T.AudioTextToText],[xw,T.EncoderOnly],[Dp,T.EncoderOnly],[ox,T.EncoderOnly],[ax,T.EncoderOnly],[lx,T.EncoderOnly],[Wx,T.EncoderOnly],[ux,T.EncoderOnly],[Tw,T.EncoderOnly],[Mw,T.EncoderOnly],[qx,T.EncoderOnly],[c_,T.EncoderOnly],[ix,T.EncoderOnly],[Gx,T.MaskGeneration],[Fg,T.EncoderOnly],[ny,T.EncoderOnly],[bw,T.Seq2Seq],[yw,T.EncoderOnly],[vw,T.EncoderOnly],[U1,T.EncoderOnly],[Hx,T.EncoderOnly]];for(const[B,j]of Kx)for(const[ye,_t]of B.values())E.set(ye,j),C.set(_t,ye),A.set(ye,_t);const Yx=[["MusicgenForConditionalGeneration",Hb,T.Musicgen],["Phi3VForCausalLM",c1,T.Phi3V],["CLIPTextModelWithProjection",Ug,T.EncoderOnly],["SiglipTextModel",Gg,T.EncoderOnly],["JinaCLIPTextModel",f_,T.EncoderOnly],["ClapTextModelWithProjection",Rx,T.EncoderOnly],["ClapAudioModelWithProjection",H2,T.EncoderOnly],["DacEncoderModel",Lg,T.EncoderOnly],["DacDecoderModel",z1,T.EncoderOnly],["MimiEncoderModel",$c,T.EncoderOnly],["MimiDecoderModel",Vc,T.EncoderOnly],["SnacEncoderModel",np,T.EncoderOnly],["SnacDecoderModel",$g,T.EncoderOnly],["Gemma3nForConditionalGeneration",S_,T.ImageAudioTextToText]];for(const[B,j,ye]of Yx)E.set(B,ye),C.set(j,B),A.set(B,j);const cx=new Map([["modnet",Dp],["birefnet",Dp],["isnet",Dp],["ben",Dp]]);for(const[B,j]of cx.entries())j.set(B,["PreTrainedModel",ke]),E.set(B,T.EncoderOnly),C.set(ke,B),A.set(B,ke);class A0 extends bu{static MODEL_CLASS_MAPPINGS=Kx.map(j=>j[0]);static BASE_IF_FAIL=!0}class Ew extends bu{static MODEL_CLASS_MAPPINGS=[Zb]}class Xx extends bu{static MODEL_CLASS_MAPPINGS=[Jb]}class Qx extends bu{static MODEL_CLASS_MAPPINGS=[X_]}class Zx extends bu{static MODEL_CLASS_MAPPINGS=[e_]}class Jx extends bu{static MODEL_CLASS_MAPPINGS=[bw]}class ev extends bu{static MODEL_CLASS_MAPPINGS=[yw]}class tv extends bu{static MODEL_CLASS_MAPPINGS=[Pp]}class Sw extends bu{static MODEL_CLASS_MAPPINGS=[B1]}class nv extends bu{static MODEL_CLASS_MAPPINGS=[j1]}class rv extends bu{static MODEL_CLASS_MAPPINGS=[ey]}class Gc extends bu{static MODEL_CLASS_MAPPINGS=[xw]}class dx extends bu{static MODEL_CLASS_MAPPINGS=[Dp]}class Tv extends bu{static MODEL_CLASS_MAPPINGS=[ax]}class sv extends bu{static MODEL_CLASS_MAPPINGS=[ox]}class Mv extends bu{static MODEL_CLASS_MAPPINGS=[c_]}class Ev extends bu{static MODEL_CLASS_MAPPINGS=[ix]}class Sv extends bu{static MODEL_CLASS_MAPPINGS=[Gx]}class Pw extends bu{static MODEL_CLASS_MAPPINGS=[Fg]}class C0 extends bu{static MODEL_CLASS_MAPPINGS=[ny]}class px extends bu{static MODEL_CLASS_MAPPINGS=[vw]}class Aw extends bu{static MODEL_CLASS_MAPPINGS=[U1]}class fx extends bu{static MODEL_CLASS_MAPPINGS=[ty]}class V1 extends bu{static MODEL_CLASS_MAPPINGS=[lx]}class Q_ extends bu{static MODEL_CLASS_MAPPINGS=[ux]}class ry extends bu{static MODEL_CLASS_MAPPINGS=[Tw]}class Pv extends bu{static MODEL_CLASS_MAPPINGS=[Mw]}class iv extends bu{static MODEL_CLASS_MAPPINGS=[qx]}class av extends bu{static MODEL_CLASS_MAPPINGS=[Hx]}class ov extends bu{static MODEL_CLASS_MAPPINGS=[ww]}class lv extends bu{static MODEL_CLASS_MAPPINGS=[sx]}class Av extends Bt{constructor({logits:j,past_key_values:ye,encoder_outputs:_t,decoder_attentions:fn=null,cross_attentions:xn=null}){super(),this.logits=j,this.past_key_values=ye,this.encoder_outputs=_t,this.decoder_attentions=fn,this.cross_attentions=xn}}class No extends Bt{constructor({logits:j,...ye}){super(),this.logits=j;const _t=Object.values(ye);_t.length>0&&(this.attentions=_t)}}class hx extends Bt{constructor({logits:j,embeddings:ye}){super(),this.logits=j,this.embeddings=ye}}class mp extends Bt{constructor({logits:j}){super(),this.logits=j}}class Ap extends Bt{constructor({logits:j}){super(),this.logits=j}}class Cp extends Bt{constructor({start_logits:j,end_logits:ye}){super(),this.start_logits=j,this.end_logits=ye}}class Ng extends Bt{constructor({logits:j}){super(),this.logits=j}}class Cv extends Bt{constructor({logits:j,past_key_values:ye}){super(),this.logits=j,this.past_key_values=ye}}class uv extends Bt{constructor({alphas:j}){super(),this.alphas=j}}class k0 extends Bt{constructor({waveform:j,spectrogram:ye}){super(),this.waveform=j,this.spectrogram=ye}}}),"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":((n,e,t)=>{t.r(e),t.d(e,{ASTFeatureExtractor:()=>c});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var a=t("./src/utils/audio.js");class c extends s.FeatureExtractor{constructor(_){super(_);const m=this.config.sampling_rate,d=(0,a.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(m/2),m,null,"kaldi",!0);this.mel_filters=d,this.window=(0,a.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(_,m){return(0,a.spectrogram)(_,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:m,transpose:!0})}async _call(_){(0,s.validate_audio_inputs)(_,"ASTFeatureExtractor");const m=await this._extract_fbank_features(_,this.config.max_length);if(this.config.do_normalize){const d=this.std*2,h=m.data;for(let i=0;i<h.length;++i)h[i]=(h[i]-this.mean)/d}return{input_values:m.unsqueeze_(0)}}}}),"./src/models/auto/feature_extraction_auto.js":((n,e,t)=>{t.r(e),t.d(e,{AutoFeatureExtractor:()=>l});var s=t("./src/utils/constants.js"),a=t("./src/utils/hub.js");t("./src/base/feature_extraction_utils.js");var c=t("./src/models/feature_extractors.js");class l{static async from_pretrained(m,d={}){const h=await(0,a.getModelJSON)(m,s.FEATURE_EXTRACTOR_NAME,!0,d),i=h.feature_extractor_type,r=c[i];if(!r)throw new Error(`Unknown feature_extractor_type: '${i}'. Please report this at ${s.GITHUB_ISSUE_URL}.`);return new r(h)}}}),"./src/models/auto/image_processing_auto.js":((n,e,t)=>{t.r(e),t.d(e,{AutoImageProcessor:()=>_});var s=t("./src/utils/constants.js"),a=t("./src/utils/hub.js"),c=t("./src/base/image_processors_utils.js"),l=t("./src/models/image_processors.js");class _{static async from_pretrained(d,h={}){const i=await(0,a.getModelJSON)(d,s.IMAGE_PROCESSOR_NAME,!0,h),r=i.image_processor_type??i.feature_extractor_type;let u=l[r?.replace(/Fast$/,"")];return u||(r!==void 0&&console.warn(`Image processor type '${r}' not found, assuming base ImageProcessor. Please report this at ${s.GITHUB_ISSUE_URL}.`),u=c.ImageProcessor),new u(i)}}}),"./src/models/auto/processing_auto.js":((n,e,t)=>{t.r(e),t.d(e,{AutoProcessor:()=>d});var s=t("./src/utils/constants.js"),a=t("./src/utils/hub.js"),c=t("./src/base/processing_utils.js"),l=t("./src/models/processors.js"),_=t("./src/models/image_processors.js"),m=t("./src/models/feature_extractors.js");class d{static async from_pretrained(i,r={}){const u=await(0,a.getModelJSON)(i,s.IMAGE_PROCESSOR_NAME,!0,r),{image_processor_type:f,feature_extractor_type:g,processor_class:w}=u;if(w&&l[w])return l[w].from_pretrained(i,r);if(!f&&!g)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const y={};if(f){const S=_[f.replace(/Fast$/,"")];if(!S)throw new Error(`Unknown image_processor_type: '${f}'.`);y.image_processor=new S(u)}if(g){const S=_[g];if(S)y.image_processor=new S(u);else{const T=m[g];if(!T)throw new Error(`Unknown feature_extractor_type: '${g}'.`);y.feature_extractor=new T(u)}}const x={};return new c.Processor(x,y,null)}}}),"./src/models/beit/image_processing_beit.js":((n,e,t)=>{t.r(e),t.d(e,{BeitFeatureExtractor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/bit/image_processing_bit.js":((n,e,t)=>{t.r(e),t.d(e,{BitImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/chinese_clip/image_processing_chinese_clip.js":((n,e,t)=>{t.r(e),t.d(e,{ChineseCLIPFeatureExtractor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/clap/feature_extraction_clap.js":((n,e,t)=>{t.r(e),t.d(e,{ClapFeatureExtractor:()=>c});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var a=t("./src/utils/audio.js");class c extends s.FeatureExtractor{constructor(_){super(_),this.mel_filters=(0,a.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,a.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,a.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(_,m,d,h){let i;const r=_.length-m;if(r>0)if(d==="rand_trunc"){const u=Math.floor(Math.random()*(r+1));_=_.subarray(u,u+m),i=await this._extract_fbank_features(_,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${d}" not implemented`);else{if(r<0){let u=new Float64Array(m);if(u.set(_),h==="repeat")for(let f=_.length;f<m;f+=_.length)u.set(_.subarray(0,Math.min(_.length,m-f)),f);else if(h==="repeatpad")for(let f=_.length;f<-r;f+=_.length)u.set(_,f);_=u}if(d==="fusion")throw new Error(`Truncation strategy "${d}" not implemented`);i=await this._extract_fbank_features(_,this.mel_filters_slaney,this.config.nb_max_samples)}return i.unsqueeze_(0)}async _extract_fbank_features(_,m,d=null){return(0,a.spectrogram)(_,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:m,log_mel:"dB",max_num_frames:d,do_pad:!1,transpose:!0})}async _call(_,{max_length:m=null}={}){return(0,s.validate_audio_inputs)(_,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(_,m??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}}),"./src/models/clip/image_processing_clip.js":((n,e,t)=>{t.r(e),t.d(e,{CLIPFeatureExtractor:()=>c,CLIPImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/convnext/image_processing_convnext.js":((n,e,t)=>{t.r(e),t.d(e,{ConvNextFeatureExtractor:()=>c,ConvNextImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{constructor(_){super(_),this.crop_pct=this.config.crop_pct??224/256}async resize(_){const m=this.size?.shortest_edge;if(m===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(m<384){const d=Math.floor(m/this.crop_pct),[h,i]=this.get_resize_output_image_size(_,{shortest_edge:d});_=await _.resize(h,i,{resample:this.resample}),_=await _.center_crop(m,m)}else _=await _.resize(m,m,{resample:this.resample});return _}}class c extends a{}}),"./src/models/dac/feature_extraction_dac.js":((n,e,t)=>{t.r(e),t.d(e,{DacFeatureExtractor:()=>a});var s=t("./src/models/encodec/feature_extraction_encodec.js");class a extends s.EncodecFeatureExtractor{}}),"./src/models/deit/image_processing_deit.js":((n,e,t)=>{t.r(e),t.d(e,{DeiTFeatureExtractor:()=>c,DeiTImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/detr/image_processing_detr.js":((n,e,t)=>{t.r(e),t.d(e,{DetrFeatureExtractor:()=>l,DetrImageProcessor:()=>c});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/tensor.js");class c extends s.ImageProcessor{async _call(m){const d=await super._call(m),h=[d.pixel_values.dims[0],64,64],i=(0,a.full)(h,1n);return{...d,pixel_mask:i}}post_process_object_detection(...m){return(0,s.post_process_object_detection)(...m)}post_process_panoptic_segmentation(...m){return(0,s.post_process_panoptic_segmentation)(...m)}post_process_instance_segmentation(...m){return(0,s.post_process_instance_segmentation)(...m)}}class l extends c{}}),"./src/models/dinov3_vit/image_processing_dinov3_vit.js":((n,e,t)=>{t.r(e),t.d(e,{DINOv3ViTImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/donut/image_processing_donut.js":((n,e,t)=>{t.r(e),t.d(e,{DonutFeatureExtractor:()=>c,DonutImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{pad_image(_,m,d,h={}){const[i,r,u]=m;let f=this.image_mean;Array.isArray(this.image_mean)||(f=new Array(u).fill(f));let g=this.image_std;Array.isArray(g)||(g=new Array(u).fill(f));const w=f.map((y,x)=>-y/g[x]);return super.pad_image(_,m,d,{center:!0,constant_values:w,...h})}}class c extends a{}}),"./src/models/dpt/image_processing_dpt.js":((n,e,t)=>{t.r(e),t.d(e,{DPTFeatureExtractor:()=>c,DPTImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/efficientnet/image_processing_efficientnet.js":((n,e,t)=>{t.r(e),t.d(e,{EfficientNetImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{constructor(l){super(l),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(_=>_*_))}}}),"./src/models/encodec/feature_extraction_encodec.js":((n,e,t)=>{t.r(e),t.d(e,{EncodecFeatureExtractor:()=>c});var s=t("./src/base/feature_extraction_utils.js"),a=t("./src/utils/tensor.js");class c extends s.FeatureExtractor{async _call(_){(0,s.validate_audio_inputs)(_,"EncodecFeatureExtractor"),_ instanceof Float64Array&&(_=new Float32Array(_));const m=this.config.feature_size;if(_.length%m!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${m}).`);const d=[1,m,_.length/m];return{input_values:new a.Tensor("float32",_,d)}}}}),"./src/models/feature_extractors.js":((n,e,t)=>{t.r(e),t.d(e,{ASTFeatureExtractor:()=>s.ASTFeatureExtractor,ClapFeatureExtractor:()=>c.ClapFeatureExtractor,DacFeatureExtractor:()=>l.DacFeatureExtractor,EncodecFeatureExtractor:()=>a.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>_.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>w.ImageProcessor,MoonshineFeatureExtractor:()=>m.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>d.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>h.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>i.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>r.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>u.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>f.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>g.WhisperFeatureExtractor});var s=t("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),a=t("./src/models/encodec/feature_extraction_encodec.js"),c=t("./src/models/clap/feature_extraction_clap.js"),l=t("./src/models/dac/feature_extraction_dac.js"),_=t("./src/models/gemma3n/feature_extraction_gemma3n.js"),m=t("./src/models/moonshine/feature_extraction_moonshine.js"),d=t("./src/models/pyannote/feature_extraction_pyannote.js"),h=t("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),i=t("./src/models/snac/feature_extraction_snac.js"),r=t("./src/models/speecht5/feature_extraction_speecht5.js"),u=t("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),f=t("./src/models/wespeaker/feature_extraction_wespeaker.js"),g=t("./src/models/whisper/feature_extraction_whisper.js"),w=t("./src/base/image_processors_utils.js")}),"./src/models/florence2/processing_florence2.js":((n,e,t)=>{t.r(e),t.d(e,{Florence2Processor:()=>l});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");class l extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;constructor(m,d,h){super(m,d,h);const{tasks_answer_post_processing_type:i,task_prompts_without_inputs:r,task_prompts_with_input:u}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(i??{})),this.task_prompts_without_inputs=new Map(Object.entries(r??{})),this.task_prompts_with_input=new Map(Object.entries(u??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(m){typeof m=="string"&&(m=[m]);const d=[];for(const h of m)if(this.task_prompts_without_inputs.has(h))d.push(this.task_prompts_without_inputs.get(h));else{for(const[i,r]of this.task_prompts_with_input)if(h.includes(i)){d.push(r.replaceAll("{input}",h).replaceAll(i,""));break}d.length!==m.length&&d.push(h)}return d}post_process_generation(m,d,h){const i=this.tasks_answer_post_processing_type.get(d)??"pure_text";m=m.replaceAll("<s>","").replaceAll("</s>","");let r;switch(i){case"pure_text":r=m;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const u=i==="ocr"?"quad_boxes":"bboxes",f=m.matchAll(this.regexes[u]),g=[],w=[];for(const[y,x,...S]of f)g.push(x?x.trim():g.at(-1)??""),w.push(S.map((T,E)=>(Number(T)+.5)/this.size_per_bin*h[E%2]));r={labels:g,[u]:w};break;default:throw new Error(`Task "${d}" (of type "${i}") not yet implemented.`)}return{[d]:r}}async _call(m,d=null,h={}){if(!m&&!d)throw new Error("Either text or images must be provided");const i=await this.image_processor(m,h),r=d?this.tokenizer(this.construct_prompts(d),h):{};return{...i,...r}}}}),"./src/models/gemma3n/feature_extraction_gemma3n.js":((n,e,t)=>{t.r(e),t.d(e,{Gemma3nAudioFeatureExtractor:()=>l});var s=t("./src/base/feature_extraction_utils.js"),a=t("./src/utils/tensor.js"),c=t("./src/utils/audio.js");class l extends s.FeatureExtractor{constructor(m){super(m);const{fft_length:d,feature_size:h,min_frequency:i,max_frequency:r,sampling_rate:u,frame_length:f}=this.config,g=(0,c.mel_filter_bank)(Math.floor(1+d/2),h,i,r,u,null,"htk",!1);this.mel_filters=g,this.window=(0,c.window_function)(f,"hann")}async _extract_fbank_features(m,d){return(0,c.spectrogram)(m,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(m,{max_length:d=48e4,truncation:h=!0,padding:i=!0,pad_to_multiple_of:r=128}={}){if((0,s.validate_audio_inputs)(m,"Gemma3nAudioFeatureExtractor"),h&&m.length>d&&(m=m.slice(0,d)),i&&m.length%r!==0){const g=r-m.length%r,w=new Float64Array(m.length+g);w.set(m),this.config.padding_value!==0&&w.fill(this.config.padding_value,m.length),m=w}const u=await this._extract_fbank_features(m,this.config.max_length),f=(0,a.full)([1,u.dims[0]],!0);return{input_features:u.unsqueeze_(0),input_features_mask:f}}}}),"./src/models/gemma3n/processing_gemma3n.js":((n,e,t)=>{t.r(e),t.d(e,{Gemma3nProcessor:()=>_});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/models/auto/feature_extraction_auto.js"),l=t("./src/tokenizers.js");t("./src/utils/image.js"),t("./src/utils/audio.js");class _ extends s.Processor{static image_processor_class=a.AutoImageProcessor;static feature_extractor_class=c.AutoFeatureExtractor;static tokenizer_class=l.AutoTokenizer;static uses_processor_config=!0;static uses_chat_template_file=!0;constructor(d,h,i){super(d,h,i),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:r,boa_token:u,audio_token:f,eoa_token:g,image_token_id:w,boi_token:y,image_token:x,eoi_token:S}=this.tokenizer.config;this.audio_token_id=r,this.boa_token=u,this.audio_token=f;const T=f.repeat(this.audio_seq_length);this.full_audio_sequence=`

${u}${T}${g}

`,this.image_token_id=w,this.boi_token=y,this.image_token=x;const E=x.repeat(this.image_seq_length);this.full_image_sequence=`

${y}${E}${S}

`}async _call(d,h=null,i=null,r={}){typeof d=="string"&&(d=[d]);let u;i&&(u=await this.feature_extractor(i,r),d=d.map(w=>w.replaceAll(this.audio_token,this.full_audio_sequence)));let f;return h&&(f=await this.image_processor(h,r),d=d.map(w=>w.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(d,r),...f,...u}}}}),"./src/models/glpn/image_processing_glpn.js":((n,e,t)=>{t.r(e),t.d(e,{GLPNFeatureExtractor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/grounding_dino/image_processing_grounding_dino.js":((n,e,t)=>{t.r(e),t.d(e,{GroundingDinoImageProcessor:()=>c});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/tensor.js");class c extends s.ImageProcessor{async _call(_){const m=await super._call(_),d=m.pixel_values.dims,h=(0,a.ones)([d[0],d[2],d[3]]);return{...m,pixel_mask:h}}}}),"./src/models/grounding_dino/processing_grounding_dino.js":((n,e,t)=>{t.r(e),t.d(e,{GroundingDinoProcessor:()=>m});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js"),l=t("./src/base/image_processors_utils.js");function _(d,h){const r=d.dims.at(-1)-1,u=d.tolist();u.fill(!1,0,1),u.fill(!1,r);const f=h.tolist();return u.map((g,w)=>g?w:null).filter(g=>g!==null).map(g=>f[g])}class m extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;async _call(h,i,r={}){const u=h?await this.image_processor(h,r):{};return{...i?this.tokenizer(i,r):{},...u}}post_process_grounded_object_detection(h,i,{box_threshold:r=.25,text_threshold:u=.25,target_sizes:f=null}={}){const{logits:g,pred_boxes:w}=h,y=g.dims[0];if(f!==null&&f.length!==y)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const x=g.dims.at(1),S=g.sigmoid(),T=S.max(-1).tolist(),E=w.tolist().map(C=>C.map(I=>(0,l.center_to_corners_format)(I))),A=[];for(let C=0;C<y;++C){const I=f!==null?f[C]:null;I!==null&&(E[C]=E[C].map(G=>G.map((te,q)=>te*I[(q+1)%2])));const D=T[C],R=[],Y=[],re=[];for(let G=0;G<x;++G){const te=D[G];if(te<=r)continue;const q=E[C][G],z=S[C][G];R.push(te),re.push(q);const H=_(z.gt(u),i[C]);Y.push(H)}A.push({scores:R,boxes:re,labels:this.batch_decode(Y)})}return A}}}),"./src/models/idefics3/image_processing_idefics3.js":((n,e,t)=>{t.r(e),t.d(e,{Idefics3ImageProcessor:()=>c});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/tensor.js");class c extends s.ImageProcessor{constructor(_){super(_),this.do_image_splitting=_.do_image_splitting??!0,this.max_image_size=_.max_image_size}get_resize_for_vision_encoder(_,m){let[d,h]=_.dims.slice(-2);const i=h/d;return h>=d?(h=Math.ceil(h/m)*m,d=Math.floor(h/i),d=Math.ceil(d/m)*m):(d=Math.ceil(d/m)*m,h=Math.floor(d*i),h=Math.ceil(h/m)*m),{height:d,width:h}}async _call(_,{do_image_splitting:m=null,return_row_col_info:d=!1}={}){let h;if(!Array.isArray(_))h=[[_]];else{if(_.length===0||!_[0])throw new Error("No images provided.");Array.isArray(_[0])?h=_:h=[_]}let i=[],r=[],u=[];const f=[],g=[];for(const C of h){let I=await Promise.all(C.map(Y=>this.preprocess(Y)));f.push(...I.map(Y=>Y.original_size)),g.push(...I.map(Y=>Y.reshaped_input_size)),I.forEach(Y=>Y.pixel_values.unsqueeze_(0));const{longest_edge:D}=this.max_image_size;let R;if(m??this.do_image_splitting){let Y=new Array(I.length),re=new Array(I.length);R=await Promise.all(I.map(async(G,te)=>{const q=this.get_resize_for_vision_encoder(G.pixel_values,D),z=await(0,a.interpolate_4d)(G.pixel_values,{size:[q.height,q.width]}),{frames:H,num_splits_h:he,num_splits_w:Ce}=await this.split_image(z,this.max_image_size);return Y[te]=he,re[te]=Ce,(0,a.cat)(H,0)})),r.push(Y),u.push(re)}else{const Y=[D,D];R=await Promise.all(I.map(re=>(0,a.interpolate_4d)(re.pixel_values,{size:Y}))),r.push(new Array(I.length).fill(0)),u.push(new Array(I.length).fill(0))}i.push((0,a.cat)(R,0))}const w=i.length,[y,x,S,T]=i[0].dims;let E,A;if(w===1)E=i[0].unsqueeze_(0),A=(0,a.full)([w,y,S,T],!0);else{const C=Math.max(...i.map(R=>R.dims.at(0)));A=(0,a.full)([w,C,S,T],!0);const I=A.data,D=C*S*T;for(let R=0;R<w;++R){const Y=i[R].dims[0];if(Y<C){i[R]=(0,a.cat)([i[R],(0,a.full)([C-Y,x,S,T],0)],0);const re=R*D+Y*S*T,G=(R+1)*D;I.fill(!1,re,G)}}E=(0,a.stack)(i,0)}return{pixel_values:E,pixel_attention_mask:A,original_sizes:f,reshaped_input_sizes:g,...d?{rows:r,cols:u}:{}}}async split_image(_,{longest_edge:m}){const d=m,h=m,i=[],[r,u]=_.dims.slice(-2);let f=0,g=0;if(r>d||u>h){f=Math.ceil(r/d),g=Math.ceil(u/h);const w=Math.ceil(r/f),y=Math.ceil(u/g);for(let T=0;T<f;++T)for(let E=0;E<g;++E){let A,C,I,D;T===f-1?(C=r-w,D=r):(C=T*w,D=(T+1)*w),E===g-1?(A=u-y,I=u):(A=E*y,I=(E+1)*y);const R=[C,A],Y=[D,I],re=await(0,a.slice)(_,R,Y,[2,3]);i.push(re)}const x=d,S=h;(r!==x||u!==S)&&(_=await(0,a.interpolate_4d)(_,{size:[x,S]}))}return i.push(_),{frames:i,num_splits_h:f,num_splits_w:g}}}}),"./src/models/idefics3/processing_idefics3.js":((n,e,t)=>{t.r(e),t.d(e,{Idefics3Processor:()=>h});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");t("./src/utils/image.js");var l=t("./src/utils/core.js");function _(i,r,u,f,g,w){let y="";for(let x=0;x<r;++x){for(let S=0;S<u;++S)y+=f+`<row_${x+1}_col_${S+1}>`+g.repeat(i);y+=`
`}return y+=`
${f}${w}`+g.repeat(i)+`${f}`,y}function m(i,r,u,f){return`${r}${f}`+u.repeat(i)+`${r}`}function d(i,r,u,f,g,w){return i===0&&r===0?m(u,f,g,w):_(u,i,r,f,g,w)}class h extends s.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=c.AutoTokenizer;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(r,u=null,f={}){f.return_row_col_info??=!0;let g;u&&(g=await this.image_processor(u,f)),Array.isArray(r)||(r=[r]);const w=g.rows??[new Array(r.length).fill(0)],y=g.cols??[new Array(r.length).fill(0)],x=this.config.image_seq_len,S=[],T=[];for(let A=0;A<r.length;++A){const C=r[A],I=w[A],D=y[A];S.push((0,l.count)(C,this.image_token));const R=I.map((G,te)=>d(G,D[te],x,this.fake_image_token,this.image_token,this.global_img_token)),Y=C.split(this.image_token);if(Y.length===0)throw new Error("The image token should be present in the text.");let re=Y[0];for(let G=0;G<R.length;++G)re+=R[G]+Y[G+1];T.push(re)}return{...this.tokenizer(T),...g}}}}),"./src/models/image_processors.js":((n,e,t)=>{t.r(e),t.d(e,{BeitFeatureExtractor:()=>s.BeitFeatureExtractor,BitImageProcessor:()=>a.BitImageProcessor,CLIPFeatureExtractor:()=>l.CLIPFeatureExtractor,CLIPImageProcessor:()=>l.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>c.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>_.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>_.ConvNextImageProcessor,DINOv3ViTImageProcessor:()=>h.DINOv3ViTImageProcessor,DPTFeatureExtractor:()=>r.DPTFeatureExtractor,DPTImageProcessor:()=>r.DPTImageProcessor,DeiTFeatureExtractor:()=>m.DeiTFeatureExtractor,DeiTImageProcessor:()=>m.DeiTImageProcessor,DetrFeatureExtractor:()=>d.DetrFeatureExtractor,DetrImageProcessor:()=>d.DetrImageProcessor,DonutFeatureExtractor:()=>i.DonutFeatureExtractor,DonutImageProcessor:()=>i.DonutImageProcessor,EfficientNetImageProcessor:()=>u.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>g.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>w.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>x.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>S.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>T.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>E.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>E.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>A.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>A.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>C.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>C.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>I.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>I.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>D.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>D.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>R.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>R.MobileViTImageProcessor,NougatImageProcessor:()=>Y.NougatImageProcessor,OwlViTFeatureExtractor:()=>G.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>G.OwlViTImageProcessor,Owlv2ImageProcessor:()=>re.Owlv2ImageProcessor,Phi3VImageProcessor:()=>te.Phi3VImageProcessor,PvtImageProcessor:()=>q.PvtImageProcessor,Qwen2VLImageProcessor:()=>z.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>H.RTDetrImageProcessor,SamImageProcessor:()=>he.SamImageProcessor,SegformerFeatureExtractor:()=>Ce.SegformerFeatureExtractor,SegformerImageProcessor:()=>Ce.SegformerImageProcessor,SiglipImageProcessor:()=>oe.SiglipImageProcessor,SmolVLMImageProcessor:()=>K.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>Q.Swin2SRImageProcessor,VLMImageProcessor:()=>y.VLMImageProcessor,ViTFeatureExtractor:()=>de.ViTFeatureExtractor,ViTImageProcessor:()=>de.ViTImageProcessor,VitMatteImageProcessor:()=>ue.VitMatteImageProcessor,VitPoseImageProcessor:()=>Ze.VitPoseImageProcessor,YolosFeatureExtractor:()=>Pt.YolosFeatureExtractor,YolosImageProcessor:()=>Pt.YolosImageProcessor});var s=t("./src/models/beit/image_processing_beit.js"),a=t("./src/models/bit/image_processing_bit.js"),c=t("./src/models/chinese_clip/image_processing_chinese_clip.js"),l=t("./src/models/clip/image_processing_clip.js"),_=t("./src/models/convnext/image_processing_convnext.js"),m=t("./src/models/deit/image_processing_deit.js"),d=t("./src/models/detr/image_processing_detr.js"),h=t("./src/models/dinov3_vit/image_processing_dinov3_vit.js"),i=t("./src/models/donut/image_processing_donut.js"),r=t("./src/models/dpt/image_processing_dpt.js"),u=t("./src/models/efficientnet/image_processing_efficientnet.js"),f=t("./src/models/glpn/image_processing_glpn.js"),g=t("./src/models/grounding_dino/image_processing_grounding_dino.js"),w=t("./src/models/idefics3/image_processing_idefics3.js"),y=t("./src/models/janus/image_processing_janus.js"),x=t("./src/models/jina_clip/image_processing_jina_clip.js"),S=t("./src/models/llava_onevision/image_processing_llava_onevision.js"),T=t("./src/models/mask2former/image_processing_mask2former.js"),E=t("./src/models/maskformer/image_processing_maskformer.js"),A=t("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),C=t("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),I=t("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),D=t("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),R=t("./src/models/mobilevit/image_processing_mobilevit.js"),Y=t("./src/models/nougat/image_processing_nougat.js"),re=t("./src/models/owlv2/image_processing_owlv2.js"),G=t("./src/models/owlvit/image_processing_owlvit.js"),te=t("./src/models/phi3_v/image_processing_phi3_v.js"),q=t("./src/models/pvt/image_processing_pvt.js"),z=t("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),H=t("./src/models/rt_detr/image_processing_rt_detr.js"),he=t("./src/models/sam/image_processing_sam.js"),Ce=t("./src/models/segformer/image_processing_segformer.js"),oe=t("./src/models/siglip/image_processing_siglip.js"),K=t("./src/models/smolvlm/image_processing_smolvlm.js"),Q=t("./src/models/swin2sr/image_processing_swin2sr.js"),de=t("./src/models/vit/image_processing_vit.js"),ue=t("./src/models/vitmatte/image_processing_vitmatte.js"),Ze=t("./src/models/vitpose/image_processing_vitpose.js"),Pt=t("./src/models/yolos/image_processing_yolos.js")}),"./src/models/janus/image_processing_janus.js":((n,e,t)=>{t.r(e),t.d(e,{VLMImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{constructor(l){super({do_pad:!0,pad_size:{width:l.image_size,height:l.image_size},...l}),this.constant_values=this.config.background_color.map(_=>_*this.rescale_factor)}pad_image(l,_,m,d){return super.pad_image(l,_,m,{constant_values:this.constant_values,center:!0,...d})}}}),"./src/models/janus/processing_janus.js":((n,e,t)=>{t.r(e),t.d(e,{VLChatProcessor:()=>d});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js"),l=t("./src/utils/core.js"),_=t("./src/utils/tensor.js"),m=t("./src/utils/image.js");class d extends s.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=c.AutoTokenizer;static uses_processor_config=!0;constructor(i,r,u){super(i,r,u),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(i,{images:r=null,chat_template:u="default"}={}){r?Array.isArray(r)||(r=[r]):r=await Promise.all(i.filter(R=>R.images).flatMap(R=>R.images).map(R=>m.RawImage.read(R)));const f=this.tokenizer,g=f.apply_chat_template(i,{tokenize:!1,add_generation_prompt:!0,chat_template:u}),w=R=>f.encode(R,{add_special_tokens:!1}),y=g.split(this.image_tag),x=y.length-1;if(r.length!==x)throw new Error(`Number of images provided (${r.length}) does not match number of "${this.image_tag}" image tags (${x})`);const[S,T,E]=f.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let A=w(y[0]),C=new Array(A.length).fill(!1);for(let R=1;R<y.length;++R){const Y=new Array(this.num_image_tokens).fill(S),re=w(y[R]);A=(0,l.mergeArrays)(A,[T],Y,[E],re);const G=new Array(this.num_image_tokens).fill(!0);C=(0,l.mergeArrays)(C,[!1],G,[!1],new Array(re.length).fill(!1))}const I=[1,A.length],D={input_ids:new _.Tensor("int64",A,I),attention_mask:new _.Tensor("int64",new Array(A.length).fill(1),I),images_seq_mask:new _.Tensor("bool",C,I),images_emb_mask:new _.Tensor("bool",new Array(x*this.num_image_tokens).fill(!0),[1,x,this.num_image_tokens])};if(r&&r.length>0){const R=await this.image_processor(r);return R.pixel_values.unsqueeze_(0),{...D,...R}}return D}}}),"./src/models/jina_clip/image_processing_jina_clip.js":((n,e,t)=>{t.r(e),t.d(e,{JinaCLIPImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{constructor(l){const{resize_mode:_,fill_color:m,interpolation:d,size:h,...i}=l,r=_==="squash"?{width:h,height:h}:_==="shortest"?{shortest_edge:h}:{longest_edge:h},u=d==="bicubic"?3:2;super({...i,size:r,resample:u,do_center_crop:!0,crop_size:h,do_normalize:!0})}}}),"./src/models/jina_clip/processing_jina_clip.js":((n,e,t)=>{t.r(e),t.d(e,{JinaCLIPProcessor:()=>l});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");class l extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;async _call(m=null,d=null,h={}){if(!m&&!d)throw new Error("Either text or images must be provided");const i=m?this.tokenizer(m,h):{},r=d?await this.image_processor(d,h):{};return{...i,...r}}}}),"./src/models/llava/processing_llava.js":((n,e,t)=>{t.r(e),t.d(e,{LlavaProcessor:()=>l});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");class l extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;static uses_processor_config=!0;async _call(m,d=null,h={}){const i=await this.image_processor(m,h);if(d){const[u,f]=i.pixel_values.dims.slice(-2),{image_token:g,patch_size:w,num_additional_image_tokens:y}=this.config,x=Math.floor(u/w)*Math.floor(f/w)+y;d=structuredClone(d),Array.isArray(d)||(d=[d]);for(let S=0;S<d.length;++S)d[S]=d[S].replace(g,g.repeat(x))}const r=d?this.tokenizer(d,h):{};return{...i,...r}}}}),"./src/models/llava_onevision/image_processing_llava_onevision.js":((n,e,t)=>{t.r(e),t.d(e,{LlavaOnevisionImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/mask2former/image_processing_mask2former.js":((n,e,t)=>{t.r(e),t.d(e,{Mask2FormerImageProcessor:()=>a});var s=t("./src/models/maskformer/image_processing_maskformer.js");class a extends s.MaskFormerImageProcessor{}}),"./src/models/maskformer/image_processing_maskformer.js":((n,e,t)=>{t.r(e),t.d(e,{MaskFormerFeatureExtractor:()=>c,MaskFormerImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{post_process_panoptic_segmentation(..._){return(0,s.post_process_panoptic_segmentation)(..._)}post_process_instance_segmentation(..._){return(0,s.post_process_instance_segmentation)(..._)}}class c extends a{}}),"./src/models/mgp_str/processing_mgp_str.js":((n,e,t)=>{t.r(e),t.d(e,{MgpstrProcessor:()=>m});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js"),l=t("./src/utils/maths.js");const _={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class m extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(h,i){if(!_.hasOwnProperty(i))throw new Error(`Format ${i} is not supported.`);const[r,u]=_[i],f=this[r].bind(this),[g,w]=h.dims,y=[],x=[],S=h.tolist();for(let E=0;E<g;++E){const A=S[E],C=[],I=[];for(let R=1;R<w;++R){const[Y,re]=(0,l.max)((0,l.softmax)(A[R]));if(I.push(Y),re==u)break;C.push(re)}const D=I.length>0?I.reduce((R,Y)=>R*Y,1):0;x.push(C),y.push(D)}return[f(x),y]}char_decode(h){return this.char_tokenizer.batch_decode(h).map(i=>i.replaceAll(" ",""))}bpe_decode(h){return this.bpe_tokenizer.batch_decode(h)}wp_decode(h){return this.wp_tokenizer.batch_decode(h).map(i=>i.replaceAll(" ",""))}batch_decode([h,i,r]){const[u,f]=this._decode_helper(h,"char"),[g,w]=this._decode_helper(i,"bpe"),[y,x]=this._decode_helper(r,"wp"),S=[],T=[];for(let E=0;E<u.length;++E){const[A,C]=(0,l.max)([f[E],w[E],x[E]]);S.push([u[E],g[E],y[E]][C]),T.push(A)}return{generated_text:S,scores:T,char_preds:u,bpe_preds:g,wp_preds:y}}static async from_pretrained(...h){const i=await super.from_pretrained(...h),r=await c.AutoTokenizer.from_pretrained("Xenova/gpt2"),u=await c.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return i.components={image_processor:i.image_processor,char_tokenizer:i.tokenizer,bpe_tokenizer:r,wp_tokenizer:u},i}async _call(h,i=null){const r=await this.image_processor(h);return i&&(r.labels=this.tokenizer(i).input_ids),r}}}),"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV1FeatureExtractor:()=>c,MobileNetV1ImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV2FeatureExtractor:()=>c,MobileNetV2ImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV3FeatureExtractor:()=>c,MobileNetV3ImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV4FeatureExtractor:()=>c,MobileNetV4ImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/mobilevit/image_processing_mobilevit.js":((n,e,t)=>{t.r(e),t.d(e,{MobileViTFeatureExtractor:()=>c,MobileViTImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/moonshine/feature_extraction_moonshine.js":((n,e,t)=>{t.r(e),t.d(e,{MoonshineFeatureExtractor:()=>c});var s=t("./src/base/feature_extraction_utils.js"),a=t("./src/utils/tensor.js");class c extends s.FeatureExtractor{async _call(_){(0,s.validate_audio_inputs)(_,"MoonshineFeatureExtractor"),_ instanceof Float64Array&&(_=new Float32Array(_));const m=[1,_.length];return{input_values:new a.Tensor("float32",_,m)}}}}),"./src/models/moonshine/processing_moonshine.js":((n,e,t)=>{t.r(e),t.d(e,{MoonshineProcessor:()=>l});var s=t("./src/models/auto/feature_extraction_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/base/processing_utils.js");class l extends c.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(m){return await this.feature_extractor(m)}}}),"./src/models/nougat/image_processing_nougat.js":((n,e,t)=>{t.r(e),t.d(e,{NougatImageProcessor:()=>a});var s=t("./src/models/donut/image_processing_donut.js");class a extends s.DonutImageProcessor{}}),"./src/models/owlv2/image_processing_owlv2.js":((n,e,t)=>{t.r(e),t.d(e,{Owlv2ImageProcessor:()=>a});var s=t("./src/models/owlvit/image_processing_owlvit.js");class a extends s.OwlViTImageProcessor{}}),"./src/models/owlvit/image_processing_owlvit.js":((n,e,t)=>{t.r(e),t.d(e,{OwlViTFeatureExtractor:()=>c,OwlViTImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{post_process_object_detection(..._){return(0,s.post_process_object_detection)(..._)}}class c extends a{}}),"./src/models/owlvit/processing_owlvit.js":((n,e,t)=>{t.r(e),t.d(e,{OwlViTProcessor:()=>l});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");class l extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor}}),"./src/models/paligemma/processing_paligemma.js":((n,e,t)=>{t.r(e),t.d(e,{PaliGemmaProcessor:()=>m});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");const l="<image>";function _(d,h,i,r,u){return`${r.repeat(i*u)}${h}${d}
`}class m extends s.Processor{static tokenizer_class=c.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;static uses_processor_config=!1;async _call(h,i=null,r={}){i||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),i=""),Array.isArray(h)||(h=[h]),Array.isArray(i)||(i=[i]);const u=this.tokenizer.bos_token,f=this.image_processor.config.image_seq_length;let g;i.some(x=>x.includes(l))?g=i.map(x=>{const S=x.replaceAll(l,l.repeat(f)),T=S.lastIndexOf(l),E=T===-1?0:T+l.length;return S.slice(0,E)+u+S.slice(E)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),g=i.map(x=>_(x,u,f,l,h.length)));const w=this.tokenizer(g,r);return{...await this.image_processor(h,r),...w}}}}),"./src/models/phi3_v/image_processing_phi3_v.js":((n,e,t)=>{t.r(e),t.d(e,{Phi3VImageProcessor:()=>h});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/tensor.js");const c=336,l=[2,3],{ceil:_,floor:m,sqrt:d}=Math;class h extends s.ImageProcessor{constructor(r){super({...r,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=r.num_crops}calc_num_image_tokens_from_image_size(r,u){const{num_img_tokens:f}=this.config;return m((m(u/c)*m(r/c)+1)*f+1+(m(u/c)+1)*d(f))}get_resize_output_image_size(r,u){const f=this._num_crops,[g,w]=r.size;let y=g/w,x=1;for(;x*Math.ceil(x/y)<=f;)x+=1;x-=1;const S=Math.floor(x*336),T=Math.floor(S/y);return[S,T]}pad_image(r,u,f,g={}){const[w,y]=u,x=c*_(w/c),S=c*_(y/c),T=[1,1,1].map((E,A)=>(E-this.image_mean[A])/this.image_std[A]);return super.pad_image(r,u,{width:S,height:x},{center:!0,constant_values:T,...g})}async _call(r,{num_crops:u=null}={}){if(this._num_crops=u??=this.config.num_crops,u<4||d(u)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(r)||(r=[r]);const f=r.length,g=await Promise.all(r.map(C=>this.preprocess(C))),w=g.map(C=>C.original_size),y=g.map(C=>C.reshaped_input_size),x=[];for(const{pixel_values:C}of g){C.unsqueeze_(0);const[I,D]=C.dims.slice(-2),R=await(0,a.interpolate_4d)(C,{size:[c,c],mode:"bicubic"});if(u>0){const Y=[],re=d(u),G=m(D/re),te=m(I/re);for(let z=0;z<re;++z)for(let H=0;H<re;++H){let he,Ce,oe,K;z===re-1?(Ce=I-te,K=I):(Ce=z*te,K=(z+1)*te),H===re-1?(he=D-G,oe=D):(he=H*G,oe=(H+1)*G);const Q=[Ce,he],de=[K,oe],ue=await(0,a.slice)(C,Q,de,l);Y.push(ue)}const q=await(0,a.interpolate_4d)((0,a.cat)(Y,0),{size:[c,c],mode:"bicubic"});x.push((0,a.cat)([R,q],0))}else x.push(R)}const S=(0,a.stack)(x,0),T=y.map(C=>C.map(I=>c*_(I/c))),E=new a.Tensor("int64",T.flat(),[f,2]),A=T.map(([C,I])=>this.calc_num_image_tokens_from_image_size(I,C));return{pixel_values:S,original_sizes:w,reshaped_input_sizes:y,image_sizes:E,num_img_tokens:A}}}}),"./src/models/phi3_v/processing_phi3_v.js":((n,e,t)=>{t.r(e),t.d(e,{Phi3VProcessor:()=>m});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");t("./src/utils/image.js");const l="<|image|>",_=/<\|image_\d+\|>/g;class m extends s.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=c.AutoTokenizer;async _call(h,i=null,{padding:r=!0,truncation:u=!0,num_crops:f=null}={}){Array.isArray(h)||(h=[h]);let g,w;if(i){w=await this.image_processor(i,{num_crops:f});const{num_img_tokens:y}=w,x=h.map((T,E)=>T.split(_).join(l.repeat(y[E])));g=this.tokenizer(x,{padding:r,truncation:u});const S=this.tokenizer.model.convert_tokens_to_ids([l])[0];g.input_ids.map_(T=>T==S?-T:T)}else g=this.tokenizer(h);return{...g,...w}}}}),"./src/models/processors.js":((n,e,t)=>{t.r(e),t.d(e,{Florence2Processor:()=>s.Florence2Processor,Gemma3nProcessor:()=>a.Gemma3nProcessor,GroundingDinoProcessor:()=>c.GroundingDinoProcessor,Idefics3Processor:()=>l.Idefics3Processor,JinaCLIPProcessor:()=>m.JinaCLIPProcessor,LlavaProcessor:()=>d.LlavaProcessor,MgpstrProcessor:()=>h.MgpstrProcessor,MoonshineProcessor:()=>i.MoonshineProcessor,OwlViTProcessor:()=>r.OwlViTProcessor,PaliGemmaProcessor:()=>f.PaliGemmaProcessor,Phi3VProcessor:()=>u.Phi3VProcessor,PyAnnoteProcessor:()=>g.PyAnnoteProcessor,Qwen2VLProcessor:()=>w.Qwen2VLProcessor,SamProcessor:()=>y.SamProcessor,SmolVLMProcessor:()=>x.SmolVLMProcessor,SpeechT5Processor:()=>S.SpeechT5Processor,UltravoxProcessor:()=>T.UltravoxProcessor,VLChatProcessor:()=>_.VLChatProcessor,VoxtralProcessor:()=>E.VoxtralProcessor,Wav2Vec2Processor:()=>A.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>C.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>I.WhisperProcessor});var s=t("./src/models/florence2/processing_florence2.js"),a=t("./src/models/gemma3n/processing_gemma3n.js"),c=t("./src/models/grounding_dino/processing_grounding_dino.js"),l=t("./src/models/idefics3/processing_idefics3.js"),_=t("./src/models/janus/processing_janus.js"),m=t("./src/models/jina_clip/processing_jina_clip.js"),d=t("./src/models/llava/processing_llava.js"),h=t("./src/models/mgp_str/processing_mgp_str.js"),i=t("./src/models/moonshine/processing_moonshine.js"),r=t("./src/models/owlvit/processing_owlvit.js"),u=t("./src/models/phi3_v/processing_phi3_v.js"),f=t("./src/models/paligemma/processing_paligemma.js"),g=t("./src/models/pyannote/processing_pyannote.js"),w=t("./src/models/qwen2_vl/processing_qwen2_vl.js"),y=t("./src/models/sam/processing_sam.js"),x=t("./src/models/smolvlm/processing_smolvlm.js"),S=t("./src/models/speecht5/processing_speecht5.js"),T=t("./src/models/ultravox/processing_ultravox.js"),E=t("./src/models/voxtral/processing_voxtral.js"),A=t("./src/models/wav2vec2/processing_wav2vec2.js"),C=t("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),I=t("./src/models/whisper/processing_whisper.js")}),"./src/models/pvt/image_processing_pvt.js":((n,e,t)=>{t.r(e),t.d(e,{PvtImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/pyannote/feature_extraction_pyannote.js":((n,e,t)=>{t.r(e),t.d(e,{PyAnnoteFeatureExtractor:()=>l});var s=t("./src/base/feature_extraction_utils.js"),a=t("./src/utils/tensor.js"),c=t("./src/utils/maths.js");class l extends s.FeatureExtractor{async _call(m){(0,s.validate_audio_inputs)(m,"PyAnnoteFeatureExtractor"),m instanceof Float64Array&&(m=new Float32Array(m));const d=[1,1,m.length];return{input_values:new a.Tensor("float32",m,d)}}samples_to_frames(m){return(m-this.config.offset)/this.config.step}post_process_speaker_diarization(m,d){const h=d/this.samples_to_frames(d)/this.config.sampling_rate,i=[];for(const r of m.tolist()){const u=[];let f=-1;for(let g=0;g<r.length;++g){const w=(0,c.softmax)(r[g]),[y,x]=(0,c.max)(w),[S,T]=[g,g+1];x!==f?(f=x,u.push({id:x,start:S,end:T,score:y})):(u.at(-1).end=T,u.at(-1).score+=y)}i.push(u.map(({id:g,start:w,end:y,score:x})=>({id:g,start:w*h,end:y*h,confidence:x/(y-w)})))}return i}}}),"./src/models/pyannote/processing_pyannote.js":((n,e,t)=>{t.r(e),t.d(e,{PyAnnoteProcessor:()=>c});var s=t("./src/base/processing_utils.js"),a=t("./src/models/pyannote/feature_extraction_pyannote.js");class c extends s.Processor{static feature_extractor_class=a.PyAnnoteFeatureExtractor;async _call(_){return await this.feature_extractor(_)}post_process_speaker_diarization(..._){return this.feature_extractor.post_process_speaker_diarization(..._)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}}),"./src/models/qwen2_vl/image_processing_qwen2_vl.js":((n,e,t)=>{t.r(e),t.d(e,{Qwen2VLImageProcessor:()=>c});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/tensor.js");class c extends s.ImageProcessor{async _call(_,...m){const{pixel_values:d,original_sizes:h,reshaped_input_sizes:i}=await super._call(_,...m);let r=d;const{temporal_patch_size:u,merge_size:f,patch_size:g}=this.config;r.dims[0]===1&&(r=(0,a.cat)(Array.from({length:u},()=>r),0));const w=r.dims[0]/u,y=r.dims[1],x=Math.floor(r.dims[2]/g),S=Math.floor(r.dims[3]/g),T=r.view(w,u,y,Math.floor(x/f),f,g,Math.floor(S/f),f,g).permute(0,3,6,4,7,2,1,5,8).view(w*x*S,y*u*g*g),E=new a.Tensor("int64",[w,x,S],[1,3]);return{pixel_values:T,image_grid_thw:E,original_sizes:h,reshaped_input_sizes:i}}}}),"./src/models/qwen2_vl/processing_qwen2_vl.js":((n,e,t)=>{t.r(e),t.d(e,{Qwen2VLProcessor:()=>l});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js"),c=t("./src/tokenizers.js");t("./src/utils/image.js");class l extends s.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=c.AutoTokenizer;async _call(m,d=null,...h){Array.isArray(m)||(m=[m]);let i,r;if(d&&(i=await this.image_processor(d),r=i.image_grid_thw),r){let f=this.image_processor.config.merge_size**2,g=0;const w=r.tolist();m=m.map(y=>{for(;y.includes("<|image_pad|>");){const x=Number(w[g++].reduce((S,T)=>S*T,1n));y=y.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(x/f)))}return y.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(m),...i}}}}),"./src/models/rt_detr/image_processing_rt_detr.js":((n,e,t)=>{t.r(e),t.d(e,{RTDetrImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{post_process_object_detection(...l){return(0,s.post_process_object_detection)(...l)}}}),"./src/models/sam/image_processing_sam.js":((n,e,t)=>{t.r(e),t.d(e,{SamImageProcessor:()=>l});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/core.js"),c=t("./src/utils/tensor.js");class l extends s.ImageProcessor{reshape_input_points(m,d,h,i=!1){m=structuredClone(m);let r=(0,a.calculateDimensions)(m);if(r.length===3)i||(r=[1,...r]),m=[m];else if(r.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let u=0;u<m.length;++u){let f=d[u],g=h[u],w=[g[0]/f[0],g[1]/f[1]];for(let y=0;y<m[u].length;++y)for(let x=0;x<m[u][y].length;++x)for(let S=0;S<m[u][y][x].length;++S)m[u][y][x][S]*=w[S%2]}return new c.Tensor("float32",Float32Array.from(m.flat(1/0)),r)}add_input_labels(m,d){let h=(0,a.calculateDimensions)(m);if(h.length===2)h=[1,...h],m=[m];else if(h.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(h.some((i,r)=>i!==d.dims[r]))throw Error(`The first ${h.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new c.Tensor("int64",m.flat(1/0).map(BigInt),h)}async _call(m,{input_points:d=null,input_labels:h=null,input_boxes:i=null}={}){const r=await super._call(m);if(d&&(r.input_points=this.reshape_input_points(d,r.original_sizes,r.reshaped_input_sizes)),h){if(!r.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");r.input_labels=this.add_input_labels(h,r.input_points)}return i&&(r.input_boxes=this.reshape_input_points(i,r.original_sizes,r.reshaped_input_sizes,!0)),r}async post_process_masks(m,d,h,{mask_threshold:i=0,binarize:r=!0,pad_size:u=null}={}){const f=[];u=u??this.pad_size;const g=[u.height,u.width];for(let w=0;w<d.length;++w){const y=d[w],x=h[w];let S=await(0,c.interpolate_4d)(m[w],{mode:"bilinear",size:g});if(S=S.slice(null,null,[0,x[0]],[0,x[1]]),S=await(0,c.interpolate_4d)(S,{mode:"bilinear",size:y}),r){const T=S.data,E=new Uint8Array(T.length);for(let A=0;A<T.length;++A)T[A]>i&&(E[A]=1);S=new c.Tensor("bool",E,S.dims)}f.push(S)}return f}generate_crop_boxes(m,d,{crop_n_layers:h=0,overlap_ratio:i=512/1500,points_per_crop:r=32,crop_n_points_downscale_factor:u=1}={}){}}}),"./src/models/sam/processing_sam.js":((n,e,t)=>{t.r(e),t.d(e,{SamProcessor:()=>c});var s=t("./src/base/processing_utils.js"),a=t("./src/models/auto/image_processing_auto.js");class c extends s.Processor{static image_processor_class=a.AutoImageProcessor;async _call(..._){return await this.image_processor(..._)}post_process_masks(..._){return this.image_processor.post_process_masks(..._)}reshape_input_points(..._){return this.image_processor.reshape_input_points(..._)}}}),"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":((n,e,t)=>{t.r(e),t.d(e,{SeamlessM4TFeatureExtractor:()=>l});var s=t("./src/base/feature_extraction_utils.js"),a=t("./src/utils/tensor.js"),c=t("./src/utils/audio.js");class l extends s.FeatureExtractor{constructor(m){super(m);const d=this.config.sampling_rate,h=(0,c.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(d/2),d,null,"kaldi",!0);this.mel_filters=h,this.window=(0,c.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(m,d){return m=m.map(h=>h*32768),(0,c.spectrogram)(m,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:d,transpose:!0})}async _call(m,{padding:d=!0,pad_to_multiple_of:h=2,do_normalize_per_mel_bins:i=!0,return_attention_mask:r=!0}={}){(0,s.validate_audio_inputs)(m,"SeamlessM4TFeatureExtractor");let u=await this._extract_fbank_features(m,this.config.max_length);if(i){const[E,A]=u.dims,C=u.data;for(let I=0;I<A;++I){let D=0;for(let G=0;G<E;++G)D+=C[G*A+I];const R=D/E;let Y=0;for(let G=0;G<E;++G)Y+=(C[G*A+I]-R)**2;Y/=E-1;const re=Math.sqrt(Y+1e-7);for(let G=0;G<E;++G){const te=G*A+I;C[te]=(C[te]-R)/re}}}let f;if(d){const[E,A]=u.dims,C=u.data,I=E%h;if(I>0){const D=new Float32Array(A*(E+I));D.set(C),D.fill(this.config.padding_value,C.length);const R=E+I;u=new a.Tensor(u.type,D,[R,A]),r&&(f=new a.Tensor("int64",new BigInt64Array(R),[1,R]),f.data.fill(1n,0,E))}}const[g,w]=u.dims,y=this.config.stride;if(g%y!==0)throw new Error(`The number of frames (${g}) must be a multiple of the stride (${y}).`);const S=u.view(1,Math.floor(g/y),w*y),T={input_features:S};if(r){const E=S.dims[1],A=new BigInt64Array(E);if(f){const C=f.data;for(let I=1,D=0;I<g;I+=y,++D)A[D]=C[I]}else A.fill(1n);T.attention_mask=new a.Tensor("int64",A,[1,E])}return T}}}),"./src/models/segformer/image_processing_segformer.js":((n,e,t)=>{t.r(e),t.d(e,{SegformerFeatureExtractor:()=>c,SegformerImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{post_process_semantic_segmentation(..._){return(0,s.post_process_semantic_segmentation)(..._)}}class c extends a{}}),"./src/models/siglip/image_processing_siglip.js":((n,e,t)=>{t.r(e),t.d(e,{SiglipImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}}),"./src/models/smolvlm/image_processing_smolvlm.js":((n,e,t)=>{t.r(e),t.d(e,{SmolVLMImageProcessor:()=>s.Idefics3ImageProcessor});var s=t("./src/models/idefics3/image_processing_idefics3.js")}),"./src/models/smolvlm/processing_smolvlm.js":((n,e,t)=>{t.r(e),t.d(e,{SmolVLMProcessor:()=>s.Idefics3Processor});var s=t("./src/models/idefics3/processing_idefics3.js")}),"./src/models/snac/feature_extraction_snac.js":((n,e,t)=>{t.r(e),t.d(e,{SnacFeatureExtractor:()=>a});var s=t("./src/models/dac/feature_extraction_dac.js");class a extends s.DacFeatureExtractor{}}),"./src/models/speecht5/feature_extraction_speecht5.js":((n,e,t)=>{t.r(e),t.d(e,{SpeechT5FeatureExtractor:()=>a});var s=t("./src/base/feature_extraction_utils.js");class a extends s.FeatureExtractor{}}),"./src/models/speecht5/processing_speecht5.js":((n,e,t)=>{t.r(e),t.d(e,{SpeechT5Processor:()=>l});var s=t("./src/base/processing_utils.js"),a=t("./src/tokenizers.js"),c=t("./src/models/auto/feature_extraction_auto.js");class l extends s.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=c.AutoFeatureExtractor;async _call(m){return await this.feature_extractor(m)}}}),"./src/models/swin2sr/image_processing_swin2sr.js":((n,e,t)=>{t.r(e),t.d(e,{Swin2SRImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{pad_image(l,_,m,d={}){const[h,i,r]=_;return super.pad_image(l,_,{width:i+(m-i%m)%m,height:h+(m-h%m)%m},{mode:"symmetric",center:!1,constant_values:-1,...d})}}}),"./src/models/ultravox/processing_ultravox.js":((n,e,t)=>{t.r(e),t.d(e,{UltravoxProcessor:()=>l});var s=t("./src/models/auto/feature_extraction_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/base/processing_utils.js");class l extends c.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;static uses_processor_config=!0;async _call(m,d=null,h={}){if(Array.isArray(m))throw new Error("Batched inputs are not supported yet.");let i={};if(d){const u=d.length,{input_features:f}=await this.feature_extractor(d,{...h,max_length:u}),g=Math.round(u/this.config.encoder_ds_factor+1e-4),w=1+Math.ceil(g/this.config.stack_factor);i.audio_token_len=[w],i.audio_values=f;const y=this.config.audio_placeholder;if(!m.includes(y))throw new Error(`The input text does not contain the image token ${y}.`);m=m.replaceAll(y,y.repeat(w))}return{...this.tokenizer(m,{add_special_tokens:!1,...h}),...i}}}}),"./src/models/vit/image_processing_vit.js":((n,e,t)=>{t.r(e),t.d(e,{ViTFeatureExtractor:()=>c,ViTImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{}class c extends a{}}),"./src/models/vitmatte/image_processing_vitmatte.js":((n,e,t)=>{t.r(e),t.d(e,{VitMatteImageProcessor:()=>c});var s=t("./src/base/image_processors_utils.js"),a=t("./src/utils/tensor.js");class c extends s.ImageProcessor{async _call(_,m){Array.isArray(_)||(_=[_]),Array.isArray(m)||(m=[m]);const d=await Promise.all(_.map(r=>this.preprocess(r))),h=await Promise.all(m.map(r=>this.preprocess(r,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,a.stack)(d.map((r,u)=>(0,a.cat)([r.pixel_values,h[u].pixel_values],0)),0),original_sizes:d.map(r=>r.original_size),reshaped_input_sizes:d.map(r=>r.reshaped_input_size)}}}}),"./src/models/vitpose/image_processing_vitpose.js":((n,e,t)=>{t.r(e),t.d(e,{VitPoseImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{post_process_pose_estimation(l,_,{threshold:m=null}={}){const d=l.tolist(),[h,i,r,u]=l.dims,f=[];for(let g=0;g<h;++g){const w=d[g],y=_[g],x=[];for(let S=0;S<y.length;++S){const T=y[S],E=[],A=[],C=[],I=T.at(-2)/u,D=T.at(-1)/r;for(let R=0;R<w.length;++R){let[Y,re]=[0,0],G=0,te=-1/0;const q=w[R];for(let H=0;H<q.length;++H){const he=q[H];for(let Ce=0;Ce<he.length;++Ce){const oe=he[Ce];G+=oe,te=Math.max(te,oe),Y+=(Ce+.5)*oe,re+=H*oe}}if(m!=null&&te<m)continue;const z=[I*Y/G,D*re/G];E.push(z),C.push(R),A.push(te)}x.push({bbox:T,scores:A,labels:C,keypoints:E})}f.push(x)}return f}}}),"./src/models/voxtral/processing_voxtral.js":((n,e,t)=>{t.r(e),t.d(e,{VoxtralProcessor:()=>i});var s=t("./src/models/auto/feature_extraction_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/base/processing_utils.js"),l=t("./src/utils/tensor.js");const _="[AUDIO]",m="[BEGIN_AUDIO]",d=375;function h(r,u){const f=[];for(let g=0;g<r.length;g+=u)f.push(r.subarray(g,Math.min(g+u,r.length)));return f}class i extends c.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;static uses_processor_config=!1;async _call(u,f=null,g={}){if(Array.isArray(u))throw new Error("Batched inputs are not supported yet.");const w={};if(f){if(!u.includes(_))throw new Error(`The input text does not contain the audio token ${_}.`);Array.isArray(f)||(f=[f]);const x=u.split(_),S=x.length-1;if(S!==f.length)throw new Error(`The number of audio inputs (${f.length}) does not match the number of audio tokens in the text (${S}).`);const T=this.feature_extractor.config.n_samples,E=f.map(R=>h(R,T)),A=E.map(R=>R.length),C=E.flat(),I=(await Promise.all(C.map(R=>this.feature_extractor(R,g)))).map(R=>R.input_features);w.audio_values=I.length>1?(0,l.cat)(I,0):I[0];let D=x[0];for(let R=0;R<A.length;++R){D+=m;for(let Y=0;Y<A[R];++Y)D+=_.repeat(d);D+=x[R+1]}u=D}return{...this.tokenizer(u,{add_special_tokens:!1,...g}),...w}}}}),"./src/models/wav2vec2/feature_extraction_wav2vec2.js":((n,e,t)=>{t.r(e),t.d(e,{Wav2Vec2FeatureExtractor:()=>c});var s=t("./src/base/feature_extraction_utils.js"),a=t("./src/utils/tensor.js");class c extends s.FeatureExtractor{_zero_mean_unit_var_norm(_){const d=_.reduce((i,r)=>i+r,0)/_.length,h=_.reduce((i,r)=>i+(r-d)**2,0)/_.length;return _.map(i=>(i-d)/Math.sqrt(h+1e-7))}async _call(_){(0,s.validate_audio_inputs)(_,"Wav2Vec2FeatureExtractor"),_ instanceof Float64Array&&(_=new Float32Array(_));let m=_;this.config.do_normalize&&(m=this._zero_mean_unit_var_norm(m));const d=[1,m.length];return{input_values:new a.Tensor("float32",m,d),attention_mask:new a.Tensor("int64",new BigInt64Array(m.length).fill(1n),d)}}}}),"./src/models/wav2vec2/processing_wav2vec2.js":((n,e,t)=>{t.r(e),t.d(e,{Wav2Vec2Processor:()=>l});var s=t("./src/tokenizers.js"),a=t("./src/models/auto/feature_extraction_auto.js"),c=t("./src/base/processing_utils.js");class l extends c.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(m){return await this.feature_extractor(m)}}}),"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":((n,e,t)=>{t.r(e),t.d(e,{Wav2Vec2ProcessorWithLM:()=>l});var s=t("./src/tokenizers.js"),a=t("./src/models/auto/feature_extraction_auto.js"),c=t("./src/base/processing_utils.js");class l extends c.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(m){return await this.feature_extractor(m)}}}),"./src/models/wespeaker/feature_extraction_wespeaker.js":((n,e,t)=>{t.r(e),t.d(e,{WeSpeakerFeatureExtractor:()=>c});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var a=t("./src/utils/audio.js");class c extends s.FeatureExtractor{constructor(_){super(_);const m=this.config.sampling_rate,d=(0,a.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(m/2),m,null,"kaldi",!0);this.mel_filters=d,this.window=(0,a.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(_){return _=_.map(m=>m*32768),(0,a.spectrogram)(_,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(_){(0,s.validate_audio_inputs)(_,"WeSpeakerFeatureExtractor");const m=(await this._extract_fbank_features(_)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const d=m.mean(1).data,h=m.data,[i,r,u]=m.dims;for(let f=0;f<i;++f){const g=f*r*u,w=f*u;for(let y=0;y<r;++y){const x=g+y*u;for(let S=0;S<u;++S)h[x+S]-=d[w+S]}}}return{input_features:m}}}}),"./src/models/whisper/common_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WHISPER_LANGUAGE_MAPPING:()=>a,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>c,whisper_language_to_code:()=>l});const s=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],a=new Map(s),c=new Map([...s.map(([_,m])=>[m,_]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function l(_){_=_.toLowerCase();let m=c.get(_);if(m===void 0){const d=_.match(/^<\|([a-z]{2})\|>$/);if(d&&(_=d[1]),a.has(_))m=_;else{const i=_.length===2?a.keys():a.values();throw new Error(`Language "${_}" is not supported. Must be one of: ${JSON.stringify(Array.from(i))}`)}}return m}}),"./src/models/whisper/feature_extraction_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WhisperFeatureExtractor:()=>l});var s=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var a=t("./src/utils/audio.js"),c=t("./src/utils/maths.js");class l extends s.FeatureExtractor{constructor(m){super(m),this.config.mel_filters??=(0,a.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,a.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(m){const d=await(0,a.spectrogram)(m,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(m.length/this.config.hop_length),this.config.nb_max_frames)}),h=d.data,i=(0,c.max)(h)[0];for(let r=0;r<h.length;++r)h[r]=(Math.max(h[r],i-8)+4)/4;return d}async _call(m,{max_length:d=null}={}){(0,s.validate_audio_inputs)(m,"WhisperFeatureExtractor");let h;const i=d??this.config.n_samples;return m.length>i?(m.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),h=m.slice(0,i)):(h=new Float32Array(i),h.set(m)),{input_features:(await this._extract_fbank_features(h)).unsqueeze_(0)}}}}),"./src/models/whisper/generation_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WhisperGenerationConfig:()=>a});var s=t("./src/generation/configuration_utils.js");class a extends s.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}}),"./src/models/whisper/processing_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WhisperProcessor:()=>l});var s=t("./src/models/auto/feature_extraction_auto.js"),a=t("./src/tokenizers.js"),c=t("./src/base/processing_utils.js");class l extends c.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(m){return await this.feature_extractor(m)}}}),"./src/models/yolos/image_processing_yolos.js":((n,e,t)=>{t.r(e),t.d(e,{YolosFeatureExtractor:()=>c,YolosImageProcessor:()=>a});var s=t("./src/base/image_processors_utils.js");class a extends s.ImageProcessor{post_process_object_detection(..._){return(0,s.post_process_object_detection)(..._)}}class c extends a{}}),"./src/ops/registry.js":((n,e,t)=>{t.r(e),t.d(e,{TensorOpRegistry:()=>m});var s=t("./src/backends/onnx.js"),a=t("./src/utils/tensor.js"),c=t("./src/env.js");const l=c.apis.IS_BROWSER_ENV||c.apis.IS_WEBWORKER_ENV,_=async(d,h,i)=>{const r=await(0,s.createInferenceSession)(new Uint8Array(d),h);let u=Promise.resolve();return(async f=>{const g=(0,s.isONNXProxy)(),w=Object.fromEntries(Object.entries(f).map(([x,S])=>[x,(g?S.clone():S).ort_tensor])),y=await(u=l?u.then(()=>r.run(w)):r.run(w));return Array.isArray(i)?i.map(x=>new a.Tensor(y[x])):new a.Tensor(y[i])})};class m{static session_options={};static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=_([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=_([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=_([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=_([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=_([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=_([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=_([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=_([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}}),"./src/pipelines.js":((n,e,t)=>{t.r(e),t.d(e,{AudioClassificationPipeline:()=>re,AutomaticSpeechRecognitionPipeline:()=>te,BackgroundRemovalPipeline:()=>he,DepthEstimationPipeline:()=>Ze,DocumentQuestionAnsweringPipeline:()=>Q,FeatureExtractionPipeline:()=>R,FillMaskPipeline:()=>S,ImageClassificationPipeline:()=>z,ImageFeatureExtractionPipeline:()=>Y,ImageSegmentationPipeline:()=>H,ImageToImagePipeline:()=>ue,ImageToTextPipeline:()=>q,ObjectDetectionPipeline:()=>oe,Pipeline:()=>g,QuestionAnsweringPipeline:()=>x,SummarizationPipeline:()=>E,Text2TextGenerationPipeline:()=>T,TextClassificationPipeline:()=>w,TextGenerationPipeline:()=>I,TextToAudioPipeline:()=>de,TokenClassificationPipeline:()=>y,TranslationPipeline:()=>A,ZeroShotAudioClassificationPipeline:()=>G,ZeroShotClassificationPipeline:()=>D,ZeroShotImageClassificationPipeline:()=>Ce,ZeroShotObjectDetectionPipeline:()=>K,pipeline:()=>bn});var s=t("./src/tokenizers.js"),a=t("./src/models.js"),c=t("./src/models/auto/processing_auto.js");t("./src/base/processing_utils.js");var l=t("./src/utils/generic.js"),_=t("./src/utils/core.js"),m=t("./src/utils/maths.js"),d=t("./src/utils/audio.js"),h=t("./src/utils/tensor.js"),i=t("./src/utils/image.js");async function r(hn){return Array.isArray(hn)||(hn=[hn]),await Promise.all(hn.map(ze=>i.RawImage.read(ze)))}async function u(hn,ze){return Array.isArray(hn)||(hn=[hn]),await Promise.all(hn.map(wt=>typeof wt=="string"||wt instanceof URL?(0,d.read_audio)(wt,ze):wt instanceof Float64Array?new Float32Array(wt):wt))}function f(hn,ze){ze&&(hn=hn.map(Tn=>Tn|0));const[wt,ke,Bt,In]=hn;return{xmin:wt,ymin:ke,xmax:Bt,ymax:In}}class g extends l.Callable{constructor({task:ze,model:wt,tokenizer:ke=null,processor:Bt=null}){super(),this.task=ze,this.model=wt,this.tokenizer=ke,this.processor=Bt}async dispose(){await this.model.dispose()}}class w extends g{constructor(ze){super(ze)}async _call(ze,{top_k:wt=1}={}){const ke=this.tokenizer(ze,{padding:!0,truncation:!0}),Bt=await this.model(ke),In=this.model.config.problem_type==="multi_label_classification"?kn=>kn.sigmoid():kn=>new h.Tensor("float32",(0,m.softmax)(kn.data),kn.dims),Tn=this.model.config.id2label,cn=[];for(const kn of Bt.logits){const yn=In(kn),$n=await(0,h.topk)(yn,wt),cr=$n[0].tolist(),vn=$n[1].tolist().map((xi,ir)=>({label:Tn?Tn[xi]:`LABEL_${xi}`,score:cr[ir]}));wt===1?cn.push(...vn):cn.push(vn)}return Array.isArray(ze)||wt===1?cn:cn[0]}}class y extends g{constructor(ze){super(ze)}async _call(ze,{ignore_labels:wt=["O"]}={}){const ke=Array.isArray(ze),Bt=this.tokenizer(ke?ze:[ze],{padding:!0,truncation:!0}),Tn=(await this.model(Bt)).logits,cn=this.model.config.id2label,kn=[];for(let yn=0;yn<Tn.dims[0];++yn){const $n=Bt.input_ids[yn],cr=Tn[yn],ti=[];for(let vn=0;vn<cr.dims[0];++vn){const xi=cr[vn],ir=(0,m.max)(xi.data)[1],ai=cn?cn[ir]:`LABEL_${ir}`;if(wt.includes(ai))continue;const mi=this.tokenizer.decode([$n[vn].item()],{skip_special_tokens:!0});if(mi==="")continue;const fi=(0,m.softmax)(xi.data);ti.push({entity:ai,score:fi[ir],index:vn,word:mi})}kn.push(ti)}return ke?kn:kn[0]}}class x extends g{constructor(ze){super(ze)}async _call(ze,wt,{top_k:ke=1}={}){const Bt=this.tokenizer(ze,{text_pair:wt,padding:!0,truncation:!0}),{start_logits:In,end_logits:Tn}=await this.model(Bt),cn=Bt.input_ids.tolist(),kn=Bt.attention_mask.tolist(),yn=this.tokenizer.all_special_ids,$n=[];for(let cr=0;cr<In.dims[0];++cr){const ti=cn[cr],vn=ti.findIndex(ui=>ui==this.tokenizer.sep_token_id);kn[cr].map((ui,wi)=>ui==1&&(wi===0||wi>vn&&yn.findIndex(Lo=>Lo==ti[wi])===-1));const xi=In[cr].tolist(),ir=Tn[cr].tolist();for(let ui=1;ui<xi.length;++ui)(kn[cr]==0||ui<=vn||yn.findIndex(wi=>wi==ti[ui])!==-1)&&(xi[ui]=-1/0,ir[ui]=-1/0);const ai=(0,m.softmax)(xi).map((ui,wi)=>[ui,wi]),mi=(0,m.softmax)(ir).map((ui,wi)=>[ui,wi]);ai[0][0]=0,mi[0][0]=0;const fi=(0,_.product)(ai,mi).filter(ui=>ui[0][1]<=ui[1][1]).map(ui=>[ui[0][1],ui[1][1],ui[0][0]*ui[1][0]]).sort((ui,wi)=>wi[2]-ui[2]);for(let ui=0;ui<Math.min(fi.length,ke);++ui){const[wi,Lo,zi]=fi[ui],Ci=ti.slice(wi,Lo+1),Si=this.tokenizer.decode(Ci,{skip_special_tokens:!0});$n.push({answer:Si,score:zi})}}return ke===1?$n[0]:$n}}class S extends g{constructor(ze){super(ze)}async _call(ze,{top_k:wt=5}={}){const ke=this.tokenizer(ze,{padding:!0,truncation:!0}),{logits:Bt}=await this.model(ke),In=[],Tn=ke.input_ids.tolist();for(let cn=0;cn<Tn.length;++cn){const kn=Tn[cn],yn=kn.findIndex(xi=>xi==this.tokenizer.mask_token_id);if(yn===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const $n=Bt[cn][yn],cr=await(0,h.topk)(new h.Tensor("float32",(0,m.softmax)($n.data),$n.dims),wt),ti=cr[0].tolist(),vn=cr[1].tolist();In.push(vn.map((xi,ir)=>{const ai=kn.slice();return ai[yn]=xi,{score:ti[ir],token:Number(xi),token_str:this.tokenizer.decode([xi]),sequence:this.tokenizer.decode(ai,{skip_special_tokens:!0})}}))}return Array.isArray(ze)?In:In[0]}}class T extends g{_key="generated_text";constructor(ze){super(ze)}async _call(ze,wt={}){Array.isArray(ze)||(ze=[ze]),this.model.config.prefix&&(ze=ze.map(kn=>this.model.config.prefix+kn));const ke=this.model.config.task_specific_params;ke&&ke[this.task]&&ke[this.task].prefix&&(ze=ze.map(kn=>ke[this.task].prefix+kn));const Bt=this.tokenizer,In={padding:!0,truncation:!0};let Tn;this instanceof A&&"_build_translation_inputs"in Bt?Tn=Bt._build_translation_inputs(ze,In,wt):Tn=Bt(ze,In);const cn=await this.model.generate({...Tn,...wt});return Bt.batch_decode(cn,{skip_special_tokens:!0}).map(kn=>({[this._key]:kn}))}}class E extends T{_key="summary_text";constructor(ze){super(ze)}}class A extends T{_key="translation_text";constructor(ze){super(ze)}}function C(hn){return Array.isArray(hn)&&hn.every(ze=>"role"in ze&&"content"in ze)}class I extends g{constructor(ze){super(ze)}async _call(ze,wt={}){let ke=!1,Bt=!1,In=wt.add_special_tokens??(this.tokenizer.add_bos_token||this.tokenizer.add_eos_token)??!1,Tn;if(typeof ze=="string")Tn=ze=[ze];else if(Array.isArray(ze)&&ze.every(vn=>typeof vn=="string"))ke=!0,Tn=ze;else{if(C(ze))ze=[ze];else if(Array.isArray(ze)&&ze.every(C))ke=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");Bt=!0,Tn=ze.map(vn=>this.tokenizer.apply_chat_template(vn,{tokenize:!1,add_generation_prompt:!0})),In=!1}const cn=Bt?!1:wt.return_full_text??!0;this.tokenizer.padding_side="left";const kn=this.tokenizer(Tn,{add_special_tokens:In,padding:!0,truncation:!0}),yn=await this.model.generate({...kn,...wt}),$n=this.tokenizer.batch_decode(yn,{skip_special_tokens:!0});let cr;!cn&&kn.input_ids.dims.at(-1)>0&&(cr=this.tokenizer.batch_decode(kn.input_ids,{skip_special_tokens:!0}).map(vn=>vn.length));const ti=Array.from({length:ze.length},vn=>[]);for(let vn=0;vn<$n.length;++vn){const xi=Math.floor(vn/yn.dims[0]*ze.length);cr&&($n[vn]=$n[vn].slice(cr[xi])),ti[xi].push({generated_text:Bt?[...ze[xi],{role:"assistant",content:$n[vn]}]:$n[vn]})}return!ke&&ti.length===1?ti[0]:ti}}class D extends g{constructor(ze){super(ze),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([wt,ke])=>[wt.toLowerCase(),ke])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(ze,wt,{hypothesis_template:ke="This example is {}.",multi_label:Bt=!1}={}){const In=Array.isArray(ze);In||(ze=[ze]),Array.isArray(wt)||(wt=[wt]);const Tn=wt.map(yn=>ke.replace("{}",yn)),cn=Bt||wt.length===1,kn=[];for(const yn of ze){const $n=[];for(const vn of Tn){const xi=this.tokenizer(yn,{text_pair:vn,padding:!0,truncation:!0}),ir=await this.model(xi);cn?$n.push([ir.logits.data[this.contradiction_id],ir.logits.data[this.entailment_id]]):$n.push(ir.logits.data[this.entailment_id])}const ti=(cn?$n.map(vn=>(0,m.softmax)(vn)[1]):(0,m.softmax)($n)).map((vn,xi)=>[vn,xi]).sort((vn,xi)=>xi[0]-vn[0]);kn.push({sequence:yn,labels:ti.map(vn=>wt[vn[1]]),scores:ti.map(vn=>vn[0])})}return In?kn:kn[0]}}class R extends g{constructor(ze){super(ze)}async _call(ze,{pooling:wt="none",normalize:ke=!1,quantize:Bt=!1,precision:In="binary"}={}){const Tn=this.tokenizer(ze,{padding:!0,truncation:!0}),cn=await this.model(Tn);let kn=cn.last_hidden_state??cn.logits??cn.token_embeddings;switch(wt){case"none":break;case"mean":kn=(0,h.mean_pooling)(kn,Tn.attention_mask);break;case"first_token":case"cls":kn=kn.slice(null,0);break;case"last_token":case"eos":kn=kn.slice(null,-1);break;default:throw Error(`Pooling method '${wt}' not supported.`)}return ke&&(kn=kn.normalize(2,-1)),Bt&&(kn=(0,h.quantize_embeddings)(kn,In)),kn}}class Y extends g{constructor(ze){super(ze)}async _call(ze,{pool:wt=null}={}){const ke=await r(ze),{pixel_values:Bt}=await this.processor(ke),In=await this.model({pixel_values:Bt});let Tn;if(wt){if(!("pooler_output"in In))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Tn=In.pooler_output}else Tn=In.last_hidden_state??In.logits??In.image_embeds;return Tn}}class re extends g{constructor(ze){super(ze)}async _call(ze,{top_k:wt=5}={}){const ke=this.processor.feature_extractor.config.sampling_rate,Bt=await u(ze,ke),In=this.model.config.id2label,Tn=[];for(const cn of Bt){const kn=await this.processor(cn),$n=(await this.model(kn)).logits[0],cr=await(0,h.topk)(new h.Tensor("float32",(0,m.softmax)($n.data),$n.dims),wt),ti=cr[0].tolist(),xi=cr[1].tolist().map((ir,ai)=>({label:In?In[ir]:`LABEL_${ir}`,score:ti[ai]}));Tn.push(xi)}return Array.isArray(ze)?Tn:Tn[0]}}class G extends g{constructor(ze){super(ze)}async _call(ze,wt,{hypothesis_template:ke="This is a sound of {}."}={}){const Bt=!Array.isArray(ze);Bt&&(ze=[ze]);const In=wt.map($n=>ke.replace("{}",$n)),Tn=this.tokenizer(In,{padding:!0,truncation:!0}),cn=this.processor.feature_extractor.config.sampling_rate,kn=await u(ze,cn),yn=[];for(const $n of kn){const cr=await this.processor($n),ti=await this.model({...Tn,...cr}),vn=(0,m.softmax)(ti.logits_per_audio.data);yn.push([...vn].map((xi,ir)=>({score:xi,label:wt[ir]})))}return Bt?yn[0]:yn}}class te extends g{constructor(ze){super(ze)}async _call(ze,wt={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(ze,wt);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(ze,wt);case"moonshine":return this._call_moonshine(ze,wt);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(ze,wt){wt.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),wt.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const ke=!Array.isArray(ze);ke&&(ze=[ze]);const Bt=this.processor.feature_extractor.config.sampling_rate,In=await u(ze,Bt),Tn=[];for(const cn of In){const kn=await this.processor(cn),$n=(await this.model(kn)).logits[0],cr=[];for(const vn of $n)cr.push((0,m.max)(vn.data)[1]);const ti=this.tokenizer.decode(cr);Tn.push({text:ti})}return ke?Tn[0]:Tn}async _call_whisper(ze,wt){const ke=wt.return_timestamps??!1,Bt=wt.chunk_length_s??0,In=wt.force_full_sequences??!1;let Tn=wt.stride_length_s??null;const cn={...wt};ke==="word"&&(cn.return_token_timestamps=!0,cn.return_timestamps=!1);const kn=!Array.isArray(ze);kn&&(ze=[ze]);const yn=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,$n=this.processor.feature_extractor.config.hop_length,cr=this.processor.feature_extractor.config.sampling_rate,ti=await u(ze,cr),vn=[];for(const xi of ti){let ir=[];if(Bt>0){if(Tn===null)Tn=Bt/6;else if(Bt<=Tn)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const fi=cr*Bt,ui=cr*Tn,wi=fi-2*ui;let Lo=0;for(;;){const zi=Lo+fi,Ci=xi.subarray(Lo,zi),Si=await this.processor(Ci),zc=Lo===0,Xc=zi>=xi.length;if(ir.push({stride:[Ci.length,zc?0:ui,Xc?0:ui],input_features:Si.input_features,is_last:Xc}),Xc)break;Lo+=wi}}else ir=[{stride:[xi.length,0,0],input_features:(await this.processor(xi)).input_features,is_last:!0}];for(const fi of ir){cn.num_frames=Math.floor(fi.stride[0]/$n);const ui=await this.model.generate({inputs:fi.input_features,...cn});ke==="word"?(fi.tokens=ui.sequences.tolist()[0],fi.token_timestamps=ui.token_timestamps.tolist()[0].map(wi=>(0,m.round)(wi,2))):fi.tokens=ui[0].tolist(),fi.stride=fi.stride.map(wi=>wi/cr)}const[ai,mi]=this.tokenizer._decode_asr(ir,{time_precision:yn,return_timestamps:ke,force_full_sequences:In});vn.push({text:ai,...mi})}return kn?vn[0]:vn}async _call_moonshine(ze,wt){const ke=!Array.isArray(ze);ke&&(ze=[ze]);const Bt=this.processor.feature_extractor.config.sampling_rate,In=await u(ze,Bt),Tn=[];for(const cn of In){const kn=await this.processor(cn),yn=Math.floor(cn.length/Bt)*6,$n=await this.model.generate({max_new_tokens:yn,...wt,...kn}),cr=this.processor.batch_decode($n,{skip_special_tokens:!0})[0];Tn.push({text:cr})}return ke?Tn[0]:Tn}}class q extends g{constructor(ze){super(ze)}async _call(ze,wt={}){const ke=Array.isArray(ze),Bt=await r(ze),{pixel_values:In}=await this.processor(Bt),Tn=[];for(const cn of In){cn.dims=[1,...cn.dims];const kn=await this.model.generate({inputs:cn,...wt}),yn=this.tokenizer.batch_decode(kn,{skip_special_tokens:!0}).map($n=>({generated_text:$n.trim()}));Tn.push(yn)}return ke?Tn:Tn[0]}}class z extends g{constructor(ze){super(ze)}async _call(ze,{top_k:wt=5}={}){const ke=await r(ze),{pixel_values:Bt}=await this.processor(ke),In=await this.model({pixel_values:Bt}),Tn=this.model.config.id2label,cn=[];for(const kn of In.logits){const yn=await(0,h.topk)(new h.Tensor("float32",(0,m.softmax)(kn.data),kn.dims),wt),$n=yn[0].tolist(),ti=yn[1].tolist().map((vn,xi)=>({label:Tn?Tn[vn]:`LABEL_${vn}`,score:$n[xi]}));cn.push(ti)}return Array.isArray(ze)?cn:cn[0]}}class H extends g{constructor(ze){super(ze),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(ze,{threshold:wt=.5,mask_threshold:ke=.5,overlap_mask_area_threshold:Bt=.8,label_ids_to_fuse:In=null,target_sizes:Tn=null,subtask:cn=null}={}){if(Array.isArray(ze)&&ze.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const yn=await r(ze),$n=yn.map(fi=>[fi.height,fi.width]),cr=await this.processor(yn),{inputNames:ti,outputNames:vn}=this.model.sessions.model;if(!ti.includes("pixel_values")){if(ti.length!==1)throw Error(`Expected a single input name, but got ${ti.length} inputs: ${ti}.`);const fi=ti[0];if(fi in cr)throw Error(`Input name ${fi} already exists in the inputs.`);cr[fi]=cr.pixel_values}const xi=await this.model(cr);let ir=null;if(cn!==null)ir=this.subtasks_mapping[cn];else if(this.processor.image_processor){for(const[fi,ui]of Object.entries(this.subtasks_mapping))if(ui in this.processor.image_processor){ir=this.processor.image_processor[ui].bind(this.processor.image_processor),cn=fi;break}}const ai=this.model.config.id2label,mi=[];if(cn)if(cn==="panoptic"||cn==="instance"){const fi=ir(xi,wt,ke,Bt,In,Tn??$n)[0],ui=fi.segmentation;for(const wi of fi.segments_info){const Lo=new Uint8ClampedArray(ui.data.length);for(let Ci=0;Ci<ui.data.length;++Ci)ui.data[Ci]===wi.id&&(Lo[Ci]=255);const zi=new i.RawImage(Lo,ui.dims[1],ui.dims[0],1);mi.push({score:wi.score,label:ai[wi.label_id],mask:zi})}}else if(cn==="semantic"){const{segmentation:fi,labels:ui}=ir(xi,Tn??$n)[0];for(const wi of ui){const Lo=new Uint8ClampedArray(fi.data.length);for(let Ci=0;Ci<fi.data.length;++Ci)fi.data[Ci]===wi&&(Lo[Ci]=255);const zi=new i.RawImage(Lo,fi.dims[1],fi.dims[0],1);mi.push({score:null,label:ai[wi],mask:zi})}}else throw Error(`Subtask ${cn} not supported.`);else{const ui=xi[vn[0]];for(let wi=0;wi<$n.length;++wi){const Lo=$n[wi],zi=ui[wi];zi.data.some(Si=>Si<-1e-5||Si>1+1e-5)&&zi.sigmoid_();const Ci=await i.RawImage.fromTensor(zi.mul_(255).to("uint8")).resize(Lo[1],Lo[0]);mi.push({label:null,score:null,mask:Ci})}}return mi}}class he extends H{constructor(ze){super(ze)}async _call(ze,wt={}){if(Array.isArray(ze)&&ze.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const Bt=await r(ze),In=await super._call(ze,wt);return Bt.map((cn,kn)=>{const yn=cn.clone();return yn.putAlpha(In[kn].mask),yn})}}class Ce extends g{constructor(ze){super(ze)}async _call(ze,wt,{hypothesis_template:ke="This is a photo of {}"}={}){const Bt=Array.isArray(ze),In=await r(ze),Tn=wt.map(ti=>ke.replace("{}",ti)),cn=this.tokenizer(Tn,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:kn}=await this.processor(In),yn=await this.model({...cn,pixel_values:kn}),$n=this.model.config.model_type==="siglip"?ti=>ti.sigmoid().data:ti=>(0,m.softmax)(ti.data),cr=[];for(const ti of yn.logits_per_image){const xi=[...$n(ti)].map((ir,ai)=>({score:ir,label:wt[ai]}));xi.sort((ir,ai)=>ai.score-ir.score),cr.push(xi)}return Bt?cr:cr[0]}}class oe extends g{constructor(ze){super(ze)}async _call(ze,{threshold:wt=.9,percentage:ke=!1}={}){const Bt=Array.isArray(ze);if(Bt&&ze.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const In=await r(ze),Tn=ke?null:In.map(vn=>[vn.height,vn.width]),{pixel_values:cn,pixel_mask:kn}=await this.processor(In),yn=await this.model({pixel_values:cn,pixel_mask:kn}),$n=this.processor.image_processor.post_process_object_detection(yn,wt,Tn),cr=this.model.config.id2label,ti=$n.map(vn=>vn.boxes.map((xi,ir)=>({score:vn.scores[ir],label:cr[vn.classes[ir]],box:f(xi,!ke)})));return Bt?ti:ti[0]}}class K extends g{constructor(ze){super(ze)}async _call(ze,wt,{threshold:ke=.1,top_k:Bt=null,percentage:In=!1}={}){const Tn=Array.isArray(ze),cn=await r(ze),kn=this.tokenizer(wt,{padding:!0,truncation:!0}),yn=await this.processor(cn),$n=[];for(let cr=0;cr<cn.length;++cr){const ti=cn[cr],vn=In?null:[[ti.height,ti.width]],xi=yn.pixel_values[cr].unsqueeze_(0),ir=await this.model({...kn,pixel_values:xi});let ai;if("post_process_grounded_object_detection"in this.processor){const mi=this.processor.post_process_grounded_object_detection(ir,kn.input_ids,{box_threshold:ke,text_threshold:ke,target_sizes:vn})[0];ai=mi.boxes.map((fi,ui)=>({score:mi.scores[ui],label:mi.labels[ui],box:f(fi,!In)}))}else{const mi=this.processor.image_processor.post_process_object_detection(ir,ke,vn,!0)[0];ai=mi.boxes.map((fi,ui)=>({score:mi.scores[ui],label:wt[mi.classes[ui]],box:f(fi,!In)}))}ai.sort((mi,fi)=>fi.score-mi.score),Bt!==null&&(ai=ai.slice(0,Bt)),$n.push(ai)}return Tn?$n:$n[0]}}class Q extends g{constructor(ze){super(ze)}async _call(ze,wt,ke={}){const Bt=(await r(ze))[0],{pixel_values:In}=await this.processor(Bt),Tn=`<s_docvqa><s_question>${wt}</s_question><s_answer>`,cn=this.tokenizer(Tn,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,kn=await this.model.generate({inputs:In,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:cn,...ke}),$n=this.tokenizer.batch_decode(kn)[0].match(/<s_answer>(.*?)<\/s_answer>/);let cr=null;return $n&&$n.length>=2&&(cr=$n[1].trim()),[{answer:cr}]}}class de extends g{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(ze){super(ze),this.vocoder=ze.vocoder??null}async _call(ze,{speaker_embeddings:wt=null}={}){return this.processor?this._call_text_to_spectrogram(ze,{speaker_embeddings:wt}):this._call_text_to_waveform(ze)}async _call_text_to_waveform(ze){const wt=this.tokenizer(ze,{padding:!0,truncation:!0}),{waveform:ke}=await this.model(wt),Bt=this.model.config.sampling_rate;return new d.RawAudio(ke.data,Bt)}async _call_text_to_spectrogram(ze,{speaker_embeddings:wt}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await a.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof wt=="string"||wt instanceof URL)&&(wt=new Float32Array(await(await fetch(wt)).arrayBuffer())),wt instanceof Float32Array)wt=new h.Tensor("float32",wt,[1,wt.length]);else if(!(wt instanceof h.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:ke}=this.tokenizer(ze,{padding:!0,truncation:!0}),{waveform:Bt}=await this.model.generate_speech(ke,wt,{vocoder:this.vocoder}),In=this.processor.feature_extractor.config.sampling_rate;return new d.RawAudio(Bt.data,In)}}class ue extends g{constructor(ze){super(ze)}async _call(ze){const wt=await r(ze),ke=await this.processor(wt),Bt=await this.model(ke),In=[];for(const Tn of Bt.reconstruction){const cn=Tn.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");In.push(i.RawImage.fromTensor(cn))}return In.length>1?In:In[0]}}class Ze extends g{constructor(ze){super(ze)}async _call(ze){const wt=await r(ze),ke=await this.processor(wt),{predicted_depth:Bt}=await this.model(ke),In=[];for(let Tn=0;Tn<wt.length;++Tn){const cn=Bt[Tn],[kn,yn]=cn.dims.slice(-2),[$n,cr]=wt[Tn].size,ti=(await(0,h.interpolate_4d)(cn.view(1,1,kn,yn),{size:[cr,$n],mode:"bilinear"})).view(cr,$n),vn=ti.min().item(),xi=ti.max().item(),ir=ti.sub(vn).div_(xi-vn).mul_(255).to("uint8").unsqueeze(0),ai=i.RawImage.fromTensor(ir);In.push({predicted_depth:ti,depth:ai})}return In.length>1?In:In[0]}}const Pt=Object.freeze({"text-classification":{tokenizer:s.AutoTokenizer,pipeline:w,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:s.AutoTokenizer,pipeline:y,model:a.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:s.AutoTokenizer,pipeline:x,model:a.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:s.AutoTokenizer,pipeline:S,model:a.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:s.AutoTokenizer,pipeline:E,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:s.AutoTokenizer,pipeline:A,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:s.AutoTokenizer,pipeline:T,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:s.AutoTokenizer,pipeline:I,model:a.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:s.AutoTokenizer,pipeline:D,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:re,model:a.AutoModelForAudioClassification,processor:c.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:s.AutoTokenizer,pipeline:G,model:a.AutoModel,processor:c.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:s.AutoTokenizer,pipeline:te,model:[a.AutoModelForSpeechSeq2Seq,a.AutoModelForCTC],processor:c.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:s.AutoTokenizer,pipeline:de,model:[a.AutoModelForTextToWaveform,a.AutoModelForTextToSpectrogram],processor:[c.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:s.AutoTokenizer,pipeline:q,model:a.AutoModelForVision2Seq,processor:c.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:z,model:a.AutoModelForImageClassification,processor:c.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:H,model:[a.AutoModelForImageSegmentation,a.AutoModelForSemanticSegmentation,a.AutoModelForUniversalSegmentation],processor:c.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:he,model:[a.AutoModelForImageSegmentation,a.AutoModelForSemanticSegmentation,a.AutoModelForUniversalSegmentation],processor:c.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:s.AutoTokenizer,pipeline:Ce,model:a.AutoModel,processor:c.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:oe,model:a.AutoModelForObjectDetection,processor:c.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:s.AutoTokenizer,pipeline:K,model:a.AutoModelForZeroShotObjectDetection,processor:c.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:s.AutoTokenizer,pipeline:Q,model:a.AutoModelForDocumentQuestionAnswering,processor:c.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ue,model:a.AutoModelForImageToImage,processor:c.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Ze,model:a.AutoModelForDepthEstimation,processor:c.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:s.AutoTokenizer,pipeline:R,model:a.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:c.AutoProcessor,pipeline:Y,model:[a.AutoModelForImageFeatureExtraction,a.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Gt=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function bn(hn,ze=null,{progress_callback:wt=null,config:ke=null,cache_dir:Bt=null,local_files_only:In=!1,revision:Tn="main",device:cn=null,dtype:kn=null,subfolder:yn="onnx",use_external_data_format:$n=null,model_file_name:cr=null,session_options:ti={}}={}){hn=Gt[hn]??hn;const vn=Pt[hn.split("_",1)[0]];if(!vn)throw Error(`Unsupported pipeline: ${hn}. Must be one of [${Object.keys(Pt)}]`);ze||(ze=vn.default.model,console.log(`No model specified. Using default model: "${ze}".`));const xi={progress_callback:wt,config:ke,cache_dir:Bt,local_files_only:In,revision:Tn,device:cn,dtype:kn,subfolder:yn,use_external_data_format:$n,model_file_name:cr,session_options:ti},ir=new Map([["tokenizer",vn.tokenizer],["model",vn.model],["processor",vn.processor]]),ai=await ri(ir,ze,xi);ai.task=hn,(0,_.dispatchCallback)(wt,{status:"ready",task:hn,model:ze});const mi=vn.pipeline;return new mi(ai)}async function ri(hn,ze,wt){const ke=Object.create(null),Bt=[];for(const[In,Tn]of hn.entries()){if(!Tn)continue;let cn;Array.isArray(Tn)?cn=new Promise(async(kn,yn)=>{let $n;for(const cr of Tn){if(cr===null){kn(null);return}try{kn(await cr.from_pretrained(ze,wt));return}catch(ti){if(ti.message?.includes("Unsupported model type"))$n=ti;else if(ti.message?.includes("Could not locate file"))$n=ti;else{yn(ti);return}}}yn($n)}):cn=Tn.from_pretrained(ze,wt),ke[In]=cn,Bt.push(cn)}await Promise.all(Bt);for(const[In,Tn]of Object.entries(ke))ke[In]=await Tn;return ke}}),"./src/tokenizers.js":((n,e,t)=>{t.r(e),t.d(e,{AlbertTokenizer:()=>_c,AutoTokenizer:()=>M_,BartTokenizer:()=>we,BertTokenizer:()=>Ri,BlenderbotSmallTokenizer:()=>Ac,BlenderbotTokenizer:()=>Mi,BloomTokenizer:()=>Ht,CLIPTokenizer:()=>Qc,CamembertTokenizer:()=>ar,CodeGenTokenizer:()=>kp,CodeLlamaTokenizer:()=>Ti,CohereTokenizer:()=>Hc,ConvBertTokenizer:()=>Ke,DebertaTokenizer:()=>W,DebertaV2Tokenizer:()=>Qe,DistilBertTokenizer:()=>_n,ElectraTokenizer:()=>Pi,Ernie4_5_Tokenizer:()=>T_,EsmTokenizer:()=>Dc,FalconTokenizer:()=>Ko,GPT2Tokenizer:()=>Oo,GPTNeoXTokenizer:()=>yc,GemmaTokenizer:()=>Oi,Grok1Tokenizer:()=>Ro,HerbertTokenizer:()=>ve,LlamaTokenizer:()=>ii,M2M100Tokenizer:()=>dp,MBart50Tokenizer:()=>pt,MBartTokenizer:()=>it,MPNetTokenizer:()=>Do,MarianTokenizer:()=>mr,MgpstrTokenizer:()=>g_,MobileBertTokenizer:()=>Ui,NllbTokenizer:()=>Oc,NougatTokenizer:()=>Op,PreTrainedTokenizer:()=>si,Qwen2Tokenizer:()=>En,RoFormerTokenizer:()=>lt,RobertaTokenizer:()=>Ot,SiglipTokenizer:()=>sp,SpeechT5Tokenizer:()=>m_,SqueezeBertTokenizer:()=>Rp,T5Tokenizer:()=>hi,TokenizerModel:()=>Y,VitsTokenizer:()=>p_,Wav2Vec2CTCTokenizer:()=>ci,WhisperTokenizer:()=>Jf,XLMRobertaTokenizer:()=>pi,XLMTokenizer:()=>vi,is_chinese_char:()=>S});var s=t("./src/utils/generic.js"),a=t("./src/utils/core.js"),c=t("./src/utils/hub.js"),l=t("./src/utils/maths.js"),_=t("./src/utils/tensor.js"),m=t("./src/utils/data-structures.js"),d=t("./node_modules/@huggingface/jinja/dist/index.js"),h=t("./src/models/whisper/common_whisper.js");async function i(Lt,X){const $e=await Promise.all([(0,c.getModelJSON)(Lt,"tokenizer.json",!0,X),(0,c.getModelJSON)(Lt,"tokenizer_config.json",!0,X)]);return X.legacy!==null&&($e[1].legacy=X.legacy),$e}function r(Lt,X){const $e=[];let at=0;for(const ft of Lt.matchAll(X)){const kt=ft[0];at<ft.index&&$e.push(Lt.slice(at,ft.index)),kt.length>0&&$e.push(kt),at=ft.index+kt.length}return at<Lt.length&&$e.push(Lt.slice(at)),$e}function u(Lt,X=!0){if(Lt.Regex!==void 0){let $e=Lt.Regex.replace(/\\([#&~])/g,"$1");for(const[at,ft]of D)$e=$e.replaceAll(at,ft);return new RegExp($e,"gu")}else if(Lt.String!==void 0){const $e=(0,a.escapeRegExp)(Lt.String);return new RegExp(X?$e:`(${$e})`,"gu")}else return console.warn("Unknown pattern type:",Lt),null}function f(Lt){return new Map(Object.entries(Lt))}function g(Lt){const X=Lt.dims;switch(X.length){case 1:return Lt.tolist();case 2:if(X[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Lt.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${X.length}.`)}}function w(Lt){return Lt.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function y(Lt){return Lt.replace(new RegExp("\\p{M}","gu"),"")}function x(Lt){return y(Lt.toLowerCase())}function S(Lt){return Lt>=19968&&Lt<=40959||Lt>=13312&&Lt<=19903||Lt>=131072&&Lt<=173791||Lt>=173824&&Lt<=177983||Lt>=177984&&Lt<=178207||Lt>=178208&&Lt<=183983||Lt>=63744&&Lt<=64255||Lt>=194560&&Lt<=195103}function T(Lt,X,$e){const at=[];let ft=0;for(;ft<Lt.length;){if(at.push(Lt[ft]),(X.get(Lt[ft])??$e)!==$e){++ft;continue}for(;++ft<Lt.length&&(X.get(Lt[ft])??$e)===$e;)X.get(at.at(-1))!==$e&&(at[at.length-1]+=Lt[ft])}return at}function E(Lt){return Lt.match(/\S+/g)||[]}const A="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",C=new RegExp(`^[${A}]+$`,"gu"),I=".,!?…。，、।۔،",D=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${I}])]+`,` ?[^\\s${I}]+`]]);class R{constructor(X){this.content=X.content,this.id=X.id,this.single_word=X.single_word??!1,this.lstrip=X.lstrip??!1,this.rstrip=X.rstrip??!1,this.special=X.special??!1,this.normalized=X.normalized??null}}class Y extends s.Callable{constructor(X){super(),this.config=X,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(X,...$e){switch(X.type){case"WordPiece":return new re(X);case"Unigram":return new G(X,...$e);case"BPE":return new z(X);default:if(X.vocab)return Array.isArray(X.vocab)?new G(X,...$e):Object.hasOwn(X,"continuing_subword_prefix")&&Object.hasOwn(X,"unk_token")?Object.hasOwn(X,"merges")?new z(X):new re(X):new H(X,...$e);throw new Error(`Unknown TokenizerModel type: ${X.type}`)}}_call(X){return X=this.encode(X),this.fuse_unk&&(X=T(X,this.tokens_to_ids,this.unk_token_id)),X}encode(X){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(X){return X.map($e=>this.tokens_to_ids.get($e)??this.unk_token_id)}convert_ids_to_tokens(X){return X.map($e=>this.vocab[$e]??this.unk_token)}}class re extends Y{constructor(X){super(X),this.tokens_to_ids=f(X.vocab),this.unk_token_id=this.tokens_to_ids.get(X.unk_token),this.unk_token=X.unk_token,this.max_input_chars_per_word=X.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[$e,at]of this.tokens_to_ids)this.vocab[at]=$e}encode(X){const $e=[];for(const at of X){const ft=[...at];if(ft.length>this.max_input_chars_per_word){$e.push(this.unk_token);continue}let kt=!1,sr=0;const or=[];for(;sr<ft.length;){let lr=ft.length,yi=null;for(;sr<lr;){let di=ft.slice(sr,lr).join("");if(sr>0&&(di=this.config.continuing_subword_prefix+di),this.tokens_to_ids.has(di)){yi=di;break}--lr}if(yi===null){kt=!0;break}or.push(yi),sr=lr}kt?$e.push(this.unk_token):$e.push(...or)}return $e}}class G extends Y{constructor(X,$e){super(X);const at=X.vocab.length;this.vocab=new Array(at),this.scores=new Array(at);for(let ft=0;ft<at;++ft)[this.vocab[ft],this.scores[ft]]=X.vocab[ft];this.unk_token_id=X.unk_id,this.unk_token=this.vocab[X.unk_id],this.tokens_to_ids=new Map(this.vocab.map((ft,kt)=>[ft,kt])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=$e.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,l.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new m.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(X){const $e=X.chars,at=1;let ft=0;for(;ft<$e.length;){let kt=!1;const sr=$e.slice(ft).join(""),or=this.trie.commonPrefixSearch(sr);for(const lr of or){const yi=this.tokens_to_ids.get(lr),di=this.scores[yi],zo=(0,a.len)(lr);X.insert(ft,zo,di,yi),!kt&&zo===at&&(kt=!0)}kt||X.insert(ft,at,this.unk_score,this.unk_token_id),ft+=at}}tokenize(X){const $e=new m.TokenLattice(X,this.bos_token_id,this.eos_token_id);return this.populateNodes($e),$e.tokens()}encode(X){const $e=[];for(const at of X){const ft=this.tokenize(at);$e.push(...ft)}return $e}}const te=(()=>{const Lt=[...Array.from({length:94},(ft,kt)=>kt+33),...Array.from({length:12},(ft,kt)=>kt+161),...Array.from({length:82},(ft,kt)=>kt+174)],X=Lt.slice();let $e=0;for(let ft=0;ft<256;++ft)Lt.includes(ft)||(Lt.push(ft),X.push(256+$e),$e+=1);const at=X.map(ft=>String.fromCharCode(ft));return Object.fromEntries(Lt.map((ft,kt)=>[ft,at[kt]]))})(),q=(0,a.reverseDictionary)(te);class z extends Y{constructor(X){super(X),this.tokens_to_ids=f(X.vocab),this.unk_token_id=this.tokens_to_ids.get(X.unk_token),this.unk_token=X.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[at,ft]of this.tokens_to_ids)this.vocab[ft]=at;const $e=Array.isArray(X.merges[0]);this.merges=$e?X.merges:X.merges.map(at=>at.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((at,ft)=>[JSON.stringify(at),ft])),this.end_of_word_suffix=X.end_of_word_suffix,this.continuing_subword_suffix=X.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new m.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(X){if(X.length===0)return[];const $e=this.cache.get(X);if($e!==void 0)return $e;const at=Array.from(X);this.end_of_word_suffix&&(at[at.length-1]+=this.end_of_word_suffix);let ft=[];if(at.length>1){const kt=new m.PriorityQueue((lr,yi)=>lr.score<yi.score);let sr={token:at[0],bias:0,prev:null,next:null},or=sr;for(let lr=1;lr<at.length;++lr){const yi={bias:lr/at.length,token:at[lr],prev:or,next:null};or.next=yi,this._add_node(kt,or),or=yi}for(;!kt.isEmpty();){const lr=kt.pop();if(lr.deleted||!lr.next||lr.next.deleted)continue;if(lr.deleted=!0,lr.next.deleted=!0,lr.prev){const di={...lr.prev};lr.prev.deleted=!0,lr.prev=di,di.prev?di.prev.next=di:sr=di}const yi={token:lr.token+lr.next.token,bias:lr.bias,prev:lr.prev,next:lr.next.next};yi.prev?(yi.prev.next=yi,this._add_node(kt,yi.prev)):sr=yi,yi.next&&(yi.next.prev=yi,this._add_node(kt,yi))}for(let lr=sr;lr!==null;lr=lr.next)ft.push(lr.token)}else ft=at;if(this.continuing_subword_suffix)for(let kt=0;kt<ft.length-1;++kt)ft[kt]+=this.continuing_subword_suffix;return X.length<this.max_length_to_cache&&this.cache.put(X,ft),ft}_add_node(X,$e){const at=this.bpe_ranks.get(JSON.stringify([$e.token,$e.next.token]));at!==void 0&&($e.score=at+$e.bias,X.push($e))}encode(X){const $e=[];for(const at of X){if(this.ignore_merges&&this.tokens_to_ids.has(at)){$e.push(at);continue}const ft=this.bpe(at);for(const kt of ft)if(this.tokens_to_ids.has(kt))$e.push(kt);else if(this.byte_fallback){const sr=Array.from(this.text_encoder.encode(kt)).map(or=>`<0x${or.toString(16).toUpperCase().padStart(2,"0")}>`);sr.every(or=>this.tokens_to_ids.has(or))?$e.push(...sr):$e.push(this.unk_token)}else $e.push(this.unk_token)}return $e}}class H extends Y{constructor(X,$e){super(X),this.tokens_to_ids=f($e.target_lang?X.vocab[$e.target_lang]:X.vocab),this.bos_token=$e.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=$e.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=$e.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=$e.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[at,ft]of this.tokens_to_ids)this.vocab[ft]=at}encode(X){return X}}class he extends s.Callable{constructor(X){super(),this.config=X}static fromConfig(X){if(X===null)return null;switch(X.type){case"BertNormalizer":return new hn(X);case"Precompiled":return new Xc(X);case"Sequence":return new ri(X);case"Replace":return new Ce(X);case"NFC":return new K(X);case"NFD":return new Q(X);case"NFKC":return new de(X);case"NFKD":return new ue(X);case"Strip":return new Ze(X);case"StripAccents":return new Pt(X);case"Lowercase":return new Gt(X);case"Prepend":return new bn(X);default:throw new Error(`Unknown Normalizer type: ${X.type}`)}}normalize(X){throw Error("normalize should be implemented in subclass.")}_call(X){return this.normalize(X)}}class Ce extends he{normalize(X){const $e=u(this.config.pattern);return $e===null?X:X.replaceAll($e,this.config.content)}}class oe extends he{form=void 0;normalize(X){return X=X.normalize(this.form),X}}class K extends oe{form="NFC"}class Q extends oe{form="NFD"}class de extends oe{form="NFKC"}class ue extends oe{form="NFKD"}class Ze extends he{normalize(X){return this.config.strip_left&&this.config.strip_right?X=X.trim():(this.config.strip_left&&(X=X.trimStart()),this.config.strip_right&&(X=X.trimEnd())),X}}class Pt extends he{normalize(X){return X=y(X),X}}class Gt extends he{normalize(X){return X=X.toLowerCase(),X}}class bn extends he{normalize(X){return X=this.config.prepend+X,X}}class ri extends he{constructor(X){super(X),this.normalizers=X.normalizers.map($e=>he.fromConfig($e))}normalize(X){return this.normalizers.reduce(($e,at)=>at.normalize($e),X)}}class hn extends he{_tokenize_chinese_chars(X){const $e=[];for(let at=0;at<X.length;++at){const ft=X[at],kt=ft.charCodeAt(0);S(kt)?($e.push(" "),$e.push(ft),$e.push(" ")):$e.push(ft)}return $e.join("")}stripAccents(X){return X.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(X){switch(X){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(X)}}_clean_text(X){const $e=[];for(const at of X){const ft=at.charCodeAt(0);ft===0||ft===65533||this._is_control(at)||(/^\s$/.test(at)?$e.push(" "):$e.push(at))}return $e.join("")}normalize(X){return this.config.clean_text&&(X=this._clean_text(X)),this.config.handle_chinese_chars&&(X=this._tokenize_chinese_chars(X)),this.config.lowercase?(X=X.toLowerCase(),this.config.strip_accents!==!1&&(X=this.stripAccents(X))):this.config.strip_accents&&(X=this.stripAccents(X)),X}}class ze extends s.Callable{static fromConfig(X){if(X===null)return null;switch(X.type){case"BertPreTokenizer":return new wt(X);case"Sequence":return new up(X);case"Whitespace":return new Jo(X);case"WhitespaceSplit":return new Mo(X);case"Metaspace":return new Si(X);case"ByteLevel":return new ke(X);case"Split":return new Bt(X);case"Punctuation":return new In(X);case"Digits":return new Tn(X);case"Replace":return new $p(X);default:throw new Error(`Unknown PreTokenizer type: ${X.type}`)}}pre_tokenize_text(X,$e){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(X,$e){return(Array.isArray(X)?X.map(at=>this.pre_tokenize_text(at,$e)):this.pre_tokenize_text(X,$e)).flat()}_call(X,$e){return this.pre_tokenize(X,$e)}}class wt extends ze{constructor(X){super(),this.pattern=new RegExp(`[^\\s${A}]+|[${A}]`,"gu")}pre_tokenize_text(X,$e){return X.trim().match(this.pattern)||[]}}class ke extends ze{constructor(X){super(),this.config=X,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=te,this.text_encoder=new TextEncoder}pre_tokenize_text(X,$e){return this.add_prefix_space&&!X.startsWith(" ")&&(X=" "+X),(this.use_regex?X.match(this.pattern)||[]:[X]).map(ft=>Array.from(this.text_encoder.encode(ft),kt=>this.byte_encoder[kt]).join(""))}}class Bt extends ze{constructor(X){super(),this.config=X,this.pattern=u(this.config.pattern,this.config.invert)}pre_tokenize_text(X,$e){return this.pattern===null?[]:this.config.invert?X.match(this.pattern)||[]:this.config.behavior?.toLowerCase()==="removed"?X.split(this.pattern).filter(at=>at):r(X,this.pattern)}}class In extends ze{constructor(X){super(),this.config=X,this.pattern=new RegExp(`[^${A}]+|[${A}]+`,"gu")}pre_tokenize_text(X,$e){return X.match(this.pattern)||[]}}class Tn extends ze{constructor(X){super(),this.config=X;const $e=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp($e,"gu")}pre_tokenize_text(X,$e){return X.match(this.pattern)||[]}}class cn extends s.Callable{constructor(X){super(),this.config=X}static fromConfig(X){if(X===null)return null;switch(X.type){case"TemplateProcessing":return new $n(X);case"ByteLevel":return new cr(X);case"RobertaProcessing":return new yn(X);case"BertProcessing":return new kn(X);case"Sequence":return new ti(X);default:throw new Error(`Unknown PostProcessor type: ${X.type}`)}}post_process(X,...$e){throw Error("post_process should be implemented in subclass.")}_call(X,...$e){return this.post_process(X,...$e)}}class kn extends cn{constructor(X){super(X),this.cls=X.cls[0],this.sep=X.sep[0]}post_process(X,$e=null,{add_special_tokens:at=!0}={}){at&&(X=(0,a.mergeArrays)([this.cls],X,[this.sep]));let ft=new Array(X.length).fill(0);if($e!==null){const kt=at&&this instanceof yn?[this.sep]:[],sr=at?[this.sep]:[];X=(0,a.mergeArrays)(X,kt,$e,sr),ft=(0,a.mergeArrays)(ft,new Array($e.length+kt.length+sr.length).fill(1))}return{tokens:X,token_type_ids:ft}}}class yn extends kn{}class $n extends cn{constructor(X){super(X),this.single=X.single,this.pair=X.pair}post_process(X,$e=null,{add_special_tokens:at=!0}={}){const ft=$e===null?this.single:this.pair;let kt=[],sr=[];for(const or of ft)"SpecialToken"in or?at&&(kt.push(or.SpecialToken.id),sr.push(or.SpecialToken.type_id)):"Sequence"in or&&(or.Sequence.id==="A"?(kt=(0,a.mergeArrays)(kt,X),sr=(0,a.mergeArrays)(sr,new Array(X.length).fill(or.Sequence.type_id))):or.Sequence.id==="B"&&(kt=(0,a.mergeArrays)(kt,$e),sr=(0,a.mergeArrays)(sr,new Array($e.length).fill(or.Sequence.type_id))));return{tokens:kt,token_type_ids:sr}}}class cr extends cn{post_process(X,$e=null){return $e&&(X=(0,a.mergeArrays)(X,$e)),{tokens:X}}}class ti extends cn{constructor(X){super(X),this.processors=X.processors.map($e=>cn.fromConfig($e))}post_process(X,$e=null,at={}){let ft;for(const kt of this.processors)if(kt instanceof cr)X=kt.post_process(X).tokens,$e&&($e=kt.post_process($e).tokens);else{const sr=kt.post_process(X,$e,at);X=sr.tokens,ft=sr.token_type_ids}return{tokens:X,token_type_ids:ft}}}class vn extends s.Callable{constructor(X){super(),this.config=X,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=X.trim_offsets}static fromConfig(X){if(X===null)return null;switch(X.type){case"WordPiece":return new fi(X);case"Metaspace":return new zc(X);case"ByteLevel":return new ui(X);case"Replace":return new xi(X);case"ByteFallback":return new ir(X);case"Fuse":return new ai(X);case"Strip":return new mi(X);case"Sequence":return new Lo(X);case"CTC":return new wi(X);case"BPEDecoder":return new zi(X);default:throw new Error(`Unknown Decoder type: ${X.type}`)}}_call(X){return this.decode(X)}decode(X){return this.decode_chain(X).join("")}decode_chain(X){throw Error("`decode_chain` should be implemented in subclass.")}}class xi extends vn{decode_chain(X){const $e=u(this.config.pattern);return $e===null?X:X.map(at=>at.replaceAll($e,this.config.content))}}class ir extends vn{constructor(X){super(X),this.text_decoder=new TextDecoder}decode_chain(X){const $e=[];let at=[];for(const ft of X){let kt=null;if(ft.length===6&&ft.startsWith("<0x")&&ft.endsWith(">")){const sr=parseInt(ft.slice(3,5),16);isNaN(sr)||(kt=sr)}if(kt!==null)at.push(kt);else{if(at.length>0){const sr=this.text_decoder.decode(Uint8Array.from(at));$e.push(sr),at=[]}$e.push(ft)}}if(at.length>0){const ft=this.text_decoder.decode(Uint8Array.from(at));$e.push(ft),at=[]}return $e}}class ai extends vn{decode_chain(X){return[X.join("")]}}class mi extends vn{constructor(X){super(X),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(X){return X.map($e=>{let at=0;for(let kt=0;kt<this.start&&$e[kt]===this.content;++kt){at=kt+1;continue}let ft=$e.length;for(let kt=0;kt<this.stop;++kt){const sr=$e.length-kt-1;if($e[sr]===this.content){ft=sr;continue}else break}return $e.slice(at,ft)})}}class fi extends vn{constructor(X){super(X),this.cleanup=X.cleanup}decode_chain(X){return X.map(($e,at)=>(at!==0&&($e.startsWith(this.config.prefix)?$e=$e.replace(this.config.prefix,""):$e=" "+$e),this.cleanup&&($e=w($e)),$e))}}class ui extends vn{constructor(X){super(X),this.byte_decoder=q,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(X){const $e=X.join(""),at=new Uint8Array([...$e].map(kt=>this.byte_decoder[kt]));return this.text_decoder.decode(at)}decode_chain(X){const $e=[];let at=[];for(const ft of X)this.added_tokens.find(kt=>kt.content===ft)!==void 0?(at.length>0&&($e.push(this.convert_tokens_to_string(at)),at=[]),$e.push(ft)):at.push(ft);return at.length>0&&$e.push(this.convert_tokens_to_string(at)),$e}}class wi extends vn{constructor(X){super(X),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(X){if(X.length===0)return"";const $e=[X[0]];for(let kt=1;kt<X.length;++kt)X[kt]!==$e.at(-1)&&$e.push(X[kt]);let ft=$e.filter(kt=>kt!==this.pad_token).join("");return this.cleanup&&(ft=w(ft).replaceAll(this.word_delimiter_token," ").trim()),ft}decode_chain(X){return[this.convert_tokens_to_string(X)]}}class Lo extends vn{constructor(X){super(X),this.decoders=X.decoders.map($e=>vn.fromConfig($e))}decode_chain(X){return this.decoders.reduce(($e,at)=>at.decode_chain($e),X)}}class zi extends vn{constructor(X){super(X),this.suffix=this.config.suffix}decode_chain(X){return X.map(($e,at)=>$e.replaceAll(this.suffix,at===X.length-1?"":" "))}}class Ci extends vn{decode_chain(X){let $e="";for(let at=1;at<X.length;at+=2)$e+=X[at];return[$e]}}class Si extends ze{constructor(X){super(),this.addPrefixSpace=X.add_prefix_space,this.replacement=X.replacement,this.strRep=X.str_rep||this.replacement,this.prepend_scheme=X.prepend_scheme??"always"}pre_tokenize_text(X,{section_index:$e=void 0}={}){let at=X.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!at.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&$e===0)&&(at=this.strRep+at),[at]}}class zc extends vn{constructor(X){super(X),this.addPrefixSpace=X.add_prefix_space,this.replacement=X.replacement}decode_chain(X){const $e=[];for(let at=0;at<X.length;++at){let ft=X[at].replaceAll(this.replacement," ");this.addPrefixSpace&&at==0&&ft.startsWith(" ")&&(ft=ft.substring(1)),$e.push(ft)}return $e}}class Xc extends he{constructor(X){super(X),this.charsmap=X.precompiled_charsmap}normalize(X){return X=X.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),X=X.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),X.includes("～")?X=X.split("～").map(at=>at.normalize("NFKC")).join("～"):X=X.normalize("NFKC"),X}}class up extends ze{constructor(X){super(),this.tokenizers=X.pretokenizers.map($e=>ze.fromConfig($e))}pre_tokenize_text(X,$e){return this.tokenizers.reduce((at,ft)=>ft.pre_tokenize(at,$e),[X])}}class Jo extends ze{constructor(X){super()}pre_tokenize_text(X,$e){return X.match(/\w+|[^\w\s]+/g)||[]}}class Mo extends ze{constructor(X){super()}pre_tokenize_text(X,$e){return E(X)}}class $p extends ze{constructor(X){super(),this.config=X,this.pattern=u(this.config.pattern),this.content=this.config.content}pre_tokenize_text(X,$e){return this.pattern===null?[X]:[X.replaceAll(this.pattern,this.config.content)]}}const rf=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function cp(Lt,X,$e,at){for(const ft of Object.keys(Lt)){const kt=X-Lt[ft].length,sr=$e(ft),or=new Array(kt).fill(sr);Lt[ft]=at==="right"?(0,a.mergeArrays)(Lt[ft],or):(0,a.mergeArrays)(or,Lt[ft])}}function Wi(Lt,X){for(const $e of Object.keys(Lt))Lt[$e].length=X}class si extends s.Callable{return_token_type_ids=!1;padding_side="right";constructor(X,$e){super(),this.config=$e,this.normalizer=he.fromConfig(X.normalizer),this.pre_tokenizer=ze.fromConfig(X.pre_tokenizer),this.model=Y.fromConfig(X.model,$e),this.post_processor=cn.fromConfig(X.post_processor),this.decoder=vn.fromConfig(X.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const at of X.added_tokens){const ft=new R(at);this.added_tokens.push(ft),this.model.tokens_to_ids.set(ft.content,ft.id),this.model.vocab[ft.id]=ft.content,ft.special&&(this.special_tokens.push(ft.content),this.all_special_ids.push(ft.id))}if(this.additional_special_tokens=$e.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new m.DictionarySplitter(this.added_tokens.map(at=>at.content)),this.added_tokens_map=new Map(this.added_tokens.map(at=>[at.content,at])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=$e.model_max_length,this.remove_space=$e.remove_space,this.clean_up_tokenization_spaces=$e.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=$e.do_lowercase_and_remove_accent??!1,$e.padding_side&&(this.padding_side=$e.padding_side),this.add_bos_token=$e.add_bos_token,this.add_eos_token=$e.add_eos_token,this.legacy=!1,this.chat_template=$e.chat_template??null,Array.isArray(this.chat_template)){const at=Object.create(null);for(const{name:ft,template:kt}of this.chat_template){if(typeof ft!="string"||typeof kt!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');at[ft]=kt}this.chat_template=at}this._compiled_template_cache=new Map}getToken(...X){for(const $e of X){const at=this.config[$e];if(at)if(typeof at=="object"){if(at.__type==="AddedToken")return at.content;throw Error(`Unknown token: ${at}`)}else return at}return null}static async from_pretrained(X,{progress_callback:$e=null,config:at=null,cache_dir:ft=null,local_files_only:kt=!1,revision:sr="main",legacy:or=null}={}){const lr=await i(X,{progress_callback:$e,config:at,cache_dir:ft,local_files_only:kt,revision:sr,legacy:or});return new this(...lr)}_call(X,{text_pair:$e=null,add_special_tokens:at=!0,padding:ft=!1,truncation:kt=null,max_length:sr=null,return_tensor:or=!0,return_token_type_ids:lr=null}={}){const yi=Array.isArray(X);let di;if(yi){if(X.length===0)throw Error("text array must be non-empty");if($e!==null){if(Array.isArray($e)){if(X.length!==$e.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");di=X.map((Hi,Tc)=>this._encode_plus(Hi,{text_pair:$e[Tc],add_special_tokens:at,return_token_type_ids:lr}))}else di=X.map(Hi=>this._encode_plus(Hi,{add_special_tokens:at,return_token_type_ids:lr}))}else{if(X==null)throw Error("text may not be null or undefined");if(Array.isArray($e))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");di=[this._encode_plus(X,{text_pair:$e,add_special_tokens:at,return_token_type_ids:lr})]}if(sr===null?sr=this.model_max_length:kt===null&&(ft===!0?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),sr=this.model_max_length):ft===!1&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),kt=!0)),ft===!0&&(sr=Math.min((0,l.max)(di.map(Hi=>Hi.input_ids.length))[0],sr??1/0)),sr=Math.min(sr,this.model_max_length??1/0),ft||kt)for(let Hi=0;Hi<di.length;++Hi)di[Hi].input_ids.length!==sr&&(di[Hi].input_ids.length>sr?kt&&Wi(di[Hi],sr):ft&&cp(di[Hi],sr,Tc=>Tc==="input_ids"?this.pad_token_id:0,this.padding_side));const zo={};if(or){if(!(ft&&kt)&&di.some(Tc=>{for(const Uc of Object.keys(Tc))if(Tc[Uc].length!==di[0][Uc]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const Hi=[di.length,di[0].input_ids.length];for(const Tc of Object.keys(di[0]))zo[Tc]=new _.Tensor("int64",BigInt64Array.from(di.flatMap(Uc=>Uc[Tc]).map(BigInt)),Hi)}else{for(const Hi of Object.keys(di[0]))zo[Hi]=di.map(Tc=>Tc[Hi]);if(!yi)for(const Hi of Object.keys(zo))zo[Hi]=zo[Hi][0]}return zo}_encode_text(X){if(X===null)return null;const $e=this.added_tokens_splitter.split(X);for(let ft=0;ft<$e.length;++ft){const kt=this.added_tokens_map.get($e[ft]);kt&&(kt.lstrip&&ft>0&&($e[ft-1]=$e[ft-1].trimEnd()),kt.rstrip&&ft<$e.length-1&&($e[ft+1]=$e[ft+1].trimStart()))}return $e.flatMap((ft,kt)=>{if(ft.length===0)return[];if(this.added_tokens_map.has(ft))return[ft];if(this.remove_space===!0&&(ft=ft.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(ft=x(ft)),this.normalizer!==null&&(ft=this.normalizer(ft)),ft.length===0)return[];const sr=this.pre_tokenizer!==null?this.pre_tokenizer(ft,{section_index:kt}):[ft];return this.model(sr)})}_encode_plus(X,{text_pair:$e=null,add_special_tokens:at=!0,return_token_type_ids:ft=null}={}){const{tokens:kt,token_type_ids:sr}=this._tokenize_helper(X,{pair:$e,add_special_tokens:at}),or=this.model.convert_tokens_to_ids(kt),lr={input_ids:or,attention_mask:new Array(or.length).fill(1)};return(ft??this.return_token_type_ids)&&sr&&(lr.token_type_ids=sr),lr}_tokenize_helper(X,{pair:$e=null,add_special_tokens:at=!1}={}){const ft=this._encode_text(X),kt=this._encode_text($e);return this.post_processor?this.post_processor(ft,kt,{add_special_tokens:at}):{tokens:(0,a.mergeArrays)(ft??[],kt??[])}}tokenize(X,{pair:$e=null,add_special_tokens:at=!1}={}){return this._tokenize_helper(X,{pair:$e,add_special_tokens:at}).tokens}encode(X,{text_pair:$e=null,add_special_tokens:at=!0,return_token_type_ids:ft=null}={}){return this._encode_plus(X,{text_pair:$e,add_special_tokens:at,return_token_type_ids:ft}).input_ids}batch_decode(X,$e={}){return X instanceof _.Tensor&&(X=X.tolist()),X.map(at=>this.decode(at,$e))}decode(X,$e={}){if(X instanceof _.Tensor&&(X=g(X)),!Array.isArray(X)||X.length===0||!(0,a.isIntegralNumber)(X[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(X,$e)}decode_single(X,{skip_special_tokens:$e=!1,clean_up_tokenization_spaces:at=null}){let ft=this.model.convert_ids_to_tokens(X);$e&&(ft=ft.filter(sr=>!this.special_tokens.includes(sr)));let kt=this.decoder?this.decoder(ft):ft.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(kt=kt.replaceAll(this.decoder.end_of_word_suffix," "),$e&&(kt=kt.trim())),(at??this.clean_up_tokenization_spaces)&&(kt=w(kt)),kt}get_chat_template({chat_template:X=null,tools:$e=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const at=this.chat_template;if(X!==null&&Object.hasOwn(at,X))X=at[X];else if(X===null)if($e!==null&&"tool_use"in at)X=at.tool_use;else if("default"in at)X=at.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(at).sort()}.`)}else if(X===null)if(this.chat_template)X=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return X}apply_chat_template(X,{tools:$e=null,documents:at=null,chat_template:ft=null,add_generation_prompt:kt=!1,tokenize:sr=!0,padding:or=!1,truncation:lr=!1,max_length:yi=null,return_tensor:di=!0,return_dict:zo=!1,tokenizer_kwargs:Hi={},...Tc}={}){if(ft=this.get_chat_template({chat_template:ft,tools:$e}),typeof ft!="string")throw Error(`chat_template must be a string, but got ${typeof ft}`);let Uc=this._compiled_template_cache.get(ft);Uc===void 0&&(Uc=new d.Template(ft),this._compiled_template_cache.set(ft,Uc));const Cc=Object.create(null);for(const Mc of rf){const ip=this.getToken(Mc);ip&&(Cc[Mc]=ip)}const Lc=Uc.render({messages:X,add_generation_prompt:kt,tools:$e,documents:at,...Cc,...Tc});if(sr){const Mc=this._call(Lc,{add_special_tokens:!1,padding:or,truncation:lr,max_length:yi,return_tensor:di,...Hi});return zo?Mc:Mc.input_ids}return Lc}}class Ri extends si{return_token_type_ids=!0}class _c extends si{return_token_type_ids=!0}class Ui extends si{return_token_type_ids=!0}class Rp extends si{return_token_type_ids=!0}class W extends si{return_token_type_ids=!0}class Qe extends si{return_token_type_ids=!0}class ve extends si{return_token_type_ids=!0}class Ke extends si{return_token_type_ids=!0}class lt extends si{return_token_type_ids=!0}class _n extends si{}class ar extends si{}class vi extends si{return_token_type_ids=!0;constructor(X,$e){super(X,$e),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Pi extends si{return_token_type_ids=!0}class hi extends si{}class Oo extends si{}class we extends si{}class it extends si{constructor(X,$e){super(X,$e),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(at=>this.languageRegex.test(at)),this.lang_to_token=at=>at}_build_translation_inputs(X,$e,at){return bc(this,X,$e,at)}}class pt extends it{}class Ot extends si{}class Ht extends si{}const mn="▁";class ii extends si{padding_side="left";constructor(X,$e){super(X,$e),this.legacy=$e.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Si({replacement:mn,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(X){if(X===null)return null;if(this.legacy||X.length===0)return super._encode_text(X);let $e=super._encode_text(mn+X.replaceAll(mn," "));return $e.length>1&&$e[0]===mn&&this.special_tokens.includes($e[1])&&($e=$e.slice(1)),$e}}class Ti extends si{}class pi extends si{}class Do extends si{}class Ko extends si{}class yc extends si{}class Dc extends si{}class En extends si{}class Oi extends si{}class Ro extends si{}function bc(Lt,X,$e,at){if(!("language_codes"in Lt)||!Array.isArray(Lt.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Lt)||!(Lt.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Lt)||typeof Lt.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const ft=at.src_lang,kt=at.tgt_lang;if(!Lt.language_codes.includes(kt))throw new Error(`Target language code "${kt}" is not valid. Must be one of: {${Lt.language_codes.join(", ")}}`);if(ft!==void 0){if(!Lt.language_codes.includes(ft))throw new Error(`Source language code "${ft}" is not valid. Must be one of: {${Lt.language_codes.join(", ")}}`);for(const sr of Lt.post_processor.config.single)if("SpecialToken"in sr&&Lt.languageRegex.test(sr.SpecialToken.id)){sr.SpecialToken.id=Lt.lang_to_token(ft);break}}return at.forced_bos_token_id=Lt.model.convert_tokens_to_ids([Lt.lang_to_token(kt)])[0],Lt._call(X,$e)}class Oc extends si{constructor(X,$e){super(X,$e),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(at=>this.languageRegex.test(at)),this.lang_to_token=at=>at}_build_translation_inputs(X,$e,at){return bc(this,X,$e,at)}}class dp extends si{constructor(X,$e){super(X,$e),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(at=>this.languageRegex.test(at)).map(at=>at.slice(2,-2)),this.lang_to_token=at=>`__${at}__`}_build_translation_inputs(X,$e,at){return bc(this,X,$e,at)}}class Jf extends si{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(X,{return_timestamps:$e=!1,return_language:at=!1,time_precision:ft=null,force_full_sequences:kt=!0}={}){if(ft===null)throw Error("Must specify time_precision");let sr=null;const or=$e==="word";function lr(){return{language:sr,timestamp:[null,null],text:""}}const yi=[];let di=lr(),zo=0;const Hi=this.timestamp_begin,Uc=Hi+1500;let Cc=[],Lc=[],Mc=!1,ip=null;const ep=new Set(this.all_special_ids);for(const wc of X){const Z=wc.tokens,xe=or?wc.token_timestamps:null;let Ve=null,ct=Hi;if("stride"in wc){const[pr,gi,Ii]=wc.stride;if(zo-=gi,ip=pr-Ii,gi&&(ct=gi/ft+Hi),Ii)for(let ki=Z.length-1;ki>=0;--ki){const Zo=Number(Z[ki]);if(Zo>=Hi){if(Ve!==null&&(Zo-Hi)*ft<ip)break;Ve=Zo}}}let zt=[],Sn=[];for(let pr=0;pr<Z.length;++pr){const gi=Number(Z[pr]);if(ep.has(gi)){const Ii=this.decode([gi]),ki=h.WHISPER_LANGUAGE_MAPPING.get(Ii.slice(2,-2));if(ki!==void 0){if(sr!==null&&ki!==sr&&!$e){Cc.push(zt);const Zo=this.findLongestCommonSequence(Cc)[0],pp=this.decode(Zo);di.text=pp,yi.push(di),Cc=[],zt=[],di=lr()}sr=di.language=ki}}else if(gi>=Hi&&gi<=Uc){const Ii=(gi-Hi)*ft+zo,ki=(0,l.round)(Ii,2);if(Ve!==null&&gi>=Ve)Mc=!0;else if(Mc||Cc.length>0&&gi<ct)Mc=!1;else if(di.timestamp[0]===null)di.timestamp[0]=ki;else if(ki!==di.timestamp[0]){di.timestamp[1]=ki,Cc.push(zt),or&&Lc.push(Sn);const[Zo,pp]=this.findLongestCommonSequence(Cc,Lc),fp=this.decode(Zo);di.text=fp,or&&(di.words=this.collateWordTimestamps(Zo,pp,sr)),yi.push(di),Cc=[],zt=[],Lc=[],Sn=[],di=lr()}}else if(zt.push(gi),or){let Ii=(0,l.round)(xe[pr]+zo,2),ki;if(pr+1<xe.length){ki=(0,l.round)(xe[pr+1]+zo,2);const Zo=this.decode([gi]);C.test(Zo)&&(ki=(0,l.round)(Math.min(Ii+ft,ki),2))}else ki=null;Sn.push([Ii,ki])}}if("stride"in wc){const[pr,gi,Ii]=wc.stride;zo+=pr-Ii}zt.length>0?(Cc.push(zt),or&&Lc.push(Sn)):Cc.every(pr=>pr.length===0)&&(di=lr(),Cc=[],zt=[],Lc=[],Sn=[])}if(Cc.length>0){if(kt&&$e)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[wc,Z]=this.findLongestCommonSequence(Cc,Lc),xe=this.decode(wc);di.text=xe,or&&(di.words=this.collateWordTimestamps(wc,Z,sr)),yi.push(di)}let tp=Object.create(null);const yp=yi.map(wc=>wc.text).join("");if($e||at){for(let wc=0;wc<yi.length;++wc){const Z=yi[wc];$e||delete Z.timestamp,at||delete Z.language}if(or){const wc=[];for(const Z of yi)for(const xe of Z.words)wc.push(xe);tp={chunks:wc}}else tp={chunks:yi}}return[yp,tp]}findLongestCommonSequence(X,$e=null){let at=X[0],ft=at.length,kt=[];const sr=Array.isArray($e)&&$e.length>0;let or=sr?[]:null,lr=sr?$e[0]:null;for(let yi=1;yi<X.length;++yi){const di=X[yi];let zo=0,Hi=[ft,ft,0,0];const Tc=di.length;for(let tp=1;tp<ft+Tc;++tp){const yp=Math.max(0,ft-tp),wc=Math.min(ft,ft+Tc-tp),Z=at.slice(yp,wc),xe=Math.max(0,tp-ft),Ve=Math.min(Tc,tp),ct=di.slice(xe,Ve);if(Z.length!==ct.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let zt;sr?zt=Z.filter((gi,Ii)=>gi===ct[Ii]&&lr[yp+Ii]<=$e[yi][xe+Ii]).length:zt=Z.filter((gi,Ii)=>gi===ct[Ii]).length;const Sn=tp/1e4,pr=zt/tp+Sn;zt>1&&pr>zo&&(zo=pr,Hi=[yp,wc,xe,Ve])}const[Uc,Cc,Lc,Mc]=Hi,ip=Math.floor((Cc+Uc)/2),ep=Math.floor((Mc+Lc)/2);kt.push(...at.slice(0,ip)),at=di.slice(ep),ft=at.length,sr&&(or.push(...lr.slice(0,ip)),lr=$e[yi].slice(ep))}return kt.push(...at),sr?(or.push(...lr),[kt,or]):[kt,[]]}collateWordTimestamps(X,$e,at){const[ft,kt,sr]=this.combineTokensIntoWords(X,at),or=[];for(let lr=0;lr<ft.length;++lr){const yi=sr[lr];or.push({text:ft[lr],timestamp:[$e[yi.at(0)][0],$e[yi.at(-1)][1]]})}return or}combineTokensIntoWords(X,$e,at=`"'“¡¿([{-`,ft=`"'.。,，!！?？:：”)]}、`){$e=$e??"english";let kt,sr,or;return["chinese","japanese","thai","lao","myanmar"].includes($e)?[kt,sr,or]=this.splitTokensOnUnicode(X):[kt,sr,or]=this.splitTokensOnSpaces(X),this.mergePunctuations(kt,sr,or,at,ft)}decode(X,$e){let at;return $e?.decode_with_timestamps?(X instanceof _.Tensor&&(X=g(X)),at=this.decodeWithTimestamps(X,$e)):at=super.decode(X,$e),at}decodeWithTimestamps(X,$e){const at=$e?.time_precision??.02,ft=Array.from(this.all_special_ids).at(-1)+1;let kt=[[]];for(let sr of X)if(sr=Number(sr),sr>=ft){const or=((sr-ft)*at).toFixed(2);kt.push(`<|${or}|>`),kt.push([])}else kt[kt.length-1].push(sr);return kt=kt.map(sr=>typeof sr=="string"?sr:super.decode(sr,$e)),kt.join("")}splitTokensOnUnicode(X){const $e=this.decode(X,{decode_with_timestamps:!0}),at="�",ft=[],kt=[],sr=[];let or=[],lr=[],yi=0;for(let di=0;di<X.length;++di){const zo=X[di];or.push(zo),lr.push(di);const Hi=this.decode(or,{decode_with_timestamps:!0});(!Hi.includes(at)||$e[yi+Hi.indexOf(at)]===at)&&(ft.push(Hi),kt.push(or),sr.push(lr),or=[],lr=[],yi+=Hi.length)}return[ft,kt,sr]}splitTokensOnSpaces(X){const[$e,at,ft]=this.splitTokensOnUnicode(X),kt=[],sr=[],or=[],lr=new RegExp(`^[${A}]$`,"gu");for(let yi=0;yi<$e.length;++yi){const di=$e[yi],zo=at[yi],Hi=ft[yi],Tc=zo[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Uc=di.startsWith(" "),Cc=di.trim(),Lc=lr.test(Cc);if(Tc||Uc||Lc||kt.length===0)kt.push(di),sr.push(zo),or.push(Hi);else{const Mc=kt.length-1;kt[Mc]+=di,sr[Mc].push(...zo),or[Mc].push(...Hi)}}return[kt,sr,or]}mergePunctuations(X,$e,at,ft,kt){const sr=structuredClone(X),or=structuredClone($e),lr=structuredClone(at);let yi=sr.length-2,di=sr.length-1;for(;yi>=0;)sr[yi].startsWith(" ")&&ft.includes(sr[yi].trim())?(sr[di]=sr[yi]+sr[di],or[di]=(0,a.mergeArrays)(or[yi],or[di]),lr[di]=(0,a.mergeArrays)(lr[yi],lr[di]),sr[yi]="",or[yi]=[],lr[yi]=[]):di=yi,--yi;for(yi=0,di=1;di<sr.length;)!sr[yi].endsWith(" ")&&kt.includes(sr[di])?(sr[yi]+=sr[di],or[yi]=(0,a.mergeArrays)(or[yi],or[di]),lr[yi]=(0,a.mergeArrays)(lr[yi],lr[di]),sr[di]="",or[di]=[],lr[di]=[]):yi=di,++di;return[sr.filter(zo=>zo),or.filter(zo=>zo.length>0),lr.filter(zo=>zo.length>0)]}}class kp extends si{}class Qc extends si{}class sp extends si{}class mr extends si{constructor(X,$e){super(X,$e),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(at=>this.languageRegex.test(at)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(X){if(X===null)return null;const[$e,...at]=X.trim().split(this.languageRegex);if(at.length===0)return super._encode_text($e);if(at.length===2){const[ft,kt]=at;return this.supported_language_codes.includes(ft)||console.warn(`Unsupported language code "${ft}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,a.mergeArrays)([ft],super._encode_text(kt))}}}class ci extends si{}class Mi extends si{}class Ac extends si{}class m_ extends si{}class Op extends si{}class p_ extends si{constructor(X,$e){super(X,$e),this.decoder=new Ci({})}}class Hc extends si{}class g_ extends si{}class T_ extends si{}class M_{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:hi,DistilBertTokenizer:_n,CamembertTokenizer:ar,DebertaTokenizer:W,DebertaV2Tokenizer:Qe,BertTokenizer:Ri,HerbertTokenizer:ve,ConvBertTokenizer:Ke,RoFormerTokenizer:lt,XLMTokenizer:vi,ElectraTokenizer:Pi,MobileBertTokenizer:Ui,SqueezeBertTokenizer:Rp,AlbertTokenizer:_c,GPT2Tokenizer:Oo,BartTokenizer:we,MBartTokenizer:it,MBart50Tokenizer:pt,RobertaTokenizer:Ot,WhisperTokenizer:Jf,CodeGenTokenizer:kp,CLIPTokenizer:Qc,SiglipTokenizer:sp,MarianTokenizer:mr,BloomTokenizer:Ht,NllbTokenizer:Oc,M2M100Tokenizer:dp,LlamaTokenizer:ii,CodeLlamaTokenizer:Ti,XLMRobertaTokenizer:pi,MPNetTokenizer:Do,FalconTokenizer:Ko,GPTNeoXTokenizer:yc,EsmTokenizer:Dc,Wav2Vec2CTCTokenizer:ci,BlenderbotTokenizer:Mi,BlenderbotSmallTokenizer:Ac,SpeechT5Tokenizer:m_,NougatTokenizer:Op,VitsTokenizer:p_,Qwen2Tokenizer:En,GemmaTokenizer:Oi,Grok1Tokenizer:Ro,CohereTokenizer:Hc,MgpstrTokenizer:g_,Ernie4_5_Tokenizer:T_,PreTrainedTokenizer:si};static async from_pretrained(X,{progress_callback:$e=null,config:at=null,cache_dir:ft=null,local_files_only:kt=!1,revision:sr="main",legacy:or=null}={}){const[lr,yi]=await i(X,{progress_callback:$e,config:at,cache_dir:ft,local_files_only:kt,revision:sr,legacy:or}),di=yi.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let zo=this.TOKENIZER_CLASS_MAPPING[di];return zo||(console.warn(`Unknown tokenizer class "${di}", attempting to construct from base class.`),zo=si),new zo(lr,yi)}}}),"./src/utils/audio.js":((n,e,t)=>{t.r(e),t.d(e,{RawAudio:()=>re,hamming:()=>r,hanning:()=>i,mel_filter_bank:()=>S,read_audio:()=>d,spectrogram:()=>I,window_function:()=>D});var s=t("./src/utils/hub.js"),a=t("./src/utils/maths.js"),c=t("./src/utils/core.js"),l=t("./src/env.js"),_=t("./src/utils/tensor.js"),m=t("?7992");async function d(G,te){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const q=await(await(0,s.getFile)(G)).arrayBuffer(),z=new AudioContext({sampleRate:te});typeof te>"u"&&console.warn(`No sampling rate provided, using default of ${z.sampleRate}Hz.`);const H=await z.decodeAudioData(q);let he;if(H.numberOfChannels===2){const Ce=Math.sqrt(2),oe=H.getChannelData(0),K=H.getChannelData(1);he=new Float32Array(oe.length);for(let Q=0;Q<H.length;++Q)he[Q]=Ce*(oe[Q]+K[Q])/2}else he=H.getChannelData(0);return he}function h(G,te){if(G<1)return new Float64Array;if(G===1)return new Float64Array([1]);const q=1-te,z=2*Math.PI/(G-1),H=new Float64Array(G);for(let he=0;he<G;++he)H[he]=te-q*Math.cos(he*z);return H}function i(G){return h(G,.5)}function r(G){return h(G,.54)}const u={htk:G=>2595*Math.log10(1+G/700),kaldi:G=>1127*Math.log(1+G/700),slaney:(G,te=1e3,q=15,z=27/Math.log(6.4))=>G>=te?q+Math.log(G/te)*z:3*G/200};function f(G,te="htk"){const q=u[te];if(!q)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof G=="number"?q(G):G.map(z=>q(z))}const g={htk:G=>700*(10**(G/2595)-1),kaldi:G=>700*(Math.exp(G/1127)-1),slaney:(G,te=1e3,q=15,z=Math.log(6.4)/27)=>G>=q?te*Math.exp(z*(G-q)):200*G/3};function w(G,te="htk"){const q=g[te];if(!q)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof G=="number"?q(G):G.map(z=>q(z))}function y(G,te){const q=Float64Array.from({length:te.length-1},(Ce,oe)=>te[oe+1]-te[oe]),z=Array.from({length:G.length},()=>new Array(te.length));for(let Ce=0;Ce<G.length;++Ce){const oe=z[Ce];for(let K=0;K<te.length;++K)oe[K]=te[K]-G[Ce]}const H=te.length-2,he=Array.from({length:H},()=>new Array(G.length));for(let Ce=0;Ce<G.length;++Ce){const oe=z[Ce];for(let K=0;K<H;++K){const Q=-oe[K]/q[K],de=oe[K+2]/q[K+1];he[K][Ce]=Math.max(0,Math.min(Q,de))}}return he}function x(G,te,q){const z=(te-G)/(q-1);return Float64Array.from({length:q},(H,he)=>G+z*he)}function S(G,te,q,z,H,he=null,Ce="htk",oe=!1){if(he!==null&&he!=="slaney")throw new Error('norm must be one of null or "slaney"');if(G<2)throw new Error(`Require num_frequency_bins: ${G} >= 2`);if(q>z)throw new Error(`Require min_frequency: ${q} <= max_frequency: ${z}`);const K=f(q,Ce),Q=f(z,Ce),de=x(K,Q,te+2);let ue=w(de,Ce),Ze;if(oe){const Gt=H/((G-1)*2);Ze=f(Float64Array.from({length:G},(bn,ri)=>ri*Gt),Ce),ue=de}else Ze=x(0,Math.floor(H/2),G);const Pt=y(Ze,ue);if(he!==null&&he==="slaney")for(let Gt=0;Gt<te;++Gt){const bn=Pt[Gt],ri=2/(ue[Gt+2]-ue[Gt]);for(let hn=0;hn<G;++hn)bn[hn]*=ri}return Pt}function T(G,te,q){const z=new G.constructor(G.length+te+q),H=G.length-1;for(let he=0;he<G.length;++he)z[te+he]=G[he];for(let he=1;he<=te;++he)z[te-he]=G[(0,c.calculateReflectOffset)(he,H)];for(let he=1;he<=q;++he)z[H+te+he]=G[(0,c.calculateReflectOffset)(H-he,H)];return z}function E(G,te,q,z,H){if(q<=0)throw new Error("reference must be greater than zero");if(z<=0)throw new Error("min_value must be greater than zero");q=Math.max(z,q);const he=Math.log10(q);for(let Ce=0;Ce<G.length;++Ce)G[Ce]=te*Math.log10(Math.max(z,G[Ce])-he);if(H!==null){if(H<=0)throw new Error("db_range must be greater than zero");const Ce=(0,a.max)(G)[0]-H;for(let oe=0;oe<G.length;++oe)G[oe]=Math.max(G[oe],Ce)}return G}function A(G,te=1,q=1e-5,z=null){return E(G,20,te,q,z)}function C(G,te=1,q=1e-10,z=null){return E(G,10,te,q,z)}async function I(G,te,q,z,{fft_length:H=null,power:he=1,center:Ce=!0,pad_mode:oe="reflect",onesided:K=!0,preemphasis:Q=null,preemphasis_htk_flavor:de=!0,mel_filters:ue=null,mel_floor:Ze=1e-10,log_mel:Pt=null,reference:Gt=1,min_value:bn=1e-10,db_range:ri=null,remove_dc_offset:hn=null,min_num_frames:ze=null,max_num_frames:wt=null,do_pad:ke=!0,transpose:Bt=!1}={}){const In=te.length;if(H===null&&(H=q),q>H)throw Error(`frame_length (${q}) may not be larger than fft_length (${H})`);if(In!==q)throw new Error(`Length of the window (${In}) must equal frame_length (${q})`);if(z<=0)throw new Error("hop_length must be greater than zero");if(he===null&&ue!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!de)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(Ce){if(oe!=="reflect")throw new Error(`pad_mode="${oe}" not implemented yet.`);const mi=Math.floor((H-1)/2)+1;G=T(G,mi,mi)}let Tn=Math.floor(1+Math.floor((G.length-q)/z));ze!==null&&Tn<ze&&(Tn=ze);const cn=K?Math.floor(H/2)+1:H;let kn=Tn,yn=Tn;wt!==null&&(wt>Tn?ke&&(yn=wt):yn=kn=wt);const $n=new a.FFT(H),cr=new Float64Array(H),ti=new Float64Array($n.outputBufferSize),vn=new Float32Array(cn*yn);for(let mi=0;mi<kn;++mi){const fi=mi*z,ui=Math.min(G.length-fi,q);ui!==q&&cr.fill(0,0,q);for(let wi=0;wi<ui;++wi)cr[wi]=G[fi+wi];if(hn){let wi=0;for(let zi=0;zi<ui;++zi)wi+=cr[zi];const Lo=wi/ui;for(let zi=0;zi<ui;++zi)cr[zi]-=Lo}if(Q!==null){for(let wi=ui-1;wi>=1;--wi)cr[wi]-=Q*cr[wi-1];cr[0]*=1-Q}for(let wi=0;wi<te.length;++wi)cr[wi]*=te[wi];$n.realTransform(ti,cr);for(let wi=0;wi<cn;++wi){const Lo=wi<<1;vn[wi*yn+mi]=ti[Lo]**2+ti[Lo+1]**2}}if(he!==null&&he!==2){const mi=he/2;for(let fi=0;fi<vn.length;++fi)vn[fi]**=mi}const xi=ue.length;let ir=await(0,_.matmul)(new _.Tensor("float32",ue.flat(),[xi,cn]),new _.Tensor("float32",vn,[cn,yn]));Bt&&(ir=ir.transpose(1,0));const ai=ir.data;for(let mi=0;mi<ai.length;++mi)ai[mi]=Math.max(Ze,ai[mi]);if(he!==null&&Pt!==null){const mi=Math.min(ai.length,kn*xi);switch(Pt){case"log":for(let fi=0;fi<mi;++fi)ai[fi]=Math.log(ai[fi]);break;case"log10":for(let fi=0;fi<mi;++fi)ai[fi]=Math.log10(ai[fi]);break;case"dB":if(he===1)A(ai,Gt,bn,ri);else if(he===2)C(ai,Gt,bn,ri);else throw new Error(`Cannot use log_mel option '${Pt}' with power ${he}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${Pt}'`)}}return ir}function D(G,te,{periodic:q=!0,frame_length:z=null,center:H=!0}={}){const he=q?G+1:G;let Ce;switch(te){case"boxcar":Ce=new Float64Array(he).fill(1);break;case"hann":case"hann_window":Ce=i(he);break;case"hamming":Ce=r(he);break;case"povey":Ce=i(he).map(oe=>Math.pow(oe,.85));break;default:throw new Error(`Unknown window type ${te}.`)}if(q&&(Ce=Ce.subarray(0,G)),z===null)return Ce;if(G>z)throw new Error(`Length of the window (${G}) may not be larger than frame_length (${z})`);return Ce}function R(G,te){let q=44;const z=new ArrayBuffer(q+G.length*4),H=new DataView(z);Y(H,0,"RIFF"),H.setUint32(4,36+G.length*4,!0),Y(H,8,"WAVE"),Y(H,12,"fmt "),H.setUint32(16,16,!0),H.setUint16(20,3,!0),H.setUint16(22,1,!0),H.setUint32(24,te,!0),H.setUint32(28,te*4,!0),H.setUint16(32,4,!0),H.setUint16(34,32,!0),Y(H,36,"data"),H.setUint32(40,G.length*4,!0);for(let he=0;he<G.length;++he,q+=4)H.setFloat32(q,G[he],!0);return z}function Y(G,te,q){for(let z=0;z<q.length;++z)G.setUint8(te+z,q.charCodeAt(z))}class re{constructor(te,q){this.audio=te,this.sampling_rate=q}toWav(){return R(this.audio,this.sampling_rate)}toBlob(){const te=this.toWav();return new Blob([te],{type:"audio/wav"})}async save(te){let q;if(l.apis.IS_BROWSER_ENV){if(l.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");q=c.saveBlob}else if(l.apis.IS_FS_AVAILABLE)q=async(z,H)=>{let he=await H.arrayBuffer();m.writeFileSync(z,Buffer.from(he))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await q(te,this.toBlob())}}}),"./src/utils/constants.js":((n,e,t)=>{t.r(e),t.d(e,{CHAT_TEMPLATE_NAME:()=>m,CONFIG_NAME:()=>a,FEATURE_EXTRACTOR_NAME:()=>c,GENERATION_CONFIG_NAME:()=>d,GITHUB_ISSUE_URL:()=>s,IMAGE_PROCESSOR_NAME:()=>l,PROCESSOR_NAME:()=>_});const s="https://github.com/huggingface/transformers.js/issues/new/choose",a="config.json",c="preprocessor_config.json",l=c,_="processor_config.json",m="chat_template.jinja",d="generation_config.json"}),"./src/utils/core.js":((n,e,t)=>{t.r(e),t.d(e,{calculateDimensions:()=>d,calculateReflectOffset:()=>u,count:()=>y,dispatchCallback:()=>s,escapeRegExp:()=>c,isIntegralNumber:()=>_,isNullishDimension:()=>m,isTypedArray:()=>l,len:()=>w,mergeArrays:()=>i,pick:()=>g,pop:()=>h,product:()=>r,reverseDictionary:()=>a,saveBlob:()=>f});function s(x,S){x&&x(S)}function a(x){return Object.fromEntries(Object.entries(x).map(([S,T])=>[T,S]))}function c(x){return x.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function l(x){return x?.prototype?.__proto__?.constructor?.name==="TypedArray"}function _(x){return Number.isInteger(x)||typeof x=="bigint"}function m(x){return x==null||x===-1}function d(x){const S=[];let T=x;for(;Array.isArray(T);)S.push(T.length),T=T[0];return S}function h(x,S,T=void 0){const E=x[S];if(E!==void 0)return delete x[S],E;if(T===void 0)throw Error(`Key ${S} does not exist in object.`);return T}function i(...x){return Array.prototype.concat.apply([],x)}function r(...x){return x.reduce((S,T)=>S.flatMap(E=>T.map(A=>[E,A])))}function u(x,S){return Math.abs((x+S)%(2*S)-S)}function f(x,S){const T=URL.createObjectURL(S),E=document.createElement("a");E.href=T,E.download=x,E.click(),E.remove(),URL.revokeObjectURL(T)}function g(x,S){return Object.assign({},...S.map(T=>{if(x[T]!==void 0)return{[T]:x[T]}}))}function w(x){let S=0;for(const T of x)++S;return S}function y(x,S){let T=0;for(const E of x)E===S&&++T;return T}}),"./src/utils/data-structures.js":((n,e,t)=>{t.r(e),t.d(e,{CharTrie:()=>a,DictionarySplitter:()=>m,LRUCache:()=>d,PriorityQueue:()=>s,TokenLattice:()=>l});class s{constructor(i=(u,f)=>u>f,r=1/0){this._heap=[],this._comparator=i,this._maxSize=r}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...i){return this.extend(i)}extend(i){for(const r of i)if(this.size<this._maxSize)this._heap.push(r),this._siftUp();else{const u=this._smallest();this._comparator(r,this._heap[u])&&(this._heap[u]=r,this._siftUpFrom(u))}return this.size}pop(){const i=this.peek(),r=this.size-1;return r>0&&this._swap(0,r),this._heap.pop(),this._siftDown(),i}replace(i){const r=this.peek();return this._heap[0]=i,this._siftDown(),r}_parent(i){return(i+1>>>1)-1}_left(i){return(i<<1)+1}_right(i){return i+1<<1}_greater(i,r){return this._comparator(this._heap[i],this._heap[r])}_swap(i,r){const u=this._heap[i];this._heap[i]=this._heap[r],this._heap[r]=u}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(i){for(;i>0&&this._greater(i,this._parent(i));)this._swap(i,this._parent(i)),i=this._parent(i)}_siftDown(){let i=0;for(;this._left(i)<this.size&&this._greater(this._left(i),i)||this._right(i)<this.size&&this._greater(this._right(i),i);){const r=this._right(i)<this.size&&this._greater(this._right(i),this._left(i))?this._right(i):this._left(i);this._swap(i,r),i=r}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class a{constructor(){this.root=c.default()}extend(i){for(const r of i)this.push(r)}push(i){let r=this.root;for(const u of i){let f=r.children.get(u);f===void 0&&(f=c.default(),r.children.set(u,f)),r=f}r.isLeaf=!0}*commonPrefixSearch(i){let r=this.root;if(r===void 0)return;let u="";for(const f of i){if(u+=f,r=r.children.get(f),r===void 0)return;r.isLeaf&&(yield u)}}}class c{constructor(i,r){this.isLeaf=i,this.children=r}static default(){return new c(!1,new Map)}}class l{constructor(i,r,u){this.chars=Array.from(i),this.len=this.chars.length,this.bosTokenId=r,this.eosTokenId=u,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const f=new _(this.bosTokenId,0,0,0,0),g=new _(this.eosTokenId,1,this.len,0,0);this.nodes.push(f.clone()),this.nodes.push(g.clone()),this.beginNodes[this.len].push(g),this.endNodes[0].push(f)}insert(i,r,u,f){const g=this.nodes.length,w=new _(f,g,i,r,u);this.beginNodes[i].push(w),this.endNodes[i+r].push(w),this.nodes.push(w)}viterbi(){const i=this.len;let r=0;for(;r<=i;){if(this.beginNodes[r].length==0)return[];for(let y of this.beginNodes[r]){y.prev=null;let x=0,S=null;for(let T of this.endNodes[r]){const E=T.backtraceScore+y.score;(S===null||E>x)&&(S=T.clone(),x=E)}if(S!==null)y.prev=S,y.backtraceScore=x;else return[]}++r}const u=[],g=this.beginNodes[i][0].prev;if(g===null)return[];let w=g.clone();for(;w.prev!==null;)u.push(w.clone()),w=w.clone().prev.clone();return u.reverse(),u}piece(i){return this.chars.slice(i.pos,i.pos+i.length).join("")}tokens(){return this.viterbi().map(r=>this.piece(r))}tokenIds(){return this.viterbi().map(r=>r.tokenId)}}class _{constructor(i,r,u,f,g){this.tokenId=i,this.nodeId=r,this.pos=u,this.length=f,this.score=g,this.prev=null,this.backtraceScore=0}clone(){const i=new _(this.tokenId,this.nodeId,this.pos,this.length,this.score);return i.prev=this.prev,i.backtraceScore=this.backtraceScore,i}}class m{constructor(i){this.trie=this._buildTrie(i)}_buildTrie(i){const r=Object.create(null);for(const u of i){let f=r;for(let g=0;g<u.length;++g)f=f[u[g]]??=Object.create(null);f.end=u}return r}split(i){const r=[],u=i.length;let f=0,g=0;for(;g<u;){let w=this.trie,y=null,x=g;for(;x<u&&(w=w[i[x]]);)w.end&&(y=w.end),++x;y?(g>f&&r.push(i.slice(f,g)),r.push(y),g+=y.length,f=g):++g}return f<u&&r.push(i.slice(f)),r}}class d{constructor(i){this.capacity=i,this.cache=new Map}get(i){if(!this.cache.has(i))return;const r=this.cache.get(i);return this.cache.delete(i),this.cache.set(i,r),r}put(i,r){this.cache.has(i)&&this.cache.delete(i),this.cache.set(i,r),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}}),"./src/utils/devices.js":((n,e,t)=>{t.r(e),t.d(e,{DEVICE_TYPES:()=>s});const s=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})}),"./src/utils/dtypes.js":((n,e,t)=>{t.r(e),t.d(e,{DATA_TYPES:()=>l,DEFAULT_DEVICE_DTYPE_MAPPING:()=>_,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>m,isWebGpuFp16Supported:()=>c});var s=t("./src/env.js"),a=t("./src/utils/devices.js");const c=(function(){let d;return async function(){if(d===void 0)if(!s.apis.IS_WEBGPU_AVAILABLE)d=!1;else try{d=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{d=!1}return d}})(),l=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),_=Object.freeze({[a.DEVICE_TYPES.wasm]:l.q8}),m=Object.freeze({[l.fp32]:"",[l.fp16]:"_fp16",[l.int8]:"_int8",[l.uint8]:"_uint8",[l.q8]:"_quantized",[l.q4]:"_q4",[l.q4f16]:"_q4f16",[l.bnb4]:"_bnb4"})}),"./src/utils/generic.js":((n,e,t)=>{t.r(e),t.d(e,{Callable:()=>s});const s=class{constructor(){let a=function(...c){return a._call(...c)};return Object.setPrototypeOf(a,new.target.prototype)}_call(...a){throw Error("Must implement _call method in subclass")}}}),"./src/utils/hub.js":((n,e,t)=>{t.r(e),t.d(e,{MAX_EXTERNAL_DATA_CHUNKS:()=>_,getFile:()=>u,getModelFile:()=>x,getModelJSON:()=>T,getModelText:()=>S});var s=t("?7992"),a=t("?5af5"),c=t("./src/env.js"),l=t("./src/utils/core.js");const _=100,m={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class d{constructor(I){if(this.filePath=I,this.headers=new Headers,this.exists=s.existsSync(I),this.exists){this.status=200,this.statusText="OK";let D=s.statSync(I);this.headers.set("content-length",D.size.toString()),this.updateContentType();const R=s.createReadStream(I);this.body=new ReadableStream({start(Y){R.on("data",re=>Y.enqueue(re)),R.on("end",()=>Y.close()),R.on("error",re=>Y.error(re))},cancel(){R.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const I=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",m[I]??"application/octet-stream")}clone(){let I=new d(this.filePath);return I.exists=this.exists,I.status=this.status,I.statusText=this.statusText,I.headers=new Headers(this.headers),I}async arrayBuffer(){return(await s.promises.readFile(this.filePath)).buffer}async blob(){const I=await s.promises.readFile(this.filePath);return new Blob([I],{type:this.headers.get("content-type")})}async text(){return await s.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function h(C,I=null,D=null){let R;try{R=new URL(C)}catch{return!1}return!(I&&!I.includes(R.protocol)||D&&!D.includes(R.hostname))}const i=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function r(C){return!(!i.test(C)||C.includes("..")||C.includes("--")||C.endsWith(".git")||C.endsWith(".ipynb"))}async function u(C){if(c.env.useFS&&!h(C,["http:","https:","blob:"]))return new d(C instanceof URL?C.protocol==="file:"?C.pathname:C.toString():C);if(typeof process<"u"&&process?.release?.name==="node"){const I=!!define_process_env_default$1?.TESTING_REMOTELY,D=c.env.version,R=new Headers;if(R.set("User-Agent",`transformers.js/${D}; is_ci/${I};`),h(C,["http:","https:"],["huggingface.co","hf.co"])){const re=define_process_env_default$1?.HF_TOKEN??define_process_env_default$1?.HF_ACCESS_TOKEN;re&&R.set("Authorization",`Bearer ${re}`)}return fetch(C,{headers:R})}else return fetch(C)}const f={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function g(C,I,D){if(!D)return null;const R=f[C]??`Error (${C}) occurred while trying to load file`;throw Error(`${R}: "${I}".`)}class w{constructor(I){this.path=I}async match(I){let D=a.join(this.path,I),R=new d(D);if(R.exists)return R}async put(I,D,R=void 0){let Y=a.join(this.path,I);try{const re=D.headers.get("Content-Length"),G=parseInt(re??"0");let te=0;await s.promises.mkdir(a.dirname(Y),{recursive:!0});const q=s.createWriteStream(Y),z=D.body.getReader();for(;;){const{done:H,value:he}=await z.read();if(H)break;await new Promise((oe,K)=>{q.write(he,Q=>{if(Q){K(Q);return}oe()})}),te+=he.length;const Ce=G?te/G*100:0;R?.({progress:Ce,loaded:te,total:G})}q.close()}catch(re){try{await s.promises.unlink(Y)}catch{}throw re}}}async function y(C,...I){for(let D of I)try{let R=await C.match(D);if(R)return R}catch{continue}}async function x(C,I,D=!0,R={},Y=!1){if(!c.env.allowLocalModels){if(R.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!c.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,l.dispatchCallback)(R.progress_callback,{status:"initiate",name:C,file:I});let re;if(!re&&c.env.useCustomCache){if(!c.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!c.env.customCache.match||!c.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");re=c.env.customCache}if(!re&&c.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{re=await caches.open("transformers-cache")}catch(Ze){console.warn("An error occurred while opening the browser cache:",Ze)}}if(!re&&c.env.useFSCache){if(!c.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");re=new w(R.cache_dir??c.env.cacheDir)}const G=R.revision??"main",te=A(C,I),q=r(C),z=q?A(c.env.localModelPath,te):te,H=A(c.env.remoteHost,c.env.remotePathTemplate.replaceAll("{model}",C).replaceAll("{revision}",encodeURIComponent(G)),I);let he;const Ce=re instanceof w?G==="main"?te:A(C,G,I):H;let oe=!1,K;re&&(K=await y(re,z,Ce));const Q=K!==void 0;if(K===void 0){if(c.env.allowLocalModels)if(h(te,["http:","https:"])){if(R.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${te}.`);if(!c.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${te}.`)}else try{K=await u(z),he=z}catch(Pt){console.warn(`Unable to load from local path "${z}": "${Pt}"`)}if(K===void 0||K.status===404){if(R.local_files_only||!c.env.allowRemoteModels){if(D)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${z}".`);return null}if(!q)throw Error(`Local file missing at "${z}" and download aborted due to invalid model ID "${C}".`);if(K=await u(H),K.status!==200)return g(K.status,H,D);he=Ce}oe=re&&typeof Response<"u"&&K instanceof Response&&K.status===200}(0,l.dispatchCallback)(R.progress_callback,{status:"download",name:C,file:I});let de;if(!(c.apis.IS_NODE_ENV&&Y)){let Ze;R.progress_callback?Q&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(Ze=new Uint8Array(await K.arrayBuffer()),(0,l.dispatchCallback)(R.progress_callback,{status:"progress",name:C,file:I,progress:100,loaded:Ze.length,total:Ze.length})):Ze=await E(K,Pt=>{(0,l.dispatchCallback)(R.progress_callback,{status:"progress",name:C,file:I,...Pt})}):Ze=new Uint8Array(await K.arrayBuffer()),de=Ze}if(oe&&he&&await re.match(he)===void 0&&(de?await re.put(he,new Response(de,{headers:K.headers})).catch(Ze=>{console.warn(`Unable to add response to browser cache: ${Ze}.`)}):await re.put(he,K,R.progress_callback)),(0,l.dispatchCallback)(R.progress_callback,{status:"done",name:C,file:I}),de){if(!c.apis.IS_NODE_ENV&&Y)throw new Error("Cannot return path in a browser environment.");return de}if(K instanceof d)return K.filePath;const ue=await re?.match(he);if(ue instanceof d)return ue.filePath;if(ue instanceof Response)return new Uint8Array(await ue.arrayBuffer());if(typeof ue=="string")return ue;throw new Error("Unable to get model file path or buffer.")}async function S(C,I,D=!0,R={}){const Y=await x(C,I,D,R,!1);return Y===null?null:new TextDecoder("utf-8").decode(Y)}async function T(C,I,D=!0,R={}){const Y=await S(C,I,D,R);return Y===null?{}:JSON.parse(Y)}async function E(C,I){const D=C.headers.get("Content-Length");D===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let R=parseInt(D??"0"),Y=new Uint8Array(R),re=0;const G=C.body.getReader();async function te(){const{done:q,value:z}=await G.read();if(q)return;const H=re+z.length;if(H>R){R=H;const Ce=new Uint8Array(R);Ce.set(Y),Y=Ce}Y.set(z,re),re=H;const he=re/R*100;return I({progress:he,loaded:re,total:R}),te()}return await te(),Y}function A(...C){return C=C.map((I,D)=>(D&&(I=I.replace(new RegExp("^/"),"")),D!==C.length-1&&(I=I.replace(new RegExp("/$"),"")),I)),C.join("/")}}),"./src/utils/image.js":((n,e,t)=>{t.r(e),t.d(e,{RawImage:()=>f,load_image:()=>g});var s=t("./src/utils/core.js"),a=t("./src/utils/hub.js"),c=t("./src/env.js"),l=t("./src/utils/tensor.js"),_=t("?2b25");let m,d,h;const i=c.apis.IS_BROWSER_ENV||c.apis.IS_WEBWORKER_ENV;if(i)m=(w,y)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(w,y)},h=self.createImageBitmap,d=self.ImageData;else if(_)h=async w=>{const x=(await w.metadata()).channels,{data:S,info:T}=await w.rotate().raw().toBuffer({resolveWithObject:!0}),E=new f(new Uint8ClampedArray(S),T.width,T.height,T.channels);return x!==void 0&&x!==T.channels&&E.convert(x),E};else throw new Error("Unable to load image processing library.");const r={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},u=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class f{constructor(y,x,S,T){this.data=y,this.width=x,this.height=S,this.channels=T}get size(){return[this.width,this.height]}static async read(y){if(y instanceof f)return y;if(typeof y=="string"||y instanceof URL)return await this.fromURL(y);if(y instanceof Blob)return await this.fromBlob(y);if(typeof HTMLCanvasElement<"u"&&y instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&y instanceof OffscreenCanvas)return this.fromCanvas(y);throw new Error(`Unsupported input type: ${typeof y}`)}static fromCanvas(y){if(!i)throw new Error("fromCanvas() is only supported in browser environments.");const S=y.getContext("2d").getImageData(0,0,y.width,y.height).data;return new f(S,y.width,y.height,4)}static async fromURL(y){const x=await(0,a.getFile)(y);if(x.status!==200)throw new Error(`Unable to read image from "${y}" (${x.status} ${x.statusText})`);const S=await x.blob();return this.fromBlob(S)}static async fromBlob(y){if(i){const x=await h(y),S=m(x.width,x.height).getContext("2d");return S.drawImage(x,0,0),new this(S.getImageData(0,0,x.width,x.height).data,x.width,x.height,4)}else{const x=_(await y.arrayBuffer());return await h(x)}}static fromTensor(y,x="CHW"){if(y.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${y.dims.length} dimensions.`);if(x==="CHW")y=y.transpose(1,2,0);else if(x!=="HWC")throw new Error(`Unsupported channel format: ${x}`);if(!(y.data instanceof Uint8ClampedArray||y.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${y.type}`);switch(y.dims[2]){case 1:case 2:case 3:case 4:return new f(y.data,y.dims[1],y.dims[0],y.dims[2]);default:throw new Error(`Unsupported number of channels: ${y.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const y=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let x=0,S=0;x<this.data.length;x+=this.channels){const T=this.data[x],E=this.data[x+1],A=this.data[x+2];y[S++]=Math.round(.2989*T+.587*E+.114*A)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(y,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const y=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let x=0,S=0;x<this.data.length;++x)y[S++]=this.data[x],y[S++]=this.data[x],y[S++]=this.data[x];break;case 4:for(let x=0,S=0;x<this.data.length;x+=4)y[S++]=this.data[x],y[S++]=this.data[x+1],y[S++]=this.data[x+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(y,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const y=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let x=0,S=0;x<this.data.length;++x)y[S++]=this.data[x],y[S++]=this.data[x],y[S++]=this.data[x],y[S++]=255;break;case 3:for(let x=0,S=0;x<this.data.length;x+=3)y[S++]=this.data[x],y[S++]=this.data[x+1],y[S++]=this.data[x+2],y[S++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(y,this.width,this.height,4)}putAlpha(y){if(y.width!==this.width||y.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${y.width}x${y.height}`);if(y.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${y.channels}`);const x=this.data,S=y.data,T=this.width*this.height;if(this.channels===3){const E=new Uint8ClampedArray(T*4);for(let A=0,C=0,I=0;A<T;++A)E[I++]=x[C++],E[I++]=x[C++],E[I++]=x[C++],E[I++]=S[A];return this._update(E,this.width,this.height,4)}else if(this.channels===4){for(let E=0;E<T;++E)x[4*E+3]=S[E];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(y,x,{resample:S=2}={}){if(this.width===y&&this.height===x)return this;let T=r[S]??S;const E=(0,s.isNullishDimension)(y),A=(0,s.isNullishDimension)(x);if(E&&A)return this;if(E?y=x/this.height*this.width:A&&(x=y/this.width*this.height),i){const C=this.channels,I=this.toCanvas(),D=m(y,x).getContext("2d");return D.drawImage(I,0,0,y,x),new f(D.getImageData(0,0,y,x).data,y,x,4).convert(C)}else{let C=this.toSharp();switch(T){case"box":case"hamming":(T==="box"||T==="hamming")&&(console.warn(`Resampling method ${T} is not yet supported. Using bilinear instead.`),T="bilinear");case"nearest":case"bilinear":case"bicubic":C=C.affine([y/this.width,0,0,x/this.height],{interpolator:T});break;case"lanczos":C=C.resize({width:y,height:x,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${T} is not supported.`)}return await h(C)}}async pad([y,x,S,T]){if(y=Math.max(y,0),x=Math.max(x,0),S=Math.max(S,0),T=Math.max(T,0),y===0&&x===0&&S===0&&T===0)return this;if(i){const E=this.channels,A=this.toCanvas(),C=this.width+y+x,I=this.height+S+T,D=m(C,I).getContext("2d");return D.drawImage(A,0,0,this.width,this.height,y,S,this.width,this.height),new f(D.getImageData(0,0,C,I).data,C,I,4).convert(E)}else{const E=this.toSharp().extend({left:y,right:x,top:S,bottom:T});return await h(E)}}async crop([y,x,S,T]){if(y=Math.max(y,0),x=Math.max(x,0),S=Math.min(S,this.width-1),T=Math.min(T,this.height-1),y===0&&x===0&&S===this.width-1&&T===this.height-1)return this;const E=S-y+1,A=T-x+1;if(i){const C=this.channels,I=this.toCanvas(),D=m(E,A).getContext("2d");return D.drawImage(I,y,x,E,A,0,0,E,A),new f(D.getImageData(0,0,E,A).data,E,A,4).convert(C)}else{const C=this.toSharp().extract({left:y,top:x,width:E,height:A});return await h(C)}}async center_crop(y,x){if(this.width===y&&this.height===x)return this;const S=(this.width-y)/2,T=(this.height-x)/2;if(i){const E=this.channels,A=this.toCanvas(),C=m(y,x).getContext("2d");let I=0,D=0,R=0,Y=0;return S>=0?I=S:R=-S,T>=0?D=T:Y=-T,C.drawImage(A,I,D,y,x,R,Y,y,x),new f(C.getImageData(0,0,y,x).data,y,x,4).convert(E)}else{let E=this.toSharp();if(S>=0&&T>=0)E=E.extract({left:Math.floor(S),top:Math.floor(T),width:y,height:x});else if(S<=0&&T<=0){const A=Math.floor(-T),C=Math.floor(-S);E=E.extend({top:A,left:C,right:y-this.width-C,bottom:x-this.height-A})}else{let A=[0,0],C=0;T<0?(A[0]=Math.floor(-T),A[1]=x-this.height-A[0]):C=Math.floor(T);let I=[0,0],D=0;S<0?(I[0]=Math.floor(-S),I[1]=y-this.width-I[0]):D=Math.floor(S),E=E.extend({top:A[0],bottom:A[1],left:I[0],right:I[1]}).extract({left:D,top:C,width:y,height:x})}return await h(E)}}async toBlob(y="image/png",x=1){if(!i)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:y,quality:x})}toTensor(y="CHW"){let x=new l.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(y!=="HWC")if(y==="CHW")x=x.permute(2,0,1);else throw new Error(`Unsupported channel format: ${y}`);return x}toCanvas(){if(!i)throw new Error("toCanvas() is only supported in browser environments.");const y=this.clone().rgba(),x=m(y.width,y.height),S=new d(y.data,y.width,y.height);return x.getContext("2d").putImageData(S,0,0),x}split(){const{data:y,width:x,height:S,channels:T}=this,E=y.constructor,A=y.length/T,C=Array.from({length:T},()=>new E(A));for(let I=0;I<A;++I){const D=T*I;for(let R=0;R<T;++R)C[R][I]=y[D+R]}return C.map(I=>new f(I,x,S,1))}_update(y,x,S,T=null){return this.data=y,this.width=x,this.height=S,T!==null&&(this.channels=T),this}clone(){return new f(this.data.slice(),this.width,this.height,this.channels)}convert(y){if(this.channels===y)return this;switch(y){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(y){if(i){if(c.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const x=y.split(".").pop().toLowerCase(),S=u.get(x)??"image/png",T=await this.toBlob(S);(0,s.saveBlob)(y,T)}else{if(c.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(y);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(i)throw new Error("toSharp() is only supported in server-side environments.");return _(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const g=f.read.bind(f)}),"./src/utils/maths.js":((n,e,t)=>{t.r(e),t.d(e,{FFT:()=>g,bankers_round:()=>x,cos_sim:()=>m,dot:()=>_,dynamic_time_warping:()=>S,interpolate_data:()=>s,log_softmax:()=>l,magnitude:()=>d,max:()=>i,medianFilter:()=>w,min:()=>h,permute_data:()=>a,round:()=>y,softmax:()=>c});function s(T,[E,A,C],[I,D],R="bilinear",Y=!1){const re=D/C,G=I/A,te=new T.constructor(I*D*E),q=A*C,z=I*D;for(let H=0;H<I;++H)for(let he=0;he<D;++he){const Ce=H*D+he,oe=(he+.5)/re-.5,K=(H+.5)/G-.5;let Q=Math.floor(oe),de=Math.floor(K);const ue=Math.min(Q+1,C-1),Ze=Math.min(de+1,A-1);Q=Math.max(Q,0),de=Math.max(de,0);const Pt=oe-Q,Gt=K-de,bn=(1-Pt)*(1-Gt),ri=Pt*(1-Gt),hn=(1-Pt)*Gt,ze=Pt*Gt,wt=de*C,ke=Ze*C,Bt=wt+Q,In=wt+ue,Tn=ke+Q,cn=ke+ue;for(let kn=0;kn<E;++kn){const yn=kn*q;te[kn*z+Ce]=bn*T[yn+Bt]+ri*T[yn+In]+hn*T[yn+Tn]+ze*T[yn+cn]}}return te}function a(T,E,A){const C=new Array(A.length),I=new Array(A.length);for(let Y=A.length-1,re=1;Y>=0;--Y)I[Y]=re,C[Y]=E[A[Y]],re*=C[Y];const D=A.map((Y,re)=>I[A.indexOf(re)]),R=new T.constructor(T.length);for(let Y=0;Y<T.length;++Y){let re=0;for(let G=E.length-1,te=Y;G>=0;--G)re+=te%E[G]*D[G],te=Math.floor(te/E[G]);R[re]=T[Y]}return[R,C]}function c(T){const E=i(T)[0],A=T.map(D=>Math.exp(D-E)),C=A.reduce((D,R)=>D+R,0);return A.map(D=>D/C)}function l(T){const E=i(T)[0];let A=0;for(let D=0;D<T.length;++D)A+=Math.exp(T[D]-E);const C=Math.log(A);return T.map(D=>D-E-C)}function _(T,E){let A=0;for(let C=0;C<T.length;++C)A+=T[C]*E[C];return A}function m(T,E){const A=_(T,E),C=d(T),I=d(E);return A/(C*I)}function d(T){return Math.sqrt(T.reduce((E,A)=>E+A*A,0))}function h(T){if(T.length===0)throw Error("Array must not be empty");let E=T[0],A=0;for(let C=1;C<T.length;++C)T[C]<E&&(E=T[C],A=C);return[E,A]}function i(T){if(T.length===0)throw Error("Array must not be empty");let E=T[0],A=0;for(let C=1;C<T.length;++C)T[C]>E&&(E=T[C],A=C);return[E,A]}function r(T){return T>0&&(T&T-1)===0}class u{constructor(E){if(this.size=E|0,this.size<=1||!r(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=E<<1,this.table=new Float64Array(this.size*2);for(let C=0;C<this.table.length;C+=2){const I=Math.PI*C/this.size;this.table[C]=Math.cos(I),this.table[C+1]=-Math.sin(I)}let A=0;for(let C=1;this.size>C;C<<=1)++A;this._width=A%2===0?A-1:A,this._bitrev=new Int32Array(1<<this._width);for(let C=0;C<this._bitrev.length;++C){this._bitrev[C]=0;for(let I=0;I<this._width;I+=2){const D=this._width-I-2;this._bitrev[C]|=(C>>>I&3)<<D}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(E,A){const C=A||new Array(E.length>>>1);for(let I=0;I<E.length;I+=2)C[I>>>1]=E[I];return C}toComplexArray(E,A){const C=A||this.createComplexArray();for(let I=0;I<C.length;I+=2)C[I]=E[I>>>1],C[I+1]=0;return C}transform(E,A){if(E===A)throw new Error("Input and output buffers must be different");this._transform4(E,A,1)}realTransform(E,A){if(E===A)throw new Error("Input and output buffers must be different");this._realTransform4(E,A,1)}inverseTransform(E,A){if(E===A)throw new Error("Input and output buffers must be different");this._transform4(E,A,-1);for(let C=0;C<E.length;++C)E[C]/=this.size}_transform4(E,A,C){const I=this._csize;let R=1<<this._width,Y=I/R<<1,re,G;const te=this._bitrev;if(Y===4)for(re=0,G=0;re<I;re+=Y,++G){const z=te[G];this._singleTransform2(A,E,re,z,R)}else for(re=0,G=0;re<I;re+=Y,++G){const z=te[G];this._singleTransform4(A,E,re,z,R,C)}const q=this.table;for(R>>=2;R>=2;R>>=2){Y=I/R<<1;const z=Y>>>2;for(re=0;re<I;re+=Y){const H=re+z-1;for(let he=re,Ce=0;he<H;he+=2,Ce+=R){const oe=he,K=oe+z,Q=K+z,de=Q+z,ue=E[oe],Ze=E[oe+1],Pt=E[K],Gt=E[K+1],bn=E[Q],ri=E[Q+1],hn=E[de],ze=E[de+1],wt=q[Ce],ke=C*q[Ce+1],Bt=Pt*wt-Gt*ke,In=Pt*ke+Gt*wt,Tn=q[2*Ce],cn=C*q[2*Ce+1],kn=bn*Tn-ri*cn,yn=bn*cn+ri*Tn,$n=q[3*Ce],cr=C*q[3*Ce+1],ti=hn*$n-ze*cr,vn=hn*cr+ze*$n,xi=ue+kn,ir=Ze+yn,ai=ue-kn,mi=Ze-yn,fi=Bt+ti,ui=In+vn,wi=C*(Bt-ti),Lo=C*(In-vn);E[oe]=xi+fi,E[oe+1]=ir+ui,E[K]=ai+Lo,E[K+1]=mi-wi,E[Q]=xi-fi,E[Q+1]=ir-ui,E[de]=ai-Lo,E[de+1]=mi+wi}}}}_singleTransform2(E,A,C,I,D){const R=E[I],Y=E[I+1],re=E[I+D],G=E[I+D+1];A[C]=R+re,A[C+1]=Y+G,A[C+2]=R-re,A[C+3]=Y-G}_singleTransform4(E,A,C,I,D,R){const Y=D*2,re=D*3,G=E[I],te=E[I+1],q=E[I+D],z=E[I+D+1],H=E[I+Y],he=E[I+Y+1],Ce=E[I+re],oe=E[I+re+1],K=G+H,Q=te+he,de=G-H,ue=te-he,Ze=q+Ce,Pt=z+oe,Gt=R*(q-Ce),bn=R*(z-oe);A[C]=K+Ze,A[C+1]=Q+Pt,A[C+2]=de+bn,A[C+3]=ue-Gt,A[C+4]=K-Ze,A[C+5]=Q-Pt,A[C+6]=de-bn,A[C+7]=ue+Gt}_realTransform4(E,A,C){const I=this._csize;let R=1<<this._width,Y=I/R<<1,re,G;const te=this._bitrev;if(Y===4)for(re=0,G=0;re<I;re+=Y,++G){const H=te[G];this._singleRealTransform2(A,E,re,H>>>1,R>>>1)}else for(re=0,G=0;re<I;re+=Y,++G){const H=te[G];this._singleRealTransform4(A,E,re,H>>>1,R>>>1,C)}const q=this.table;for(R>>=2;R>=2;R>>=2){Y=I/R<<1;const H=Y>>>1,he=H>>>1,Ce=he>>>1;for(re=0;re<I;re+=Y)for(let oe=0,K=0;oe<=Ce;oe+=2,K+=R){const Q=re+oe,de=Q+he,ue=de+he,Ze=ue+he,Pt=E[Q],Gt=E[Q+1],bn=E[de],ri=E[de+1],hn=E[ue],ze=E[ue+1],wt=E[Ze],ke=E[Ze+1],Bt=Pt,In=Gt,Tn=q[K],cn=C*q[K+1],kn=bn*Tn-ri*cn,yn=bn*cn+ri*Tn,$n=q[2*K],cr=C*q[2*K+1],ti=hn*$n-ze*cr,vn=hn*cr+ze*$n,xi=q[3*K],ir=C*q[3*K+1],ai=wt*xi-ke*ir,mi=wt*ir+ke*xi,fi=Bt+ti,ui=In+vn,wi=Bt-ti,Lo=In-vn,zi=kn+ai,Ci=yn+mi,Si=C*(kn-ai),zc=C*(yn-mi);if(E[Q]=fi+zi,E[Q+1]=ui+Ci,E[de]=wi+zc,E[de+1]=Lo-Si,oe===0){E[ue]=fi-zi,E[ue+1]=ui-Ci;continue}if(oe===Ce)continue;const Xc=re+he-oe,up=re+H-oe;E[Xc]=wi-C*zc,E[Xc+1]=-Lo-C*Si,E[up]=fi-C*zi,E[up+1]=-ui+C*Ci}}const z=I>>>1;for(let H=2;H<z;H+=2)E[I-H]=E[H],E[I-H+1]=-E[H+1]}_singleRealTransform2(E,A,C,I,D){const R=E[I],Y=E[I+D];A[C]=R+Y,A[C+1]=0,A[C+2]=R-Y,A[C+3]=0}_singleRealTransform4(E,A,C,I,D,R){const Y=D*2,re=D*3,G=E[I],te=E[I+D],q=E[I+Y],z=E[I+re],H=G+q,he=G-q,Ce=te+z,oe=R*(te-z);A[C]=H+Ce,A[C+1]=0,A[C+2]=he,A[C+3]=-oe,A[C+4]=H-Ce,A[C+5]=0,A[C+6]=he,A[C+7]=oe}}class f{constructor(E){const A=2*(E-1),C=2*(2*E-1),I=2**Math.ceil(Math.log2(C));this.bufferSize=I,this._a=A;const D=new Float64Array(C),R=new Float64Array(I);this._chirpBuffer=new Float64Array(I),this._buffer1=new Float64Array(I),this._buffer2=new Float64Array(I),this._outBuffer1=new Float64Array(I),this._outBuffer2=new Float64Array(I);const Y=-2*Math.PI/E,re=Math.cos(Y),G=Math.sin(Y);for(let te=0;te<C>>1;++te){const q=(te+1-E)**2/2,z=Math.sqrt(re**2+G**2)**q,H=q*Math.atan2(G,re),he=2*te;D[he]=z*Math.cos(H),D[he+1]=z*Math.sin(H),R[he]=D[he],R[he+1]=-D[he+1]}this._slicedChirpBuffer=D.subarray(A,C),this._f=new u(I>>1),this._f.transform(this._chirpBuffer,R)}_transform(E,A,C){const I=this._buffer1,D=this._buffer2,R=this._outBuffer1,Y=this._outBuffer2,re=this._chirpBuffer,G=this._slicedChirpBuffer,te=this._a;if(C)for(let q=0;q<G.length;q+=2){const z=q+1,H=q>>1,he=A[H];I[q]=he*G[q],I[z]=he*G[z]}else for(let q=0;q<G.length;q+=2){const z=q+1;I[q]=A[q]*G[q]-A[z]*G[z],I[z]=A[q]*G[z]+A[z]*G[q]}this._f.transform(R,I);for(let q=0;q<re.length;q+=2){const z=q+1;D[q]=R[q]*re[q]-R[z]*re[z],D[z]=R[q]*re[z]+R[z]*re[q]}this._f.inverseTransform(Y,D);for(let q=0;q<Y.length;q+=2){const z=Y[q+te],H=Y[q+te+1],he=G[q],Ce=G[q+1];E[q]=z*he-H*Ce,E[q+1]=z*Ce+H*he}}transform(E,A){this._transform(E,A,!1)}realTransform(E,A){this._transform(E,A,!0)}}class g{constructor(E){this.fft_length=E,this.isPowerOfTwo=r(E),this.isPowerOfTwo?(this.fft=new u(E),this.outputBufferSize=2*E):(this.fft=new f(E),this.outputBufferSize=this.fft.bufferSize)}realTransform(E,A){this.fft.realTransform(E,A)}transform(E,A){this.fft.transform(E,A)}}function w(T,E){if(E%2===0||E<=0)throw new Error("Window size must be a positive odd number");const A=new T.constructor(T.length),C=new T.constructor(E),I=Math.floor(E/2);for(let D=0;D<T.length;++D){let R=0;for(let Y=-I;Y<=I;++Y){let re=D+Y;re<0?re=Math.abs(re):re>=T.length&&(re=2*(T.length-1)-re),C[R++]=T[re]}C.sort(),A[D]=C[I]}return A}function y(T,E){const A=Math.pow(10,E);return Math.round(T*A)/A}function x(T){const E=Math.round(T);return Math.abs(T)%1===.5?E%2===0?E:E-1:E}function S(T){const E=T.length,A=T[0].length,C=[E+1,A+1],I=Array.from({length:C[0]},()=>Array(C[1]).fill(1/0));I[0][0]=0;const D=Array.from({length:C[0]},()=>Array(C[1]).fill(-1));for(let te=1;te<C[1];++te)for(let q=1;q<C[0];++q){const z=I[q-1][te-1],H=I[q-1][te],he=I[q][te-1];let Ce,oe;z<H&&z<he?(Ce=z,oe=0):H<z&&H<he?(Ce=H,oe=1):(Ce=he,oe=2),I[q][te]=T[q-1][te-1]+Ce,D[q][te]=oe}for(let te=0;te<C[1];++te)D[0][te]=2;for(let te=0;te<C[0];++te)D[te][0]=1;let R=E,Y=A,re=[],G=[];for(;R>0||Y>0;)switch(re.push(R-1),G.push(Y-1),D[R][Y]){case 0:--R,--Y;break;case 1:--R;break;case 2:--Y;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${R}, ${Y}]. Please file a bug report.`)}return re.reverse(),G.reverse(),[re,G]}}),"./src/utils/tensor.js":((n,e,t)=>{t.r(e),t.d(e,{DataTypeMap:()=>l,Tensor:()=>_,cat:()=>A,full:()=>G,full_like:()=>te,interpolate:()=>h,interpolate_4d:()=>i,layer_norm:()=>x,matmul:()=>r,mean:()=>R,mean_pooling:()=>y,ones:()=>q,ones_like:()=>z,permute:()=>d,quantize_embeddings:()=>oe,rand:()=>Ce,rfft:()=>u,slice:()=>w,stack:()=>C,std_mean:()=>D,topk:()=>f,zeros:()=>H,zeros_like:()=>he});var s=t("./src/utils/maths.js"),a=t("./src/backends/onnx.js"),c=t("./src/ops/registry.js");const l=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class _{get dims(){return this.ort_tensor.dims}set dims(Q){this.ort_tensor.dims=Q}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...Q){return(0,a.isONNXTensor)(Q[0])?this.ort_tensor=Q[0]:this.ort_tensor=new a.Tensor(Q[0],Q[1],Q[2]),new Proxy(this,{get:(de,ue)=>{if(typeof ue=="string"){let Ze=Number(ue);if(Number.isInteger(Ze))return de._getitem(Ze)}return de[ue]},set:(de,ue,Ze)=>de[ue]=Ze})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[Q,...de]=this.dims;if(de.length>0){const ue=de.reduce((Ze,Pt)=>Ze*Pt);for(let Ze=0;Ze<Q;++Ze)yield this._subarray(Ze,ue,de)}else yield*this.data}_getitem(Q){const[de,...ue]=this.dims;if(Q=E(Q,de),ue.length>0){const Ze=ue.reduce((Pt,Gt)=>Pt*Gt);return this._subarray(Q,Ze,ue)}else return new _(this.type,[this.data[Q]],ue)}indexOf(Q){const de=this.data;for(let ue=0;ue<de.length;++ue)if(de[ue]==Q)return ue;return-1}_subarray(Q,de,ue){const Ze=Q*de,Pt=(Q+1)*de,Gt="subarray"in this.data?this.data.subarray(Ze,Pt):this.data.slice(Ze,Pt);return new _(this.type,Gt,ue)}item(){const Q=this.data;if(Q.length!==1)throw new Error(`a Tensor with ${Q.length} elements cannot be converted to Scalar`);return Q[0]}tolist(){return m(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const Q=this.data;for(let de=0;de<Q.length;++de)Q[de]=1/(1+Math.exp(-Q[de]));return this}map(Q){return this.clone().map_(Q)}map_(Q){const de=this.data;for(let ue=0;ue<de.length;++ue)de[ue]=Q(de[ue],ue,de);return this}mul(Q){return this.clone().mul_(Q)}mul_(Q){const de=this.data;for(let ue=0;ue<de.length;++ue)de[ue]*=Q;return this}div(Q){return this.clone().div_(Q)}div_(Q){const de=this.data;for(let ue=0;ue<de.length;++ue)de[ue]/=Q;return this}add(Q){return this.clone().add_(Q)}add_(Q){const de=this.data;for(let ue=0;ue<de.length;++ue)de[ue]+=Q;return this}sub(Q){return this.clone().sub_(Q)}sub_(Q){const de=this.data;for(let ue=0;ue<de.length;++ue)de[ue]-=Q;return this}clone(){return new _(this.type,this.data.slice(),this.dims.slice())}slice(...Q){const de=[],ue=[];for(let ze=0;ze<this.dims.length;++ze){let wt=Q[ze];if(wt==null)ue.push([0,this.dims[ze]]),de.push(this.dims[ze]);else if(typeof wt=="number")wt=E(wt,this.dims[ze],ze),ue.push([wt,wt+1]);else if(Array.isArray(wt)&&wt.length===2){let[ke,Bt]=wt;if(ke=ke===null?0:E(ke,this.dims[ze],ze,!1),Bt=Bt===null?this.dims[ze]:E(Bt,this.dims[ze],ze,!1),ke>Bt)throw new Error(`Invalid slice: ${wt}`);const In=[Math.max(ke,0),Math.min(Bt,this.dims[ze])];ue.push(In),de.push(In[1]-In[0])}else throw new Error(`Invalid slice: ${wt}`)}const Ze=ue.map(([ze,wt])=>wt-ze),Pt=Ze.reduce((ze,wt)=>ze*wt),Gt=this.data,bn=new Gt.constructor(Pt),ri=this.stride();let hn=!0;for(let ze=1;ze<Ze.length;++ze)if(ue[ze][0]!==0||ue[ze][1]!==this.dims[ze]){hn=!1;break}if(hn){const ze=ue[0][0]*ri[0],wt=ue[0][1]*ri[0];if(ArrayBuffer.isView(Gt))bn.set(Gt.subarray(ze,wt));else if(Array.isArray(Gt)){const ke=Gt.slice(ze,wt);for(let Bt=0;Bt<ke.length;++Bt)bn[Bt]=ke[Bt]}else throw new Error("Unsupported data type for slicing")}else for(let ze=0;ze<Pt;++ze){let wt=0;for(let ke=Ze.length-1,Bt=ze;ke>=0;--ke){const In=Ze[ke];wt+=(Bt%In+ue[ke][0])*ri[ke],Bt=Math.floor(Bt/In)}bn[ze]=Gt[wt]}return new _(this.type,bn,de)}permute(...Q){return d(this,Q)}transpose(...Q){return this.permute(...Q)}sum(Q=null,de=!1){return this.norm(1,Q,de)}norm(Q="fro",de=null,ue=!1){if(Q==="fro")Q=2;else if(typeof Q=="string")throw Error(`Unsupported norm: ${Q}`);const Ze=this.data,Pt=(hn,ze)=>hn+ze**Q;if(de===null){const hn=Ze.reduce(Pt,0)**(1/Q);return new _(this.type,[hn],[])}const[Gt,bn,ri]=I(Pt,this,de,ue);if(Q!==1)for(let hn=0;hn<bn.length;++hn)bn[hn]=bn[hn]**(1/Q);return new _(Gt,bn,ri)}normalize_(Q=2,de=1){de=E(de,this.dims.length);const ue=this.norm(Q,de,!0),Ze=this.data,Pt=ue.data;for(let Gt=0;Gt<Ze.length;++Gt){let bn=0;for(let ri=this.dims.length-1,hn=Gt,ze=1;ri>=0;--ri){const wt=this.dims[ri];if(ri!==de){const ke=hn%wt;bn+=ke*ze,ze*=this.dims[ri]}hn=Math.floor(hn/wt)}Ze[Gt]/=Pt[bn]}return this}normalize(Q=2,de=1){return this.clone().normalize_(Q,de)}stride(){return Y(this.dims)}squeeze(Q=null){return new _(this.type,this.data,S(this.dims,Q))}squeeze_(Q=null){return this.dims=S(this.dims,Q),this}unsqueeze(Q=null){return new _(this.type,this.data,T(this.dims,Q))}unsqueeze_(Q=null){return this.dims=T(this.dims,Q),this}flatten_(Q=0,de=-1){de=(de+this.dims.length)%this.dims.length;let ue=this.dims.slice(0,Q),Ze=this.dims.slice(Q,de+1),Pt=this.dims.slice(de+1);return this.dims=[...ue,Ze.reduce((Gt,bn)=>Gt*bn,1),...Pt],this}flatten(Q=0,de=-1){return this.clone().flatten_(Q,de)}view(...Q){let de=-1;for(let Ze=0;Ze<Q.length;++Ze)if(Q[Ze]===-1){if(de!==-1)throw new Error("Only one dimension can be inferred");de=Ze}const ue=this.data;if(de!==-1){const Ze=Q.reduce((Pt,Gt,bn)=>bn!==de?Pt*Gt:Pt,1);Q[de]=ue.length/Ze}return new _(this.type,ue,Q)}neg_(){const Q=this.data;for(let de=0;de<Q.length;++de)Q[de]=-Q[de];return this}neg(){return this.clone().neg_()}gt(Q){const de=new Uint8Array(this.data.length),ue=this.data;for(let Ze=0;Ze<ue.length;++Ze)de[Ze]=ue[Ze]>Q?1:0;return new _("bool",de,this.dims)}lt(Q){const de=new Uint8Array(this.data.length),ue=this.data;for(let Ze=0;Ze<ue.length;++Ze)de[Ze]=ue[Ze]<Q?1:0;return new _("bool",de,this.dims)}clamp_(Q,de){const ue=this.data;for(let Ze=0;Ze<ue.length;++Ze)ue[Ze]=Math.min(Math.max(ue[Ze],Q),de);return this}clamp(Q,de){return this.clone().clamp_(Q,de)}round_(){const Q=this.data;for(let de=0;de<Q.length;++de)Q[de]=Math.round(Q[de]);return this}round(){return this.clone().round_()}mean(Q=null,de=!1){return R(this,Q,de)}min(Q=null,de=!1){if(Q===null){const Gt=(0,s.min)(this.data)[0];return new _(this.type,[Gt],[])}const[ue,Ze,Pt]=I((Gt,bn)=>Math.min(Gt,bn),this,Q,de,1/0);return new _(ue,Ze,Pt)}max(Q=null,de=!1){if(Q===null){const Gt=(0,s.max)(this.data)[0];return new _(this.type,[Gt],[])}const[ue,Ze,Pt]=I((Gt,bn)=>Math.max(Gt,bn),this,Q,de,-1/0);return new _(ue,Ze,Pt)}argmin(Q=null,de=!1){if(Q!==null)throw new Error("`dim !== null` not yet implemented.");const ue=(0,s.min)(this.data)[1];return new _("int64",[BigInt(ue)],[])}argmax(Q=null,de=!1){if(Q!==null)throw new Error("`dim !== null` not yet implemented.");const ue=(0,s.max)(this.data)[1];return new _("int64",[BigInt(ue)],[])}to(Q){if(this.type===Q)return this;if(!l.hasOwnProperty(Q))throw new Error(`Unsupported type: ${Q}`);let de;const ue=["int64","uint64"].includes(this.type),Ze=["int64","uint64"].includes(Q);return ue&&!Ze?de=Number:!ue&&Ze&&(de=BigInt),new _(Q,l[Q].from(this.data,de),this.dims)}}function m(K,Q){const de=K.length,ue=Q.reduce((Pt,Gt)=>Pt*Gt);if(de!==ue)throw Error(`cannot reshape array of size ${de} into shape (${Q})`);let Ze=K;for(let Pt=Q.length-1;Pt>=0;Pt--)Ze=Ze.reduce((Gt,bn)=>{let ri=Gt[Gt.length-1];return ri.length<Q[Pt]?ri.push(bn):Gt.push([bn]),Gt},[[]]);return Ze[0]}function d(K,Q){const[de,ue]=(0,s.permute_data)(K.data,K.dims,Q);return new _(K.type,de,ue)}function h(K,[Q,de],ue="bilinear",Ze=!1){const Pt=K.dims.at(-3)??1,Gt=K.dims.at(-2),bn=K.dims.at(-1);let ri=(0,s.interpolate_data)(K.data,[Pt,Gt,bn],[Q,de],ue,Ze);return new _(K.type,ri,[Pt,Q,de])}async function i(K,{size:Q=null,mode:de="bilinear"}={}){if(K.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!Q)throw new Error("`interpolate_4d` requires a `size` argument.");let ue;if(Q.length===2)ue=[...K.dims.slice(0,2),...Q];else if(Q.length===3)ue=[K.dims[0],...Q];else if(Q.length===4)ue=Q;else throw new Error("`size` must be of length 2, 3, or 4.");let Ze;if(de==="nearest")Ze=await c.TensorOpRegistry.nearest_interpolate_4d;else if(de==="bilinear")Ze=await c.TensorOpRegistry.bilinear_interpolate_4d;else if(de==="bicubic")Ze=await c.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${de}`);const Pt=new _("int64",new BigInt64Array(ue.map(BigInt)),[ue.length]);return await Ze({x:K,s:Pt})}async function r(K,Q){return await(await c.TensorOpRegistry.matmul)({a:K,b:Q})}async function u(K,Q){return await(await c.TensorOpRegistry.rfft)({x:K,a:Q})}async function f(K,Q){const de=await c.TensorOpRegistry.top_k;return Q==null?Q=K.dims.at(-1):Q=Math.min(Q,K.dims.at(-1)),await de({x:K,k:new _("int64",[BigInt(Q)],[1])})}const g=K=>new _("int64",K,[K.length]);async function w(K,Q,de,ue,Ze){return await(await c.TensorOpRegistry.slice)({x:K,s:g(Q),e:g(de),a:g(ue),t:g(Ze??new Array(ue.length).fill(1))})}function y(K,Q){const de=K.data,ue=Q.data,Ze=[K.dims[0],K.dims[2]],Pt=new de.constructor(Ze[0]*Ze[1]),[Gt,bn,ri]=K.dims;let hn=0;for(let ze=0;ze<Gt;++ze){const wt=ze*ri*bn;for(let ke=0;ke<ri;++ke){let Bt=0,In=0;const Tn=ze*bn,cn=wt+ke;for(let yn=0;yn<bn;++yn){const $n=Number(ue[Tn+yn]);In+=$n,Bt+=de[cn+yn*ri]*$n}const kn=Bt/In;Pt[hn++]=kn}}return new _(K.type,Pt,Ze)}function x(K,Q,{eps:de=1e-5}={}){if(K.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[ue,Ze]=K.dims;if(Q.length!==1&&Q[0]!==Ze)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[Pt,Gt]=D(K,1,0,!0),bn=Pt.data,ri=Gt.data,hn=K.data,ze=new hn.constructor(hn.length);for(let wt=0;wt<ue;++wt){const ke=wt*Ze;for(let Bt=0;Bt<Ze;++Bt){const In=ke+Bt;ze[In]=(hn[In]-ri[wt])/(bn[wt]+de)}}return new _(K.type,ze,K.dims)}function S(K,Q){return K=K.slice(),Q===null?K=K.filter(de=>de!==1):typeof Q=="number"?K[Q]===1&&K.splice(Q,1):Array.isArray(Q)&&(K=K.filter((de,ue)=>de!==1||!Q.includes(ue))),K}function T(K,Q){return Q=E(Q,K.length+1),K=K.slice(),K.splice(Q,0,1),K}function E(K,Q,de=null,ue=!0){if(K<-Q||K>=Q){if(ue)throw new Error(`IndexError: index ${K} is out of bounds for dimension${de===null?"":" "+de} with size ${Q}`);return K<-Q?0:Q}return K<0&&(K=(K%Q+Q)%Q),K}function A(K,Q=0){Q=E(Q,K[0].dims.length);const de=K[0].dims.slice();de[Q]=K.reduce((Gt,bn)=>Gt+bn.dims[Q],0);const ue=de.reduce((Gt,bn)=>Gt*bn,1),Ze=new K[0].data.constructor(ue),Pt=K[0].type;if(Q===0){let Gt=0;for(const bn of K){const ri=bn.data;Ze.set(ri,Gt),Gt+=ri.length}}else{let Gt=0;for(let bn=0;bn<K.length;++bn){const{data:ri,dims:hn}=K[bn];for(let ze=0;ze<ri.length;++ze){let wt=0;for(let ke=hn.length-1,Bt=ze,In=1;ke>=0;--ke){const Tn=hn[ke];let cn=Bt%Tn;ke===Q&&(cn+=Gt),wt+=cn*In,In*=de[ke],Bt=Math.floor(Bt/Tn)}Ze[wt]=ri[ze]}Gt+=hn[Q]}}return new _(Pt,Ze,de)}function C(K,Q=0){return A(K.map(de=>de.unsqueeze(Q)),Q)}function I(K,Q,de=null,ue=!1,Ze=null){const Pt=Q.data,Gt=Q.dims;de=E(de,Gt.length);const bn=Gt.slice();bn[de]=1;const ri=new Pt.constructor(Pt.length/Gt[de]);Ze!==null&&ri.fill(Ze);for(let hn=0;hn<Pt.length;++hn){let ze=0;for(let wt=Gt.length-1,ke=hn,Bt=1;wt>=0;--wt){const In=Gt[wt];if(wt!==de){const Tn=ke%In;ze+=Tn*Bt,Bt*=bn[wt]}ke=Math.floor(ke/In)}ri[ze]=K(ri[ze],Pt[hn],hn,ze)}return ue||bn.splice(de,1),[Q.type,ri,bn]}function D(K,Q=null,de=1,ue=!1){const Ze=K.data,Pt=K.dims;if(Q===null){const Bt=Ze.reduce((kn,yn)=>kn+yn,0)/Ze.length,In=Math.sqrt(Ze.reduce((kn,yn)=>kn+(yn-Bt)**2,0)/(Ze.length-de)),Tn=new _(K.type,[Bt],[]);return[new _(K.type,[In],[]),Tn]}Q=E(Q,Pt.length);const Gt=R(K,Q,ue),bn=Gt.data,[ri,hn,ze]=I((ke,Bt,In,Tn)=>ke+(Bt-bn[Tn])**2,K,Q,ue);for(let ke=0;ke<hn.length;++ke)hn[ke]=Math.sqrt(hn[ke]/(Pt[Q]-de));return[new _(ri,hn,ze),Gt]}function R(K,Q=null,de=!1){const ue=K.dims,Ze=K.data;if(Q===null){const ri=Ze.reduce((hn,ze)=>hn+ze,0);return new _(K.type,[ri/Ze.length],[])}Q=E(Q,ue.length);const[Pt,Gt,bn]=I((ri,hn)=>ri+hn,K,Q,de);if(ue[Q]!==1)for(let ri=0;ri<Gt.length;++ri)Gt[ri]/=ue[Q];return new _(Pt,Gt,bn)}function Y(K){const Q=new Array(K.length);for(let de=K.length-1,ue=1;de>=0;--de)Q[de]=ue,ue*=K[de];return Q}function re(K,Q,de,ue){const Ze=K.reduce((Pt,Gt)=>Pt*Gt,1);return new _(de,new ue(Ze).fill(Q),K)}function G(K,Q){let de,ue;if(typeof Q=="number")de="float32",ue=Float32Array;else if(typeof Q=="bigint")de="int64",ue=BigInt64Array;else if(typeof Q=="boolean")de="bool",ue=Uint8Array;else throw new Error(`Unsupported data type: ${typeof Q}`);return re(K,Q,de,ue)}function te(K,Q){return G(K.dims,Q)}function q(K){return re(K,1n,"int64",BigInt64Array)}function z(K){return q(K.dims)}function H(K){return re(K,0n,"int64",BigInt64Array)}function he(K){return H(K.dims)}function Ce(K){const Q=K.reduce((de,ue)=>de*ue,1);return new _("float32",Float32Array.from({length:Q},()=>Math.random()),K)}function oe(K,Q){if(K.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(K.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(Q))throw new Error("The precision must be either 'binary' or 'ubinary'");const de=Q==="binary",ue=de?"int8":"uint8",Ze=de?Int8Array:Uint8Array,Pt=K.data,Gt=new Ze(Pt.length/8);for(let bn=0;bn<Pt.length;++bn){const ri=Pt[bn]>0?1:0,hn=Math.floor(bn/8),ze=bn%8;Gt[hn]|=ri<<7-ze,de&&ze===0&&(Gt[hn]-=128)}return new _(ue,Gt,[K.dims[0],K.dims[1]/8])}}),"./src/utils/video.js":((n,e,t)=>{t.r(e),t.d(e,{RawVideo:()=>l,RawVideoFrame:()=>c,load_video:()=>_});var s=t("./src/utils/image.js"),a=t("./src/env.js");class c{constructor(d,h){this.image=d,this.timestamp=h}}class l{constructor(d,h){d.length>0&&d[0]instanceof s.RawImage&&(d=d.map((i,r)=>new c(i,(r+1)/(d.length+1)*h))),this.frames=d,this.duration=h}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function _(m,{num_frames:d=null,fps:h=null}={}){if(!a.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(d==null&&h==null)throw new Error("Either num_frames or fps must be provided.");const i=[],r=document.createElement("video");if(r.crossOrigin="anonymous",r.muted=!0,typeof m=="string")r.src=m;else if(m instanceof Blob)r.src=URL.createObjectURL(m);else if(m instanceof HTMLVideoElement)r.src=m.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(S=>r.onloadedmetadata=S),r.seekable.start(0)===r.seekable.end(0)){const T=await(await fetch(r.src)).blob();r.src=URL.createObjectURL(T),await new Promise(E=>r.onloadedmetadata=E)}const u=r.duration;let f,g;d!=null?(f=d,g=d===1?0:u/(d-1)):(g=1/h,f=Math.floor(u/g));let w=[];for(let S=0;S<f;++S)w.push(d===1?u/2:S*g);const y=document.createElement("canvas");y.width=r.videoWidth,y.height=r.videoHeight;const x=y.getContext("2d",{willReadFrequently:!0});for(const S of w){r.currentTime=S,await new Promise(C=>{r.onseeked=C}),x.drawImage(r,0,0,y.width,y.height);const T=x.getImageData(0,0,y.width,y.height),E=new s.RawImage(T.data,y.width,y.height,4),A=new c(E,S);i.push(A)}return r.remove(),new l(i,u)}})},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(e!==void 0)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}(()=>{var n=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,e;__webpack_require__.t=function(t,s){if(s&1&&(t=this(t)),s&8||typeof t=="object"&&t&&(s&4&&t.__esModule||s&16&&typeof t.then=="function"))return t;var a=Object.create(null);__webpack_require__.r(a);var c={};e=e||[null,n({}),n([]),n(n)];for(var l=s&2&&t;typeof l=="object"&&!~e.indexOf(l);l=n(l))Object.getOwnPropertyNames(l).forEach(_=>c[_]=()=>t[_]);return c.default=()=>t,__webpack_require__.d(a,c),a}})();__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})};__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e);__webpack_require__.r=n=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{ASTFeatureExtractor:()=>i.ASTFeatureExtractor,ASTForAudioClassification:()=>t.ASTForAudioClassification,ASTModel:()=>t.ASTModel,ASTPreTrainedModel:()=>t.ASTPreTrainedModel,AlbertForMaskedLM:()=>t.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>t.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>t.AlbertForSequenceClassification,AlbertModel:()=>t.AlbertModel,AlbertPreTrainedModel:()=>t.AlbertPreTrainedModel,AlbertTokenizer:()=>s.AlbertTokenizer,ArceeForCausalLM:()=>t.ArceeForCausalLM,ArceeModel:()=>t.ArceeModel,ArceePreTrainedModel:()=>t.ArceePreTrainedModel,AudioClassificationPipeline:()=>e.AudioClassificationPipeline,AutoConfig:()=>a.AutoConfig,AutoFeatureExtractor:()=>r.AutoFeatureExtractor,AutoImageProcessor:()=>g.AutoImageProcessor,AutoModel:()=>t.AutoModel,AutoModelForAudioClassification:()=>t.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>t.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>t.AutoModelForAudioTextToText,AutoModelForCTC:()=>t.AutoModelForCTC,AutoModelForCausalLM:()=>t.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>t.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>t.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>t.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>t.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>t.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>t.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>t.AutoModelForImageTextToText,AutoModelForImageToImage:()=>t.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>t.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>t.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>t.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>t.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>t.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>t.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>t.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>t.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>t.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>t.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>t.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>t.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>t.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>t.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>t.AutoModelForVision2Seq,AutoModelForXVector:()=>t.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>t.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>x.AutoProcessor,AutoTokenizer:()=>s.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>e.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>e.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>t.BartForConditionalGeneration,BartForSequenceClassification:()=>t.BartForSequenceClassification,BartModel:()=>t.BartModel,BartPretrainedModel:()=>t.BartPretrainedModel,BartTokenizer:()=>s.BartTokenizer,BaseModelOutput:()=>t.BaseModelOutput,BaseStreamer:()=>S.BaseStreamer,BeitFeatureExtractor:()=>f.BeitFeatureExtractor,BeitForImageClassification:()=>t.BeitForImageClassification,BeitModel:()=>t.BeitModel,BeitPreTrainedModel:()=>t.BeitPreTrainedModel,BertForMaskedLM:()=>t.BertForMaskedLM,BertForQuestionAnswering:()=>t.BertForQuestionAnswering,BertForSequenceClassification:()=>t.BertForSequenceClassification,BertForTokenClassification:()=>t.BertForTokenClassification,BertModel:()=>t.BertModel,BertPreTrainedModel:()=>t.BertPreTrainedModel,BertTokenizer:()=>s.BertTokenizer,BitImageProcessor:()=>f.BitImageProcessor,BlenderbotForConditionalGeneration:()=>t.BlenderbotForConditionalGeneration,BlenderbotModel:()=>t.BlenderbotModel,BlenderbotPreTrainedModel:()=>t.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>t.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>t.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>t.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>s.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>s.BlenderbotTokenizer,BloomForCausalLM:()=>t.BloomForCausalLM,BloomModel:()=>t.BloomModel,BloomPreTrainedModel:()=>t.BloomPreTrainedModel,BloomTokenizer:()=>s.BloomTokenizer,CLIPFeatureExtractor:()=>f.CLIPFeatureExtractor,CLIPImageProcessor:()=>f.CLIPImageProcessor,CLIPModel:()=>t.CLIPModel,CLIPPreTrainedModel:()=>t.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>t.CLIPSegForImageSegmentation,CLIPSegModel:()=>t.CLIPSegModel,CLIPSegPreTrainedModel:()=>t.CLIPSegPreTrainedModel,CLIPTextModel:()=>t.CLIPTextModel,CLIPTextModelWithProjection:()=>t.CLIPTextModelWithProjection,CLIPTokenizer:()=>s.CLIPTokenizer,CLIPVisionModel:()=>t.CLIPVisionModel,CLIPVisionModelWithProjection:()=>t.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>t.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>t.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>t.CamembertForSequenceClassification,CamembertForTokenClassification:()=>t.CamembertForTokenClassification,CamembertModel:()=>t.CamembertModel,CamembertPreTrainedModel:()=>t.CamembertPreTrainedModel,CamembertTokenizer:()=>s.CamembertTokenizer,CausalLMOutput:()=>t.CausalLMOutput,CausalLMOutputWithPast:()=>t.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>f.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>t.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>t.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>t.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>i.ClapFeatureExtractor,ClapModel:()=>t.ClapModel,ClapPreTrainedModel:()=>t.ClapPreTrainedModel,ClapTextModelWithProjection:()=>t.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>E.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>t.CodeGenForCausalLM,CodeGenModel:()=>t.CodeGenModel,CodeGenPreTrainedModel:()=>t.CodeGenPreTrainedModel,CodeGenTokenizer:()=>s.CodeGenTokenizer,CodeLlamaTokenizer:()=>s.CodeLlamaTokenizer,CohereForCausalLM:()=>t.CohereForCausalLM,CohereModel:()=>t.CohereModel,CoherePreTrainedModel:()=>t.CoherePreTrainedModel,CohereTokenizer:()=>s.CohereTokenizer,ConvBertForMaskedLM:()=>t.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>t.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>t.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>t.ConvBertForTokenClassification,ConvBertModel:()=>t.ConvBertModel,ConvBertPreTrainedModel:()=>t.ConvBertPreTrainedModel,ConvBertTokenizer:()=>s.ConvBertTokenizer,ConvNextFeatureExtractor:()=>f.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>t.ConvNextForImageClassification,ConvNextImageProcessor:()=>f.ConvNextImageProcessor,ConvNextModel:()=>t.ConvNextModel,ConvNextPreTrainedModel:()=>t.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>t.ConvNextV2ForImageClassification,ConvNextV2Model:()=>t.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>t.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>t.DFineForObjectDetection,DFineModel:()=>t.DFineModel,DFinePreTrainedModel:()=>t.DFinePreTrainedModel,DINOv3ConvNextModel:()=>t.DINOv3ConvNextModel,DINOv3ConvNextPreTrainedModel:()=>t.DINOv3ConvNextPreTrainedModel,DINOv3ViTImageProcessor:()=>f.DINOv3ViTImageProcessor,DINOv3ViTModel:()=>t.DINOv3ViTModel,DINOv3ViTPreTrainedModel:()=>t.DINOv3ViTPreTrainedModel,DPTFeatureExtractor:()=>f.DPTFeatureExtractor,DPTForDepthEstimation:()=>t.DPTForDepthEstimation,DPTImageProcessor:()=>f.DPTImageProcessor,DPTModel:()=>t.DPTModel,DPTPreTrainedModel:()=>t.DPTPreTrainedModel,DacDecoderModel:()=>t.DacDecoderModel,DacDecoderOutput:()=>t.DacDecoderOutput,DacEncoderModel:()=>t.DacEncoderModel,DacEncoderOutput:()=>t.DacEncoderOutput,DacFeatureExtractor:()=>i.DacFeatureExtractor,DacModel:()=>t.DacModel,DacPreTrainedModel:()=>t.DacPreTrainedModel,DataTypeMap:()=>m.DataTypeMap,DebertaForMaskedLM:()=>t.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>t.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>t.DebertaForSequenceClassification,DebertaForTokenClassification:()=>t.DebertaForTokenClassification,DebertaModel:()=>t.DebertaModel,DebertaPreTrainedModel:()=>t.DebertaPreTrainedModel,DebertaTokenizer:()=>s.DebertaTokenizer,DebertaV2ForMaskedLM:()=>t.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>t.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>t.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>t.DebertaV2ForTokenClassification,DebertaV2Model:()=>t.DebertaV2Model,DebertaV2PreTrainedModel:()=>t.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>s.DebertaV2Tokenizer,DecisionTransformerModel:()=>t.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>t.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>f.DeiTFeatureExtractor,DeiTForImageClassification:()=>t.DeiTForImageClassification,DeiTImageProcessor:()=>f.DeiTImageProcessor,DeiTModel:()=>t.DeiTModel,DeiTPreTrainedModel:()=>t.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>t.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>t.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>e.DepthEstimationPipeline,DepthProForDepthEstimation:()=>t.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>t.DepthProPreTrainedModel,DetrFeatureExtractor:()=>f.DetrFeatureExtractor,DetrForObjectDetection:()=>t.DetrForObjectDetection,DetrForSegmentation:()=>t.DetrForSegmentation,DetrImageProcessor:()=>f.DetrImageProcessor,DetrModel:()=>t.DetrModel,DetrObjectDetectionOutput:()=>t.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>t.DetrPreTrainedModel,DetrSegmentationOutput:()=>t.DetrSegmentationOutput,Dinov2ForImageClassification:()=>t.Dinov2ForImageClassification,Dinov2Model:()=>t.Dinov2Model,Dinov2PreTrainedModel:()=>t.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>t.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>t.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>t.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>t.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>t.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>t.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>t.DistilBertForTokenClassification,DistilBertModel:()=>t.DistilBertModel,DistilBertPreTrainedModel:()=>t.DistilBertPreTrainedModel,DistilBertTokenizer:()=>s.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>e.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>f.DonutFeatureExtractor,DonutImageProcessor:()=>f.DonutImageProcessor,DonutSwinModel:()=>t.DonutSwinModel,DonutSwinPreTrainedModel:()=>t.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>t.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>f.EfficientNetImageProcessor,EfficientNetModel:()=>t.EfficientNetModel,EfficientNetPreTrainedModel:()=>t.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>t.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>t.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>t.ElectraForSequenceClassification,ElectraForTokenClassification:()=>t.ElectraForTokenClassification,ElectraModel:()=>t.ElectraModel,ElectraPreTrainedModel:()=>t.ElectraPreTrainedModel,ElectraTokenizer:()=>s.ElectraTokenizer,EncodecFeatureExtractor:()=>i.EncodecFeatureExtractor,EosTokenCriteria:()=>T.EosTokenCriteria,Ernie4_5_ForCausalLM:()=>t.Ernie4_5_ForCausalLM,Ernie4_5_Model:()=>t.Ernie4_5_Model,Ernie4_5_PretrainedModel:()=>t.Ernie4_5_PretrainedModel,Ernie4_5_Tokenizer:()=>s.Ernie4_5_Tokenizer,EsmForMaskedLM:()=>t.EsmForMaskedLM,EsmForSequenceClassification:()=>t.EsmForSequenceClassification,EsmForTokenClassification:()=>t.EsmForTokenClassification,EsmModel:()=>t.EsmModel,EsmPreTrainedModel:()=>t.EsmPreTrainedModel,EsmTokenizer:()=>s.EsmTokenizer,ExaoneForCausalLM:()=>t.ExaoneForCausalLM,ExaoneModel:()=>t.ExaoneModel,ExaonePreTrainedModel:()=>t.ExaonePreTrainedModel,FFT:()=>d.FFT,FalconForCausalLM:()=>t.FalconForCausalLM,FalconModel:()=>t.FalconModel,FalconPreTrainedModel:()=>t.FalconPreTrainedModel,FalconTokenizer:()=>s.FalconTokenizer,FastViTForImageClassification:()=>t.FastViTForImageClassification,FastViTModel:()=>t.FastViTModel,FastViTPreTrainedModel:()=>t.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>e.FeatureExtractionPipeline,FeatureExtractor:()=>h.FeatureExtractor,FillMaskPipeline:()=>e.FillMaskPipeline,Florence2ForConditionalGeneration:()=>t.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>t.Florence2PreTrainedModel,Florence2Processor:()=>y.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>E.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>E.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>t.GLPNForDepthEstimation,GLPNModel:()=>t.GLPNModel,GLPNPreTrainedModel:()=>t.GLPNPreTrainedModel,GPT2LMHeadModel:()=>t.GPT2LMHeadModel,GPT2Model:()=>t.GPT2Model,GPT2PreTrainedModel:()=>t.GPT2PreTrainedModel,GPT2Tokenizer:()=>s.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>t.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>t.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>t.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>t.GPTJForCausalLM,GPTJModel:()=>t.GPTJModel,GPTJPreTrainedModel:()=>t.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>t.GPTNeoForCausalLM,GPTNeoModel:()=>t.GPTNeoModel,GPTNeoPreTrainedModel:()=>t.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>t.GPTNeoXForCausalLM,GPTNeoXModel:()=>t.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>t.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>s.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>t.Gemma2ForCausalLM,Gemma2Model:()=>t.Gemma2Model,Gemma2PreTrainedModel:()=>t.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>t.Gemma3ForCausalLM,Gemma3Model:()=>t.Gemma3Model,Gemma3PreTrainedModel:()=>t.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>i.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>t.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>t.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>y.Gemma3nProcessor,GemmaForCausalLM:()=>t.GemmaForCausalLM,GemmaModel:()=>t.GemmaModel,GemmaPreTrainedModel:()=>t.GemmaPreTrainedModel,GemmaTokenizer:()=>s.GemmaTokenizer,GlmForCausalLM:()=>t.GlmForCausalLM,GlmModel:()=>t.GlmModel,GlmPreTrainedModel:()=>t.GlmPreTrainedModel,GraniteForCausalLM:()=>t.GraniteForCausalLM,GraniteModel:()=>t.GraniteModel,GranitePreTrainedModel:()=>t.GranitePreTrainedModel,Grok1Tokenizer:()=>s.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>t.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>f.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>t.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>y.GroundingDinoProcessor,GroupViTModel:()=>t.GroupViTModel,GroupViTPreTrainedModel:()=>t.GroupViTPreTrainedModel,HeliumForCausalLM:()=>t.HeliumForCausalLM,HeliumModel:()=>t.HeliumModel,HeliumPreTrainedModel:()=>t.HeliumPreTrainedModel,HerbertTokenizer:()=>s.HerbertTokenizer,HieraForImageClassification:()=>t.HieraForImageClassification,HieraModel:()=>t.HieraModel,HieraPreTrainedModel:()=>t.HieraPreTrainedModel,HubertForCTC:()=>t.HubertForCTC,HubertForSequenceClassification:()=>t.HubertForSequenceClassification,HubertModel:()=>t.HubertModel,HubertPreTrainedModel:()=>t.HubertPreTrainedModel,IJepaForImageClassification:()=>t.IJepaForImageClassification,IJepaModel:()=>t.IJepaModel,IJepaPreTrainedModel:()=>t.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>t.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>f.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>t.Idefics3PreTrainedModel,Idefics3Processor:()=>y.Idefics3Processor,ImageClassificationPipeline:()=>e.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>e.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>i.ImageFeatureExtractor,ImageMattingOutput:()=>t.ImageMattingOutput,ImageProcessor:()=>u.ImageProcessor,ImageSegmentationPipeline:()=>e.ImageSegmentationPipeline,ImageToImagePipeline:()=>e.ImageToImagePipeline,ImageToTextPipeline:()=>e.ImageToTextPipeline,InterruptableStoppingCriteria:()=>T.InterruptableStoppingCriteria,JAISLMHeadModel:()=>t.JAISLMHeadModel,JAISModel:()=>t.JAISModel,JAISPreTrainedModel:()=>t.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>f.JinaCLIPImageProcessor,JinaCLIPModel:()=>t.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>t.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>y.JinaCLIPProcessor,JinaCLIPTextModel:()=>t.JinaCLIPTextModel,JinaCLIPVisionModel:()=>t.JinaCLIPVisionModel,Lfm2ForCausalLM:()=>t.Lfm2ForCausalLM,Lfm2Model:()=>t.Lfm2Model,Lfm2PreTrainedModel:()=>t.Lfm2PreTrainedModel,LiteWhisperForConditionalGeneration:()=>t.LiteWhisperForConditionalGeneration,LlamaForCausalLM:()=>t.LlamaForCausalLM,LlamaModel:()=>t.LlamaModel,LlamaPreTrainedModel:()=>t.LlamaPreTrainedModel,LlamaTokenizer:()=>s.LlamaTokenizer,LlavaForConditionalGeneration:()=>t.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>t.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>f.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>t.LlavaPreTrainedModel,LlavaProcessor:()=>y.LlavaProcessor,LlavaQwen2ForCausalLM:()=>t.LlavaQwen2ForCausalLM,LogitsProcessor:()=>E.LogitsProcessor,LogitsProcessorList:()=>E.LogitsProcessorList,LogitsWarper:()=>E.LogitsWarper,LongT5ForConditionalGeneration:()=>t.LongT5ForConditionalGeneration,LongT5Model:()=>t.LongT5Model,LongT5PreTrainedModel:()=>t.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>t.M2M100ForConditionalGeneration,M2M100Model:()=>t.M2M100Model,M2M100PreTrainedModel:()=>t.M2M100PreTrainedModel,M2M100Tokenizer:()=>s.M2M100Tokenizer,MBart50Tokenizer:()=>s.MBart50Tokenizer,MBartForCausalLM:()=>t.MBartForCausalLM,MBartForConditionalGeneration:()=>t.MBartForConditionalGeneration,MBartForSequenceClassification:()=>t.MBartForSequenceClassification,MBartModel:()=>t.MBartModel,MBartPreTrainedModel:()=>t.MBartPreTrainedModel,MBartTokenizer:()=>s.MBartTokenizer,MPNetForMaskedLM:()=>t.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>t.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>t.MPNetForSequenceClassification,MPNetForTokenClassification:()=>t.MPNetForTokenClassification,MPNetModel:()=>t.MPNetModel,MPNetPreTrainedModel:()=>t.MPNetPreTrainedModel,MPNetTokenizer:()=>s.MPNetTokenizer,MT5ForConditionalGeneration:()=>t.MT5ForConditionalGeneration,MT5Model:()=>t.MT5Model,MT5PreTrainedModel:()=>t.MT5PreTrainedModel,MarianMTModel:()=>t.MarianMTModel,MarianModel:()=>t.MarianModel,MarianPreTrainedModel:()=>t.MarianPreTrainedModel,MarianTokenizer:()=>s.MarianTokenizer,Mask2FormerImageProcessor:()=>f.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>f.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>t.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>f.MaskFormerImageProcessor,MaskFormerModel:()=>t.MaskFormerModel,MaskFormerPreTrainedModel:()=>t.MaskFormerPreTrainedModel,MaskedLMOutput:()=>t.MaskedLMOutput,MaxLengthCriteria:()=>T.MaxLengthCriteria,Metric3DForDepthEstimation:()=>t.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>t.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>t.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>t.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>t.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>t.MgpstrModelOutput,MgpstrPreTrainedModel:()=>t.MgpstrPreTrainedModel,MgpstrProcessor:()=>y.MgpstrProcessor,MgpstrTokenizer:()=>s.MgpstrTokenizer,MimiDecoderModel:()=>t.MimiDecoderModel,MimiDecoderOutput:()=>t.MimiDecoderOutput,MimiEncoderModel:()=>t.MimiEncoderModel,MimiEncoderOutput:()=>t.MimiEncoderOutput,MimiModel:()=>t.MimiModel,MimiPreTrainedModel:()=>t.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>E.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>E.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>t.MistralForCausalLM,MistralModel:()=>t.MistralModel,MistralPreTrainedModel:()=>t.MistralPreTrainedModel,MobileBertForMaskedLM:()=>t.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>t.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>t.MobileBertForSequenceClassification,MobileBertModel:()=>t.MobileBertModel,MobileBertPreTrainedModel:()=>t.MobileBertPreTrainedModel,MobileBertTokenizer:()=>s.MobileBertTokenizer,MobileLLMForCausalLM:()=>t.MobileLLMForCausalLM,MobileLLMModel:()=>t.MobileLLMModel,MobileLLMPreTrainedModel:()=>t.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>f.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>t.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>t.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>f.MobileNetV1ImageProcessor,MobileNetV1Model:()=>t.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>t.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>f.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>t.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>t.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>f.MobileNetV2ImageProcessor,MobileNetV2Model:()=>t.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>t.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>f.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>t.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>t.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>f.MobileNetV3ImageProcessor,MobileNetV3Model:()=>t.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>t.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>f.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>t.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>t.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>f.MobileNetV4ImageProcessor,MobileNetV4Model:()=>t.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>t.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>f.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>t.MobileViTForImageClassification,MobileViTImageProcessor:()=>f.MobileViTImageProcessor,MobileViTModel:()=>t.MobileViTModel,MobileViTPreTrainedModel:()=>t.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>t.MobileViTV2ForImageClassification,MobileViTV2Model:()=>t.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>t.MobileViTV2PreTrainedModel,ModelOutput:()=>t.ModelOutput,ModernBertDecoderForCausalLM:()=>t.ModernBertDecoderForCausalLM,ModernBertDecoderModel:()=>t.ModernBertDecoderModel,ModernBertDecoderPreTrainedModel:()=>t.ModernBertDecoderPreTrainedModel,ModernBertForMaskedLM:()=>t.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>t.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>t.ModernBertForTokenClassification,ModernBertModel:()=>t.ModernBertModel,ModernBertPreTrainedModel:()=>t.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>t.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>i.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>t.MoonshineForConditionalGeneration,MoonshineModel:()=>t.MoonshineModel,MoonshinePreTrainedModel:()=>t.MoonshinePreTrainedModel,MoonshineProcessor:()=>y.MoonshineProcessor,MptForCausalLM:()=>t.MptForCausalLM,MptModel:()=>t.MptModel,MptPreTrainedModel:()=>t.MptPreTrainedModel,MultiModalityCausalLM:()=>t.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>t.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>t.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>t.MusicgenForConditionalGeneration,MusicgenModel:()=>t.MusicgenModel,MusicgenPreTrainedModel:()=>t.MusicgenPreTrainedModel,NeoBertForMaskedLM:()=>t.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>t.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>t.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>t.NeoBertForTokenClassification,NeoBertModel:()=>t.NeoBertModel,NeoBertPreTrainedModel:()=>t.NeoBertPreTrainedModel,NllbTokenizer:()=>s.NllbTokenizer,NoBadWordsLogitsProcessor:()=>E.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>E.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>t.NomicBertModel,NomicBertPreTrainedModel:()=>t.NomicBertPreTrainedModel,NougatImageProcessor:()=>f.NougatImageProcessor,NougatTokenizer:()=>s.NougatTokenizer,OPTForCausalLM:()=>t.OPTForCausalLM,OPTModel:()=>t.OPTModel,OPTPreTrainedModel:()=>t.OPTPreTrainedModel,ObjectDetectionPipeline:()=>e.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>t.Olmo2ForCausalLM,Olmo2Model:()=>t.Olmo2Model,Olmo2PreTrainedModel:()=>t.Olmo2PreTrainedModel,OlmoForCausalLM:()=>t.OlmoForCausalLM,OlmoModel:()=>t.OlmoModel,OlmoPreTrainedModel:()=>t.OlmoPreTrainedModel,OpenELMForCausalLM:()=>t.OpenELMForCausalLM,OpenELMModel:()=>t.OpenELMModel,OpenELMPreTrainedModel:()=>t.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>f.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>t.OwlViTForObjectDetection,OwlViTImageProcessor:()=>f.OwlViTImageProcessor,OwlViTModel:()=>t.OwlViTModel,OwlViTPreTrainedModel:()=>t.OwlViTPreTrainedModel,OwlViTProcessor:()=>y.OwlViTProcessor,Owlv2ForObjectDetection:()=>t.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>f.Owlv2ImageProcessor,Owlv2Model:()=>t.Owlv2Model,Owlv2PreTrainedModel:()=>t.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>t.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>t.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>y.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>t.PatchTSMixerForPrediction,PatchTSMixerModel:()=>t.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>t.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>t.PatchTSTForPrediction,PatchTSTModel:()=>t.PatchTSTModel,PatchTSTPreTrainedModel:()=>t.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>t.Phi3ForCausalLM,Phi3Model:()=>t.Phi3Model,Phi3PreTrainedModel:()=>t.Phi3PreTrainedModel,Phi3VForCausalLM:()=>t.Phi3VForCausalLM,Phi3VImageProcessor:()=>f.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>t.Phi3VPreTrainedModel,Phi3VProcessor:()=>y.Phi3VProcessor,PhiForCausalLM:()=>t.PhiForCausalLM,PhiModel:()=>t.PhiModel,PhiPreTrainedModel:()=>t.PhiPreTrainedModel,Pipeline:()=>e.Pipeline,PreTrainedModel:()=>t.PreTrainedModel,PreTrainedTokenizer:()=>s.PreTrainedTokenizer,PretrainedConfig:()=>a.PretrainedConfig,PretrainedMixin:()=>t.PretrainedMixin,Processor:()=>w.Processor,PvtForImageClassification:()=>t.PvtForImageClassification,PvtImageProcessor:()=>f.PvtImageProcessor,PvtModel:()=>t.PvtModel,PvtPreTrainedModel:()=>t.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>i.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>t.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>t.PyAnnoteModel,PyAnnotePreTrainedModel:()=>t.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>y.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>t.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>e.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>t.Qwen2ForCausalLM,Qwen2Model:()=>t.Qwen2Model,Qwen2PreTrainedModel:()=>t.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>s.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>t.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>f.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>t.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>y.Qwen2VLProcessor,Qwen3ForCausalLM:()=>t.Qwen3ForCausalLM,Qwen3Model:()=>t.Qwen3Model,Qwen3PreTrainedModel:()=>t.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>t.RFDetrForObjectDetection,RFDetrModel:()=>t.RFDetrModel,RFDetrObjectDetectionOutput:()=>t.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>t.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>t.RTDetrForObjectDetection,RTDetrImageProcessor:()=>f.RTDetrImageProcessor,RTDetrModel:()=>t.RTDetrModel,RTDetrObjectDetectionOutput:()=>t.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>t.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>t.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>t.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>t.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>t.RTDetrV2PreTrainedModel,RawAudio:()=>c.RawAudio,RawImage:()=>l.RawImage,RawVideo:()=>_.RawVideo,RawVideoFrame:()=>_.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>E.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>t.ResNetForImageClassification,ResNetModel:()=>t.ResNetModel,ResNetPreTrainedModel:()=>t.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>t.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>t.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>t.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>t.RoFormerForTokenClassification,RoFormerModel:()=>t.RoFormerModel,RoFormerPreTrainedModel:()=>t.RoFormerPreTrainedModel,RoFormerTokenizer:()=>s.RoFormerTokenizer,RobertaForMaskedLM:()=>t.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>t.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>t.RobertaForSequenceClassification,RobertaForTokenClassification:()=>t.RobertaForTokenClassification,RobertaModel:()=>t.RobertaModel,RobertaPreTrainedModel:()=>t.RobertaPreTrainedModel,RobertaTokenizer:()=>s.RobertaTokenizer,SamImageProcessor:()=>f.SamImageProcessor,SamImageSegmentationOutput:()=>t.SamImageSegmentationOutput,SamModel:()=>t.SamModel,SamPreTrainedModel:()=>t.SamPreTrainedModel,SamProcessor:()=>y.SamProcessor,SapiensForDepthEstimation:()=>t.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>t.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>t.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>t.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>i.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>f.SegformerFeatureExtractor,SegformerForImageClassification:()=>t.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>t.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>f.SegformerImageProcessor,SegformerModel:()=>t.SegformerModel,SegformerPreTrainedModel:()=>t.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>t.Seq2SeqLMOutput,SequenceClassifierOutput:()=>t.SequenceClassifierOutput,SiglipImageProcessor:()=>f.SiglipImageProcessor,SiglipModel:()=>t.SiglipModel,SiglipPreTrainedModel:()=>t.SiglipPreTrainedModel,SiglipTextModel:()=>t.SiglipTextModel,SiglipTokenizer:()=>s.SiglipTokenizer,SiglipVisionModel:()=>t.SiglipVisionModel,SmolLM3ForCausalLM:()=>t.SmolLM3ForCausalLM,SmolLM3Model:()=>t.SmolLM3Model,SmolLM3PreTrainedModel:()=>t.SmolLM3PreTrainedModel,SmolVLMForConditionalGeneration:()=>t.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>f.SmolVLMImageProcessor,SmolVLMProcessor:()=>y.SmolVLMProcessor,SnacDecoderModel:()=>t.SnacDecoderModel,SnacEncoderModel:()=>t.SnacEncoderModel,SnacFeatureExtractor:()=>i.SnacFeatureExtractor,SnacModel:()=>t.SnacModel,SnacPreTrainedModel:()=>t.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>i.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>t.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>t.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>t.SpeechT5HifiGan,SpeechT5Model:()=>t.SpeechT5Model,SpeechT5PreTrainedModel:()=>t.SpeechT5PreTrainedModel,SpeechT5Processor:()=>y.SpeechT5Processor,SpeechT5Tokenizer:()=>s.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>t.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>t.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>t.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>t.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>t.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>s.SqueezeBertTokenizer,StableLmForCausalLM:()=>t.StableLmForCausalLM,StableLmModel:()=>t.StableLmModel,StableLmPreTrainedModel:()=>t.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>t.Starcoder2ForCausalLM,Starcoder2Model:()=>t.Starcoder2Model,Starcoder2PreTrainedModel:()=>t.Starcoder2PreTrainedModel,StoppingCriteria:()=>T.StoppingCriteria,StoppingCriteriaList:()=>T.StoppingCriteriaList,StyleTextToSpeech2Model:()=>t.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>t.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>e.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>E.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>t.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>f.Swin2SRImageProcessor,Swin2SRModel:()=>t.Swin2SRModel,Swin2SRPreTrainedModel:()=>t.Swin2SRPreTrainedModel,SwinForImageClassification:()=>t.SwinForImageClassification,SwinForSemanticSegmentation:()=>t.SwinForSemanticSegmentation,SwinModel:()=>t.SwinModel,SwinPreTrainedModel:()=>t.SwinPreTrainedModel,T5ForConditionalGeneration:()=>t.T5ForConditionalGeneration,T5Model:()=>t.T5Model,T5PreTrainedModel:()=>t.T5PreTrainedModel,T5Tokenizer:()=>s.T5Tokenizer,TableTransformerForObjectDetection:()=>t.TableTransformerForObjectDetection,TableTransformerModel:()=>t.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>t.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>t.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>E.TemperatureLogitsWarper,Tensor:()=>m.Tensor,Text2TextGenerationPipeline:()=>e.Text2TextGenerationPipeline,TextClassificationPipeline:()=>e.TextClassificationPipeline,TextGenerationPipeline:()=>e.TextGenerationPipeline,TextStreamer:()=>S.TextStreamer,TextToAudioPipeline:()=>e.TextToAudioPipeline,TokenClassificationPipeline:()=>e.TokenClassificationPipeline,TokenClassifierOutput:()=>t.TokenClassifierOutput,TokenizerModel:()=>s.TokenizerModel,TopKLogitsWarper:()=>E.TopKLogitsWarper,TopPLogitsWarper:()=>E.TopPLogitsWarper,TrOCRForCausalLM:()=>t.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>t.TrOCRPreTrainedModel,TranslationPipeline:()=>e.TranslationPipeline,UltravoxModel:()=>t.UltravoxModel,UltravoxPreTrainedModel:()=>t.UltravoxPreTrainedModel,UltravoxProcessor:()=>y.UltravoxProcessor,UniSpeechForCTC:()=>t.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>t.UniSpeechForSequenceClassification,UniSpeechModel:()=>t.UniSpeechModel,UniSpeechPreTrainedModel:()=>t.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>t.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>t.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>t.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>t.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>t.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>y.VLChatProcessor,VLMImageProcessor:()=>f.VLMImageProcessor,ViTFeatureExtractor:()=>f.ViTFeatureExtractor,ViTForImageClassification:()=>t.ViTForImageClassification,ViTImageProcessor:()=>f.ViTImageProcessor,ViTMAEModel:()=>t.ViTMAEModel,ViTMAEPreTrainedModel:()=>t.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>t.ViTMSNForImageClassification,ViTMSNModel:()=>t.ViTMSNModel,ViTMSNPreTrainedModel:()=>t.ViTMSNPreTrainedModel,ViTModel:()=>t.ViTModel,ViTPreTrainedModel:()=>t.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>t.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>t.VitMatteForImageMatting,VitMatteImageProcessor:()=>f.VitMatteImageProcessor,VitMattePreTrainedModel:()=>t.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>t.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>f.VitPoseImageProcessor,VitPosePreTrainedModel:()=>t.VitPosePreTrainedModel,VitsModel:()=>t.VitsModel,VitsModelOutput:()=>t.VitsModelOutput,VitsPreTrainedModel:()=>t.VitsPreTrainedModel,VitsTokenizer:()=>s.VitsTokenizer,VoxtralForConditionalGeneration:()=>t.VoxtralForConditionalGeneration,VoxtralProcessor:()=>y.VoxtralProcessor,Wav2Vec2BertForCTC:()=>t.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>t.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>t.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>t.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>s.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>i.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>t.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>t.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>t.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>t.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>t.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>y.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>y.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>t.WavLMForAudioFrameClassification,WavLMForCTC:()=>t.WavLMForCTC,WavLMForSequenceClassification:()=>t.WavLMForSequenceClassification,WavLMForXVector:()=>t.WavLMForXVector,WavLMModel:()=>t.WavLMModel,WavLMPreTrainedModel:()=>t.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>i.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>t.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>t.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>i.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>t.WhisperForConditionalGeneration,WhisperModel:()=>t.WhisperModel,WhisperPreTrainedModel:()=>t.WhisperPreTrainedModel,WhisperProcessor:()=>y.WhisperProcessor,WhisperTextStreamer:()=>S.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>E.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>s.WhisperTokenizer,XLMForQuestionAnswering:()=>t.XLMForQuestionAnswering,XLMForSequenceClassification:()=>t.XLMForSequenceClassification,XLMForTokenClassification:()=>t.XLMForTokenClassification,XLMModel:()=>t.XLMModel,XLMPreTrainedModel:()=>t.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>t.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>t.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>t.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>t.XLMRobertaForTokenClassification,XLMRobertaModel:()=>t.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>t.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>s.XLMRobertaTokenizer,XLMTokenizer:()=>s.XLMTokenizer,XLMWithLMHeadModel:()=>t.XLMWithLMHeadModel,XVectorOutput:()=>t.XVectorOutput,YolosFeatureExtractor:()=>f.YolosFeatureExtractor,YolosForObjectDetection:()=>t.YolosForObjectDetection,YolosImageProcessor:()=>f.YolosImageProcessor,YolosModel:()=>t.YolosModel,YolosObjectDetectionOutput:()=>t.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>t.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>e.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>e.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>e.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>e.ZeroShotObjectDetectionPipeline,bankers_round:()=>d.bankers_round,cat:()=>m.cat,cos_sim:()=>d.cos_sim,dot:()=>d.dot,dynamic_time_warping:()=>d.dynamic_time_warping,env:()=>n.env,full:()=>m.full,full_like:()=>m.full_like,getCacheShapes:()=>a.getCacheShapes,hamming:()=>c.hamming,hanning:()=>c.hanning,interpolate:()=>m.interpolate,interpolate_4d:()=>m.interpolate_4d,interpolate_data:()=>d.interpolate_data,is_chinese_char:()=>s.is_chinese_char,layer_norm:()=>m.layer_norm,load_image:()=>l.load_image,load_video:()=>_.load_video,log_softmax:()=>d.log_softmax,magnitude:()=>d.magnitude,matmul:()=>m.matmul,max:()=>d.max,mean:()=>m.mean,mean_pooling:()=>m.mean_pooling,medianFilter:()=>d.medianFilter,mel_filter_bank:()=>c.mel_filter_bank,min:()=>d.min,ones:()=>m.ones,ones_like:()=>m.ones_like,permute:()=>m.permute,permute_data:()=>d.permute_data,pipeline:()=>e.pipeline,quantize_embeddings:()=>m.quantize_embeddings,rand:()=>m.rand,read_audio:()=>c.read_audio,rfft:()=>m.rfft,round:()=>d.round,slice:()=>m.slice,softmax:()=>d.softmax,spectrogram:()=>c.spectrogram,stack:()=>m.stack,std_mean:()=>m.std_mean,topk:()=>m.topk,window_function:()=>c.window_function,zeros:()=>m.zeros,zeros_like:()=>m.zeros_like});var n=__webpack_require__("./src/env.js"),e=__webpack_require__("./src/pipelines.js"),t=__webpack_require__("./src/models.js"),s=__webpack_require__("./src/tokenizers.js"),a=__webpack_require__("./src/configs.js"),c=__webpack_require__("./src/utils/audio.js"),l=__webpack_require__("./src/utils/image.js"),_=__webpack_require__("./src/utils/video.js"),m=__webpack_require__("./src/utils/tensor.js"),d=__webpack_require__("./src/utils/maths.js"),h=__webpack_require__("./src/base/feature_extraction_utils.js"),i=__webpack_require__("./src/models/feature_extractors.js"),r=__webpack_require__("./src/models/auto/feature_extraction_auto.js"),u=__webpack_require__("./src/base/image_processors_utils.js"),f=__webpack_require__("./src/models/image_processors.js"),g=__webpack_require__("./src/models/auto/image_processing_auto.js"),w=__webpack_require__("./src/base/processing_utils.js"),y=__webpack_require__("./src/models/processors.js"),x=__webpack_require__("./src/models/auto/processing_auto.js"),S=__webpack_require__("./src/generation/streamers.js"),T=__webpack_require__("./src/generation/stopping_criteria.js"),E=__webpack_require__("./src/generation/logits_process.js")})();__webpack_exports__.ASTFeatureExtractor;__webpack_exports__.ASTForAudioClassification;__webpack_exports__.ASTModel;__webpack_exports__.ASTPreTrainedModel;__webpack_exports__.AlbertForMaskedLM;__webpack_exports__.AlbertForQuestionAnswering;__webpack_exports__.AlbertForSequenceClassification;__webpack_exports__.AlbertModel;__webpack_exports__.AlbertPreTrainedModel;__webpack_exports__.AlbertTokenizer;__webpack_exports__.ArceeForCausalLM;__webpack_exports__.ArceeModel;__webpack_exports__.ArceePreTrainedModel;__webpack_exports__.AudioClassificationPipeline;__webpack_exports__.AutoConfig;__webpack_exports__.AutoFeatureExtractor;__webpack_exports__.AutoImageProcessor;__webpack_exports__.AutoModel;__webpack_exports__.AutoModelForAudioClassification;__webpack_exports__.AutoModelForAudioFrameClassification;__webpack_exports__.AutoModelForAudioTextToText;__webpack_exports__.AutoModelForCTC;__webpack_exports__.AutoModelForCausalLM;__webpack_exports__.AutoModelForDepthEstimation;__webpack_exports__.AutoModelForDocumentQuestionAnswering;__webpack_exports__.AutoModelForImageClassification;__webpack_exports__.AutoModelForImageFeatureExtraction;__webpack_exports__.AutoModelForImageMatting;__webpack_exports__.AutoModelForImageSegmentation;var __webpack_exports__AutoModelForImageTextToText=__webpack_exports__.AutoModelForImageTextToText;__webpack_exports__.AutoModelForImageToImage;__webpack_exports__.AutoModelForMaskGeneration;__webpack_exports__.AutoModelForMaskedLM;__webpack_exports__.AutoModelForNormalEstimation;__webpack_exports__.AutoModelForObjectDetection;__webpack_exports__.AutoModelForPoseEstimation;__webpack_exports__.AutoModelForQuestionAnswering;__webpack_exports__.AutoModelForSemanticSegmentation;__webpack_exports__.AutoModelForSeq2SeqLM;__webpack_exports__.AutoModelForSequenceClassification;__webpack_exports__.AutoModelForSpeechSeq2Seq;__webpack_exports__.AutoModelForTextToSpectrogram;__webpack_exports__.AutoModelForTextToWaveform;__webpack_exports__.AutoModelForTokenClassification;__webpack_exports__.AutoModelForUniversalSegmentation;__webpack_exports__.AutoModelForVision2Seq;__webpack_exports__.AutoModelForXVector;__webpack_exports__.AutoModelForZeroShotObjectDetection;var __webpack_exports__AutoProcessor=__webpack_exports__.AutoProcessor;__webpack_exports__.AutoTokenizer;__webpack_exports__.AutomaticSpeechRecognitionPipeline;__webpack_exports__.BackgroundRemovalPipeline;__webpack_exports__.BartForConditionalGeneration;__webpack_exports__.BartForSequenceClassification;__webpack_exports__.BartModel;__webpack_exports__.BartPretrainedModel;__webpack_exports__.BartTokenizer;__webpack_exports__.BaseModelOutput;__webpack_exports__.BaseStreamer;__webpack_exports__.BeitFeatureExtractor;__webpack_exports__.BeitForImageClassification;__webpack_exports__.BeitModel;__webpack_exports__.BeitPreTrainedModel;__webpack_exports__.BertForMaskedLM;__webpack_exports__.BertForQuestionAnswering;__webpack_exports__.BertForSequenceClassification;__webpack_exports__.BertForTokenClassification;__webpack_exports__.BertModel;__webpack_exports__.BertPreTrainedModel;__webpack_exports__.BertTokenizer;__webpack_exports__.BitImageProcessor;__webpack_exports__.BlenderbotForConditionalGeneration;__webpack_exports__.BlenderbotModel;__webpack_exports__.BlenderbotPreTrainedModel;__webpack_exports__.BlenderbotSmallForConditionalGeneration;__webpack_exports__.BlenderbotSmallModel;__webpack_exports__.BlenderbotSmallPreTrainedModel;__webpack_exports__.BlenderbotSmallTokenizer;__webpack_exports__.BlenderbotTokenizer;__webpack_exports__.BloomForCausalLM;__webpack_exports__.BloomModel;__webpack_exports__.BloomPreTrainedModel;__webpack_exports__.BloomTokenizer;__webpack_exports__.CLIPFeatureExtractor;__webpack_exports__.CLIPImageProcessor;__webpack_exports__.CLIPModel;__webpack_exports__.CLIPPreTrainedModel;__webpack_exports__.CLIPSegForImageSegmentation;__webpack_exports__.CLIPSegModel;__webpack_exports__.CLIPSegPreTrainedModel;__webpack_exports__.CLIPTextModel;__webpack_exports__.CLIPTextModelWithProjection;__webpack_exports__.CLIPTokenizer;__webpack_exports__.CLIPVisionModel;__webpack_exports__.CLIPVisionModelWithProjection;__webpack_exports__.CamembertForMaskedLM;__webpack_exports__.CamembertForQuestionAnswering;__webpack_exports__.CamembertForSequenceClassification;__webpack_exports__.CamembertForTokenClassification;__webpack_exports__.CamembertModel;__webpack_exports__.CamembertPreTrainedModel;__webpack_exports__.CamembertTokenizer;__webpack_exports__.CausalLMOutput;__webpack_exports__.CausalLMOutputWithPast;__webpack_exports__.ChineseCLIPFeatureExtractor;__webpack_exports__.ChineseCLIPModel;__webpack_exports__.ChineseCLIPPreTrainedModel;__webpack_exports__.ClapAudioModelWithProjection;__webpack_exports__.ClapFeatureExtractor;__webpack_exports__.ClapModel;__webpack_exports__.ClapPreTrainedModel;__webpack_exports__.ClapTextModelWithProjection;__webpack_exports__.ClassifierFreeGuidanceLogitsProcessor;__webpack_exports__.CodeGenForCausalLM;__webpack_exports__.CodeGenModel;__webpack_exports__.CodeGenPreTrainedModel;__webpack_exports__.CodeGenTokenizer;__webpack_exports__.CodeLlamaTokenizer;__webpack_exports__.CohereForCausalLM;__webpack_exports__.CohereModel;__webpack_exports__.CoherePreTrainedModel;__webpack_exports__.CohereTokenizer;__webpack_exports__.ConvBertForMaskedLM;__webpack_exports__.ConvBertForQuestionAnswering;__webpack_exports__.ConvBertForSequenceClassification;__webpack_exports__.ConvBertForTokenClassification;__webpack_exports__.ConvBertModel;__webpack_exports__.ConvBertPreTrainedModel;__webpack_exports__.ConvBertTokenizer;__webpack_exports__.ConvNextFeatureExtractor;__webpack_exports__.ConvNextForImageClassification;__webpack_exports__.ConvNextImageProcessor;__webpack_exports__.ConvNextModel;__webpack_exports__.ConvNextPreTrainedModel;__webpack_exports__.ConvNextV2ForImageClassification;__webpack_exports__.ConvNextV2Model;__webpack_exports__.ConvNextV2PreTrainedModel;__webpack_exports__.DFineForObjectDetection;__webpack_exports__.DFineModel;__webpack_exports__.DFinePreTrainedModel;__webpack_exports__.DINOv3ConvNextModel;__webpack_exports__.DINOv3ConvNextPreTrainedModel;__webpack_exports__.DINOv3ViTImageProcessor;__webpack_exports__.DINOv3ViTModel;__webpack_exports__.DINOv3ViTPreTrainedModel;__webpack_exports__.DPTFeatureExtractor;__webpack_exports__.DPTForDepthEstimation;__webpack_exports__.DPTImageProcessor;__webpack_exports__.DPTModel;__webpack_exports__.DPTPreTrainedModel;__webpack_exports__.DacDecoderModel;__webpack_exports__.DacDecoderOutput;__webpack_exports__.DacEncoderModel;__webpack_exports__.DacEncoderOutput;__webpack_exports__.DacFeatureExtractor;__webpack_exports__.DacModel;__webpack_exports__.DacPreTrainedModel;__webpack_exports__.DataTypeMap;__webpack_exports__.DebertaForMaskedLM;__webpack_exports__.DebertaForQuestionAnswering;__webpack_exports__.DebertaForSequenceClassification;__webpack_exports__.DebertaForTokenClassification;__webpack_exports__.DebertaModel;__webpack_exports__.DebertaPreTrainedModel;__webpack_exports__.DebertaTokenizer;__webpack_exports__.DebertaV2ForMaskedLM;__webpack_exports__.DebertaV2ForQuestionAnswering;__webpack_exports__.DebertaV2ForSequenceClassification;__webpack_exports__.DebertaV2ForTokenClassification;__webpack_exports__.DebertaV2Model;__webpack_exports__.DebertaV2PreTrainedModel;__webpack_exports__.DebertaV2Tokenizer;__webpack_exports__.DecisionTransformerModel;__webpack_exports__.DecisionTransformerPreTrainedModel;__webpack_exports__.DeiTFeatureExtractor;__webpack_exports__.DeiTForImageClassification;__webpack_exports__.DeiTImageProcessor;__webpack_exports__.DeiTModel;__webpack_exports__.DeiTPreTrainedModel;__webpack_exports__.DepthAnythingForDepthEstimation;__webpack_exports__.DepthAnythingPreTrainedModel;__webpack_exports__.DepthEstimationPipeline;__webpack_exports__.DepthProForDepthEstimation;__webpack_exports__.DepthProPreTrainedModel;__webpack_exports__.DetrFeatureExtractor;__webpack_exports__.DetrForObjectDetection;__webpack_exports__.DetrForSegmentation;__webpack_exports__.DetrImageProcessor;__webpack_exports__.DetrModel;__webpack_exports__.DetrObjectDetectionOutput;__webpack_exports__.DetrPreTrainedModel;__webpack_exports__.DetrSegmentationOutput;__webpack_exports__.Dinov2ForImageClassification;__webpack_exports__.Dinov2Model;__webpack_exports__.Dinov2PreTrainedModel;__webpack_exports__.Dinov2WithRegistersForImageClassification;__webpack_exports__.Dinov2WithRegistersModel;__webpack_exports__.Dinov2WithRegistersPreTrainedModel;__webpack_exports__.DistilBertForMaskedLM;__webpack_exports__.DistilBertForQuestionAnswering;__webpack_exports__.DistilBertForSequenceClassification;__webpack_exports__.DistilBertForTokenClassification;__webpack_exports__.DistilBertModel;__webpack_exports__.DistilBertPreTrainedModel;__webpack_exports__.DistilBertTokenizer;__webpack_exports__.DocumentQuestionAnsweringPipeline;__webpack_exports__.DonutFeatureExtractor;__webpack_exports__.DonutImageProcessor;__webpack_exports__.DonutSwinModel;__webpack_exports__.DonutSwinPreTrainedModel;__webpack_exports__.EfficientNetForImageClassification;__webpack_exports__.EfficientNetImageProcessor;__webpack_exports__.EfficientNetModel;__webpack_exports__.EfficientNetPreTrainedModel;__webpack_exports__.ElectraForMaskedLM;__webpack_exports__.ElectraForQuestionAnswering;__webpack_exports__.ElectraForSequenceClassification;__webpack_exports__.ElectraForTokenClassification;__webpack_exports__.ElectraModel;__webpack_exports__.ElectraPreTrainedModel;__webpack_exports__.ElectraTokenizer;__webpack_exports__.EncodecFeatureExtractor;__webpack_exports__.EosTokenCriteria;__webpack_exports__.Ernie4_5_ForCausalLM;__webpack_exports__.Ernie4_5_Model;__webpack_exports__.Ernie4_5_PretrainedModel;__webpack_exports__.Ernie4_5_Tokenizer;__webpack_exports__.EsmForMaskedLM;__webpack_exports__.EsmForSequenceClassification;__webpack_exports__.EsmForTokenClassification;__webpack_exports__.EsmModel;__webpack_exports__.EsmPreTrainedModel;__webpack_exports__.EsmTokenizer;__webpack_exports__.ExaoneForCausalLM;__webpack_exports__.ExaoneModel;__webpack_exports__.ExaonePreTrainedModel;__webpack_exports__.FFT;__webpack_exports__.FalconForCausalLM;__webpack_exports__.FalconModel;__webpack_exports__.FalconPreTrainedModel;__webpack_exports__.FalconTokenizer;__webpack_exports__.FastViTForImageClassification;__webpack_exports__.FastViTModel;__webpack_exports__.FastViTPreTrainedModel;__webpack_exports__.FeatureExtractionPipeline;__webpack_exports__.FeatureExtractor;__webpack_exports__.FillMaskPipeline;__webpack_exports__.Florence2ForConditionalGeneration;__webpack_exports__.Florence2PreTrainedModel;__webpack_exports__.Florence2Processor;__webpack_exports__.ForcedBOSTokenLogitsProcessor;__webpack_exports__.ForcedEOSTokenLogitsProcessor;__webpack_exports__.GLPNFeatureExtractor;__webpack_exports__.GLPNForDepthEstimation;__webpack_exports__.GLPNModel;__webpack_exports__.GLPNPreTrainedModel;__webpack_exports__.GPT2LMHeadModel;__webpack_exports__.GPT2Model;__webpack_exports__.GPT2PreTrainedModel;__webpack_exports__.GPT2Tokenizer;__webpack_exports__.GPTBigCodeForCausalLM;__webpack_exports__.GPTBigCodeModel;__webpack_exports__.GPTBigCodePreTrainedModel;__webpack_exports__.GPTJForCausalLM;__webpack_exports__.GPTJModel;__webpack_exports__.GPTJPreTrainedModel;__webpack_exports__.GPTNeoForCausalLM;__webpack_exports__.GPTNeoModel;__webpack_exports__.GPTNeoPreTrainedModel;__webpack_exports__.GPTNeoXForCausalLM;__webpack_exports__.GPTNeoXModel;__webpack_exports__.GPTNeoXPreTrainedModel;__webpack_exports__.GPTNeoXTokenizer;__webpack_exports__.Gemma2ForCausalLM;__webpack_exports__.Gemma2Model;__webpack_exports__.Gemma2PreTrainedModel;__webpack_exports__.Gemma3ForCausalLM;__webpack_exports__.Gemma3Model;__webpack_exports__.Gemma3PreTrainedModel;__webpack_exports__.Gemma3nAudioFeatureExtractor;__webpack_exports__.Gemma3nForConditionalGeneration;__webpack_exports__.Gemma3nPreTrainedModel;__webpack_exports__.Gemma3nProcessor;__webpack_exports__.GemmaForCausalLM;__webpack_exports__.GemmaModel;__webpack_exports__.GemmaPreTrainedModel;__webpack_exports__.GemmaTokenizer;__webpack_exports__.GlmForCausalLM;__webpack_exports__.GlmModel;__webpack_exports__.GlmPreTrainedModel;__webpack_exports__.GraniteForCausalLM;__webpack_exports__.GraniteModel;__webpack_exports__.GranitePreTrainedModel;__webpack_exports__.Grok1Tokenizer;__webpack_exports__.GroundingDinoForObjectDetection;__webpack_exports__.GroundingDinoImageProcessor;__webpack_exports__.GroundingDinoPreTrainedModel;__webpack_exports__.GroundingDinoProcessor;__webpack_exports__.GroupViTModel;__webpack_exports__.GroupViTPreTrainedModel;__webpack_exports__.HeliumForCausalLM;__webpack_exports__.HeliumModel;__webpack_exports__.HeliumPreTrainedModel;__webpack_exports__.HerbertTokenizer;__webpack_exports__.HieraForImageClassification;__webpack_exports__.HieraModel;__webpack_exports__.HieraPreTrainedModel;__webpack_exports__.HubertForCTC;__webpack_exports__.HubertForSequenceClassification;__webpack_exports__.HubertModel;__webpack_exports__.HubertPreTrainedModel;__webpack_exports__.IJepaForImageClassification;__webpack_exports__.IJepaModel;__webpack_exports__.IJepaPreTrainedModel;__webpack_exports__.Idefics3ForConditionalGeneration;__webpack_exports__.Idefics3ImageProcessor;__webpack_exports__.Idefics3PreTrainedModel;__webpack_exports__.Idefics3Processor;__webpack_exports__.ImageClassificationPipeline;__webpack_exports__.ImageFeatureExtractionPipeline;__webpack_exports__.ImageFeatureExtractor;__webpack_exports__.ImageMattingOutput;__webpack_exports__.ImageProcessor;__webpack_exports__.ImageSegmentationPipeline;__webpack_exports__.ImageToImagePipeline;__webpack_exports__.ImageToTextPipeline;__webpack_exports__.InterruptableStoppingCriteria;__webpack_exports__.JAISLMHeadModel;__webpack_exports__.JAISModel;__webpack_exports__.JAISPreTrainedModel;__webpack_exports__.JinaCLIPImageProcessor;__webpack_exports__.JinaCLIPModel;__webpack_exports__.JinaCLIPPreTrainedModel;__webpack_exports__.JinaCLIPProcessor;__webpack_exports__.JinaCLIPTextModel;__webpack_exports__.JinaCLIPVisionModel;__webpack_exports__.Lfm2ForCausalLM;__webpack_exports__.Lfm2Model;__webpack_exports__.Lfm2PreTrainedModel;__webpack_exports__.LiteWhisperForConditionalGeneration;__webpack_exports__.LlamaForCausalLM;__webpack_exports__.LlamaModel;__webpack_exports__.LlamaPreTrainedModel;__webpack_exports__.LlamaTokenizer;__webpack_exports__.LlavaForConditionalGeneration;__webpack_exports__.LlavaOnevisionForConditionalGeneration;__webpack_exports__.LlavaOnevisionImageProcessor;__webpack_exports__.LlavaPreTrainedModel;__webpack_exports__.LlavaProcessor;__webpack_exports__.LlavaQwen2ForCausalLM;__webpack_exports__.LogitsProcessor;__webpack_exports__.LogitsProcessorList;__webpack_exports__.LogitsWarper;__webpack_exports__.LongT5ForConditionalGeneration;__webpack_exports__.LongT5Model;__webpack_exports__.LongT5PreTrainedModel;__webpack_exports__.M2M100ForConditionalGeneration;__webpack_exports__.M2M100Model;__webpack_exports__.M2M100PreTrainedModel;__webpack_exports__.M2M100Tokenizer;__webpack_exports__.MBart50Tokenizer;__webpack_exports__.MBartForCausalLM;__webpack_exports__.MBartForConditionalGeneration;__webpack_exports__.MBartForSequenceClassification;__webpack_exports__.MBartModel;__webpack_exports__.MBartPreTrainedModel;__webpack_exports__.MBartTokenizer;__webpack_exports__.MPNetForMaskedLM;__webpack_exports__.MPNetForQuestionAnswering;__webpack_exports__.MPNetForSequenceClassification;__webpack_exports__.MPNetForTokenClassification;__webpack_exports__.MPNetModel;__webpack_exports__.MPNetPreTrainedModel;__webpack_exports__.MPNetTokenizer;__webpack_exports__.MT5ForConditionalGeneration;__webpack_exports__.MT5Model;__webpack_exports__.MT5PreTrainedModel;__webpack_exports__.MarianMTModel;__webpack_exports__.MarianModel;__webpack_exports__.MarianPreTrainedModel;__webpack_exports__.MarianTokenizer;__webpack_exports__.Mask2FormerImageProcessor;__webpack_exports__.MaskFormerFeatureExtractor;__webpack_exports__.MaskFormerForInstanceSegmentation;__webpack_exports__.MaskFormerImageProcessor;__webpack_exports__.MaskFormerModel;__webpack_exports__.MaskFormerPreTrainedModel;__webpack_exports__.MaskedLMOutput;__webpack_exports__.MaxLengthCriteria;__webpack_exports__.Metric3DForDepthEstimation;__webpack_exports__.Metric3DPreTrainedModel;__webpack_exports__.Metric3Dv2ForDepthEstimation;__webpack_exports__.Metric3Dv2PreTrainedModel;__webpack_exports__.MgpstrForSceneTextRecognition;__webpack_exports__.MgpstrModelOutput;__webpack_exports__.MgpstrPreTrainedModel;__webpack_exports__.MgpstrProcessor;__webpack_exports__.MgpstrTokenizer;__webpack_exports__.MimiDecoderModel;__webpack_exports__.MimiDecoderOutput;__webpack_exports__.MimiEncoderModel;__webpack_exports__.MimiEncoderOutput;__webpack_exports__.MimiModel;__webpack_exports__.MimiPreTrainedModel;__webpack_exports__.MinLengthLogitsProcessor;__webpack_exports__.MinNewTokensLengthLogitsProcessor;__webpack_exports__.MistralForCausalLM;__webpack_exports__.MistralModel;__webpack_exports__.MistralPreTrainedModel;__webpack_exports__.MobileBertForMaskedLM;__webpack_exports__.MobileBertForQuestionAnswering;__webpack_exports__.MobileBertForSequenceClassification;__webpack_exports__.MobileBertModel;__webpack_exports__.MobileBertPreTrainedModel;__webpack_exports__.MobileBertTokenizer;__webpack_exports__.MobileLLMForCausalLM;__webpack_exports__.MobileLLMModel;__webpack_exports__.MobileLLMPreTrainedModel;__webpack_exports__.MobileNetV1FeatureExtractor;__webpack_exports__.MobileNetV1ForImageClassification;__webpack_exports__.MobileNetV1ForSemanticSegmentation;__webpack_exports__.MobileNetV1ImageProcessor;__webpack_exports__.MobileNetV1Model;__webpack_exports__.MobileNetV1PreTrainedModel;__webpack_exports__.MobileNetV2FeatureExtractor;__webpack_exports__.MobileNetV2ForImageClassification;__webpack_exports__.MobileNetV2ForSemanticSegmentation;__webpack_exports__.MobileNetV2ImageProcessor;__webpack_exports__.MobileNetV2Model;__webpack_exports__.MobileNetV2PreTrainedModel;__webpack_exports__.MobileNetV3FeatureExtractor;__webpack_exports__.MobileNetV3ForImageClassification;__webpack_exports__.MobileNetV3ForSemanticSegmentation;__webpack_exports__.MobileNetV3ImageProcessor;__webpack_exports__.MobileNetV3Model;__webpack_exports__.MobileNetV3PreTrainedModel;__webpack_exports__.MobileNetV4FeatureExtractor;__webpack_exports__.MobileNetV4ForImageClassification;__webpack_exports__.MobileNetV4ForSemanticSegmentation;__webpack_exports__.MobileNetV4ImageProcessor;__webpack_exports__.MobileNetV4Model;__webpack_exports__.MobileNetV4PreTrainedModel;__webpack_exports__.MobileViTFeatureExtractor;__webpack_exports__.MobileViTForImageClassification;__webpack_exports__.MobileViTImageProcessor;__webpack_exports__.MobileViTModel;__webpack_exports__.MobileViTPreTrainedModel;__webpack_exports__.MobileViTV2ForImageClassification;__webpack_exports__.MobileViTV2Model;__webpack_exports__.MobileViTV2PreTrainedModel;__webpack_exports__.ModelOutput;__webpack_exports__.ModernBertDecoderForCausalLM;__webpack_exports__.ModernBertDecoderModel;__webpack_exports__.ModernBertDecoderPreTrainedModel;__webpack_exports__.ModernBertForMaskedLM;__webpack_exports__.ModernBertForSequenceClassification;__webpack_exports__.ModernBertForTokenClassification;__webpack_exports__.ModernBertModel;__webpack_exports__.ModernBertPreTrainedModel;__webpack_exports__.Moondream1ForConditionalGeneration;__webpack_exports__.MoonshineFeatureExtractor;__webpack_exports__.MoonshineForConditionalGeneration;__webpack_exports__.MoonshineModel;__webpack_exports__.MoonshinePreTrainedModel;__webpack_exports__.MoonshineProcessor;__webpack_exports__.MptForCausalLM;__webpack_exports__.MptModel;__webpack_exports__.MptPreTrainedModel;__webpack_exports__.MultiModalityCausalLM;__webpack_exports__.MultiModalityPreTrainedModel;__webpack_exports__.MusicgenForCausalLM;__webpack_exports__.MusicgenForConditionalGeneration;__webpack_exports__.MusicgenModel;__webpack_exports__.MusicgenPreTrainedModel;__webpack_exports__.NeoBertForMaskedLM;__webpack_exports__.NeoBertForQuestionAnswering;__webpack_exports__.NeoBertForSequenceClassification;__webpack_exports__.NeoBertForTokenClassification;__webpack_exports__.NeoBertModel;__webpack_exports__.NeoBertPreTrainedModel;__webpack_exports__.NllbTokenizer;__webpack_exports__.NoBadWordsLogitsProcessor;__webpack_exports__.NoRepeatNGramLogitsProcessor;__webpack_exports__.NomicBertModel;__webpack_exports__.NomicBertPreTrainedModel;__webpack_exports__.NougatImageProcessor;__webpack_exports__.NougatTokenizer;__webpack_exports__.OPTForCausalLM;__webpack_exports__.OPTModel;__webpack_exports__.OPTPreTrainedModel;__webpack_exports__.ObjectDetectionPipeline;__webpack_exports__.Olmo2ForCausalLM;__webpack_exports__.Olmo2Model;__webpack_exports__.Olmo2PreTrainedModel;__webpack_exports__.OlmoForCausalLM;__webpack_exports__.OlmoModel;__webpack_exports__.OlmoPreTrainedModel;__webpack_exports__.OpenELMForCausalLM;__webpack_exports__.OpenELMModel;__webpack_exports__.OpenELMPreTrainedModel;__webpack_exports__.OwlViTFeatureExtractor;__webpack_exports__.OwlViTForObjectDetection;__webpack_exports__.OwlViTImageProcessor;__webpack_exports__.OwlViTModel;__webpack_exports__.OwlViTPreTrainedModel;__webpack_exports__.OwlViTProcessor;__webpack_exports__.Owlv2ForObjectDetection;__webpack_exports__.Owlv2ImageProcessor;__webpack_exports__.Owlv2Model;__webpack_exports__.Owlv2PreTrainedModel;__webpack_exports__.PaliGemmaForConditionalGeneration;__webpack_exports__.PaliGemmaPreTrainedModel;__webpack_exports__.PaliGemmaProcessor;__webpack_exports__.PatchTSMixerForPrediction;__webpack_exports__.PatchTSMixerModel;__webpack_exports__.PatchTSMixerPreTrainedModel;__webpack_exports__.PatchTSTForPrediction;__webpack_exports__.PatchTSTModel;__webpack_exports__.PatchTSTPreTrainedModel;__webpack_exports__.Phi3ForCausalLM;__webpack_exports__.Phi3Model;__webpack_exports__.Phi3PreTrainedModel;__webpack_exports__.Phi3VForCausalLM;__webpack_exports__.Phi3VImageProcessor;__webpack_exports__.Phi3VPreTrainedModel;__webpack_exports__.Phi3VProcessor;__webpack_exports__.PhiForCausalLM;__webpack_exports__.PhiModel;__webpack_exports__.PhiPreTrainedModel;__webpack_exports__.Pipeline;__webpack_exports__.PreTrainedModel;__webpack_exports__.PreTrainedTokenizer;__webpack_exports__.PretrainedConfig;__webpack_exports__.PretrainedMixin;__webpack_exports__.Processor;__webpack_exports__.PvtForImageClassification;__webpack_exports__.PvtImageProcessor;__webpack_exports__.PvtModel;__webpack_exports__.PvtPreTrainedModel;__webpack_exports__.PyAnnoteFeatureExtractor;__webpack_exports__.PyAnnoteForAudioFrameClassification;__webpack_exports__.PyAnnoteModel;__webpack_exports__.PyAnnotePreTrainedModel;__webpack_exports__.PyAnnoteProcessor;__webpack_exports__.QuestionAnsweringModelOutput;__webpack_exports__.QuestionAnsweringPipeline;__webpack_exports__.Qwen2ForCausalLM;__webpack_exports__.Qwen2Model;__webpack_exports__.Qwen2PreTrainedModel;__webpack_exports__.Qwen2Tokenizer;__webpack_exports__.Qwen2VLForConditionalGeneration;__webpack_exports__.Qwen2VLImageProcessor;__webpack_exports__.Qwen2VLPreTrainedModel;__webpack_exports__.Qwen2VLProcessor;__webpack_exports__.Qwen3ForCausalLM;__webpack_exports__.Qwen3Model;__webpack_exports__.Qwen3PreTrainedModel;__webpack_exports__.RFDetrForObjectDetection;__webpack_exports__.RFDetrModel;__webpack_exports__.RFDetrObjectDetectionOutput;__webpack_exports__.RFDetrPreTrainedModel;__webpack_exports__.RTDetrForObjectDetection;__webpack_exports__.RTDetrImageProcessor;__webpack_exports__.RTDetrModel;__webpack_exports__.RTDetrObjectDetectionOutput;__webpack_exports__.RTDetrPreTrainedModel;__webpack_exports__.RTDetrV2ForObjectDetection;__webpack_exports__.RTDetrV2Model;__webpack_exports__.RTDetrV2ObjectDetectionOutput;__webpack_exports__.RTDetrV2PreTrainedModel;__webpack_exports__.RawAudio;var __webpack_exports__RawImage=__webpack_exports__.RawImage;__webpack_exports__.RawVideo;__webpack_exports__.RawVideoFrame;__webpack_exports__.RepetitionPenaltyLogitsProcessor;__webpack_exports__.ResNetForImageClassification;__webpack_exports__.ResNetModel;__webpack_exports__.ResNetPreTrainedModel;__webpack_exports__.RoFormerForMaskedLM;__webpack_exports__.RoFormerForQuestionAnswering;__webpack_exports__.RoFormerForSequenceClassification;__webpack_exports__.RoFormerForTokenClassification;__webpack_exports__.RoFormerModel;__webpack_exports__.RoFormerPreTrainedModel;__webpack_exports__.RoFormerTokenizer;__webpack_exports__.RobertaForMaskedLM;__webpack_exports__.RobertaForQuestionAnswering;__webpack_exports__.RobertaForSequenceClassification;__webpack_exports__.RobertaForTokenClassification;__webpack_exports__.RobertaModel;__webpack_exports__.RobertaPreTrainedModel;__webpack_exports__.RobertaTokenizer;__webpack_exports__.SamImageProcessor;__webpack_exports__.SamImageSegmentationOutput;__webpack_exports__.SamModel;__webpack_exports__.SamPreTrainedModel;__webpack_exports__.SamProcessor;__webpack_exports__.SapiensForDepthEstimation;__webpack_exports__.SapiensForNormalEstimation;__webpack_exports__.SapiensForSemanticSegmentation;__webpack_exports__.SapiensPreTrainedModel;__webpack_exports__.SeamlessM4TFeatureExtractor;__webpack_exports__.SegformerFeatureExtractor;__webpack_exports__.SegformerForImageClassification;__webpack_exports__.SegformerForSemanticSegmentation;__webpack_exports__.SegformerImageProcessor;__webpack_exports__.SegformerModel;__webpack_exports__.SegformerPreTrainedModel;__webpack_exports__.Seq2SeqLMOutput;__webpack_exports__.SequenceClassifierOutput;__webpack_exports__.SiglipImageProcessor;__webpack_exports__.SiglipModel;__webpack_exports__.SiglipPreTrainedModel;__webpack_exports__.SiglipTextModel;__webpack_exports__.SiglipTokenizer;__webpack_exports__.SiglipVisionModel;__webpack_exports__.SmolLM3ForCausalLM;__webpack_exports__.SmolLM3Model;__webpack_exports__.SmolLM3PreTrainedModel;__webpack_exports__.SmolVLMForConditionalGeneration;__webpack_exports__.SmolVLMImageProcessor;__webpack_exports__.SmolVLMProcessor;__webpack_exports__.SnacDecoderModel;__webpack_exports__.SnacEncoderModel;__webpack_exports__.SnacFeatureExtractor;__webpack_exports__.SnacModel;__webpack_exports__.SnacPreTrainedModel;__webpack_exports__.SpeechT5FeatureExtractor;__webpack_exports__.SpeechT5ForSpeechToText;__webpack_exports__.SpeechT5ForTextToSpeech;__webpack_exports__.SpeechT5HifiGan;__webpack_exports__.SpeechT5Model;__webpack_exports__.SpeechT5PreTrainedModel;__webpack_exports__.SpeechT5Processor;__webpack_exports__.SpeechT5Tokenizer;__webpack_exports__.SqueezeBertForMaskedLM;__webpack_exports__.SqueezeBertForQuestionAnswering;__webpack_exports__.SqueezeBertForSequenceClassification;__webpack_exports__.SqueezeBertModel;__webpack_exports__.SqueezeBertPreTrainedModel;__webpack_exports__.SqueezeBertTokenizer;__webpack_exports__.StableLmForCausalLM;__webpack_exports__.StableLmModel;__webpack_exports__.StableLmPreTrainedModel;__webpack_exports__.Starcoder2ForCausalLM;__webpack_exports__.Starcoder2Model;__webpack_exports__.Starcoder2PreTrainedModel;__webpack_exports__.StoppingCriteria;__webpack_exports__.StoppingCriteriaList;__webpack_exports__.StyleTextToSpeech2Model;__webpack_exports__.StyleTextToSpeech2PreTrainedModel;__webpack_exports__.SummarizationPipeline;__webpack_exports__.SuppressTokensAtBeginLogitsProcessor;__webpack_exports__.Swin2SRForImageSuperResolution;__webpack_exports__.Swin2SRImageProcessor;__webpack_exports__.Swin2SRModel;__webpack_exports__.Swin2SRPreTrainedModel;__webpack_exports__.SwinForImageClassification;__webpack_exports__.SwinForSemanticSegmentation;__webpack_exports__.SwinModel;__webpack_exports__.SwinPreTrainedModel;__webpack_exports__.T5ForConditionalGeneration;__webpack_exports__.T5Model;__webpack_exports__.T5PreTrainedModel;__webpack_exports__.T5Tokenizer;__webpack_exports__.TableTransformerForObjectDetection;__webpack_exports__.TableTransformerModel;__webpack_exports__.TableTransformerObjectDetectionOutput;__webpack_exports__.TableTransformerPreTrainedModel;__webpack_exports__.TemperatureLogitsWarper;__webpack_exports__.Tensor;__webpack_exports__.Text2TextGenerationPipeline;__webpack_exports__.TextClassificationPipeline;__webpack_exports__.TextGenerationPipeline;var __webpack_exports__TextStreamer=__webpack_exports__.TextStreamer;__webpack_exports__.TextToAudioPipeline;__webpack_exports__.TokenClassificationPipeline;__webpack_exports__.TokenClassifierOutput;__webpack_exports__.TokenizerModel;__webpack_exports__.TopKLogitsWarper;__webpack_exports__.TopPLogitsWarper;__webpack_exports__.TrOCRForCausalLM;__webpack_exports__.TrOCRPreTrainedModel;__webpack_exports__.TranslationPipeline;__webpack_exports__.UltravoxModel;__webpack_exports__.UltravoxPreTrainedModel;__webpack_exports__.UltravoxProcessor;__webpack_exports__.UniSpeechForCTC;__webpack_exports__.UniSpeechForSequenceClassification;__webpack_exports__.UniSpeechModel;__webpack_exports__.UniSpeechPreTrainedModel;__webpack_exports__.UniSpeechSatForAudioFrameClassification;__webpack_exports__.UniSpeechSatForCTC;__webpack_exports__.UniSpeechSatForSequenceClassification;__webpack_exports__.UniSpeechSatModel;__webpack_exports__.UniSpeechSatPreTrainedModel;__webpack_exports__.VLChatProcessor;__webpack_exports__.VLMImageProcessor;__webpack_exports__.ViTFeatureExtractor;__webpack_exports__.ViTForImageClassification;__webpack_exports__.ViTImageProcessor;__webpack_exports__.ViTMAEModel;__webpack_exports__.ViTMAEPreTrainedModel;__webpack_exports__.ViTMSNForImageClassification;__webpack_exports__.ViTMSNModel;__webpack_exports__.ViTMSNPreTrainedModel;__webpack_exports__.ViTModel;__webpack_exports__.ViTPreTrainedModel;__webpack_exports__.VisionEncoderDecoderModel;__webpack_exports__.VitMatteForImageMatting;__webpack_exports__.VitMatteImageProcessor;__webpack_exports__.VitMattePreTrainedModel;__webpack_exports__.VitPoseForPoseEstimation;__webpack_exports__.VitPoseImageProcessor;__webpack_exports__.VitPosePreTrainedModel;__webpack_exports__.VitsModel;__webpack_exports__.VitsModelOutput;__webpack_exports__.VitsPreTrainedModel;__webpack_exports__.VitsTokenizer;__webpack_exports__.VoxtralForConditionalGeneration;__webpack_exports__.VoxtralProcessor;__webpack_exports__.Wav2Vec2BertForCTC;__webpack_exports__.Wav2Vec2BertForSequenceClassification;__webpack_exports__.Wav2Vec2BertModel;__webpack_exports__.Wav2Vec2BertPreTrainedModel;__webpack_exports__.Wav2Vec2CTCTokenizer;__webpack_exports__.Wav2Vec2FeatureExtractor;__webpack_exports__.Wav2Vec2ForAudioFrameClassification;__webpack_exports__.Wav2Vec2ForCTC;__webpack_exports__.Wav2Vec2ForSequenceClassification;__webpack_exports__.Wav2Vec2Model;__webpack_exports__.Wav2Vec2PreTrainedModel;__webpack_exports__.Wav2Vec2Processor;__webpack_exports__.Wav2Vec2ProcessorWithLM;__webpack_exports__.WavLMForAudioFrameClassification;__webpack_exports__.WavLMForCTC;__webpack_exports__.WavLMForSequenceClassification;__webpack_exports__.WavLMForXVector;__webpack_exports__.WavLMModel;__webpack_exports__.WavLMPreTrainedModel;__webpack_exports__.WeSpeakerFeatureExtractor;__webpack_exports__.WeSpeakerResNetModel;__webpack_exports__.WeSpeakerResNetPreTrainedModel;__webpack_exports__.WhisperFeatureExtractor;__webpack_exports__.WhisperForConditionalGeneration;__webpack_exports__.WhisperModel;__webpack_exports__.WhisperPreTrainedModel;__webpack_exports__.WhisperProcessor;__webpack_exports__.WhisperTextStreamer;__webpack_exports__.WhisperTimeStampLogitsProcessor;__webpack_exports__.WhisperTokenizer;__webpack_exports__.XLMForQuestionAnswering;__webpack_exports__.XLMForSequenceClassification;__webpack_exports__.XLMForTokenClassification;__webpack_exports__.XLMModel;__webpack_exports__.XLMPreTrainedModel;__webpack_exports__.XLMRobertaForMaskedLM;__webpack_exports__.XLMRobertaForQuestionAnswering;__webpack_exports__.XLMRobertaForSequenceClassification;__webpack_exports__.XLMRobertaForTokenClassification;__webpack_exports__.XLMRobertaModel;__webpack_exports__.XLMRobertaPreTrainedModel;__webpack_exports__.XLMRobertaTokenizer;__webpack_exports__.XLMTokenizer;__webpack_exports__.XLMWithLMHeadModel;__webpack_exports__.XVectorOutput;__webpack_exports__.YolosFeatureExtractor;__webpack_exports__.YolosForObjectDetection;__webpack_exports__.YolosImageProcessor;__webpack_exports__.YolosModel;__webpack_exports__.YolosObjectDetectionOutput;__webpack_exports__.YolosPreTrainedModel;__webpack_exports__.ZeroShotAudioClassificationPipeline;__webpack_exports__.ZeroShotClassificationPipeline;__webpack_exports__.ZeroShotImageClassificationPipeline;__webpack_exports__.ZeroShotObjectDetectionPipeline;__webpack_exports__.bankers_round;__webpack_exports__.cat;__webpack_exports__.cos_sim;__webpack_exports__.dot;__webpack_exports__.dynamic_time_warping;__webpack_exports__.env;__webpack_exports__.full;__webpack_exports__.full_like;__webpack_exports__.getCacheShapes;__webpack_exports__.hamming;__webpack_exports__.hanning;__webpack_exports__.interpolate;__webpack_exports__.interpolate_4d;__webpack_exports__.interpolate_data;__webpack_exports__.is_chinese_char;__webpack_exports__.layer_norm;__webpack_exports__.load_image;__webpack_exports__.load_video;__webpack_exports__.log_softmax;__webpack_exports__.magnitude;__webpack_exports__.matmul;__webpack_exports__.max;__webpack_exports__.mean;__webpack_exports__.mean_pooling;__webpack_exports__.medianFilter;__webpack_exports__.mel_filter_bank;__webpack_exports__.min;__webpack_exports__.ones;__webpack_exports__.ones_like;__webpack_exports__.permute;__webpack_exports__.permute_data;__webpack_exports__.pipeline;__webpack_exports__.quantize_embeddings;__webpack_exports__.rand;__webpack_exports__.read_audio;__webpack_exports__.rfft;__webpack_exports__.round;__webpack_exports__.slice;__webpack_exports__.softmax;__webpack_exports__.spectrogram;__webpack_exports__.stack;__webpack_exports__.std_mean;__webpack_exports__.topk;__webpack_exports__.window_function;__webpack_exports__.zeros;__webpack_exports__.zeros_like;const VLMContext=reactExports.createContext(null),MODEL_ID="onnx-community/FastVLM-0.5B-ONNX",MAX_NEW_TOKENS=512,VLMProvider=({children:n})=>{const[e,t]=reactExports.useState(!1),[s,a]=reactExports.useState(!1),[c,l]=reactExports.useState(null),_=reactExports.useRef(null),m=reactExports.useRef(null),d=reactExports.useRef(null),h=reactExports.useRef(!1),i=reactExports.useRef(null),[r,u]=reactExports.useState(!1),f=reactExports.useCallback(async w=>{if(e){w?.("Model already loaded!");return}return d.current||(a(!0),l(null),d.current=(async()=>{try{w?.("Loading processor..."),_.current=await __webpack_exports__AutoProcessor.from_pretrained(MODEL_ID),w?.("Processor loaded. Loading model..."),m.current=await __webpack_exports__AutoModelForImageTextToText.from_pretrained(MODEL_ID,{dtype:{embed_tokens:"fp16",vision_encoder:"q4",decoder_model_merged:"q4"},device:"webgpu"}),w?.("Model loaded successfully!"),t(!0)}catch(y){const x=y instanceof Error?y.message:String(y);throw l(x),console.error("Error loading model:",y),y}finally{a(!1),d.current=null}})()),d.current},[e]),g=reactExports.useCallback(async(w,y,x)=>{if(u(!1),h.current)return console.log("Inference already running, skipping frame"),"";if(h.current=!0,!_.current||!m.current)throw new Error("Model/processor not loaded");i.current||(i.current=document.createElement("canvas"));const S=i.current;S.width=w.videoWidth,S.height=w.videoHeight;const T=S.getContext("2d",{willReadFrequently:!0});if(!T)throw new Error("Could not get canvas context");T.drawImage(w,0,0);const E=T.getImageData(0,0,S.width,S.height),A=new __webpack_exports__RawImage(E.data,E.width,E.height,4),C=[{role:"system",content:"You are a helpful visual AI assistant tasked with creating a visual diary for the blind. Provide detailed descriptions of the image so that the user can always reference back to what they previously saw. Provide actual names and rich, specific details as much as possible."},{role:"user",content:`<image>${y}`}],I=_.current.apply_chat_template(C,{add_generation_prompt:!0}),D=await _.current(A,I,{add_special_tokens:!1});let R="";const Y=new __webpack_exports__TextStreamer(_.current.tokenizer,{skip_prompt:!0,skip_special_tokens:!0,callback_function:te=>{R+=te,x?.(R.trim())}}),re=await m.current.generate({...D,max_new_tokens:MAX_NEW_TOKENS,do_sample:!1,streamer:Y,repetition_penalty:1.2}),G=_.current.batch_decode(re.slice(null,[D.input_ids.dims.at(-1),null]),{skip_special_tokens:!0});return h.current=!1,u(!0),G[0].trim()},[]);return jsxRuntimeExports.jsx(VLMContext.Provider,{value:{isLoaded:e,isLoading:s,error:c,loadModel:f,runInference:g,responseCompleted:r},children:n})};function useVLMContext(){const n=reactExports.useContext(VLMContext);if(!n)throw new Error("useVLMContext must be inside VLMProvider");return n}const GLASS_EFFECTS={BASE_FREQUENCY:.008,NUM_OCTAVES:2,SCALE:77,COLORS:{DEFAULT_BG:"rgba(0, 0, 0, 0.25)",SUCCESS_BG:"rgba(0, 50, 0, 0.25)",ERROR_BG:"rgba(50, 0, 0, 0.25)",BUTTON_BG:"rgba(59, 130, 246, 0.25)"}},LAYOUT={MARGINS:{DEFAULT:20,BOTTOM:20}},TIMING={FRAME_CAPTURE_DELAY:50},DEFAULT_PROMPT="Describe what you see in one sentence.",PROMPTS={default:DEFAULT_PROMPT,placeholder:DEFAULT_PROMPT,suggestions:[DEFAULT_PROMPT,"What is the color of my shirt?","Identify any text or written content visible.","What emotions or actions are being portrayed?","Name the object I am holding in my hand."],fallbackCaption:"Waiting for first caption...",processingMessage:"Starting analysis..."};function GlassFilters(){return jsxRuntimeExports.jsx("svg",{style:{display:"none"},"aria-hidden":"true",children:jsxRuntimeExports.jsxs("filter",{id:"glass-distortion",children:[jsxRuntimeExports.jsx("feTurbulence",{type:"turbulence",baseFrequency:GLASS_EFFECTS.BASE_FREQUENCY,numOctaves:GLASS_EFFECTS.NUM_OCTAVES,result:"noise"}),jsxRuntimeExports.jsx("feDisplacementMap",{in:"SourceGraphic",in2:"noise",scale:GLASS_EFFECTS.SCALE})]})})}function GlassContainer({children:n,className:e="",bgColor:t="rgba(0, 0, 0, 0.25)",highlight:s="rgba(255, 255, 255, 0.15)",onClick:a,onMouseDown:c,role:l,style:_,...m}){const d=reactExports.useRef(null),h=reactExports.useCallback(r=>{if(!d.current)return;const u=r.currentTarget.getBoundingClientRect(),f=r.clientX-u.left,g=r.clientY-u.top;d.current.style.background=`radial-gradient(
      circle at ${f}px ${g}px,
      rgba(255,255,255,0.15) 0%,
      rgba(255,255,255,0.05) 30%,
      rgba(255,255,255,0) 60%
    )`},[]),i=reactExports.useCallback(()=>{d.current&&(d.current.style.background="none")},[]);return jsxRuntimeExports.jsxs("div",{className:`glass-container relative overflow-hidden ${e}`,onMouseMove:h,onMouseLeave:i,onClick:a,onMouseDown:c,role:l,style:{"--bg-color":t,"--highlight":s,"--text":"#ffffff",..._},...m,children:[jsxRuntimeExports.jsx(GlassFilters,{}),jsxRuntimeExports.jsx("div",{className:"glass-filter absolute inset-0 backdrop-blur-md z-10",style:{filter:"url(#glass-distortion) saturate(120%) brightness(1.15)",borderRadius:"inherit"}}),jsxRuntimeExports.jsx("div",{className:"glass-overlay absolute inset-0 z-20",style:{background:"var(--bg-color)",borderRadius:"inherit"}}),jsxRuntimeExports.jsx("div",{ref:d,className:"glass-specular absolute inset-0 z-30",style:{boxShadow:"inset 1px 1px 1px var(--highlight)",borderRadius:"inherit"}}),jsxRuntimeExports.jsx("div",{className:"glass-content relative z-40",children:n})]})}function LoadingScreen({onComplete:n}){const[e,t]=reactExports.useState(0),[s,a]=reactExports.useState("Initializing..."),[c,l]=reactExports.useState(!1),[_,m]=reactExports.useState(!1),{loadModel:d,isLoaded:h,isLoading:i}=useVLMContext();return reactExports.useEffect(()=>{if(_||i||h)return;(async()=>{m(!0);try{if(a("Checking WebGPU support..."),t(5),!navigator.gpu){a("WebGPU not available in this browser"),l(!0);return}await d(u=>{a(u),u.includes("Loading processor")?t(10):u.includes("Processor loaded")?t(20):u.includes("Model loaded")&&t(80)}),a("Ready to start!"),t(100),await new Promise(u=>setTimeout(u,300)),n()}catch(u){console.error("Error loading model:",u),a(`Error loading model: ${u instanceof Error?u.message:String(u)}`),l(!0)}})()},[_,i,h,d,n]),reactExports.useEffect(()=>{h&&!_&&(t(100),a("Model already loaded!"),setTimeout(n,300))},[h,_,n]),jsxRuntimeExports.jsx("div",{className:"absolute inset-0 text-white flex items-center justify-center p-8",style:{opacity:1},children:jsxRuntimeExports.jsx(GlassContainer,{className:"max-w-md w-full rounded-3xl shadow-2xl",bgColor:c?GLASS_EFFECTS.COLORS.ERROR_BG:GLASS_EFFECTS.COLORS.DEFAULT_BG,children:jsxRuntimeExports.jsxs("div",{className:"p-8 text-center space-y-8",children:[jsxRuntimeExports.jsxs("div",{className:"space-y-4",children:[jsxRuntimeExports.jsx("div",{className:"w-16 h-16 mx-auto",children:c?jsxRuntimeExports.jsx("div",{className:"w-16 h-16 rounded-full bg-red-500/20 flex items-center justify-center",children:jsxRuntimeExports.jsx("svg",{className:"w-8 h-8 text-red-400",fill:"currentColor",viewBox:"0 0 20 20",children:jsxRuntimeExports.jsx("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",clipRule:"evenodd"})})}):jsxRuntimeExports.jsx("div",{className:"animate-spin rounded-full h-16 w-16 border-4 border-blue-500 border-t-transparent"})}),jsxRuntimeExports.jsx("h2",{className:"text-2xl font-bold text-gray-100",children:c?"Loading Failed":"Loading AI Model"}),jsxRuntimeExports.jsx("p",{className:`${c?"text-red-400":"text-gray-400"}`,children:s})]}),!c&&jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("div",{className:"w-full bg-gray-800/50 rounded-full h-3 overflow-hidden backdrop-blur-sm border border-gray-700/30",children:jsxRuntimeExports.jsx("div",{className:"h-full bg-gradient-to-r from-blue-500 to-blue-600 rounded-full transition-all duration-300 ease-out",style:{width:`${e}%`}})}),jsxRuntimeExports.jsxs("p",{className:"text-sm text-gray-500",children:[Math.round(e),"% complete"]})]}),c&&jsxRuntimeExports.jsx("div",{className:"mt-4",children:jsxRuntimeExports.jsx("button",{onClick:()=>window.location.reload(),className:"px-6 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white font-medium transition-colors",children:"Reload Page"})})]})})})}function GlassButton({children:n,onClick:e,className:t="",disabled:s=!1,bgColor:a=GLASS_EFFECTS.COLORS.BUTTON_BG,...c}){return jsxRuntimeExports.jsx(GlassContainer,{bgColor:a,className:"rounded-xl",children:jsxRuntimeExports.jsx("button",{className:`px-4 py-2 border-none cursor-pointer bg-transparent transition-transform duration-200 outline-none ${s?"opacity-50 cursor-not-allowed":"hover:scale-105 active:scale-95"} ${t}`,onClick:s?void 0:e,disabled:s,...c,children:jsxRuntimeExports.jsx("div",{className:"font-medium text-white",children:n})})})}function WebcamCapture({isRunning:n,onToggleRunning:e,error:t}){const s=!!t,[a,c,l]=s?["Error","bg-red-500",GLASS_EFFECTS.COLORS.ERROR_BG]:n?["Live","bg-green-500 animate-pulse",GLASS_EFFECTS.COLORS.DEFAULT_BG]:["Paused","bg-red-500",GLASS_EFFECTS.COLORS.DEFAULT_BG];return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx("div",{className:"absolute top-4 right-4 flex space-x-2 z-20",children:jsxRuntimeExports.jsx(GlassButton,{onClick:e,"aria-label":n?"Pause captioning":"Resume captioning",children:n?"Pause":"Resume"})}),jsxRuntimeExports.jsx("div",{className:"absolute top-4 left-4 z-20",children:jsxRuntimeExports.jsx(GlassContainer,{bgColor:l,className:"px-3 py-2 rounded-lg",role:"status","aria-label":`Caption status: ${a}`,children:jsxRuntimeExports.jsxs("div",{className:"flex items-center space-x-2",children:[jsxRuntimeExports.jsx("div",{className:`w-2 h-2 rounded-full ${c}`}),jsxRuntimeExports.jsx("span",{className:"text-white text-sm font-medium",children:a})]})})})]})}const clampPosition=(n,e,t)=>({x:Math.max(0,Math.min(n.x,e)),y:Math.max(0,Math.min(n.y,t))}),getBasePosition=(n,e)=>{const{width:t,height:s}=e;switch(n){case"bottom-left":return{x:LAYOUT.MARGINS.DEFAULT,y:window.innerHeight-s-LAYOUT.MARGINS.BOTTOM};case"bottom-right":return{x:window.innerWidth-t-LAYOUT.MARGINS.DEFAULT,y:window.innerHeight-s-LAYOUT.MARGINS.BOTTOM}}};function DraggableContainer({children:n,initialPosition:e,className:t="",onDimensionsReady:s}){const[a,c]=reactExports.useState({x:0,y:0}),[l,_]=reactExports.useState(!1),[m,d]=reactExports.useState(!1),[h,i]=reactExports.useState({x:0,y:0}),[r,u]=reactExports.useState({x:0,y:0}),[f,g]=reactExports.useState({width:0,height:0}),[w,y]=reactExports.useState(!1),x=reactExports.useRef(null),S=reactExports.useCallback(()=>{if(!x.current||f.width===0)return{x:0,y:0};if(typeof e=="object")return e;const C=getBasePosition(e,f);return m?{x:C.x+r.x,y:C.y+r.y}:C},[f,e,m,r]),T=reactExports.useCallback(C=>{g(C),s&&!m&&s(C)},[s,m]),E=reactExports.useCallback(C=>{if(!x.current)return C;const I=window.innerWidth-x.current.offsetWidth,D=window.innerHeight-x.current.offsetHeight;return clampPosition(C,I,D)},[]);reactExports.useEffect(()=>{if(!w&&f.width>0&&!m){const C=S();c(E(C)),y(!0)}},[w,f.width,m,S,E]),reactExports.useEffect(()=>{if(!x.current)return;const C=new ResizeObserver(()=>{if(!x.current)return;const I=x.current.getBoundingClientRect(),D={width:I.width,height:I.height};T(D),c(R=>E(R))});return C.observe(x.current),()=>C.disconnect()},[T,E]),reactExports.useEffect(()=>{const C=()=>{const I=S();c(E(I))};return window.addEventListener("resize",C),()=>window.removeEventListener("resize",C)},[S,E]),reactExports.useEffect(()=>{if(!l)return;const C=D=>{const R={x:D.clientX-h.x,y:D.clientY-h.y};c(E(R))},I=()=>{if(_(!1),d(!0),x.current&&typeof e!="object"){const D=getBasePosition(e,f);u({x:a.x-D.x,y:a.y-D.y})}};return document.addEventListener("mousemove",C),document.addEventListener("mouseup",I),()=>{document.removeEventListener("mousemove",C),document.removeEventListener("mouseup",I)}},[l,h,a,e,f,E]);const A=C=>{if(!x.current)return;const I=x.current.getBoundingClientRect();i({x:C.clientX-I.left,y:C.clientY-I.top}),_(!0)};return jsxRuntimeExports.jsx("div",{ref:x,className:`fixed z-50 ${t} ${l?"cursor-grabbing":"cursor-grab"}`,style:{left:a.x,top:a.y,transform:l?"scale(1.02)":"scale(1)",transition:l?"none":"transform 0.2s ease",opacity:w?1:0},onMouseDown:A,children:n})}function PromptInput({onPromptChange:n,defaultPrompt:e=PROMPTS.default}){const[t,s]=reactExports.useState(e),[a,c]=reactExports.useState(!1),l=reactExports.useRef(null),_=reactExports.useRef(null),m=()=>{if(l.current){l.current.style.height="auto";const g=Math.min(l.current.scrollHeight,200);l.current.style.height=`${g}px`}};reactExports.useEffect(()=>{n(t),m()},[t,n]);const d=()=>{c(!0)},h=()=>{c(!0)},i=g=>{(!g.relatedTarget||!_.current?.contains(g.relatedTarget))&&c(!1)},r=g=>{s(g),c(!1),l.current?.focus()},u=()=>{s(""),l.current?.focus()},f=g=>{s(g.target.value)};return jsxRuntimeExports.jsxs("div",{ref:_,className:"w-[420px] relative",style:{"--input-bg":"rgba(0, 0, 0, 0.2)","--input-border":"rgba(255, 255, 255, 0.1)"},children:[jsxRuntimeExports.jsx("div",{className:`absolute bottom-full left-0 right-0 mb-2 ${a?"opacity-100 pointer-events-auto":"opacity-0 pointer-events-none"}`,children:jsxRuntimeExports.jsx(GlassContainer,{className:"rounded-2xl shadow-2xl",children:jsxRuntimeExports.jsx("div",{className:`p-5 text-white transition-opacity duration-100 ${a?"opacity-100":"opacity-0"}`,children:jsxRuntimeExports.jsxs("div",{className:"suggestion-group",children:[jsxRuntimeExports.jsx("h4",{className:"text-sm mb-3 opacity-70 font-medium",children:"Suggested Prompts"}),jsxRuntimeExports.jsx("ul",{className:"space-y-1",children:PROMPTS.suggestions.map((g,w)=>jsxRuntimeExports.jsxs("li",{tabIndex:0,onMouseDown:y=>{y.preventDefault()},onClick:()=>r(g),onKeyDown:y=>{(y.key==="Enter"||y.key===" ")&&(y.preventDefault(),r(g))},className:"py-2 px-3 rounded-lg cursor-pointer flex items-center gap-3 transition-all duration-200 hover:bg-white/20 hover:translate-x-1 hover:shadow-sm focus:bg-white/20 focus:translate-x-1 focus:outline-none",children:[jsxRuntimeExports.jsx("span",{className:"opacity-70 text-sm transition-all duration-200 hover:opacity-100",children:"→"}),jsxRuntimeExports.jsx("span",{className:"text-sm transition-all duration-200 hover:text-white/90",children:g})]},w))})]})})})}),jsxRuntimeExports.jsx(GlassContainer,{className:"rounded-2xl shadow-2xl",children:jsxRuntimeExports.jsx("div",{className:"text-white",children:jsxRuntimeExports.jsx("div",{className:"search-container relative p-5 flex items-center transition-all duration-400",children:jsxRuntimeExports.jsxs("div",{className:"relative w-full",children:[jsxRuntimeExports.jsx("textarea",{ref:l,value:t,onChange:f,onFocus:d,onBlur:i,onClick:h,className:"search-input w-full py-3 pl-4 pr-8 rounded-xl text-white text-base transition-all duration-400 border resize-none focus:outline-none focus:-translate-y-0.5 focus:shadow-lg",style:{background:"var(--input-bg)",borderColor:"var(--input-border)",color:"#ffffff",minHeight:"48px",maxHeight:"200px",height:"auto",overflowY:"hidden"},placeholder:PROMPTS.placeholder,rows:1}),t&&jsxRuntimeExports.jsx("button",{type:"button",onClick:u,className:"search-clear absolute right-3 top-2 text-white opacity-70 hover:opacity-100 hover:bg-white/10 rounded-full p-1 transition-all duration-300",children:"×"})]})})})})]})}function LiveCaption({caption:n,isRunning:e,error:t}){const s=t||n,{color:a,label:c}=t?{color:"bg-red-500",label:"ERROR"}:e?{color:"bg-green-500 animate-pulse",label:"RUNNING"}:{color:"bg-yellow-500 animate-pulse",label:"STOPPED"};return jsxRuntimeExports.jsx(GlassContainer,{bgColor:t?GLASS_EFFECTS.COLORS.ERROR_BG:GLASS_EFFECTS.COLORS.DEFAULT_BG,className:`w-150 h-45 rounded-2xl shadow-2xl hover:scale-105 transition-transform duration-200 ${t?"border border-red-500/30":""}`,children:jsxRuntimeExports.jsxs("div",{className:"p-5 text-white flex flex-col flex-start h-full",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between mb-3",children:[jsxRuntimeExports.jsx("h3",{className:"text-base font-semibold opacity-90",children:"Live Caption"}),jsxRuntimeExports.jsxs("div",{className:"flex items-center space-x-2",children:[jsxRuntimeExports.jsx("div",{className:`w-2 h-2 rounded-full ${a}`}),jsxRuntimeExports.jsx("span",{className:"text-sm opacity-70",children:c})]})]}),jsxRuntimeExports.jsx("div",{className:"min-h-[4rem] flex flex-col",children:s?jsxRuntimeExports.jsx("div",{className:`text-sm opacity-85 leading-relaxed flex-1 ${t?"text-red-300":""}`,children:jsxRuntimeExports.jsx("span",{children:s||PROMPTS.fallbackCaption})}):jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-center w-full space-x-2",children:[jsxRuntimeExports.jsx("div",{className:"animate-spin rounded-full h-4 w-4 border border-blue-400 border-t-transparent"}),jsxRuntimeExports.jsx("p",{className:"text-sm opacity-80 italic",children:PROMPTS.processingMessage})]})})]})})}function useCaptioningLoop(n,e,t,s,a,c){const{isLoaded:l,runInference:_,responseCompleted:m}=useVLMContext(),d=reactExports.useRef(null),h=reactExports.useRef(s),i=reactExports.useRef(c);reactExports.useEffect(()=>{h.current=s},[s]),reactExports.useEffect(()=>{a(m)},[m,a]),reactExports.useEffect(()=>{i.current=c},[c]),reactExports.useEffect(()=>{if(d.current?.abort(),!e||!l)return;d.current=new AbortController;const r=d.current.signal,u=n.current;return setTimeout(async()=>{for(;!r.aborted;){if(u&&u.readyState>=2&&!u.paused&&u.videoWidth>0)try{const g=t.current||"",w=await _(u,g,h.current);w&&!r.aborted&&h.current(w)}catch(g){if(!r.aborted){const w=g instanceof Error?g.message:String(g);i.current(w),console.error("Error processing frame:",g)}}if(r.aborted)break;await new Promise(g=>setTimeout(g,TIMING.FRAME_CAPTURE_DELAY))}},0),()=>{d.current?.abort()}},[e,l,_,t,n])}function CaptioningView({videoRef:n,db:e}){const[t,s]=reactExports.useState(""),[a,c]=reactExports.useState(!0),[l,_]=reactExports.useState(PROMPTS.default),[m,d]=reactExports.useState(null),[h,i]=reactExports.useState(!1),r=reactExports.useRef(l);reactExports.useEffect(()=>{r.current=l},[l]);const u=reactExports.useCallback(x=>{s(x),d(null)},[]),f=reactExports.useCallback(x=>{d(x),s(`Error: ${x}`)},[]);useCaptioningLoop(n,a,r,u,i,f);const g=reactExports.useCallback(x=>{_(x),d(null)},[]),w=reactExports.useCallback(()=>{c(x=>!x),m&&d(null)},[m]);h&&(y(t),i(!1));async function y(x){try{const T=new Date().toISOString()+" : "+x;console.log(T),await e.insert({text:T})}catch(S){console.error(S)}}return jsxRuntimeExports.jsx("div",{className:"absolute inset-0 text-white",children:jsxRuntimeExports.jsxs("div",{className:"relative w-full h-full",children:[jsxRuntimeExports.jsx(WebcamCapture,{isRunning:a,onToggleRunning:w,error:m}),jsxRuntimeExports.jsx(DraggableContainer,{initialPosition:"bottom-left",children:jsxRuntimeExports.jsx(PromptInput,{onPromptChange:g})}),jsxRuntimeExports.jsx(DraggableContainer,{initialPosition:"bottom-right",children:jsxRuntimeExports.jsx(LiveCaption,{caption:t,isRunning:a,error:m})})]})})}const HfIcon=({className:n})=>jsxRuntimeExports.jsxs("svg",{className:n,viewBox:"0 8 256 256",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[jsxRuntimeExports.jsx("path",{d:"M230.721 172.7C230.183 170.673 229.313 168.75 228.146 167.008C228.396 166.091 228.587 165.159 228.714 164.217C229.543 158.241 227.471 152.77 223.567 148.537C221.452 146.225 219.185 144.698 216.784 143.761C218.36 137.018 219.157 130.117 219.161 123.193C219.161 120.03 218.982 116.932 218.682 113.88C218.526 112.356 218.337 110.836 218.115 109.32C217.428 104.847 216.408 100.431 215.064 96.11C214.183 93.2707 213.164 90.476 212.01 87.736C210.281 83.6782 208.262 79.75 205.969 75.982C204.465 73.475 202.827 71.0508 201.062 68.72C200.197 67.543 199.296 66.3938 198.358 65.274C195.58 61.898 192.561 58.7277 189.325 55.788C188.25 54.7997 187.145 53.8453 186.01 52.926C184.893 51.9943 183.751 51.0927 182.586 50.222C180.241 48.4766 177.818 46.8392 175.324 45.315C161.543 36.945 145.382 32.145 128.109 32.145C77.817 32.145 37.057 72.907 37.057 123.196C37.055 130.208 37.867 137.196 39.477 144.02C37.317 144.958 35.247 146.42 33.327 148.535C29.424 152.766 27.351 158.217 28.18 164.193C28.306 165.142 28.495 166.082 28.747 167.006C27.5811 168.749 26.7117 170.673 26.174 172.7C24.974 177.261 25.369 181.374 26.894 184.978C25.236 189.688 25.65 194.704 27.809 199.065C29.379 202.25 31.626 204.714 34.396 206.916C37.689 209.534 41.811 211.758 46.783 213.892C52.715 216.422 59.956 218.799 63.249 219.671C71.755 221.873 79.911 223.269 88.177 223.337C99.954 223.446 110.096 220.677 117.357 213.59C120.924 214.027 124.515 214.246 128.109 214.244C131.906 214.236 135.699 213.997 139.467 213.529C146.711 220.661 156.892 223.455 168.712 223.343C176.977 223.277 185.133 221.881 193.617 219.676C196.932 218.804 204.17 216.427 210.105 213.897C215.077 211.76 219.199 209.536 222.514 206.922C225.263 204.719 227.508 202.256 229.079 199.071C231.26 194.709 231.652 189.693 230.017 184.983C231.527 181.379 231.92 177.257 230.721 172.7ZM222.281 184.673C223.952 187.844 224.059 191.427 222.585 194.764C220.349 199.821 214.795 203.805 204.008 208.082C197.3 210.742 191.158 212.443 191.104 212.458C182.232 214.759 174.208 215.928 167.262 215.928C155.76 215.928 147.201 212.754 141.773 206.486C132.594 208.05 123.222 208.103 114.026 206.644C108.591 212.808 100.081 215.928 88.676 215.928C81.729 215.928 73.706 214.759 64.833 212.458C64.779 212.443 58.639 210.742 51.929 208.082C41.143 203.805 35.587 199.824 33.352 194.764C31.878 191.427 31.985 187.844 33.656 184.673C33.81 184.378 33.976 184.091 34.153 183.813C33.1516 182.309 32.4799 180.61 32.182 178.827C31.8842 177.045 31.967 175.22 32.425 173.472C33.089 170.949 34.46 168.851 36.322 167.344C35.425 165.87 34.8365 164.23 34.592 162.522C34.056 158.808 35.289 155.1 38.062 152.076C40.222 149.723 43.275 148.428 46.655 148.428H46.745C44.1965 140.259 42.9044 131.75 42.913 123.193C42.913 76.522 80.749 38.683 127.427 38.683C174.104 38.683 211.94 76.518 211.94 123.193C211.947 131.773 210.646 140.304 208.081 148.492C208.489 148.452 208.889 148.432 209.282 148.431C212.662 148.431 215.716 149.726 217.874 152.079C220.647 155.1 221.881 158.811 221.344 162.525C221.1 164.233 220.511 165.873 219.615 167.347C221.477 168.854 222.849 170.952 223.512 173.475C223.97 175.223 224.053 177.048 223.755 178.831C223.458 180.613 222.786 182.312 221.784 183.816C221.961 184.091 222.129 184.378 222.281 184.673Z",fill:"white"}),jsxRuntimeExports.jsx("path",{d:"M221.784 183.816C222.786 182.312 223.458 180.613 223.756 178.831C224.053 177.048 223.97 175.223 223.512 173.475C222.848 170.952 221.476 168.854 219.615 167.347C220.512 165.873 221.1 164.233 221.344 162.525C221.881 158.811 220.648 155.103 217.874 152.079C215.716 149.726 212.662 148.431 209.282 148.431C208.889 148.431 208.489 148.452 208.081 148.492C210.643 140.304 211.942 131.774 211.933 123.195C211.933 76.5231 174.097 38.6851 127.424 38.6851C80.75 38.6851 42.9099 76.5191 42.9099 123.195C42.9015 131.752 44.1936 140.261 46.742 148.43H46.6519C43.2719 148.43 40.219 149.724 38.06 152.077C35.287 155.098 34.0529 158.81 34.5899 162.523C34.8346 164.231 35.4231 165.872 36.3199 167.346C34.4579 168.852 33.086 170.95 32.422 173.473C31.9642 175.222 31.8817 177.047 32.1799 178.83C32.4781 180.612 33.1501 182.312 34.1519 183.816C33.9739 184.094 33.8099 184.381 33.6549 184.676C31.9849 187.847 31.877 191.43 33.352 194.767C35.588 199.824 41.1419 203.808 51.9289 208.085C58.6359 210.745 64.779 212.446 64.833 212.461C73.705 214.762 81.729 215.931 88.675 215.931C100.081 215.931 108.591 212.811 114.026 206.647C123.222 208.106 132.594 208.052 141.773 206.489C147.201 212.757 155.76 215.931 167.262 215.931C174.208 215.931 182.232 214.762 191.103 212.461C191.158 212.446 197.298 210.745 204.008 208.085C214.795 203.808 220.35 199.824 222.585 194.767C224.059 191.43 223.952 187.847 222.281 184.676C222.129 184.379 221.961 184.091 221.784 183.816ZM110.137 196.997C109.669 197.815 109.168 198.614 108.635 199.391C107.23 201.448 105.382 203.02 103.237 204.188C99.1369 206.424 93.947 207.205 88.675 207.205C80.346 207.205 71.808 205.256 67.023 204.015C66.787 203.954 37.689 195.735 41.373 188.739C41.993 187.562 43.0129 187.092 44.2979 187.092C49.4849 187.092 58.9299 194.816 62.9889 194.816C63.8959 194.816 64.5359 194.43 64.7969 193.488C66.5269 187.284 38.5039 184.676 40.8639 175.692C41.2799 174.102 42.41 173.456 43.998 173.456C50.856 173.455 66.248 185.516 69.467 185.516C69.714 185.516 69.8909 185.443 69.9869 185.291C70.0009 185.268 70.015 185.246 70.028 185.222C71.539 182.727 70.6719 180.913 60.3209 174.573L59.3269 173.968C47.9359 167.074 39.9409 162.925 44.4879 157.975C45.0109 157.404 45.7529 157.151 46.6539 157.151C47.7219 157.151 49.0149 157.508 50.4389 158.108C56.4549 160.645 64.793 167.564 68.276 170.581C68.8239 171.057 69.3683 171.538 69.9089 172.022C69.9089 172.022 74.319 176.608 76.985 176.608C77.599 176.608 78.1199 176.366 78.4729 175.768C80.364 172.58 60.9099 157.838 59.8129 151.755C59.0689 147.634 60.3349 145.546 62.6749 145.546C63.7879 145.546 65.1459 146.02 66.6449 146.971C71.2949 149.922 80.2729 165.35 83.5599 171.352C84.6619 173.363 86.5429 174.213 88.2379 174.213C91.6009 174.213 94.2299 170.87 88.5459 166.622C80.0029 160.23 83.001 149.782 87.078 149.139C87.252 149.111 87.4279 149.097 87.6029 149.097C91.3109 149.097 92.9459 155.486 92.9459 155.486C92.9459 155.486 97.7399 167.524 105.975 175.753C113.447 183.222 114.491 189.351 110.137 196.997ZM136.766 198.407L136.339 198.458L135.611 198.541C135.228 198.581 134.844 198.619 134.459 198.654L134.084 198.688L133.741 198.717L133.255 198.756L132.718 198.795L132.182 198.83L132.063 198.838C131.923 198.846 131.783 198.855 131.641 198.862L131.462 198.872C131.296 198.881 131.13 198.889 130.962 198.896L130.381 198.921L129.854 198.939L129.502 198.949H129.323C129.213 198.949 129.104 198.955 128.994 198.956H128.82C128.71 198.956 128.601 198.956 128.491 198.961L128.043 198.967H127.418C126.927 198.967 126.437 198.962 125.949 198.952L125.553 198.943C125.44 198.943 125.327 198.938 125.216 198.934L124.796 198.922L124.275 198.902L123.805 198.881L123.684 198.876L123.237 198.853C123.112 198.846 122.989 198.84 122.865 198.831L122.576 198.814C122.213 198.791 121.85 198.766 121.487 198.738L121.107 198.707C120.947 198.695 120.787 198.68 120.628 198.666C120.441 198.65 120.254 198.632 120.067 198.614C119.754 198.585 119.441 198.553 119.128 198.519H119.113C123.683 188.324 121.372 178.802 112.137 169.575C106.08 163.526 102.051 154.594 101.215 152.633C99.5229 146.828 95.045 140.375 87.608 140.375C86.979 140.375 86.351 140.425 85.73 140.523C82.472 141.036 79.624 142.911 77.592 145.733C75.396 143.002 73.262 140.831 71.332 139.605C68.422 137.76 65.5179 136.824 62.6889 136.824C59.1579 136.824 56.0019 138.274 53.8019 140.904L53.7459 140.971C53.7039 140.798 53.6639 140.625 53.6229 140.451L53.6179 140.428C53.1992 138.638 52.8477 136.833 52.5639 135.016C52.5639 135.004 52.5639 134.992 52.5579 134.98C52.5359 134.843 52.5159 134.705 52.4949 134.568C52.4334 134.162 52.3757 133.755 52.3219 133.348C52.2979 133.163 52.2719 132.978 52.2489 132.793L52.1809 132.238C52.1589 132.053 52.1409 131.885 52.1209 131.709L52.115 131.665C52.0351 130.945 51.9651 130.225 51.9049 129.503L51.8829 129.226L51.8479 128.754C51.8379 128.625 51.8279 128.495 51.8209 128.365C51.8209 128.334 51.8159 128.304 51.8149 128.275C51.7895 127.913 51.7678 127.55 51.7499 127.187C51.7399 126.998 51.7299 126.81 51.7219 126.62L51.7019 126.124L51.6969 125.974L51.6809 125.517L51.6709 125.128C51.6709 124.973 51.6629 124.818 51.6609 124.663C51.6579 124.508 51.6539 124.338 51.6529 124.174C51.6509 124.01 51.6529 123.848 51.6479 123.685C51.6439 123.521 51.6479 123.358 51.6479 123.195C51.6479 81.3421 85.5789 47.4111 127.436 47.4111C169.292 47.4111 203.222 81.3411 203.222 123.195V124.174C203.222 124.337 203.217 124.501 203.214 124.663C203.214 124.798 203.208 124.931 203.204 125.068C203.204 125.188 203.199 125.309 203.195 125.425C203.195 125.578 203.186 125.731 203.181 125.884V125.896L203.16 126.427C203.153 126.582 203.147 126.738 203.139 126.893L203.134 127.003L203.107 127.499C203.048 128.562 202.967 129.623 202.866 130.683V130.696C202.849 130.87 202.832 131.044 202.813 131.218L202.768 131.629L202.679 132.433L202.628 132.84L202.565 133.319C202.542 133.493 202.519 133.668 202.493 133.841C202.467 134.036 202.438 134.23 202.409 134.424L202.34 134.883L202.258 135.403C202.23 135.576 202.2 135.748 202.168 135.92C202.135 136.093 202.109 136.265 202.079 136.437C202.019 136.781 201.956 137.125 201.89 137.468C201.789 137.981 201.686 138.493 201.58 139.005L201.47 139.512C201.434 139.681 201.395 139.851 201.357 140.02C199.224 137.947 196.399 136.818 193.284 136.818C190.457 136.818 187.55 137.753 184.641 139.598C182.711 140.824 180.578 142.996 178.381 145.726C176.346 142.904 173.498 141.029 170.242 140.516C169.621 140.418 168.993 140.368 168.364 140.368C160.925 140.368 156.45 146.821 154.757 152.626C153.917 154.587 149.887 163.519 143.825 169.577C134.596 178.775 132.268 188.254 136.766 198.407ZM215.007 177.998L214.977 178.087C214.901 178.288 214.813 178.484 214.714 178.674C214.639 178.814 214.558 178.95 214.47 179.082C214.303 179.331 214.12 179.569 213.921 179.793C213.875 179.845 213.831 179.897 213.779 179.948C213.707 180.025 213.634 180.101 213.559 180.175C212.213 181.509 210.161 182.679 207.841 183.752C207.578 183.871 207.311 183.99 207.042 184.11L206.774 184.229C206.595 184.308 206.416 184.386 206.228 184.463C206.049 184.541 205.863 184.619 205.677 184.695L205.119 184.925C203.814 185.462 202.477 185.974 201.173 186.479L200.615 186.696L200.064 186.912C199.697 187.055 199.335 187.198 198.979 187.341L198.448 187.555L197.926 187.768L197.67 187.876C197.499 187.947 197.332 188.018 197.165 188.089C193.328 189.736 190.567 191.411 191.147 193.489C191.163 193.548 191.181 193.604 191.201 193.659C191.253 193.813 191.324 193.958 191.413 194.095C191.465 194.176 191.525 194.253 191.592 194.323C192.274 195.032 193.515 194.92 195.08 194.357C195.3 194.276 195.519 194.192 195.736 194.104L195.872 194.048C196.23 193.896 196.609 193.726 196.996 193.542C197.093 193.496 197.191 193.452 197.289 193.401C199.203 192.465 201.372 191.205 203.524 190.058C204.385 189.593 205.258 189.152 206.142 188.733C208.18 187.774 210.096 187.094 211.636 187.094C212.359 187.094 212.997 187.242 213.529 187.582L213.618 187.641C213.952 187.876 214.232 188.178 214.441 188.528C214.482 188.595 214.522 188.666 214.561 188.739C215.322 190.184 214.685 191.68 213.194 193.147C211.763 194.556 209.537 195.937 207.007 197.215C206.819 197.31 206.631 197.405 206.44 197.498C198.91 201.196 189.049 203.981 188.912 204.016C186.284 204.697 182.526 205.591 178.292 206.26L177.666 206.358L177.563 206.373C177.089 206.445 176.614 206.512 176.138 206.574C175.655 206.639 175.167 206.698 174.676 206.753L174.586 206.763C172.806 206.968 171.019 207.104 169.228 207.169H169.202C168.554 207.192 167.907 207.204 167.259 207.204H166.512C165.524 207.191 164.538 207.146 163.553 207.07C163.53 207.07 163.505 207.07 163.482 207.064C163.129 207.037 162.777 207.004 162.425 206.965C162.06 206.926 161.696 206.882 161.333 206.833C161.094 206.801 160.856 206.765 160.618 206.726C160.376 206.687 160.134 206.647 159.893 206.605L159.564 206.543L159.539 206.538C159.192 206.472 158.847 206.399 158.503 206.319C158.303 206.274 158.104 206.23 157.907 206.176L157.788 206.146C157.69 206.122 157.595 206.096 157.498 206.07L157.445 206.056L157.137 205.966C157.025 205.935 156.913 205.901 156.801 205.868L156.762 205.857L156.471 205.768C156.361 205.734 156.251 205.698 156.142 205.662L155.874 205.573L155.677 205.504C155.487 205.437 155.298 205.368 155.111 205.296L154.933 205.226L154.786 205.168C154.502 205.054 154.22 204.935 153.941 204.81L153.756 204.72L153.725 204.706C153.659 204.675 153.594 204.644 153.528 204.617C153.399 204.555 153.271 204.491 153.144 204.426L153.105 204.407L152.921 204.31C152.594 204.139 152.274 203.957 151.96 203.764L151.788 203.658C151.702 203.605 151.616 203.55 151.532 203.494L151.308 203.346L151.067 203.18L150.923 203.077C150.771 202.969 150.622 202.857 150.476 202.742L150.243 202.563C150.15 202.488 150.058 202.412 149.967 202.335C149.89 202.272 149.815 202.206 149.74 202.14L149.734 202.135C149.653 202.064 149.574 201.993 149.495 201.92C149.417 201.849 149.339 201.777 149.263 201.704L149.254 201.695C149.174 201.619 149.096 201.542 149.019 201.463C148.942 201.385 148.863 201.307 148.788 201.227C148.713 201.148 148.636 201.067 148.562 200.984C148.488 200.902 148.42 200.827 148.35 200.746L148.327 200.719C148.259 200.641 148.192 200.562 148.126 200.481C147.983 200.31 147.844 200.135 147.71 199.956C147.575 199.776 147.443 199.592 147.314 199.405L147.191 199.221C147.027 198.981 146.867 198.739 146.712 198.493C146.596 198.316 146.483 198.138 146.373 197.957C146.302 197.844 146.234 197.73 146.166 197.618L146.138 197.572C146.073 197.462 146.009 197.354 145.947 197.245C145.911 197.186 145.877 197.127 145.845 197.066C145.812 197.004 145.774 196.941 145.739 196.878L145.682 196.779L145.647 196.715C145.58 196.595 145.514 196.474 145.45 196.352C145.42 196.298 145.391 196.244 145.36 196.192L145.271 196.019L145.181 195.848C144.956 195.398 144.743 194.942 144.543 194.48L144.472 194.311C144.426 194.198 144.383 194.086 144.337 193.975C144.315 193.921 144.293 193.868 144.274 193.814C144.167 193.537 144.067 193.257 143.975 192.975C143.942 192.874 143.91 192.775 143.88 192.675C143.808 192.448 143.743 192.219 143.685 191.988C143.614 191.719 143.551 191.448 143.498 191.175C143.487 191.12 143.476 191.065 143.467 191.012C143.415 190.745 143.373 190.476 143.34 190.206C143.332 190.153 143.326 190.1 143.32 190.047L143.303 189.885C143.281 189.673 143.264 189.46 143.254 189.247C143.254 189.193 143.249 189.139 143.247 189.087C143.242 188.981 143.24 188.875 143.239 188.769C143.183 184.496 145.345 180.388 149.968 175.767C158.203 167.54 162.997 155.501 162.997 155.501C162.997 155.501 163.126 154.996 163.394 154.269C163.431 154.168 163.47 154.064 163.514 153.955C163.67 153.548 163.846 153.148 164.041 152.758L164.08 152.683C164.246 152.351 164.428 152.027 164.624 151.712C164.67 151.639 164.714 151.567 164.765 151.494C164.912 151.277 165.067 151.065 165.23 150.86C165.319 150.749 165.416 150.639 165.513 150.532C165.552 150.49 165.59 150.448 165.631 150.408C166.108 149.915 166.653 149.513 167.27 149.299L167.348 149.273C167.4 149.256 167.452 149.24 167.505 149.225C167.566 149.209 167.627 149.195 167.69 149.182L167.719 149.176C167.849 149.15 167.981 149.133 168.114 149.124H168.125C168.194 149.124 168.264 149.117 168.335 149.117C168.424 149.117 168.507 149.117 168.594 149.126C168.684 149.134 168.773 149.144 168.863 149.158C169.605 149.276 170.311 149.718 170.919 150.4C171.15 150.66 171.358 150.94 171.54 151.236C171.66 151.428 171.773 151.631 171.88 151.845C171.923 151.934 171.964 152.016 172.004 152.104C172.108 152.33 172.202 152.56 172.284 152.795C172.479 153.345 172.626 153.911 172.723 154.487C172.807 154.992 172.857 155.502 172.873 156.013C172.881 156.286 172.881 156.563 172.873 156.842C172.819 158.14 172.553 159.421 172.086 160.634C172.044 160.745 171.997 160.857 171.952 160.969C171.86 161.195 171.759 161.417 171.65 161.634C171.569 161.799 171.484 161.965 171.392 162.13C171.332 162.24 171.269 162.35 171.206 162.46C171.045 162.734 170.871 163.006 170.684 163.277L170.571 163.439C170.129 164.055 169.637 164.633 169.099 165.167C168.569 165.698 168.001 166.189 167.4 166.637C166.798 167.083 166.233 167.577 165.711 168.114C164.208 169.691 163.858 171.083 164.196 172.138C164.25 172.304 164.321 172.465 164.407 172.617C164.508 172.791 164.628 172.951 164.764 173.097L164.817 173.152L164.871 173.206C164.925 173.258 164.982 173.309 165.043 173.359L165.103 173.407C165.248 173.519 165.402 173.619 165.563 173.707C165.61 173.732 165.652 173.757 165.705 173.781C165.879 173.866 166.058 173.939 166.242 173.998C166.293 174.015 166.344 174.03 166.396 174.046L166.461 174.063L166.551 174.087L166.628 174.106L166.712 174.124L166.795 174.141L166.874 174.154C166.932 174.164 166.992 174.174 167.052 174.181L167.109 174.19L167.213 174.2L167.277 174.207L167.382 174.214H167.444L167.554 174.22H167.9L167.999 174.214L168.113 174.207L168.252 174.194L168.382 174.179C168.412 174.179 168.442 174.171 168.472 174.165C168.872 174.107 169.264 174.001 169.639 173.849L169.798 173.782C169.887 173.743 169.977 173.702 170.059 173.658C170.235 173.57 170.406 173.47 170.57 173.361C170.799 173.211 171.015 173.043 171.217 172.858C171.265 172.815 171.312 172.769 171.358 172.725C171.381 172.703 171.403 172.682 171.425 172.658C171.469 172.613 171.514 172.569 171.558 172.52C171.878 172.168 172.155 171.78 172.383 171.363C174.34 167.804 176.391 164.298 178.534 160.849L178.828 160.378L179.125 159.907C179.273 159.668 179.423 159.433 179.572 159.199L179.722 158.965C180.22 158.185 180.726 157.41 181.241 156.641L181.546 156.185C182.158 155.278 182.768 154.396 183.373 153.558L183.674 153.143C184.332 152.236 185.017 151.348 185.728 150.482L186.01 150.144C186.057 150.088 186.1 150.032 186.151 149.978C186.244 149.868 186.337 149.761 186.428 149.657C186.474 149.604 186.517 149.552 186.566 149.5L186.834 149.198L186.968 149.051C187.103 148.906 187.235 148.767 187.365 148.634C187.455 148.544 187.538 148.455 187.624 148.371C188.131 147.853 188.69 147.388 189.293 146.985L189.433 146.895C189.567 146.805 189.706 146.721 189.848 146.645C192.212 145.303 194.169 145.204 195.296 146.331C195.978 147.013 196.356 148.144 196.335 149.718C196.335 149.787 196.335 149.857 196.33 149.929V150.006C196.33 150.078 196.324 150.15 196.318 150.223C196.318 150.313 196.308 150.402 196.299 150.492C196.29 150.581 196.285 150.649 196.276 150.729C196.276 150.751 196.272 150.774 196.268 150.798C196.262 150.867 196.253 150.938 196.243 151.009C196.243 151.03 196.243 151.052 196.235 151.074C196.224 151.169 196.21 151.263 196.194 151.357C196.183 151.447 196.168 151.531 196.152 151.619L196.126 151.768C196.1 151.91 196.067 152.05 196.026 152.188C195.948 152.447 195.854 152.7 195.743 152.946C195.588 153.284 195.417 153.613 195.229 153.933C195.125 154.111 195.018 154.286 194.907 154.459C194.793 154.638 194.673 154.819 194.549 155.002C194.233 155.454 193.905 155.897 193.564 156.33L193.408 156.527C192.852 157.22 192.278 157.899 191.686 158.562L191.499 158.772C191.247 159.053 190.991 159.336 190.729 159.62L190.532 159.834C190.401 159.977 190.264 160.12 190.132 160.264C190.001 160.407 189.864 160.552 189.726 160.697L189.315 161.13L188.898 161.566L188.478 162.002C188.196 162.294 187.913 162.586 187.628 162.878C183.573 167.037 179.301 171.182 177.855 173.766C177.758 173.934 177.671 174.108 177.593 174.285C177.387 174.755 177.301 175.157 177.36 175.482C177.379 175.589 177.416 175.691 177.471 175.785C177.552 175.926 177.651 176.056 177.766 176.172C177.819 176.224 177.875 176.272 177.934 176.316C178.232 176.528 178.591 176.637 178.957 176.627H179.071L179.188 176.618L179.305 176.605L179.402 176.591C179.415 176.589 179.429 176.587 179.442 176.583L179.531 176.566L179.554 176.561L179.653 176.54L179.688 176.531C179.723 176.522 179.757 176.513 179.792 176.503C179.827 176.493 179.875 176.48 179.917 176.466C180.093 176.413 180.265 176.35 180.434 176.278C180.523 176.242 180.61 176.203 180.696 176.161C180.741 176.141 180.786 176.12 180.828 176.098L180.962 176.032C181.282 175.866 181.594 175.685 181.898 175.491L182.031 175.401C182.076 175.373 182.121 175.344 182.164 175.312L182.297 175.223L182.368 175.174L182.56 175.039C182.739 174.916 182.906 174.789 183.075 174.66L183.09 174.648L183.359 174.44C183.726 174.15 184.074 173.858 184.39 173.583L184.6 173.399L184.619 173.381L184.729 173.284C184.987 173.052 185.217 172.836 185.408 172.658L185.487 172.581C185.556 172.516 185.619 172.455 185.676 172.403L185.788 172.292L185.828 172.253L185.839 172.242L185.956 172.125L186.03 172.048L186.039 172.041L186.074 172.009L186.118 171.969L186.132 171.956L186.169 171.922L186.373 171.743L186.487 171.641C186.548 171.588 186.607 171.534 186.666 171.479L186.802 171.358C186.827 171.338 186.851 171.316 186.876 171.294L187.019 171.169L187.229 170.984L187.341 170.887C187.776 170.509 188.305 170.052 188.913 169.537L189.162 169.326L189.573 168.981L189.994 168.63C190.544 168.173 191.136 167.688 191.762 167.185L192.173 166.855C192.523 166.576 192.882 166.292 193.246 166.006C193.393 165.891 193.542 165.776 193.694 165.662C194.066 165.373 194.44 165.086 194.817 164.803C195.675 164.155 196.56 163.506 197.456 162.874L197.84 162.606C198.109 162.421 198.377 162.235 198.645 162.054L198.888 161.89C199.367 161.565 199.853 161.248 200.343 160.939L200.586 160.786L200.827 160.636C201.069 160.486 201.309 160.339 201.548 160.196L201.787 160.053L202.265 159.775L202.734 159.506L202.829 159.454L203.2 159.25C203.355 159.166 203.509 159.085 203.663 159.006L203.892 158.888L204.115 158.776C204.193 158.739 204.27 158.7 204.346 158.663C204.848 158.415 205.36 158.187 205.88 157.979C206.021 157.919 206.161 157.865 206.3 157.818L206.71 157.674C206.833 157.633 206.953 157.594 207.068 157.559L207.108 157.547C207.17 157.527 207.232 157.509 207.293 157.493L207.311 157.488C207.439 157.451 207.566 157.419 207.691 157.389H207.7C208.054 157.304 208.414 157.243 208.777 157.206C208.944 157.189 209.111 157.18 209.279 157.181H209.363C209.475 157.181 209.583 157.188 209.69 157.199C209.739 157.199 209.788 157.209 209.836 157.215H209.856C209.904 157.221 209.952 157.228 210 157.239C210.047 157.248 210.095 157.256 210.141 157.267H210.156C210.203 157.277 210.245 157.289 210.294 157.303C210.548 157.374 210.79 157.484 211.012 157.628C211.121 157.699 211.223 157.779 211.317 157.868L211.344 157.894C211.362 157.91 211.379 157.927 211.395 157.944L211.444 157.997C211.846 158.418 212.178 158.901 212.428 159.427L212.466 159.517C212.551 159.717 212.618 159.924 212.666 160.135C212.808 160.781 212.753 161.455 212.508 162.07C212.415 162.318 212.302 162.557 212.169 162.785C211.858 163.309 211.489 163.796 211.07 164.237L210.981 164.332C210.848 164.472 210.71 164.612 210.565 164.752C210.501 164.815 210.434 164.877 210.367 164.94L210.162 165.129L210.055 165.224C209.797 165.454 209.532 165.677 209.263 165.893C209.1 166.025 208.936 166.154 208.77 166.281C208.184 166.729 207.587 167.161 206.979 167.578C206.612 167.83 206.242 168.077 205.869 168.321C204.95 168.924 204.021 169.512 203.083 170.084C201.115 171.294 198.934 172.588 196.609 173.995L196.007 174.36C195.348 174.762 194.726 175.146 194.14 175.512L193.845 175.697L193.287 176.055C192.917 176.292 192.548 176.531 192.179 176.77L191.882 176.966C191.737 177.06 191.593 177.156 191.449 177.252L191.308 177.342L190.876 177.633L190.647 177.79L190.379 177.976L190.13 178.149C189.713 178.444 189.325 178.725 188.968 178.992L188.834 179.094C188.624 179.253 188.416 179.415 188.211 179.58C187.902 179.829 187.62 180.067 187.367 180.296L187.243 180.409C187.172 180.474 187.102 180.539 187.035 180.603C186.989 180.648 186.946 180.693 186.898 180.736L186.834 180.8C186.691 180.944 186.551 181.091 186.416 181.242L186.35 181.318C186.203 181.488 186.075 181.651 185.963 181.81L185.913 181.881C185.825 182.009 185.744 182.141 185.671 182.277C185.652 182.311 185.635 182.345 185.618 182.379L185.569 182.481L185.536 182.555L185.515 182.605L185.498 182.65L185.475 182.711C185.413 182.88 185.37 183.056 185.345 183.234L185.337 183.296L185.331 183.354V183.669C185.331 183.695 185.331 183.721 185.338 183.749L185.343 183.797C185.343 183.823 185.349 183.848 185.353 183.876C185.357 183.902 185.364 183.949 185.372 183.986V183.991C185.379 184.026 185.386 184.06 185.395 184.095C185.404 184.13 185.413 184.17 185.424 184.206C185.443 184.277 185.467 184.347 185.492 184.417C185.508 184.459 185.523 184.5 185.54 184.541C185.54 184.549 185.546 184.558 185.55 184.566L185.586 184.647L185.636 184.758C185.69 184.873 185.749 184.985 185.813 185.094L185.879 185.208L185.947 185.322C185.959 185.341 185.973 185.359 185.988 185.376L186.01 185.399L186.035 185.422L186.061 185.442C186.099 185.469 186.14 185.49 186.183 185.505C186.206 185.513 186.23 185.519 186.254 185.525C186.831 185.655 188.017 185.178 189.593 184.346C189.682 184.298 189.78 184.248 189.875 184.196L190.355 183.934L190.589 183.804C190.756 183.715 190.926 183.614 191.1 183.515L191.417 183.336C193.5 182.137 195.988 180.597 198.56 179.093C198.801 178.952 199.043 178.811 199.285 178.672L199.771 178.361C200.335 178.038 200.902 177.719 201.471 177.404C202.188 177.01 202.91 176.626 203.639 176.254L204.115 176.013C204.431 175.857 204.744 175.705 205.053 175.557C205.651 175.273 206.256 175.003 206.868 174.748L207.203 174.612L207.243 174.596C209.018 173.893 210.627 173.459 211.929 173.459C212.21 173.456 212.492 173.48 212.769 173.528H212.778C212.867 173.544 212.948 173.562 213.031 173.582H213.046C213.259 173.636 213.466 173.713 213.662 173.812C213.937 173.954 214.184 174.143 214.393 174.371C214.489 174.477 214.574 174.592 214.649 174.714C214.789 174.929 214.899 175.162 214.978 175.406C215.01 175.501 215.038 175.594 215.067 175.693C215.278 176.45 215.257 177.253 215.007 177.998Z",fill:"#FF9D00"}),jsxRuntimeExports.jsx("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M203.21 123.685V123.194C203.21 81.34 169.292 47.411 127.435 47.411C85.5791 47.411 51.648 81.342 51.648 123.194V123.358C51.646 123.467 51.645 123.576 51.648 123.685C51.6529 123.848 51.6546 124.011 51.653 124.174L51.6581 124.534L51.661 124.663C51.661 124.723 51.6631 124.782 51.6651 124.842C51.6681 124.937 51.67 125.033 51.67 125.128L51.681 125.517L51.697 125.974L51.702 126.124L51.722 126.597V126.62C51.73 126.805 51.7401 126.989 51.7491 127.173L51.75 127.187C51.76 127.375 51.7701 127.564 51.7821 127.753C51.7921 127.927 51.802 128.101 51.815 128.275L51.8171 128.306C51.8258 128.455 51.8358 128.605 51.847 128.754L51.85 128.794L51.883 129.226L51.8861 129.254C51.8921 129.338 51.898 129.422 51.906 129.503C51.9658 130.224 52.0355 130.945 52.1151 131.664L52.12 131.709L52.181 132.238L52.2491 132.793L52.299 133.17L52.322 133.347C52.3753 133.755 52.433 134.162 52.495 134.568L52.4991 134.595L52.558 134.979C52.8435 136.808 53.1971 138.626 53.618 140.429L53.6231 140.451L53.655 140.586L53.746 140.971L53.802 140.904C56.002 138.274 59.158 136.824 62.689 136.824C65.519 136.824 68.4221 137.76 71.3321 139.605C73.2621 140.831 75.3961 143.002 77.5921 145.733C79.6241 142.911 82.4721 141.035 85.7301 140.523C86.3513 140.425 86.9792 140.376 87.6081 140.375C95.0441 140.375 99.523 146.828 101.215 152.633C102.051 154.594 106.08 163.526 112.156 169.568C121.392 178.795 123.703 188.316 119.132 198.511H119.148C119.459 198.546 119.772 198.578 120.087 198.607C120.274 198.625 120.46 198.643 120.648 198.659L120.714 198.665L121.127 198.7L121.507 198.73C121.869 198.758 122.232 198.784 122.596 198.807L122.885 198.824L123.114 198.838L123.256 198.846L123.703 198.869L123.825 198.874L124.294 198.895L124.816 198.915L125.235 198.927L125.305 198.929C125.394 198.933 125.483 198.936 125.572 198.936L125.668 198.939C126.258 198.953 126.847 198.96 127.437 198.959H128.063L128.51 198.954C128.62 198.949 128.729 198.949 128.84 198.949H129.014L129.165 198.945C129.224 198.943 129.283 198.941 129.343 198.941H129.522L129.873 198.932L130.401 198.914L130.982 198.888C131.15 198.882 131.316 198.873 131.482 198.865L131.661 198.854L131.927 198.84L132.083 198.831L132.201 198.823L132.738 198.788L133.274 198.749L133.761 198.71L134.103 198.681L134.479 198.647C135.107 198.591 135.733 198.525 136.359 198.45L136.786 198.399C132.287 188.247 134.616 178.767 143.813 169.577C149.876 163.519 153.905 154.587 154.745 152.625C156.438 146.821 160.914 140.368 168.352 140.368C168.981 140.368 169.61 140.418 170.231 140.516C173.486 141.028 176.334 142.904 178.369 145.726C180.566 142.996 182.699 140.823 184.63 139.597C187.539 137.753 190.445 136.817 193.272 136.817C196.388 136.817 199.212 137.947 201.345 140.02C201.384 139.851 201.422 139.682 201.459 139.512L201.568 139.006C201.607 138.821 201.646 138.636 201.683 138.451C201.749 138.124 201.815 137.797 201.878 137.467C201.944 137.125 202.007 136.781 202.067 136.437L202.098 136.251C202.117 136.141 202.135 136.031 202.156 135.92C202.19 135.748 202.218 135.576 202.246 135.402L202.257 135.336L202.328 134.883L202.398 134.424V134.42C202.449 134.081 202.497 133.742 202.542 133.403L202.553 133.319L202.616 132.841L202.667 132.433L202.757 131.629L202.792 131.306L202.801 131.218C202.82 131.044 202.838 130.87 202.854 130.696V130.682C202.867 130.544 202.881 130.405 202.893 130.266C202.964 129.478 203.024 128.686 203.072 127.891C203.081 127.761 203.088 127.63 203.096 127.499V127.493L203.122 127.002L203.128 126.892C203.144 126.56 203.158 126.228 203.169 125.896V125.884L203.174 125.754C203.179 125.645 203.183 125.535 203.183 125.425L203.185 125.381C203.189 125.278 203.193 125.172 203.193 125.067L203.196 124.977C203.199 124.872 203.202 124.768 203.202 124.663L203.204 124.574C203.207 124.441 203.21 124.307 203.21 124.174V123.685ZM108.638 199.391C114.64 190.59 114.214 183.984 105.98 175.754C97.7441 167.523 92.951 155.487 92.951 155.487C92.951 155.487 91.1621 148.496 87.0821 149.138C83.0021 149.78 80.0091 160.227 88.5521 166.622C97.0941 173.017 86.8521 177.353 83.5641 171.352C80.2761 165.35 71.299 149.923 66.645 146.972C61.991 144.021 58.718 145.675 59.815 151.757C60.36 154.776 65.4281 159.929 70.1631 164.743C74.9671 169.627 79.428 174.163 78.474 175.768C76.581 178.955 69.9141 172.023 69.9141 172.023C69.9141 172.023 49.038 153.025 44.494 157.976C40.304 162.539 46.765 166.418 56.7211 172.397C57.5671 172.905 58.4391 173.429 59.3321 173.969C70.7231 180.865 71.609 182.684 69.992 185.293C69.395 186.257 65.582 183.968 60.892 181.153C52.897 176.352 42.3551 170.023 40.8661 175.688C39.5781 180.591 47.334 183.595 54.368 186.32C60.228 188.59 65.5881 190.666 64.7991 193.484C63.9821 196.406 59.5531 193.969 54.7121 191.305C49.2771 188.314 43.3221 185.038 41.3731 188.735C37.6901 195.725 66.7831 203.954 67.0231 204.015C76.4231 206.453 100.295 211.619 108.638 199.391ZM147.303 199.391C141.301 190.59 141.727 183.984 149.962 175.754C158.197 167.523 162.99 155.487 162.99 155.487C162.99 155.487 164.779 148.496 168.859 149.138C172.939 149.78 175.932 160.227 167.39 166.622C158.847 173.017 169.089 177.353 172.377 171.352C175.666 165.35 184.637 149.923 189.291 146.972C193.945 144.021 197.22 145.675 196.122 151.757C195.578 154.776 190.509 159.929 185.774 164.744C180.97 169.628 176.509 174.163 177.462 175.768C179.355 178.955 186.027 172.019 186.027 172.019C186.027 172.019 206.902 153.022 211.448 157.973C215.637 162.535 209.176 166.415 199.219 172.394C198.348 172.917 197.478 173.441 196.609 173.966C185.218 180.862 184.332 182.681 185.948 185.289C186.546 186.254 190.359 183.964 195.048 181.149C203.044 176.349 213.586 170.019 215.075 175.685C216.364 180.588 208.607 183.592 201.573 186.317C195.713 188.587 190.353 190.663 191.141 193.481C191.957 196.402 196.385 193.965 201.225 191.301C206.66 188.31 212.616 185.032 214.564 188.732C218.248 195.726 189.15 203.947 188.915 204.007C179.515 206.453 155.643 211.619 147.303 199.391Z",fill:"#FFD21E"}),jsxRuntimeExports.jsx("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M152.047 102.567C153.229 102.985 154.108 104.257 154.944 105.468C156.074 107.104 157.126 108.627 158.74 107.769C160.644 106.756 162.205 105.202 163.225 103.302C164.246 101.402 164.681 99.2427 164.475 97.096C164.321 95.4908 163.813 93.9398 162.987 92.5548C162.161 91.1697 161.038 89.985 159.7 89.0862C158.361 88.1874 156.839 87.5968 155.245 87.3569C153.65 87.117 152.022 87.2339 150.478 87.699C148.934 88.1639 147.513 88.9653 146.316 90.0455C145.119 91.1257 144.176 92.4578 143.556 93.946C142.936 95.4342 142.653 97.0415 142.728 98.652C142.804 100.263 143.235 101.836 143.992 103.26C144.74 104.667 146.4 104.003 148.152 103.302C149.525 102.753 150.956 102.181 152.047 102.567ZM100.672 102.567C99.49 102.985 98.611 104.258 97.775 105.468C96.645 107.105 95.592 108.627 93.979 107.769C91.5845 106.501 89.7482 104.386 88.8278 101.838C87.9075 99.2895 87.9692 96.4896 89.0008 93.9841C90.0324 91.4786 91.9601 89.4471 94.408 88.2855C96.856 87.1239 99.6488 86.9156 102.242 87.701C104.307 88.3228 106.141 89.5427 107.513 91.2065C108.885 92.8704 109.732 94.9035 109.949 97.049C110.165 99.1945 109.74 101.356 108.728 103.26C107.979 104.667 106.319 104.003 104.567 103.303C103.193 102.753 101.764 102.181 100.672 102.567ZM144.099 149.318C152.242 142.903 155.233 132.429 155.233 125.977C155.233 120.877 151.802 122.482 146.309 125.202L145.999 125.355C140.957 127.852 134.245 131.177 126.877 131.177C119.508 131.177 112.796 127.852 107.755 125.354C102.084 122.545 98.527 120.783 98.527 125.978C98.527 132.634 101.709 143.563 110.443 149.912C111.596 147.573 113.219 145.497 115.211 143.813C117.202 142.129 119.52 140.874 122.018 140.126C122.89 139.866 123.788 141.367 124.707 142.904C125.594 144.386 126.501 145.902 127.423 145.902C128.406 145.902 129.371 144.408 130.314 142.95C131.299 141.425 132.26 139.94 133.189 140.237C137.864 141.738 141.775 144.993 144.099 149.318Z",fill:"#32343D"}),jsxRuntimeExports.jsx("path",{d:"M144.097 149.317C139.856 152.659 134.219 154.9 126.878 154.9C119.981 154.9 114.587 152.922 110.443 149.911C111.596 147.572 113.219 145.495 115.211 143.812C117.202 142.128 119.52 140.873 122.018 140.125C123.73 139.614 125.545 145.901 127.423 145.901C129.433 145.901 131.37 139.655 133.189 140.236C137.863 141.738 141.773 144.993 144.097 149.317Z",fill:"#FF323D"}),jsxRuntimeExports.jsx("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M81.2 111.64C80.2312 112.288 79.1173 112.687 77.9572 112.801C76.7971 112.916 75.6267 112.742 74.55 112.295C73.6893 111.94 72.9072 111.418 72.2488 110.759C71.5903 110.101 71.0684 109.319 70.713 108.458C70.267 107.381 70.0935 106.211 70.2082 105.051C70.3228 103.891 70.7219 102.777 71.37 101.808C72.1488 100.642 73.2558 99.7333 74.5512 99.1967C75.8466 98.6601 77.272 98.5197 78.6471 98.7935C80.0223 99.0672 81.2853 99.7427 82.2764 100.734C83.2675 101.726 83.9422 102.99 84.215 104.365C84.4883 105.74 84.3477 107.165 83.8113 108.46C83.2748 109.755 82.3654 110.861 81.2 111.64ZM182.613 111.64C181.644 112.288 180.53 112.687 179.37 112.801C178.209 112.916 177.039 112.742 175.962 112.295C175.101 111.939 174.319 111.418 173.661 110.759C173.003 110.101 172.481 109.319 172.125 108.458C171.68 107.381 171.507 106.211 171.621 105.051C171.736 103.891 172.135 102.777 172.782 101.808C173.364 100.936 174.133 100.205 175.032 99.6658C175.931 99.1269 176.938 98.7942 177.981 98.6917C179.025 98.5891 180.078 98.7193 181.064 99.0728C182.051 99.4264 182.947 99.9944 183.688 100.736C184.68 101.727 185.355 102.99 185.628 104.365C185.902 105.74 185.761 107.165 185.224 108.46C184.687 109.755 183.779 110.861 182.613 111.64Z",fill:"#FFAD03"})]});function WelcomeScreen({onStart:n}){return jsxRuntimeExports.jsx("div",{className:"absolute inset-0 text-white flex items-center justify-center p-8",children:jsxRuntimeExports.jsxs("div",{className:"max-w-2xl w-full space-y-8",children:[jsxRuntimeExports.jsx(GlassContainer,{className:"rounded-3xl shadow-2xl hover:scale-105 transition-transform duration-200",role:"banner",children:jsxRuntimeExports.jsxs("div",{className:"p-8 text-center",children:[jsxRuntimeExports.jsx("h1",{className:"text-5xl font-bold text-gray-100 mb-4",children:"FastVLM WebGPU"}),jsxRuntimeExports.jsxs("p",{className:"text-xl text-gray-300 leading-relaxed",children:["Real-time video captioning powered by"," ",jsxRuntimeExports.jsx("a",{href:"https://huggingface.co/onnx-community/FastVLM-0.5B-ONNX",className:"text-blue-400 underline hover:text-blue-300 transition-colors",target:"_blank",rel:"noopener noreferrer","aria-label":"FastVLM-0.5B model on Hugging Face",children:"FastVLM-0.5B"})]})]})}),jsxRuntimeExports.jsx(GlassContainer,{bgColor:GLASS_EFFECTS.COLORS.SUCCESS_BG,className:"rounded-2xl shadow-2xl hover:scale-105 transition-transform duration-200",role:"status","aria-label":"Camera status",children:jsxRuntimeExports.jsx("div",{className:"p-4",children:jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-center space-x-2",children:[jsxRuntimeExports.jsx("div",{className:"w-3 h-3 rounded-full bg-green-500 animate-pulse"}),jsxRuntimeExports.jsx("p",{className:"text-green-400 font-medium",children:"Camera ready"})]})})}),jsxRuntimeExports.jsx(GlassContainer,{className:"rounded-2xl shadow-2xl hover:scale-105 transition-transform duration-200",role:"region","aria-labelledby":"how-it-works-title",children:jsxRuntimeExports.jsxs("div",{className:"p-6",children:[jsxRuntimeExports.jsx("h2",{id:"how-it-works-title",className:"text-lg font-semibold text-gray-200 mb-4 text-center",children:"How it works:"}),jsxRuntimeExports.jsxs("div",{className:"space-y-3",children:[jsxRuntimeExports.jsxs("div",{className:"flex items-start space-x-3",children:[jsxRuntimeExports.jsx("div",{className:"w-6 h-6 rounded-full bg-blue-600 flex items-center justify-center text-sm font-bold mt-0.5 flex-shrink-0",children:"1"}),jsxRuntimeExports.jsxs("p",{className:"text-gray-300",children:["You are about to load"," ",jsxRuntimeExports.jsx("a",{href:"https://huggingface.co/onnx-community/FastVLM-0.5B-ONNX",className:"text-blue-400 underline",target:"_blank",rel:"noopener noreferrer",children:"FastVLM-0.5B"}),", a powerful multimodal model optimized for in-browser inference."]})]}),jsxRuntimeExports.jsxs("div",{className:"flex items-start space-x-3",children:[jsxRuntimeExports.jsx("div",{className:"w-6 h-6 rounded-full bg-blue-600 flex items-center justify-center text-sm font-bold mt-0.5 flex-shrink-0",children:"2"}),jsxRuntimeExports.jsxs("p",{className:"text-gray-300",children:["Everything runs entirely in your browser with"," ",jsxRuntimeExports.jsxs("a",{href:"https://github.com/huggingface/transformers.js",className:"text-blue-400 underline",target:"_blank",rel:"noopener noreferrer",children:[jsxRuntimeExports.jsx(HfIcon,{className:"inline-flex w-7 h-7 pointer-events-none"}),"Transformers.js"]})," ","and ONNX Runtime Web, meaning no data is sent to a server. It can even run offline!"]})]}),jsxRuntimeExports.jsxs("div",{className:"flex items-start space-x-3",children:[jsxRuntimeExports.jsx("div",{className:"w-6 h-6 rounded-full bg-blue-600 flex items-center justify-center text-sm font-bold mt-0.5 flex-shrink-0",children:"3"}),jsxRuntimeExports.jsx("p",{className:"text-gray-300",children:"Get started by clicking the button below."})]})]})]})}),jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center space-y-4",children:[jsxRuntimeExports.jsx(GlassButton,{onClick:n,className:"px-8 py-4 rounded-2xl","aria-label":"Start live captioning with AI model",children:jsxRuntimeExports.jsx("span",{className:"font-semibold text-lg",children:"Start Live Captioning"})}),jsxRuntimeExports.jsx("p",{className:"text-sm text-gray-400 opacity-80",children:"AI model will load when you click start"})]})]})})}const ERROR_TYPES={HTTPS:"https",NOT_SUPPORTED:"not-supported",PERMISSION:"permission",GENERAL:"general"},VIDEO_CONSTRAINTS={video:{width:{ideal:1920,max:1920},height:{ideal:1080,max:1080},facingMode:"user"}};function WebcamPermissionDialog({onPermissionGranted:n}){const[e,t]=reactExports.useState(!1),[s,a]=reactExports.useState(null),c=g=>{if(!navigator.mediaDevices)return{type:ERROR_TYPES.HTTPS,message:"Camera access requires a secure connection (HTTPS)"};if(!navigator.mediaDevices.getUserMedia)return{type:ERROR_TYPES.NOT_SUPPORTED,message:"Camera access not supported in this browser"};if(g instanceof DOMException)switch(g.name){case"NotAllowedError":return{type:ERROR_TYPES.PERMISSION,message:"Camera access denied"};case"NotFoundError":return{type:ERROR_TYPES.GENERAL,message:"No camera found"};case"NotReadableError":return{type:ERROR_TYPES.GENERAL,message:"Camera is in use by another application"};case"OverconstrainedError":return{type:ERROR_TYPES.GENERAL,message:"Camera doesn't meet requirements"};case"SecurityError":return{type:ERROR_TYPES.HTTPS,message:"Security error accessing camera"};default:return{type:ERROR_TYPES.GENERAL,message:`Camera error: ${g.name}`}}return{type:ERROR_TYPES.GENERAL,message:"Failed to access camera"}},l=reactExports.useCallback(async()=>{t(!0),a(null);try{if(!navigator.mediaDevices?.getUserMedia)throw new Error("NOT_SUPPORTED");const g=await navigator.mediaDevices.getUserMedia(VIDEO_CONSTRAINTS);n(g)}catch(g){const w=c(g);a(w),console.error("Error accessing webcam:",g,w)}finally{t(!1)}},[n]);reactExports.useEffect(()=>{l()},[l]);const _=reactExports.useMemo(()=>({[ERROR_TYPES.HTTPS]:{title:"🔒 HTTPS Required",items:["Access this app via https:// instead of http://","If developing locally, use localhost (exempt from HTTPS requirement)","Deploy to a hosting service that provides HTTPS (Vercel, Netlify, GitHub Pages)"]},[ERROR_TYPES.NOT_SUPPORTED]:{title:"🌐 Browser Compatibility",items:["Update your browser to the latest version","Use Chrome 120+, Edge 120+, Firefox Nightly, or Safari 26 beta+","Enable JavaScript if disabled"]},[ERROR_TYPES.PERMISSION]:{title:"🚫 Permission Issues",items:["Click the camera icon in your browser's address bar",'Select "Always allow" for camera access',"Check browser settings → Privacy & Security → Camera","Clear browser data and try again"]},[ERROR_TYPES.GENERAL]:{title:"General Troubleshooting",items:["Check if camera permissions are blocked in your browser","Try refreshing the page and allowing access","Ensure no other apps are using your camera","Try using a different browser or device"]}}),[]),m=g=>({container:`border rounded-lg p-4 ${g?"bg-orange-900/20 border-orange-500/30":"bg-red-900/20 border-red-500/30"}`,text:`text-sm ${g?"text-orange-400":"text-red-400"}`,troubleshooting:{bg:`border rounded-lg p-3 ${g?"bg-orange-900/20 border-orange-500/30":"bg-red-900/20 border-red-500/30"}`,title:`text-xs font-semibold mb-2 ${g?"text-orange-400":"text-red-400"}`,list:`text-xs space-y-1 ${g?"text-orange-300":"text-red-300"}`}}),d=()=>{if(e)return jsxRuntimeExports.jsx("div",{className:"animate-spin rounded-full h-16 w-16 border-4 border-blue-500 border-t-transparent",role:"progressbar","aria-label":"Requesting camera access"});const g="w-8 h-8",w=`w-16 h-16 rounded-full flex items-center justify-center ${s?"bg-red-500/20":"bg-blue-500/20"}`;return jsxRuntimeExports.jsx("div",{className:w,"aria-hidden":"true",children:s?jsxRuntimeExports.jsx("svg",{className:`${g} text-red-400`,fill:"currentColor",viewBox:"0 0 20 20",children:jsxRuntimeExports.jsx("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",clipRule:"evenodd"})}):jsxRuntimeExports.jsx("svg",{className:`${g} text-blue-400`,fill:"currentColor",viewBox:"0 0 20 20",children:jsxRuntimeExports.jsx("path",{fillRule:"evenodd",d:"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z",clipRule:"evenodd"})})})},h=()=>{if(!s)return null;const g=_[s.type],w=s.type===ERROR_TYPES.HTTPS,y=m(w);return jsxRuntimeExports.jsxs("div",{className:y.troubleshooting.bg,children:[jsxRuntimeExports.jsx("h4",{className:y.troubleshooting.title,children:g.title}),jsxRuntimeExports.jsx("ul",{className:y.troubleshooting.list,children:g.items.map((x,S)=>jsxRuntimeExports.jsxs("li",{children:["• ",x]},S))})]})},i=()=>e?"Requesting Camera Access":s?"Camera Access Required":"Camera Permission Required",r=()=>e?"Please allow camera access in your browser to continue...":s?s.message:"This app requires camera access for live video captioning. Please grant permission to continue.",u=s?.type===ERROR_TYPES.HTTPS,f=s?m(u):null;return jsxRuntimeExports.jsx("div",{className:"absolute inset-0 text-white flex items-center justify-center p-8",role:"dialog","aria-labelledby":"webcam-dialog-title","aria-describedby":"webcam-dialog-description",children:jsxRuntimeExports.jsxs("div",{className:"max-w-md w-full space-y-6",children:[jsxRuntimeExports.jsx(GlassContainer,{className:"rounded-3xl shadow-2xl",bgColor:s?GLASS_EFFECTS.COLORS.ERROR_BG:GLASS_EFFECTS.COLORS.DEFAULT_BG,children:jsxRuntimeExports.jsxs("div",{className:"p-8 text-center space-y-6",children:[jsxRuntimeExports.jsxs("div",{className:"space-y-4",children:[jsxRuntimeExports.jsx("div",{className:"w-16 h-16 mx-auto",children:d()}),jsxRuntimeExports.jsx("h2",{id:"webcam-dialog-title",className:"text-2xl font-bold text-gray-100",children:i()}),jsxRuntimeExports.jsx("p",{id:"webcam-dialog-description",className:"text-gray-400",children:r()})]}),s&&f&&jsxRuntimeExports.jsxs("div",{className:"space-y-4",children:[jsxRuntimeExports.jsx("div",{className:f.container,children:jsxRuntimeExports.jsx("p",{className:f.text,children:u?"This app requires HTTPS to access your camera. Live video captioning cannot work without camera input.":"Camera access is required for this app to function. Live video captioning cannot work without camera input."})}),jsxRuntimeExports.jsx(GlassButton,{onClick:l,disabled:e,className:"px-6 py-3","aria-label":"Try again to request camera access",children:"Try Again"})]}),e&&jsxRuntimeExports.jsx("p",{className:"text-sm text-gray-500",children:"If you don't see a permission dialog, check your browser settings or try refreshing the page."})]})}),s&&jsxRuntimeExports.jsx(GlassContainer,{className:"rounded-2xl shadow-2xl",children:jsxRuntimeExports.jsxs("div",{className:"p-4 text-left",children:[jsxRuntimeExports.jsx("h3",{className:"text-sm font-semibold text-gray-300 mb-3",children:"Troubleshooting:"}),jsxRuntimeExports.jsx("div",{className:"space-y-3",children:h()}),jsxRuntimeExports.jsxs("div",{className:"mt-3 pt-3 border-t border-gray-700/30",children:[jsxRuntimeExports.jsxs("p",{className:"text-xs text-gray-500",children:["Current URL:"," ",jsxRuntimeExports.jsxs("code",{className:"bg-gray-800/50 px-1 rounded text-gray-400",children:[window.location.protocol,"//",window.location.host]})]}),u&&!window.location.protocol.startsWith("https")&&jsxRuntimeExports.jsx("p",{className:"text-xs text-orange-400 mt-1",children:"⚠️ Non-secure connection detected"})]})]})})]})})}const instanceOfAny=(n,e)=>e.some(t=>n instanceof t);let idbProxyableTypes,cursorAdvanceMethods;function getIdbProxyableTypes(){return idbProxyableTypes||(idbProxyableTypes=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function getCursorAdvanceMethods(){return cursorAdvanceMethods||(cursorAdvanceMethods=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const transactionDoneMap=new WeakMap,transformCache=new WeakMap,reverseTransformCache=new WeakMap;function promisifyRequest(n){const e=new Promise((t,s)=>{const a=()=>{n.removeEventListener("success",c),n.removeEventListener("error",l)},c=()=>{t(wrap(n.result)),a()},l=()=>{s(n.error),a()};n.addEventListener("success",c),n.addEventListener("error",l)});return reverseTransformCache.set(e,n),e}function cacheDonePromiseForTransaction(n){if(transactionDoneMap.has(n))return;const e=new Promise((t,s)=>{const a=()=>{n.removeEventListener("complete",c),n.removeEventListener("error",l),n.removeEventListener("abort",l)},c=()=>{t(),a()},l=()=>{s(n.error||new DOMException("AbortError","AbortError")),a()};n.addEventListener("complete",c),n.addEventListener("error",l),n.addEventListener("abort",l)});transactionDoneMap.set(n,e)}let idbProxyTraps={get(n,e,t){if(n instanceof IDBTransaction){if(e==="done")return transactionDoneMap.get(n);if(e==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return wrap(n[e])},set(n,e,t){return n[e]=t,!0},has(n,e){return n instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in n}};function replaceTraps(n){idbProxyTraps=n(idbProxyTraps)}function wrapFunction(n){return getCursorAdvanceMethods().includes(n)?function(...e){return n.apply(unwrap(this),e),wrap(this.request)}:function(...e){return wrap(n.apply(unwrap(this),e))}}function transformCachableValue(n){return typeof n=="function"?wrapFunction(n):(n instanceof IDBTransaction&&cacheDonePromiseForTransaction(n),instanceOfAny(n,getIdbProxyableTypes())?new Proxy(n,idbProxyTraps):n)}function wrap(n){if(n instanceof IDBRequest)return promisifyRequest(n);if(transformCache.has(n))return transformCache.get(n);const e=transformCachableValue(n);return e!==n&&(transformCache.set(n,e),reverseTransformCache.set(e,n)),e}const unwrap=n=>reverseTransformCache.get(n);function openDB(n,e,{blocked:t,upgrade:s,blocking:a,terminated:c}={}){const l=indexedDB.open(n,e),_=wrap(l);return s&&l.addEventListener("upgradeneeded",m=>{s(wrap(l.result),m.oldVersion,m.newVersion,wrap(l.transaction),m)}),t&&l.addEventListener("blocked",m=>t(m.oldVersion,m.newVersion,m)),_.then(m=>{c&&m.addEventListener("close",()=>c()),a&&m.addEventListener("versionchange",d=>a(d.oldVersion,d.newVersion,d))}).catch(()=>{}),_}const readMethods=["get","getKey","getAll","getAllKeys","count"],writeMethods=["put","add","delete","clear"],cachedMethods=new Map;function getMethod(n,e){if(!(n instanceof IDBDatabase&&!(e in n)&&typeof e=="string"))return;if(cachedMethods.get(e))return cachedMethods.get(e);const t=e.replace(/FromIndex$/,""),s=e!==t,a=writeMethods.includes(t);if(!(t in(s?IDBIndex:IDBObjectStore).prototype)||!(a||readMethods.includes(t)))return;const c=async function(l,..._){const m=this.transaction(l,a?"readwrite":"readonly");let d=m.store;return s&&(d=d.index(_.shift())),(await Promise.all([d[t](..._),a&&m.done]))[0]};return cachedMethods.set(e,c),c}replaceTraps(n=>({...n,get:(e,t,s)=>getMethod(e,t)||n.get(e,t,s),has:(e,t)=>!!getMethod(e,t)||n.has(e,t)}));const advanceMethodProps=["continue","continuePrimaryKey","advance"],methodMap={},advanceResults=new WeakMap,ittrProxiedCursorToOriginalProxy=new WeakMap,cursorIteratorTraps={get(n,e){if(!advanceMethodProps.includes(e))return n[e];let t=methodMap[e];return t||(t=methodMap[e]=function(...s){advanceResults.set(this,ittrProxiedCursorToOriginalProxy.get(this)[e](...s))}),t}};async function*iterate(...n){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...n)),!e)return;e=e;const t=new Proxy(e,cursorIteratorTraps);for(ittrProxiedCursorToOriginalProxy.set(t,e),reverseTransformCache.set(t,unwrap(e));e;)yield t,e=await(advanceResults.get(t)||e.continue()),advanceResults.delete(t)}function isIteratorProp(n,e){return e===Symbol.asyncIterator&&instanceOfAny(n,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&instanceOfAny(n,[IDBIndex,IDBObjectStore])}replaceTraps(n=>({...n,get(e,t,s){return isIteratorProp(e,t)?iterate:n.get(e,t,s)},has(e,t){return isIteratorProp(e,t)||n.has(e,t)}}));function dispatchCallback(n,e){n&&n(e)}function reverseDictionary(n){return Object.fromEntries(Object.entries(n).map(([e,t])=>[t,e]))}function escapeRegExp(n){return n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const Callable=class{constructor(){let n=function(...e){return n._call(...e)};return Object.setPrototypeOf(n,new.target.prototype)}_call(...n){throw Error("Must implement _call method in subclass")}};function isTypedArray(n){return n?.prototype?.__proto__?.constructor?.name==="TypedArray"}function isIntegralNumber(n){return Number.isInteger(n)||typeof n=="bigint"}function exists(n){return n!=null}function calculateDimensions(n){const e=[];let t=n;for(;Array.isArray(t);)e.push(t.length),t=t[0];return e}function pop(n,e,t=void 0){const s=n[e];if(s!==void 0)return delete n[e],s;if(t===void 0)throw Error(`Key ${e} does not exist in object.`);return t}function mergeArrays(...n){return Array.prototype.concat.apply([],n)}function product(...n){return n.reduce((e,t)=>e.flatMap(s=>t.map(a=>[s,a])))}function calculateReflectOffset(n,e){return Math.abs((n+e)%(2*e)-e)}const sharp={},ONNX_NODE=Object.freeze(Object.defineProperty({__proto__:null,default:sharp},Symbol.toStringTag,{value:"Module"}));var ortWeb_min$1={exports:{}};const backends={},backendsSortedByPriority=[],registerBackend=(n,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createSessionHandler=="function"){const s=backends[n];if(s===void 0)backends[n]={backend:e,priority:t};else{if(s.priority>t)return;if(s.priority===t&&s.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${t}`)}if(t>=0){const a=backendsSortedByPriority.indexOf(n);a!==-1&&backendsSortedByPriority.splice(a,1);for(let c=0;c<backendsSortedByPriority.length;c++)if(backends[backendsSortedByPriority[c]].priority<=t){backendsSortedByPriority.splice(c,0,n);return}backendsSortedByPriority.push(n)}return}throw new TypeError("not a valid backend")},resolveBackend=async n=>{const e=n.length===0?backendsSortedByPriority:n,t=[];for(const s of e){const a=backends[s];if(a){if(a.initialized)return a.backend;if(a.aborted)continue;const c=!!a.initPromise;try{return c||(a.initPromise=a.backend.init()),await a.initPromise,a.initialized=!0,a.backend}catch(l){c||t.push({name:s,err:l}),a.aborted=!0}finally{delete a.initPromise}}}throw new Error(`no available backend found. ERR: ${t.map(s=>`[${s.name}] ${s.err}`).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",isBigUint64ArrayAvailable=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function",NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64"));isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=n=>{let e=1;for(let t=0;t<n.length;t++){const s=n[t];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${t}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${s}`);e*=s}return e};let Tensor$2=class oy{constructor(e,t,s){let a,c,l;if(typeof e=="string")if(a=e,l=s,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");c=t}else{const m=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(e);if(m===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))c=m.from(t);else if(t instanceof m)c=t;else throw new TypeError(`A ${a} tensor's data must be type of ${m}`)}else if(l=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const m=typeof e[0];if(m==="string")a="string",c=e;else if(m==="boolean")a="bool",c=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${m}.`)}else{const m=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(e.constructor);if(m===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);a=m,c=e}if(l===void 0)l=[c.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");const _=calculateSize(l);if(_!==c.length)throw new Error(`Tensor's size(${_}) does not match data length(${c.length}).`);this.dims=l,this.type=a,this.data=c,this.size=_}static bufferToTensor(e,t){if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");const{height:s,width:a}=t,c=t.norm;let l,_;c===void 0||c.mean===void 0?l=255:l=c.mean,c===void 0||c.bias===void 0?_=0:_=c.bias;const m=t.bitmapFormat!==void 0?t.bitmapFormat:"RGBA",d=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",h=s*a,i=d==="RGBA"?new Float32Array(h*4):new Float32Array(h*3);let r=4,u=0,f=1,g=2,w=3,y=0,x=h,S=h*2,T=-1;m==="RGB"&&(r=3,u=0,f=1,g=2,w=-1),d==="RGBA"?T=h*3:d==="RBG"?(y=0,S=h,x=h*2):d==="BGR"&&(S=0,x=h,y=h*2);for(let A=0;A<h;A++,u+=r,g+=r,f+=r,w+=r)i[y++]=(e[u]+_)/l,i[x++]=(e[f]+_)/l,i[S++]=(e[g]+_)/l,T!==-1&&w!==-1&&(i[T++]=(e[w]+_)/l);return d==="RGBA"?new oy("float32",i,[1,4,s,a]):new oy("float32",i,[1,3,s,a])}static async fromImage(e,t){const s=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,c=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,l=typeof String<"u"&&(e instanceof String||typeof e=="string");let _,m={};if(s){const d=document.createElement("canvas"),h=d.getContext("2d");if(h!=null){let i=e.naturalHeight,r=e.naturalWidth;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(i=t.resizedHeight,r=t.resizedWidth),t!==void 0){if(m=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(m.tensorFormat="RGBA",t.height!==void 0&&t.height!==i)throw new Error("Image input config height doesn't match HTMLImageElement height");if(m.height=i,t.width!==void 0&&t.width!==r)throw new Error("Image input config width doesn't match HTMLImageElement width");m.width=r}else m.tensorFormat="RGBA",m.height=i,m.width=r;d.width=r,d.height=i,h.drawImage(e,0,0,r,i),_=h.getImageData(0,0,r,i).data}else throw new Error("Can not access image data")}else if(a){const d="RGBA";let h,i;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(h=t.resizedHeight,i=t.resizedWidth):(h=e.height,i=e.width),t!==void 0){if(m=t,t.bitmapFormat!==void 0&&t.bitmapFormat!==d)throw new Error("Image input config format must be RGBA for ImageData");m.bitmapFormat="RGBA"}else m.bitmapFormat="RGBA";if(m.height=h,m.width=i,t!==void 0){const r=document.createElement("canvas");r.width=i,r.height=h;const u=r.getContext("2d");if(u!=null)u.putImageData(e,0,0),_=u.getImageData(0,0,i,h).data;else throw new Error("Can not access image data")}else _=e.data}else if(c){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(t.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const d=document.createElement("canvas").getContext("2d");if(d!=null){const h=e.height,i=e.width;if(d.drawImage(e,0,0,i,h),_=d.getImageData(0,0,i,h).data,t!==void 0){if(t.height!==void 0&&t.height!==h)throw new Error("Image input config height doesn't match ImageBitmap height");if(m.height=h,t.width!==void 0&&t.width!==i)throw new Error("Image input config width doesn't match ImageBitmap width");m.width=i}else m.height=h,m.width=i;return oy.bufferToTensor(_,m)}else throw new Error("Can not access image data")}else{if(l)return new Promise((d,h)=>{const i=document.createElement("canvas"),r=i.getContext("2d");if(!e||!r)return h();const u=new Image;u.crossOrigin="Anonymous",u.src=e,u.onload=()=>{i.width=u.width,i.height=u.height,r.drawImage(u,0,0,i.width,i.height);const f=r.getImageData(0,0,i.width,i.height);if(t!==void 0){if(t.height!==void 0&&t.height!==i.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(m.height=i.height,t.width!==void 0&&t.width!==i.width)throw new Error("Image input config width doesn't match ImageBitmap width");m.width=i.width}else m.height=i.height,m.width=i.width;d(oy.bufferToTensor(f.data,m))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(_!==void 0)return oy.bufferToTensor(_,m);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var t,s;const a=document.createElement("canvas").getContext("2d");let c;if(a!=null){const l=this.dims[3],_=this.dims[2],m=this.dims[1],d=e!==void 0&&e.format!==void 0?e.format:"RGB",h=e!==void 0&&((t=e.norm)===null||t===void 0?void 0:t.mean)!==void 0?e.norm.mean:255,i=e!==void 0&&((s=e.norm)===null||s===void 0?void 0:s.bias)!==void 0?e.norm.bias:0,r=_*l;if(e!==void 0){if(e.height!==void 0&&e.height!==_)throw new Error("Image output config height doesn't match tensor height");if(e.width!==void 0&&e.width!==l)throw new Error("Image output config width doesn't match tensor width");if(e.format!==void 0&&m===4&&e.format!=="RGBA"||m===3&&e.format!=="RGB"&&e.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const u=4;let f=0,g=1,w=2,y=3,x=0,S=r,T=r*2,E=-1;d==="RGBA"?(x=0,S=r,T=r*2,E=r*3):d==="RGB"?(x=0,S=r,T=r*2):d==="RBG"&&(x=0,T=r,S=r*2),c=a.createImageData(l,_);for(let A=0;A<_*l;f+=u,g+=u,w+=u,y+=u,A++)c.data[f]=(this.data[x++]-i)*h,c.data[g]=(this.data[S++]-i)*h,c.data[w]=(this.data[T++]-i)*h,c.data[y]=E===-1?255:(this.data[E++]-i)*h}else throw new Error("Can not access image data");return c}reshape(e){return new oy(this.type,this.data,e)}};const Tensor$1=Tensor$2;let InferenceSession$2=class lT{constructor(e){this.handler=e}async run(e,t,s){const a={};let c={};if(typeof e!="object"||e===null||e instanceof Tensor$1||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let l=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Tensor$1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");l=!1;for(const d of t){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);a[d]=null}if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let d=!1;const h=Object.getOwnPropertyNames(t);for(const i of this.outputNames)if(h.indexOf(i)!==-1){const r=t[i];(r===null||r instanceof Tensor$1)&&(d=!0,l=!1,a[i]=r)}if(d){if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else c=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const d of this.inputNames)if(typeof e[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(l)for(const d of this.outputNames)a[d]=null;const _=await this.handler.run(e,a,c),m={};for(const d in _)Object.hasOwnProperty.call(_,d)&&(m[d]=new Tensor$1(_[d].type,_[d].data,_[d].dims));return m}static async create(e,t,s,a){let c,l={};if(typeof e=="string"){if(c=e,typeof t=="object"&&t!==null)l=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(c=e,typeof t=="object"&&t!==null)l=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){const i=e;let r=0,u=e.byteLength;if(typeof t=="object"&&t!==null)l=t;else if(typeof t=="number"){if(r=t,!Number.isSafeInteger(r))throw new RangeError("'byteOffset' must be an integer.");if(r<0||r>=i.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${i.byteLength}).`);if(u=e.byteLength-r,typeof s=="number"){if(u=s,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||r+u>i.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${i.byteLength-r}].`);if(typeof a=="object"&&a!==null)l=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(i,r,u)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const m=(l.executionProviders||[]).map(i=>typeof i=="string"?i:i.name),h=await(await resolveBackend(m)).createSessionHandler(c,l);return new lT(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$1=InferenceSession$2,lib=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:InferenceSession$1,Tensor:Tensor$1,env:env$2,registerBackend},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(lib);/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/var hasRequiredOrtWeb_min;function requireOrtWeb_min(){return hasRequiredOrtWeb_min||(hasRequiredOrtWeb_min=1,(function(module,exports){(function(n,e){module.exports=e(require$$0)})(self,(__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(n,e,t)=>{var s,a=(s=(s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(c){function l(){return Ce.buffer!=K&&ke(Ce.buffer),Q}function _(){return Ce.buffer!=K&&ke(Ce.buffer),de}function m(){return Ce.buffer!=K&&ke(Ce.buffer),ue}function d(){return Ce.buffer!=K&&ke(Ce.buffer),Ze}function h(){return Ce.buffer!=K&&ke(Ce.buffer),Pt}var i,r,u;c=c||{},i||(i=c!==void 0?c:{}),i.ready=new Promise((function(Z,xe){r=Z,u=xe}));var f,g,w,y,x,S,T=Object.assign({},i),E="./this.program",A=(Z,xe)=>{throw xe},C=typeof window=="object",I=typeof importScripts=="function",D=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",R=i.ENVIRONMENT_IS_PTHREAD||!1,Y="";function re(Z){return i.locateFile?i.locateFile(Z,Y):Y+Z}if(D){let Z;Y=I?t(908).dirname(Y)+"/":"//",S=()=>{x||(y=t(1384),x=t(908))},f=function(xe,Ve){return S(),xe=x.normalize(xe),y.readFileSync(xe,Ve?void 0:"utf8")},w=xe=>((xe=f(xe,!0)).buffer||(xe=new Uint8Array(xe)),xe),g=(xe,Ve,ct)=>{S(),xe=x.normalize(xe),y.readFile(xe,(function(zt,Sn){zt?ct(zt):Ve(Sn.buffer)}))},1<process.argv.length&&(E=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(xe){if(!(xe instanceof ui))throw xe})),process.on("unhandledRejection",(function(xe){throw xe})),A=(xe,Ve)=>{if($n())throw process.exitCode=xe,Ve;Ve instanceof ui||H("exiting due to exception: "+Ve),process.exit(xe)},i.inspect=function(){return"[Emscripten Module object]"};try{Z=t(9925)}catch(xe){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),xe}t.g.Worker=Z.Worker}else(C||I)&&(I?Y=self.location.href:typeof document<"u"&&document.currentScript&&(Y=document.currentScript.src),s&&(Y=s),Y=Y.indexOf("blob:")!==0?Y.substr(0,Y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",D||(f=Z=>{var xe=new XMLHttpRequest;return xe.open("GET",Z,!1),xe.send(null),xe.responseText},I&&(w=Z=>{var xe=new XMLHttpRequest;return xe.open("GET",Z,!1),xe.responseType="arraybuffer",xe.send(null),new Uint8Array(xe.response)}),g=(Z,xe,Ve)=>{var ct=new XMLHttpRequest;ct.open("GET",Z,!0),ct.responseType="arraybuffer",ct.onload=()=>{ct.status==200||ct.status==0&&ct.response?xe(ct.response):Ve()},ct.onerror=Ve,ct.send(null)}));D&&typeof performance>"u"&&(t.g.performance=t(6953).performance);var G=console.log.bind(console),te=console.warn.bind(console);D&&(S(),G=Z=>y.writeSync(1,Z+`
`),te=Z=>y.writeSync(2,Z+`
`));var q,z=i.print||G,H=i.printErr||te;Object.assign(i,T),T=null,i.thisProgram&&(E=i.thisProgram),i.quit&&(A=i.quit),i.wasmBinary&&(q=i.wasmBinary);var he=i.noExitRuntime||!1;typeof WebAssembly!="object"&&ir("no native wasm support detected");var Ce,oe,K,Q,de,ue,Ze,Pt,Gt=!1,bn=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ri(Z,xe,Ve){var ct=(xe>>>=0)+Ve;for(Ve=xe;Z[Ve]&&!(Ve>=ct);)++Ve;if(16<Ve-xe&&Z.buffer&&bn)return bn.decode(Z.buffer instanceof SharedArrayBuffer?Z.slice(xe,Ve):Z.subarray(xe,Ve));for(ct="";xe<Ve;){var zt=Z[xe++];if(128&zt){var Sn=63&Z[xe++];if((224&zt)==192)ct+=String.fromCharCode((31&zt)<<6|Sn);else{var pr=63&Z[xe++];65536>(zt=(240&zt)==224?(15&zt)<<12|Sn<<6|pr:(7&zt)<<18|Sn<<12|pr<<6|63&Z[xe++])?ct+=String.fromCharCode(zt):(zt-=65536,ct+=String.fromCharCode(55296|zt>>10,56320|1023&zt))}}else ct+=String.fromCharCode(zt)}return ct}function hn(Z,xe){return(Z>>>=0)?ri(_(),Z,xe):""}function ze(Z,xe,Ve,ct){if(!(0<ct))return 0;var zt=Ve>>>=0;ct=Ve+ct-1;for(var Sn=0;Sn<Z.length;++Sn){var pr=Z.charCodeAt(Sn);if(55296<=pr&&57343>=pr&&(pr=65536+((1023&pr)<<10)|1023&Z.charCodeAt(++Sn)),127>=pr){if(Ve>=ct)break;xe[Ve++>>>0]=pr}else{if(2047>=pr){if(Ve+1>=ct)break;xe[Ve++>>>0]=192|pr>>6}else{if(65535>=pr){if(Ve+2>=ct)break;xe[Ve++>>>0]=224|pr>>12}else{if(Ve+3>=ct)break;xe[Ve++>>>0]=240|pr>>18,xe[Ve++>>>0]=128|pr>>12&63}xe[Ve++>>>0]=128|pr>>6&63}xe[Ve++>>>0]=128|63&pr}}return xe[Ve>>>0]=0,Ve-zt}function wt(Z){for(var xe=0,Ve=0;Ve<Z.length;++Ve){var ct=Z.charCodeAt(Ve);127>=ct?xe++:2047>=ct?xe+=2:55296<=ct&&57343>=ct?(xe+=4,++Ve):xe+=3}return xe}function ke(Z){K=Z,i.HEAP8=Q=new Int8Array(Z),i.HEAP16=new Int16Array(Z),i.HEAP32=ue=new Int32Array(Z),i.HEAPU8=de=new Uint8Array(Z),i.HEAPU16=new Uint16Array(Z),i.HEAPU32=Ze=new Uint32Array(Z),i.HEAPF32=new Float32Array(Z),i.HEAPF64=Pt=new Float64Array(Z)}R&&(K=i.buffer);var Bt=i.INITIAL_MEMORY||16777216;if(R)Ce=i.wasmMemory,K=i.buffer;else if(i.wasmMemory)Ce=i.wasmMemory;else if(!((Ce=new WebAssembly.Memory({initial:Bt/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw H("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),D&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Ce&&(K=Ce.buffer),Bt=K.byteLength,ke(K);var In,Tn=[],cn=[],kn=[],yn=[];function $n(){return he||!1}function cr(){var Z=i.preRun.shift();Tn.unshift(Z)}var ti,vn=0,xi=null;function ir(Z){throw R?postMessage({cmd:"onAbort",arg:Z}):i.onAbort&&i.onAbort(Z),H(Z="Aborted("+Z+")"),Gt=!0,Z=new WebAssembly.RuntimeError(Z+". Build with -sASSERTIONS for more info."),u(Z),Z}function ai(){return ti.startsWith("data:application/octet-stream;base64,")}function mi(){var Z=ti;try{if(Z==ti&&q)return new Uint8Array(q);if(w)return w(Z);throw"both async and sync fetching of the wasm failed"}catch(xe){ir(xe)}}ti="ort-wasm-threaded.wasm",ai()||(ti=re(ti));var fi={};function ui(Z){this.name="ExitStatus",this.message="Program terminated with exit("+Z+")",this.status=Z}function wi(Z){(Z=Si.Vb[Z])||ir(),Si.mc(Z)}function Lo(Z){var xe=Si.Cc();if(!xe)return 6;Si.ac.push(xe),Si.Vb[Z.Ub]=xe,xe.Ub=Z.Ub;var Ve={cmd:"run",start_routine:Z.Ic,arg:Z.zc,pthread_ptr:Z.Ub};return xe.$b=()=>{Ve.time=performance.now(),xe.postMessage(Ve,Z.Nc)},xe.loaded&&(xe.$b(),delete xe.$b),0}function zi(Z){if(R)return pi(1,1,Z);$n()||(Si.oc(),i.onExit&&i.onExit(Z),Gt=!0),A(Z,new ui(Z))}function Ci(Z,xe){if(!xe&&R)throw up(Z),"unwind";$n()||R||(T_(),zc(kn),g_(0),dp[1].length&&Jf(1,10),dp[2].length&&Jf(2,10),Si.oc()),zi(Z)}var Si={Yb:[],ac:[],qc:[],Vb:{},fc:function(){R&&Si.Ec()},Pc:function(){},Ec:function(){Si.receiveObjectTransfer=Si.Gc,Si.threadInitTLS=Si.pc,Si.setExitStatus=Si.nc,he=!1},nc:function(){},oc:function(){for(var Z of Object.values(Si.Vb))Si.mc(Z);for(Z of Si.Yb)Z.terminate();Si.Yb=[]},mc:function(Z){var xe=Z.Ub;delete Si.Vb[xe],Si.Yb.push(Z),Si.ac.splice(Si.ac.indexOf(Z),1),Z.Ub=0,at(xe)},Gc:function(){},pc:function(){Si.qc.forEach((Z=>Z()))},Fc:function(Z,xe){Z.onmessage=Ve=>{var ct=(Ve=Ve.data).cmd;if(Z.Ub&&(Si.Bc=Z.Ub),Ve.targetThread&&Ve.targetThread!=Op()){var zt=Si.Vb[Ve.Qc];zt?zt.postMessage(Ve,Ve.transferList):H('Internal error! Worker sent a message "'+ct+'" to target pthread '+Ve.targetThread+", but that thread no longer exists!")}else ct==="processProxyingQueue"?pt(Ve.queue):ct==="spawnThread"?Lo(Ve):ct==="cleanupThread"?wi(Ve.thread):ct==="killThread"?(Ve=Ve.thread,ct=Si.Vb[Ve],delete Si.Vb[Ve],ct.terminate(),at(Ve),Si.ac.splice(Si.ac.indexOf(ct),1),ct.Ub=0):ct==="cancelThread"?Si.Vb[Ve.thread].postMessage({cmd:"cancel"}):ct==="loaded"?(Z.loaded=!0,xe&&xe(Z),Z.$b&&(Z.$b(),delete Z.$b)):ct==="print"?z("Thread "+Ve.threadId+": "+Ve.text):ct==="printErr"?H("Thread "+Ve.threadId+": "+Ve.text):ct==="alert"?alert("Thread "+Ve.threadId+": "+Ve.text):Ve.target==="setimmediate"?Z.postMessage(Ve):ct==="onAbort"?i.onAbort&&i.onAbort(Ve.arg):ct&&H("worker sent an unknown command "+ct);Si.Bc=void 0},Z.onerror=Ve=>{throw H("worker sent an error! "+Ve.filename+":"+Ve.lineno+": "+Ve.message),Ve},D&&(Z.on("message",(function(Ve){Z.onmessage({data:Ve})})),Z.on("error",(function(Ve){Z.onerror(Ve)})),Z.on("detachedExit",(function(){}))),Z.postMessage({cmd:"load",urlOrBlob:i.mainScriptUrlOrBlob||s,wasmMemory:Ce,wasmModule:oe})},yc:function(){var Z=re("ort-wasm-threaded.worker.js");Si.Yb.push(new Worker(Z))},Cc:function(){return Si.Yb.length==0&&(Si.yc(),Si.Fc(Si.Yb[0])),Si.Yb.pop()}};function zc(Z){for(;0<Z.length;)Z.shift()(i)}function Xc(Z){var xe=or();return Z=Z(),lr(xe),Z}function up(Z){if(R)return pi(2,0,Z);try{Ci(Z)}catch(xe){xe instanceof ui||xe=="unwind"||A(1,xe)}}i.PThread=Si,i.establishStackSpace=function(){var Z=Op(),xe=m()[Z+44>>2>>>0];Z=m()[Z+48>>2>>>0],sr(xe,xe-Z),lr(xe)};var Jo=[];function Mo(Z){var xe=Jo[Z];return xe||(Z>=Jo.length&&(Jo.length=Z+1),Jo[Z]=xe=In.get(Z)),xe}i.invokeEntryPoint=function(Z,xe){Z=Mo(Z)(xe),$n()?Si.nc(Z):ft(Z)};var $p,rf,cp=[],Wi=0,si=0;function Ri(Z){this.Zb=Z,this.Sb=Z-24,this.xc=function(xe){d()[this.Sb+4>>2>>>0]=xe},this.bc=function(){return d()[this.Sb+4>>2>>>0]},this.wc=function(xe){d()[this.Sb+8>>2>>>0]=xe},this.Dc=function(){return d()[this.Sb+8>>2>>>0]},this.rc=function(){m()[this.Sb>>2>>>0]=0},this.hc=function(xe){xe=xe?1:0,l()[this.Sb+12>>0>>>0]=xe},this.uc=function(){return l()[this.Sb+12>>0>>>0]!=0},this.ic=function(xe){xe=xe?1:0,l()[this.Sb+13>>0>>>0]=xe},this.kc=function(){return l()[this.Sb+13>>0>>>0]!=0},this.fc=function(xe,Ve){this.cc(0),this.xc(xe),this.wc(Ve),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(m(),this.Sb>>2,1)},this.Hc=function(){return Atomics.sub(m(),this.Sb>>2,1)===1},this.cc=function(xe){d()[this.Sb+16>>2>>>0]=xe},this.tc=function(){return d()[this.Sb+16>>2>>>0]},this.vc=function(){if(zo(this.bc()))return d()[this.Zb>>2>>>0];var xe=this.tc();return xe!==0?xe:this.Zb}}function _c(Z){return Hc(new Ri(Z).Sb)}function Ui(Z,xe,Ve,ct){return R?pi(3,1,Z,xe,Ve,ct):Rp(Z,xe,Ve,ct)}function Rp(Z,xe,Ve,ct){if(typeof SharedArrayBuffer>"u")return H("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var zt=[];return R&&zt.length===0?Ui(Z,xe,Ve,ct):(Z={Ic:Ve,Ub:Z,zc:ct,Nc:zt},R?(Z.Oc="spawnThread",postMessage(Z,zt),0):Lo(Z))}function W(Z,xe,Ve){return R?pi(4,1,Z,xe,Ve):0}function Qe(Z,xe){if(R)return pi(5,1,Z,xe)}function ve(Z,xe){if(R)return pi(6,1,Z,xe)}function Ke(Z,xe,Ve){if(R)return pi(7,1,Z,xe,Ve)}function lt(Z,xe,Ve){return R?pi(8,1,Z,xe,Ve):0}function _n(Z,xe){if(R)return pi(9,1,Z,xe)}function ar(Z,xe,Ve){if(R)return pi(10,1,Z,xe,Ve)}function vi(Z,xe,Ve,ct){if(R)return pi(11,1,Z,xe,Ve,ct)}function Pi(Z,xe,Ve,ct){if(R)return pi(12,1,Z,xe,Ve,ct)}function hi(Z,xe,Ve,ct){if(R)return pi(13,1,Z,xe,Ve,ct)}function Oo(Z){if(R)return pi(14,1,Z)}function we(Z,xe){if(R)return pi(15,1,Z,xe)}function it(Z,xe,Ve){if(R)return pi(16,1,Z,xe,Ve)}function pt(Z){Atomics.store(m(),Z>>2,1),Op()&&$e(Z),Atomics.compareExchange(m(),Z>>2,1,0)}function Ot(Z){return d()[Z>>>2]+4294967296*m()[Z+4>>>2]}function Ht(Z,xe,Ve,ct,zt,Sn){return R?pi(17,1,Z,xe,Ve,ct,zt,Sn):-52}function mn(Z,xe,Ve,ct,zt,Sn){if(R)return pi(18,1,Z,xe,Ve,ct,zt,Sn)}function ii(Z){var xe=wt(Z)+1,Ve=p_(xe);return Ve&&ze(Z,l(),Ve,xe),Ve}function Ti(Z,xe,Ve){function ct(ki){return(ki=ki.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ki[1]:"GMT"}if(R)return pi(19,1,Z,xe,Ve);var zt=new Date().getFullYear(),Sn=new Date(zt,0,1),pr=new Date(zt,6,1);zt=Sn.getTimezoneOffset();var gi=pr.getTimezoneOffset(),Ii=Math.max(zt,gi);m()[Z>>2>>>0]=60*Ii,m()[xe>>2>>>0]=+(zt!=gi),Z=ct(Sn),xe=ct(pr),Z=ii(Z),xe=ii(xe),gi<zt?(d()[Ve>>2>>>0]=Z,d()[Ve+4>>2>>>0]=xe):(d()[Ve>>2>>>0]=xe,d()[Ve+4>>2>>>0]=Z)}function pi(Z,xe){var Ve=arguments.length-2,ct=arguments;return Xc((()=>{for(var zt=yi(8*Ve),Sn=zt>>3,pr=0;pr<Ve;pr++){var gi=ct[2+pr];h()[Sn+pr>>>0]=gi}return X(Z,Ve,zt,xe)}))}i.executeNotifiedProxyingQueue=pt,rf=D?()=>{var Z=process.hrtime();return 1e3*Z[0]+Z[1]/1e6}:R?()=>performance.now()-i.__performance_now_clock_drift:()=>performance.now();var Do,Ko=[],yc={};function Dc(){if(!Do){var Z,xe={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:E||"./this.program"};for(Z in yc)yc[Z]===void 0?delete xe[Z]:xe[Z]=yc[Z];var Ve=[];for(Z in xe)Ve.push(Z+"="+xe[Z]);Do=Ve}return Do}function En(Z,xe){if(R)return pi(20,1,Z,xe);var Ve=0;return Dc().forEach((function(ct,zt){var Sn=xe+Ve;for(zt=d()[Z+4*zt>>2>>>0]=Sn,Sn=0;Sn<ct.length;++Sn)l()[zt++>>0>>>0]=ct.charCodeAt(Sn);l()[zt>>0>>>0]=0,Ve+=ct.length+1})),0}function Oi(Z,xe){if(R)return pi(21,1,Z,xe);var Ve=Dc();d()[Z>>2>>>0]=Ve.length;var ct=0;return Ve.forEach((function(zt){ct+=zt.length+1})),d()[xe>>2>>>0]=ct,0}function Ro(Z){return R?pi(22,1,Z):52}function bc(Z,xe,Ve,ct){return R?pi(23,1,Z,xe,Ve,ct):52}function Oc(Z,xe,Ve,ct,zt){return R?pi(24,1,Z,xe,Ve,ct,zt):70}var dp=[null,[],[]];function Jf(Z,xe){var Ve=dp[Z];xe===0||xe===10?((Z===1?z:H)(ri(Ve,0)),Ve.length=0):Ve.push(xe)}function kp(Z,xe,Ve,ct){if(R)return pi(25,1,Z,xe,Ve,ct);for(var zt=0,Sn=0;Sn<Ve;Sn++){var pr=d()[xe>>2>>>0],gi=d()[xe+4>>2>>>0];xe+=8;for(var Ii=0;Ii<gi;Ii++)Jf(Z,_()[pr+Ii>>>0]);zt+=gi}return d()[ct>>2>>>0]=zt,0}var Qc=0;function sp(Z){return Z%4==0&&(Z%100!=0||Z%400==0)}var mr=[31,29,31,30,31,30,31,31,30,31,30,31],ci=[31,28,31,30,31,30,31,31,30,31,30,31];function Mi(Z,xe,Ve,ct){function zt(An,Ho,Bc){for(An=typeof An=="number"?An.toString():An||"";An.length<Ho;)An=Bc[0]+An;return An}function Sn(An,Ho){return zt(An,Ho,"0")}function pr(An,Ho){function Bc(E_){return 0>E_?-1:0<E_?1:0}var s_;return(s_=Bc(An.getFullYear()-Ho.getFullYear()))===0&&(s_=Bc(An.getMonth()-Ho.getMonth()))===0&&(s_=Bc(An.getDate()-Ho.getDate())),s_}function gi(An){switch(An.getDay()){case 0:return new Date(An.getFullYear()-1,11,29);case 1:return An;case 2:return new Date(An.getFullYear(),0,3);case 3:return new Date(An.getFullYear(),0,2);case 4:return new Date(An.getFullYear(),0,1);case 5:return new Date(An.getFullYear()-1,11,31);case 6:return new Date(An.getFullYear()-1,11,30)}}function Ii(An){var Ho=An.Wb;for(An=new Date(new Date(An.Xb+1900,0,1).getTime());0<Ho;){var Bc=An.getMonth(),s_=(sp(An.getFullYear())?mr:ci)[Bc];if(!(Ho>s_-An.getDate())){An.setDate(An.getDate()+Ho);break}Ho-=s_-An.getDate()+1,An.setDate(1),11>Bc?An.setMonth(Bc+1):(An.setMonth(0),An.setFullYear(An.getFullYear()+1))}return Bc=new Date(An.getFullYear()+1,0,4),Ho=gi(new Date(An.getFullYear(),0,4)),Bc=gi(Bc),0>=pr(Ho,An)?0>=pr(Bc,An)?An.getFullYear()+1:An.getFullYear():An.getFullYear()-1}var ki=m()[ct+40>>2>>>0];for(var Zo in ct={Lc:m()[ct>>2>>>0],Kc:m()[ct+4>>2>>>0],dc:m()[ct+8>>2>>>0],jc:m()[ct+12>>2>>>0],ec:m()[ct+16>>2>>>0],Xb:m()[ct+20>>2>>>0],Tb:m()[ct+24>>2>>>0],Wb:m()[ct+28>>2>>>0],Rc:m()[ct+32>>2>>>0],Jc:m()[ct+36>>2>>>0],Mc:ki?hn(ki):""},Ve=hn(Ve),ki={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Ve=Ve.replace(new RegExp(Zo,"g"),ki[Zo]);var pp="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),fp="January February March April May June July August September October November December".split(" ");for(Zo in ki={"%a":function(An){return pp[An.Tb].substring(0,3)},"%A":function(An){return pp[An.Tb]},"%b":function(An){return fp[An.ec].substring(0,3)},"%B":function(An){return fp[An.ec]},"%C":function(An){return Sn((An.Xb+1900)/100|0,2)},"%d":function(An){return Sn(An.jc,2)},"%e":function(An){return zt(An.jc,2," ")},"%g":function(An){return Ii(An).toString().substring(2)},"%G":function(An){return Ii(An)},"%H":function(An){return Sn(An.dc,2)},"%I":function(An){return(An=An.dc)==0?An=12:12<An&&(An-=12),Sn(An,2)},"%j":function(An){for(var Ho=0,Bc=0;Bc<=An.ec-1;Ho+=(sp(An.Xb+1900)?mr:ci)[Bc++]);return Sn(An.jc+Ho,3)},"%m":function(An){return Sn(An.ec+1,2)},"%M":function(An){return Sn(An.Kc,2)},"%n":function(){return`
`},"%p":function(An){return 0<=An.dc&&12>An.dc?"AM":"PM"},"%S":function(An){return Sn(An.Lc,2)},"%t":function(){return"	"},"%u":function(An){return An.Tb||7},"%U":function(An){return Sn(Math.floor((An.Wb+7-An.Tb)/7),2)},"%V":function(An){var Ho=Math.floor((An.Wb+7-(An.Tb+6)%7)/7);if(2>=(An.Tb+371-An.Wb-2)%7&&Ho++,Ho)Ho==53&&((Bc=(An.Tb+371-An.Wb)%7)==4||Bc==3&&sp(An.Xb)||(Ho=1));else{Ho=52;var Bc=(An.Tb+7-An.Wb-1)%7;(Bc==4||Bc==5&&sp(An.Xb%400-1))&&Ho++}return Sn(Ho,2)},"%w":function(An){return An.Tb},"%W":function(An){return Sn(Math.floor((An.Wb+7-(An.Tb+6)%7)/7),2)},"%y":function(An){return(An.Xb+1900).toString().substring(2)},"%Y":function(An){return An.Xb+1900},"%z":function(An){var Ho=0<=(An=An.Jc);return An=Math.abs(An)/60,(Ho?"+":"-")+("0000"+(An/60*100+An%60)).slice(-4)},"%Z":function(An){return An.Mc},"%%":function(){return"%"}},Ve=Ve.replace(/%%/g,"\0\0"),ki)Ve.includes(Zo)&&(Ve=Ve.replace(new RegExp(Zo,"g"),ki[Zo](ct)));return Zo=(function(An){var Ho=Array(wt(An)+1);return ze(An,Ho,0,Ho.length),Ho})(Ve=Ve.replace(/\0\0/g,"%")),Zo.length>xe?0:((function(An,Ho){l().set(An,Ho>>>0)})(Zo,Z),Zo.length-1)}Si.fc();var Ac=[null,zi,up,Ui,W,Qe,ve,Ke,lt,_n,ar,vi,Pi,hi,Oo,we,it,Ht,mn,Ti,En,Oi,Ro,bc,Oc,kp],m_={b:function(Z){return p_(Z+24)+24},n:function(Z){return(Z=new Ri(Z)).uc()||(Z.hc(!0),Wi--),Z.ic(!1),cp.push(Z),Z.sc(),Z.vc()},ma:function(Z){throw H("Unexpected exception thrown, this is not properly supported - aborting"),Gt=!0,Z},x:function(){kt(0);var Z=cp.pop();if(Z.Hc()&&!Z.kc()){var xe=Z.Dc();xe&&Mo(xe)(Z.Zb),_c(Z.Zb)}si=0},e:function(){var Z=si;if(!Z)return Qc=0;var xe=new Ri(Z);xe.cc(Z);var Ve=xe.bc();if(!Ve)return Qc=0,Z;for(var ct=Array.prototype.slice.call(arguments),zt=0;zt<ct.length;zt++){var Sn=ct[zt];if(Sn===0||Sn===Ve)break;if(di(Sn,Ve,xe.Sb+16))return Qc=Sn,Z}return Qc=Ve,Z},l:function(){var Z=si;if(!Z)return Qc=0;var xe=new Ri(Z);xe.cc(Z);var Ve=xe.bc();if(!Ve)return Qc=0,Z;for(var ct=Array.prototype.slice.call(arguments),zt=0;zt<ct.length;zt++){var Sn=ct[zt];if(Sn===0||Sn===Ve)break;if(di(Sn,Ve,xe.Sb+16))return Qc=Sn,Z}return Qc=Ve,Z},h:function(){var Z=si;if(!Z)return Qc=0;var xe=new Ri(Z);xe.cc(Z);var Ve=xe.bc();if(!Ve)return Qc=0,Z;for(var ct=Array.prototype.slice.call(arguments),zt=0;zt<ct.length;zt++){var Sn=ct[zt];if(Sn===0||Sn===Ve)break;if(di(Sn,Ve,xe.Sb+16))return Qc=Sn,Z}return Qc=Ve,Z},t:_c,M:function(){var Z=cp.pop();Z||ir("no exception to throw");var xe=Z.Zb;throw Z.kc()||(cp.push(Z),Z.ic(!0),Z.hc(!1),Wi++),si=xe,xe},c:function(Z,xe,Ve){throw new Ri(Z).fc(xe,Ve),si=Z,Wi++,Z},pa:function(){return Wi},Fa:function(Z){M_(Z,!I,1,!C),Si.pc()},T:function(Z){R?postMessage({cmd:"cleanupThread",thread:Z}):wi(Z)},xa:Rp,j:function(Z){throw si||(si=Z),Z},H:W,Ma:Qe,ua:ve,wa:Ke,oa:lt,Ka:_n,Ca:ar,Ja:vi,V:Pi,va:hi,sa:Oo,La:we,ta:it,Ta:function(){},X:function(){ir("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){ir("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(Z,xe,Ve,ct){if(Z==xe)setTimeout((()=>pt(ct)));else if(R)postMessage({targetThread:Z,cmd:"processProxyingQueue",queue:ct});else{if(!(Z=Si.Vb[Z]))return;Z.postMessage({cmd:"processProxyingQueue",queue:ct})}return 1},Ea:function(){return-1},Pa:function(Z,xe){Z=new Date(1e3*Ot(Z)),m()[xe>>2>>>0]=Z.getUTCSeconds(),m()[xe+4>>2>>>0]=Z.getUTCMinutes(),m()[xe+8>>2>>>0]=Z.getUTCHours(),m()[xe+12>>2>>>0]=Z.getUTCDate(),m()[xe+16>>2>>>0]=Z.getUTCMonth(),m()[xe+20>>2>>>0]=Z.getUTCFullYear()-1900,m()[xe+24>>2>>>0]=Z.getUTCDay(),Z=(Z.getTime()-Date.UTC(Z.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,m()[xe+28>>2>>>0]=Z},Qa:function(Z,xe){Z=new Date(1e3*Ot(Z)),m()[xe>>2>>>0]=Z.getSeconds(),m()[xe+4>>2>>>0]=Z.getMinutes(),m()[xe+8>>2>>>0]=Z.getHours(),m()[xe+12>>2>>>0]=Z.getDate(),m()[xe+16>>2>>>0]=Z.getMonth(),m()[xe+20>>2>>>0]=Z.getFullYear()-1900,m()[xe+24>>2>>>0]=Z.getDay();var Ve=new Date(Z.getFullYear(),0,1),ct=(Z.getTime()-Ve.getTime())/864e5|0;m()[xe+28>>2>>>0]=ct,m()[xe+36>>2>>>0]=-60*Z.getTimezoneOffset(),ct=new Date(Z.getFullYear(),6,1).getTimezoneOffset(),Z=0|(ct!=(Ve=Ve.getTimezoneOffset())&&Z.getTimezoneOffset()==Math.min(Ve,ct)),m()[xe+32>>2>>>0]=Z},Ra:function(Z){var xe=new Date(m()[Z+20>>2>>>0]+1900,m()[Z+16>>2>>>0],m()[Z+12>>2>>>0],m()[Z+8>>2>>>0],m()[Z+4>>2>>>0],m()[Z>>2>>>0],0),Ve=m()[Z+32>>2>>>0],ct=xe.getTimezoneOffset(),zt=new Date(xe.getFullYear(),0,1),Sn=new Date(xe.getFullYear(),6,1).getTimezoneOffset(),pr=zt.getTimezoneOffset(),gi=Math.min(pr,Sn);return 0>Ve?m()[Z+32>>2>>>0]=+(Sn!=pr&&gi==ct):0<Ve!=(gi==ct)&&(Sn=Math.max(pr,Sn),xe.setTime(xe.getTime()+6e4*((0<Ve?gi:Sn)-ct))),m()[Z+24>>2>>>0]=xe.getDay(),Ve=(xe.getTime()-zt.getTime())/864e5|0,m()[Z+28>>2>>>0]=Ve,m()[Z>>2>>>0]=xe.getSeconds(),m()[Z+4>>2>>>0]=xe.getMinutes(),m()[Z+8>>2>>>0]=xe.getHours(),m()[Z+12>>2>>>0]=xe.getDate(),m()[Z+16>>2>>>0]=xe.getMonth(),xe.getTime()/1e3|0},Aa:Ht,Ba:mn,Sa:function Z(xe,Ve,ct){Z.Ac||(Z.Ac=!0,Ti(xe,Ve,ct))},y:function(){ir("")},U:function(){if(!D&&!I){var Z="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";$p||($p={}),$p[Z]||($p[Z]=1,D&&(Z="warning: "+Z),H(Z))}},ra:function(){return 4294901760},B:rf,Ia:function(Z,xe,Ve){_().copyWithin(Z>>>0,xe>>>0,xe+Ve>>>0)},F:function(){return D?t(3993).cpus().length:navigator.hardwareConcurrency},Da:function(Z,xe,Ve){Ko.length=xe,Ve>>=3;for(var ct=0;ct<xe;ct++)Ko[ct]=h()[Ve+ct>>>0];return(0>Z?fi[-Z-1]:Ac[Z]).apply(null,Ko)},qa:function(Z){var xe=_().length;if((Z>>>=0)<=xe||4294901760<Z)return!1;for(var Ve=1;4>=Ve;Ve*=2){var ct=xe*(1+.2/Ve);ct=Math.min(ct,Z+100663296);var zt=Math;ct=Math.max(Z,ct),zt=zt.min.call(zt,4294901760,ct+(65536-ct%65536)%65536);e:{try{Ce.grow(zt-K.byteLength+65535>>>16),ke(Ce.buffer);var Sn=1;break e}catch{}Sn=void 0}if(Sn)return!0}return!1},Na:function(){throw"unwind"},Ga:En,Ha:Oi,J:Ci,I:Ro,S:bc,ga:Oc,R:kp,d:function(){return Qc},na:function Z(xe,Ve){Z.lc||(Z.lc=(function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var zt=new Uint8Array(1);return()=>(crypto.getRandomValues(zt),zt[0])}if(D)try{var Sn=t(Object((function(){var pr=new Error("Cannot find module 'crypto'");throw pr.code="MODULE_NOT_FOUND",pr})()));return()=>Sn.randomBytes(1)[0]}catch{}return()=>ir("randomDevice")})());for(var ct=0;ct<Ve;ct++)l()[xe+ct>>0>>>0]=Z.lc();return 0},ia:function(Z,xe,Ve){var ct=or();try{return Mo(Z)(xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},ja:function(Z,xe,Ve){var ct=or();try{return Mo(Z)(xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},K:function(Z){var xe=or();try{return Mo(Z)()}catch(Ve){if(lr(xe),Ve!==Ve+0)throw Ve;kt(1,0)}},f:function(Z,xe){var Ve=or();try{return Mo(Z)(xe)}catch(ct){if(lr(Ve),ct!==ct+0)throw ct;kt(1,0)}},P:function(Z,xe,Ve){var ct=or();try{return Mo(Z)(xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},Q:function(Z,xe,Ve){var ct=or();try{return Mo(Z)(xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},k:function(Z,xe,Ve){var ct=or();try{return Mo(Z)(xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},p:function(Z,xe,Ve,ct){var zt=or();try{return Mo(Z)(xe,Ve,ct)}catch(Sn){if(lr(zt),Sn!==Sn+0)throw Sn;kt(1,0)}},q:function(Z,xe,Ve,ct,zt){var Sn=or();try{return Mo(Z)(xe,Ve,ct,zt)}catch(pr){if(lr(Sn),pr!==pr+0)throw pr;kt(1,0)}},N:function(Z,xe,Ve,ct,zt,Sn){var pr=or();try{return Mo(Z)(xe,Ve,ct,zt,Sn)}catch(gi){if(lr(pr),gi!==gi+0)throw gi;kt(1,0)}},s:function(Z,xe,Ve,ct,zt,Sn){var pr=or();try{return Mo(Z)(xe,Ve,ct,zt,Sn)}catch(gi){if(lr(pr),gi!==gi+0)throw gi;kt(1,0)}},w:function(Z,xe,Ve,ct,zt,Sn,pr){var gi=or();try{return Mo(Z)(xe,Ve,ct,zt,Sn,pr)}catch(Ii){if(lr(gi),Ii!==Ii+0)throw Ii;kt(1,0)}},L:function(Z,xe,Ve,ct,zt,Sn,pr,gi){var Ii=or();try{return Mo(Z)(xe,Ve,ct,zt,Sn,pr,gi)}catch(ki){if(lr(Ii),ki!==ki+0)throw ki;kt(1,0)}},E:function(Z,xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo,pp){var fp=or();try{return Mo(Z)(xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo,pp)}catch(An){if(lr(fp),An!==An+0)throw An;kt(1,0)}},aa:function(Z,xe,Ve,ct,zt,Sn,pr,gi){var Ii=or();try{return tp(Z,xe,Ve,ct,zt,Sn,pr,gi)}catch(ki){if(lr(Ii),ki!==ki+0)throw ki;kt(1,0)}},_:function(Z,xe,Ve,ct,zt,Sn,pr){var gi=or();try{return Tc(Z,xe,Ve,ct,zt,Sn,pr)}catch(Ii){if(lr(gi),Ii!==Ii+0)throw Ii;kt(1,0)}},Z:function(Z,xe,Ve,ct,zt){var Sn=or();try{return yp(Z,xe,Ve,ct,zt)}catch(pr){if(lr(Sn),pr!==pr+0)throw pr;kt(1,0)}},ca:function(Z,xe,Ve,ct){var zt=or();try{return ip(Z,xe,Ve,ct)}catch(Sn){if(lr(zt),Sn!==Sn+0)throw Sn;kt(1,0)}},$:function(Z){var xe=or();try{return Hi(Z)}catch(Ve){if(lr(xe),Ve!==Ve+0)throw Ve;kt(1,0)}},ba:function(Z,xe){var Ve=or();try{return ep(Z,xe)}catch(ct){if(lr(Ve),ct!==ct+0)throw ct;kt(1,0)}},Y:function(Z,xe,Ve){var ct=or();try{return Uc(Z,xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},g:function(Z){var xe=or();try{Mo(Z)()}catch(Ve){if(lr(xe),Ve!==Ve+0)throw Ve;kt(1,0)}},r:function(Z,xe){var Ve=or();try{Mo(Z)(xe)}catch(ct){if(lr(Ve),ct!==ct+0)throw ct;kt(1,0)}},i:function(Z,xe,Ve){var ct=or();try{Mo(Z)(xe,Ve)}catch(zt){if(lr(ct),zt!==zt+0)throw zt;kt(1,0)}},ha:function(Z,xe,Ve,ct){var zt=or();try{Mo(Z)(xe,Ve,ct)}catch(Sn){if(lr(zt),Sn!==Sn+0)throw Sn;kt(1,0)}},m:function(Z,xe,Ve,ct){var zt=or();try{Mo(Z)(xe,Ve,ct)}catch(Sn){if(lr(zt),Sn!==Sn+0)throw Sn;kt(1,0)}},v:function(Z,xe,Ve,ct,zt){var Sn=or();try{Mo(Z)(xe,Ve,ct,zt)}catch(pr){if(lr(Sn),pr!==pr+0)throw pr;kt(1,0)}},u:function(Z,xe,Ve,ct,zt,Sn){var pr=or();try{Mo(Z)(xe,Ve,ct,zt,Sn)}catch(gi){if(lr(pr),gi!==gi+0)throw gi;kt(1,0)}},O:function(Z,xe,Ve,ct,zt,Sn,pr){var gi=or();try{Mo(Z)(xe,Ve,ct,zt,Sn,pr)}catch(Ii){if(lr(gi),Ii!==Ii+0)throw Ii;kt(1,0)}},A:function(Z,xe,Ve,ct,zt,Sn,pr,gi){var Ii=or();try{Mo(Z)(xe,Ve,ct,zt,Sn,pr,gi)}catch(ki){if(lr(Ii),ki!==ki+0)throw ki;kt(1,0)}},ka:function(Z,xe,Ve,ct,zt,Sn,pr,gi,Ii){var ki=or();try{Mo(Z)(xe,Ve,ct,zt,Sn,pr,gi,Ii)}catch(Zo){if(lr(ki),Zo!==Zo+0)throw Zo;kt(1,0)}},C:function(Z,xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo){var pp=or();try{Mo(Z)(xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo)}catch(fp){if(lr(pp),fp!==fp+0)throw fp;kt(1,0)}},D:function(Z,xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo,pp,fp,An,Ho,Bc){var s_=or();try{Mo(Z)(xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo,pp,fp,An,Ho,Bc)}catch(E_){if(lr(s_),E_!==E_+0)throw E_;kt(1,0)}},fa:function(Z,xe,Ve,ct,zt,Sn,pr,gi){var Ii=or();try{Cc(Z,xe,Ve,ct,zt,Sn,pr,gi)}catch(ki){if(lr(Ii),ki!==ki+0)throw ki;kt(1,0)}},da:function(Z,xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo,pp){var fp=or();try{Mc(Z,xe,Ve,ct,zt,Sn,pr,gi,Ii,ki,Zo,pp)}catch(An){if(lr(fp),An!==An+0)throw An;kt(1,0)}},ea:function(Z,xe,Ve,ct,zt,Sn){var pr=or();try{Lc(Z,xe,Ve,ct,zt,Sn)}catch(gi){if(lr(pr),gi!==gi+0)throw gi;kt(1,0)}},o:function(Z){return Z},a:Ce||i.wasmMemory,G:function(Z){Qc=Z},la:Mi,z:function(Z,xe,Ve,ct){return Mi(Z,xe,Ve,ct)}};(function(){function Z(zt,Sn){i.asm=zt.exports,Si.qc.push(i.asm.sb),In=i.asm.ub,cn.unshift(i.asm.Va),oe=Sn,R||(vn--,i.monitorRunDependencies&&i.monitorRunDependencies(vn),vn==0&&xi&&(zt=xi,xi=null,zt()))}function xe(zt){Z(zt.instance,zt.module)}function Ve(zt){return(function(){if(!q&&(C||I)){if(typeof fetch=="function"&&!ti.startsWith("file://"))return fetch(ti,{credentials:"same-origin"}).then((function(Sn){if(!Sn.ok)throw"failed to load wasm binary file at '"+ti+"'";return Sn.arrayBuffer()})).catch((function(){return mi()}));if(g)return new Promise((function(Sn,pr){g(ti,(function(gi){Sn(new Uint8Array(gi))}),pr)}))}return Promise.resolve().then((function(){return mi()}))})().then((function(Sn){return WebAssembly.instantiate(Sn,ct)})).then((function(Sn){return Sn})).then(zt,(function(Sn){H("failed to asynchronously prepare wasm: "+Sn),ir(Sn)}))}var ct={a:m_};if(R||(vn++,i.monitorRunDependencies&&i.monitorRunDependencies(vn)),i.instantiateWasm)try{return i.instantiateWasm(ct,Z)}catch(zt){return H("Module.instantiateWasm callback failed with error: "+zt),!1}(q||typeof WebAssembly.instantiateStreaming!="function"||ai()||ti.startsWith("file://")||D||typeof fetch!="function"?Ve(xe):fetch(ti,{credentials:"same-origin"}).then((function(zt){return WebAssembly.instantiateStreaming(zt,ct).then(xe,(function(Sn){return H("wasm streaming compile failed: "+Sn),H("falling back to ArrayBuffer instantiation"),Ve(xe)}))}))).catch(u)})(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.Va).apply(null,arguments)},i._OrtInit=function(){return(i._OrtInit=i.asm.Wa).apply(null,arguments)},i._OrtCreateSessionOptions=function(){return(i._OrtCreateSessionOptions=i.asm.Xa).apply(null,arguments)},i._OrtAppendExecutionProvider=function(){return(i._OrtAppendExecutionProvider=i.asm.Ya).apply(null,arguments)},i._OrtAddSessionConfigEntry=function(){return(i._OrtAddSessionConfigEntry=i.asm.Za).apply(null,arguments)},i._OrtReleaseSessionOptions=function(){return(i._OrtReleaseSessionOptions=i.asm._a).apply(null,arguments)},i._OrtCreateSession=function(){return(i._OrtCreateSession=i.asm.$a).apply(null,arguments)},i._OrtReleaseSession=function(){return(i._OrtReleaseSession=i.asm.ab).apply(null,arguments)},i._OrtGetInputCount=function(){return(i._OrtGetInputCount=i.asm.bb).apply(null,arguments)},i._OrtGetOutputCount=function(){return(i._OrtGetOutputCount=i.asm.cb).apply(null,arguments)},i._OrtGetInputName=function(){return(i._OrtGetInputName=i.asm.db).apply(null,arguments)},i._OrtGetOutputName=function(){return(i._OrtGetOutputName=i.asm.eb).apply(null,arguments)},i._OrtFree=function(){return(i._OrtFree=i.asm.fb).apply(null,arguments)},i._OrtCreateTensor=function(){return(i._OrtCreateTensor=i.asm.gb).apply(null,arguments)},i._OrtGetTensorData=function(){return(i._OrtGetTensorData=i.asm.hb).apply(null,arguments)},i._OrtReleaseTensor=function(){return(i._OrtReleaseTensor=i.asm.ib).apply(null,arguments)},i._OrtCreateRunOptions=function(){return(i._OrtCreateRunOptions=i.asm.jb).apply(null,arguments)},i._OrtAddRunConfigEntry=function(){return(i._OrtAddRunConfigEntry=i.asm.kb).apply(null,arguments)},i._OrtReleaseRunOptions=function(){return(i._OrtReleaseRunOptions=i.asm.lb).apply(null,arguments)},i._OrtRun=function(){return(i._OrtRun=i.asm.mb).apply(null,arguments)},i._OrtEndProfiling=function(){return(i._OrtEndProfiling=i.asm.nb).apply(null,arguments)};var Op=i._pthread_self=function(){return(Op=i._pthread_self=i.asm.ob).apply(null,arguments)},p_=i._malloc=function(){return(p_=i._malloc=i.asm.pb).apply(null,arguments)},Hc=i._free=function(){return(Hc=i._free=i.asm.qb).apply(null,arguments)},g_=i._fflush=function(){return(g_=i._fflush=i.asm.rb).apply(null,arguments)};i.__emscripten_tls_init=function(){return(i.__emscripten_tls_init=i.asm.sb).apply(null,arguments)};var T_=i.___funcs_on_exit=function(){return(T_=i.___funcs_on_exit=i.asm.tb).apply(null,arguments)},M_=i.__emscripten_thread_init=function(){return(M_=i.__emscripten_thread_init=i.asm.vb).apply(null,arguments)};i.__emscripten_thread_crashed=function(){return(i.__emscripten_thread_crashed=i.asm.wb).apply(null,arguments)};var Lt,X=i._emscripten_run_in_main_runtime_thread_js=function(){return(X=i._emscripten_run_in_main_runtime_thread_js=i.asm.xb).apply(null,arguments)},$e=i.__emscripten_proxy_execute_task_queue=function(){return($e=i.__emscripten_proxy_execute_task_queue=i.asm.yb).apply(null,arguments)},at=i.__emscripten_thread_free_data=function(){return(at=i.__emscripten_thread_free_data=i.asm.zb).apply(null,arguments)},ft=i.__emscripten_thread_exit=function(){return(ft=i.__emscripten_thread_exit=i.asm.Ab).apply(null,arguments)},kt=i._setThrew=function(){return(kt=i._setThrew=i.asm.Bb).apply(null,arguments)},sr=i._emscripten_stack_set_limits=function(){return(sr=i._emscripten_stack_set_limits=i.asm.Cb).apply(null,arguments)},or=i.stackSave=function(){return(or=i.stackSave=i.asm.Db).apply(null,arguments)},lr=i.stackRestore=function(){return(lr=i.stackRestore=i.asm.Eb).apply(null,arguments)},yi=i.stackAlloc=function(){return(yi=i.stackAlloc=i.asm.Fb).apply(null,arguments)},di=i.___cxa_can_catch=function(){return(di=i.___cxa_can_catch=i.asm.Gb).apply(null,arguments)},zo=i.___cxa_is_pointer_type=function(){return(zo=i.___cxa_is_pointer_type=i.asm.Hb).apply(null,arguments)},Hi=i.dynCall_j=function(){return(Hi=i.dynCall_j=i.asm.Ib).apply(null,arguments)},Tc=i.dynCall_iiiiij=function(){return(Tc=i.dynCall_iiiiij=i.asm.Jb).apply(null,arguments)},Uc=i.dynCall_jii=function(){return(Uc=i.dynCall_jii=i.asm.Kb).apply(null,arguments)},Cc=i.dynCall_viiiiij=function(){return(Cc=i.dynCall_viiiiij=i.asm.Lb).apply(null,arguments)},Lc=i.dynCall_vjji=function(){return(Lc=i.dynCall_vjji=i.asm.Mb).apply(null,arguments)},Mc=i.dynCall_viiijjjii=function(){return(Mc=i.dynCall_viiijjjii=i.asm.Nb).apply(null,arguments)},ip=i.dynCall_iij=function(){return(ip=i.dynCall_iij=i.asm.Ob).apply(null,arguments)},ep=i.dynCall_ji=function(){return(ep=i.dynCall_ji=i.asm.Pb).apply(null,arguments)},tp=i.dynCall_iiiiiij=function(){return(tp=i.dynCall_iiiiiij=i.asm.Qb).apply(null,arguments)},yp=i.dynCall_iiij=function(){return(yp=i.dynCall_iiij=i.asm.Rb).apply(null,arguments)};function wc(){function Z(){if(!Lt&&(Lt=!0,i.calledRun=!0,!Gt)&&(R||zc(cn),r(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),!R)){if(i.postRun)for(typeof i.postRun=="function"&&(i.postRun=[i.postRun]);i.postRun.length;){var xe=i.postRun.shift();yn.unshift(xe)}zc(yn)}}if(!(0<vn))if(R)r(i),R||zc(cn),postMessage({cmd:"loaded"});else{if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)cr();zc(Tn),0<vn||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1),Z()}),1)):Z())}}if(i.UTF8ToString=hn,i.stringToUTF8=function(Z,xe,Ve){return ze(Z,_(),xe,Ve)},i.lengthBytesUTF8=wt,i.keepRuntimeAlive=$n,i.wasmMemory=Ce,i.stackSave=or,i.stackRestore=lr,i.stackAlloc=yi,i.ExitStatus=ui,i.PThread=Si,xi=function Z(){Lt||wc(),Lt||(xi=Z)},i.preInit)for(typeof i.preInit=="function"&&(i.preInit=[i.preInit]);0<i.preInit.length;)i.preInit.pop()();return wc(),c.ready});n.exports=a},932:(n,e,t)=>{var s,a=(s=(s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(c){var l,_,m;c=c||{},l||(l=c!==void 0?c:{}),l.ready=new Promise((function(we,it){_=we,m=it}));var d,h,i,r,u,f,g=Object.assign({},l),w="./this.program",y=(we,it)=>{throw it},x=typeof window=="object",S=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",E="";T?(E=S?t(908).dirname(E)+"/":"//",f=()=>{u||(r=t(1384),u=t(908))},d=function(we,it){return f(),we=u.normalize(we),r.readFileSync(we,it?void 0:"utf8")},i=we=>((we=d(we,!0)).buffer||(we=new Uint8Array(we)),we),h=(we,it,pt)=>{f(),we=u.normalize(we),r.readFile(we,(function(Ot,Ht){Ot?pt(Ot):it(Ht.buffer)}))},1<process.argv.length&&(w=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(we){if(!(we instanceof cn))throw we})),process.on("unhandledRejection",(function(we){throw we})),y=(we,it)=>{if(D||0<bn)throw process.exitCode=we,it;it instanceof cn||I("exiting due to exception: "+it),process.exit(we)},l.inspect=function(){return"[Emscripten Module object]"}):(x||S)&&(S?E=self.location.href:typeof document<"u"&&document.currentScript&&(E=document.currentScript.src),s&&(E=s),E=E.indexOf("blob:")!==0?E.substr(0,E.replace(/[?#].*/,"").lastIndexOf("/")+1):"",d=we=>{var it=new XMLHttpRequest;return it.open("GET",we,!1),it.send(null),it.responseText},S&&(i=we=>{var it=new XMLHttpRequest;return it.open("GET",we,!1),it.responseType="arraybuffer",it.send(null),new Uint8Array(it.response)}),h=(we,it,pt)=>{var Ot=new XMLHttpRequest;Ot.open("GET",we,!0),Ot.responseType="arraybuffer",Ot.onload=()=>{Ot.status==200||Ot.status==0&&Ot.response?it(Ot.response):pt()},Ot.onerror=pt,Ot.send(null)});var A,C=l.print||console.log.bind(console),I=l.printErr||console.warn.bind(console);Object.assign(l,g),g=null,l.thisProgram&&(w=l.thisProgram),l.quit&&(y=l.quit),l.wasmBinary&&(A=l.wasmBinary);var D=l.noExitRuntime||!1;typeof WebAssembly!="object"&&ke("no native wasm support detected");var R,Y,re,G,te,q,z=!1,H=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function he(we,it,pt){var Ot=(it>>>=0)+pt;for(pt=it;we[pt]&&!(pt>=Ot);)++pt;if(16<pt-it&&we.buffer&&H)return H.decode(we.subarray(it,pt));for(Ot="";it<pt;){var Ht=we[it++];if(128&Ht){var mn=63&we[it++];if((224&Ht)==192)Ot+=String.fromCharCode((31&Ht)<<6|mn);else{var ii=63&we[it++];65536>(Ht=(240&Ht)==224?(15&Ht)<<12|mn<<6|ii:(7&Ht)<<18|mn<<12|ii<<6|63&we[it++])?Ot+=String.fromCharCode(Ht):(Ht-=65536,Ot+=String.fromCharCode(55296|Ht>>10,56320|1023&Ht))}}else Ot+=String.fromCharCode(Ht)}return Ot}function Ce(we,it){return(we>>>=0)?he(G,we,it):""}function oe(we,it,pt,Ot){if(!(0<Ot))return 0;var Ht=pt>>>=0;Ot=pt+Ot-1;for(var mn=0;mn<we.length;++mn){var ii=we.charCodeAt(mn);if(55296<=ii&&57343>=ii&&(ii=65536+((1023&ii)<<10)|1023&we.charCodeAt(++mn)),127>=ii){if(pt>=Ot)break;it[pt++>>>0]=ii}else{if(2047>=ii){if(pt+1>=Ot)break;it[pt++>>>0]=192|ii>>6}else{if(65535>=ii){if(pt+2>=Ot)break;it[pt++>>>0]=224|ii>>12}else{if(pt+3>=Ot)break;it[pt++>>>0]=240|ii>>18,it[pt++>>>0]=128|ii>>12&63}it[pt++>>>0]=128|ii>>6&63}it[pt++>>>0]=128|63&ii}}return it[pt>>>0]=0,pt-Ht}function K(we){for(var it=0,pt=0;pt<we.length;++pt){var Ot=we.charCodeAt(pt);127>=Ot?it++:2047>=Ot?it+=2:55296<=Ot&&57343>=Ot?(it+=4,++pt):it+=3}return it}function Q(){var we=R.buffer;Y=we,l.HEAP8=re=new Int8Array(we),l.HEAP16=new Int16Array(we),l.HEAP32=te=new Int32Array(we),l.HEAPU8=G=new Uint8Array(we),l.HEAPU16=new Uint16Array(we),l.HEAPU32=q=new Uint32Array(we),l.HEAPF32=new Float32Array(we),l.HEAPF64=new Float64Array(we)}var de,ue=[],Ze=[],Pt=[],Gt=[],bn=0;function ri(){var we=l.preRun.shift();ue.unshift(we)}var hn,ze=0,wt=null;function ke(we){throw l.onAbort&&l.onAbort(we),I(we="Aborted("+we+")"),z=!0,we=new WebAssembly.RuntimeError(we+". Build with -sASSERTIONS for more info."),m(we),we}function Bt(){return hn.startsWith("data:application/octet-stream;base64,")}if(hn="ort-wasm.wasm",!Bt()){var In=hn;hn=l.locateFile?l.locateFile(In,E):E+In}function Tn(){var we=hn;try{if(we==hn&&A)return new Uint8Array(A);if(i)return i(we);throw"both async and sync fetching of the wasm failed"}catch(it){ke(it)}}function cn(we){this.name="ExitStatus",this.message="Program terminated with exit("+we+")",this.status=we}function kn(we){for(;0<we.length;)we.shift()(l)}var yn=[],$n=0,cr=0;function ti(we){this.Db=we,this.zb=we-24,this.Ub=function(it){q[this.zb+4>>2>>>0]=it},this.Eb=function(){return q[this.zb+4>>2>>>0]},this.Sb=function(it){q[this.zb+8>>2>>>0]=it},this.Wb=function(){return q[this.zb+8>>2>>>0]},this.Tb=function(){te[this.zb>>2>>>0]=0},this.Ib=function(it){re[this.zb+12>>0>>>0]=it?1:0},this.Pb=function(){return re[this.zb+12>>0>>>0]!=0},this.Jb=function(it){re[this.zb+13>>0>>>0]=it?1:0},this.Lb=function(){return re[this.zb+13>>0>>>0]!=0},this.Rb=function(it,pt){this.Fb(0),this.Ub(it),this.Sb(pt),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){te[this.zb>>2>>>0]+=1},this.Xb=function(){var it=te[this.zb>>2>>>0];return te[this.zb>>2>>>0]=it-1,it===1},this.Fb=function(it){q[this.zb+16>>2>>>0]=it},this.Ob=function(){return q[this.zb+16>>2>>>0]},this.Qb=function(){if(Rp(this.Eb()))return q[this.Db>>2>>>0];var it=this.Ob();return it!==0?it:this.Db}}function vn(we){return $p(new ti(we).zb)}var xi=[];function ir(we){var it=xi[we];return it||(we>=xi.length&&(xi.length=we+1),xi[we]=it=de.get(we)),it}function ai(we){var it=K(we)+1,pt=Mo(it);return pt&&oe(we,re,pt,it),pt}var mi={};function fi(){if(!ui){var we,it={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:w||"./this.program"};for(we in mi)mi[we]===void 0?delete it[we]:it[we]=mi[we];var pt=[];for(we in it)pt.push(we+"="+it[we]);ui=pt}return ui}var ui,wi=[null,[],[]];function Lo(we,it){var pt=wi[we];it===0||it===10?((we===1?C:I)(he(pt,0)),pt.length=0):pt.push(it)}var zi=0;function Ci(we){return we%4==0&&(we%100!=0||we%400==0)}var Si=[31,29,31,30,31,30,31,31,30,31,30,31],zc=[31,28,31,30,31,30,31,31,30,31,30,31];function Xc(we,it,pt,Ot){function Ht(En,Oi,Ro){for(En=typeof En=="number"?En.toString():En||"";En.length<Oi;)En=Ro[0]+En;return En}function mn(En,Oi){return Ht(En,Oi,"0")}function ii(En,Oi){function Ro(Oc){return 0>Oc?-1:0<Oc?1:0}var bc;return(bc=Ro(En.getFullYear()-Oi.getFullYear()))===0&&(bc=Ro(En.getMonth()-Oi.getMonth()))===0&&(bc=Ro(En.getDate()-Oi.getDate())),bc}function Ti(En){switch(En.getDay()){case 0:return new Date(En.getFullYear()-1,11,29);case 1:return En;case 2:return new Date(En.getFullYear(),0,3);case 3:return new Date(En.getFullYear(),0,2);case 4:return new Date(En.getFullYear(),0,1);case 5:return new Date(En.getFullYear()-1,11,31);case 6:return new Date(En.getFullYear()-1,11,30)}}function pi(En){var Oi=En.Bb;for(En=new Date(new Date(En.Cb+1900,0,1).getTime());0<Oi;){var Ro=En.getMonth(),bc=(Ci(En.getFullYear())?Si:zc)[Ro];if(!(Oi>bc-En.getDate())){En.setDate(En.getDate()+Oi);break}Oi-=bc-En.getDate()+1,En.setDate(1),11>Ro?En.setMonth(Ro+1):(En.setMonth(0),En.setFullYear(En.getFullYear()+1))}return Ro=new Date(En.getFullYear()+1,0,4),Oi=Ti(new Date(En.getFullYear(),0,4)),Ro=Ti(Ro),0>=ii(Oi,En)?0>=ii(Ro,En)?En.getFullYear()+1:En.getFullYear():En.getFullYear()-1}var Do=te[Ot+40>>2>>>0];for(var Ko in Ot={$b:te[Ot>>2>>>0],Zb:te[Ot+4>>2>>>0],Gb:te[Ot+8>>2>>>0],Kb:te[Ot+12>>2>>>0],Hb:te[Ot+16>>2>>>0],Cb:te[Ot+20>>2>>>0],Ab:te[Ot+24>>2>>>0],Bb:te[Ot+28>>2>>>0],bc:te[Ot+32>>2>>>0],Yb:te[Ot+36>>2>>>0],ac:Do?Ce(Do):""},pt=Ce(pt),Do={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})pt=pt.replace(new RegExp(Ko,"g"),Do[Ko]);var yc="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Dc="January February March April May June July August September October November December".split(" ");for(Ko in Do={"%a":function(En){return yc[En.Ab].substring(0,3)},"%A":function(En){return yc[En.Ab]},"%b":function(En){return Dc[En.Hb].substring(0,3)},"%B":function(En){return Dc[En.Hb]},"%C":function(En){return mn((En.Cb+1900)/100|0,2)},"%d":function(En){return mn(En.Kb,2)},"%e":function(En){return Ht(En.Kb,2," ")},"%g":function(En){return pi(En).toString().substring(2)},"%G":function(En){return pi(En)},"%H":function(En){return mn(En.Gb,2)},"%I":function(En){return(En=En.Gb)==0?En=12:12<En&&(En-=12),mn(En,2)},"%j":function(En){for(var Oi=0,Ro=0;Ro<=En.Hb-1;Oi+=(Ci(En.Cb+1900)?Si:zc)[Ro++]);return mn(En.Kb+Oi,3)},"%m":function(En){return mn(En.Hb+1,2)},"%M":function(En){return mn(En.Zb,2)},"%n":function(){return`
`},"%p":function(En){return 0<=En.Gb&&12>En.Gb?"AM":"PM"},"%S":function(En){return mn(En.$b,2)},"%t":function(){return"	"},"%u":function(En){return En.Ab||7},"%U":function(En){return mn(Math.floor((En.Bb+7-En.Ab)/7),2)},"%V":function(En){var Oi=Math.floor((En.Bb+7-(En.Ab+6)%7)/7);if(2>=(En.Ab+371-En.Bb-2)%7&&Oi++,Oi)Oi==53&&((Ro=(En.Ab+371-En.Bb)%7)==4||Ro==3&&Ci(En.Cb)||(Oi=1));else{Oi=52;var Ro=(En.Ab+7-En.Bb-1)%7;(Ro==4||Ro==5&&Ci(En.Cb%400-1))&&Oi++}return mn(Oi,2)},"%w":function(En){return En.Ab},"%W":function(En){return mn(Math.floor((En.Bb+7-(En.Ab+6)%7)/7),2)},"%y":function(En){return(En.Cb+1900).toString().substring(2)},"%Y":function(En){return En.Cb+1900},"%z":function(En){var Oi=0<=(En=En.Yb);return En=Math.abs(En)/60,(Oi?"+":"-")+("0000"+(En/60*100+En%60)).slice(-4)},"%Z":function(En){return En.ac},"%%":function(){return"%"}},pt=pt.replace(/%%/g,"\0\0"),Do)pt.includes(Ko)&&(pt=pt.replace(new RegExp(Ko,"g"),Do[Ko](Ot)));return Ko=(function(En){var Oi=Array(K(En)+1);return oe(En,Oi,0,Oi.length),Oi})(pt=pt.replace(/\0\0/g,"%")),Ko.length>it?0:(re.set(Ko,we>>>0),Ko.length-1)}var up={a:function(we){return Mo(we+24)+24},m:function(we){return(we=new ti(we)).Pb()||(we.Ib(!0),$n--),we.Jb(!1),yn.push(we),we.Nb(),we.Qb()},ia:function(we){throw I("Unexpected exception thrown, this is not properly supported - aborting"),z=!0,we},w:function(){Wi(0);var we=yn.pop();if(we.Xb()&&!we.Lb()){var it=we.Wb();it&&ir(it)(we.Db),vn(we.Db)}cr=0},d:function(){var we=cr;if(!we)return zi=0;var it=new ti(we);it.Fb(we);var pt=it.Eb();if(!pt)return zi=0,we;for(var Ot=Array.prototype.slice.call(arguments),Ht=0;Ht<Ot.length;Ht++){var mn=Ot[Ht];if(mn===0||mn===pt)break;if(Ui(mn,pt,it.zb+16))return zi=mn,we}return zi=pt,we},k:function(){var we=cr;if(!we)return zi=0;var it=new ti(we);it.Fb(we);var pt=it.Eb();if(!pt)return zi=0,we;for(var Ot=Array.prototype.slice.call(arguments),Ht=0;Ht<Ot.length;Ht++){var mn=Ot[Ht];if(mn===0||mn===pt)break;if(Ui(mn,pt,it.zb+16))return zi=mn,we}return zi=pt,we},g:function(){var we=cr;if(!we)return zi=0;var it=new ti(we);it.Fb(we);var pt=it.Eb();if(!pt)return zi=0,we;for(var Ot=Array.prototype.slice.call(arguments),Ht=0;Ht<Ot.length;Ht++){var mn=Ot[Ht];if(mn===0||mn===pt)break;if(Ui(mn,pt,it.zb+16))return zi=mn,we}return zi=pt,we},s:vn,L:function(){var we=yn.pop();we||ke("no exception to throw");var it=we.Db;throw we.Lb()||(yn.push(we),we.Jb(!0),we.Ib(!1),$n++),cr=it,it},b:function(we,it,pt){throw new ti(we).Rb(it,pt),cr=we,$n++,we},la:function(){return $n},i:function(we){throw cr||(cr=we),we},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){ke("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){ke("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(we,it){we=new Date(1e3*(q[we>>>2]+4294967296*te[we+4>>>2])),te[it>>2>>>0]=we.getUTCSeconds(),te[it+4>>2>>>0]=we.getUTCMinutes(),te[it+8>>2>>>0]=we.getUTCHours(),te[it+12>>2>>>0]=we.getUTCDate(),te[it+16>>2>>>0]=we.getUTCMonth(),te[it+20>>2>>>0]=we.getUTCFullYear()-1900,te[it+24>>2>>>0]=we.getUTCDay(),te[it+28>>2>>>0]=(we.getTime()-Date.UTC(we.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(we,it){we=new Date(1e3*(q[we>>>2]+4294967296*te[we+4>>>2])),te[it>>2>>>0]=we.getSeconds(),te[it+4>>2>>>0]=we.getMinutes(),te[it+8>>2>>>0]=we.getHours(),te[it+12>>2>>>0]=we.getDate(),te[it+16>>2>>>0]=we.getMonth(),te[it+20>>2>>>0]=we.getFullYear()-1900,te[it+24>>2>>>0]=we.getDay();var pt=new Date(we.getFullYear(),0,1);te[it+28>>2>>>0]=(we.getTime()-pt.getTime())/864e5|0,te[it+36>>2>>>0]=-60*we.getTimezoneOffset();var Ot=new Date(we.getFullYear(),6,1).getTimezoneOffset();pt=pt.getTimezoneOffset(),te[it+32>>2>>>0]=0|(Ot!=pt&&we.getTimezoneOffset()==Math.min(pt,Ot))},Fa:function(we){var it=new Date(te[we+20>>2>>>0]+1900,te[we+16>>2>>>0],te[we+12>>2>>>0],te[we+8>>2>>>0],te[we+4>>2>>>0],te[we>>2>>>0],0),pt=te[we+32>>2>>>0],Ot=it.getTimezoneOffset(),Ht=new Date(it.getFullYear(),0,1),mn=new Date(it.getFullYear(),6,1).getTimezoneOffset(),ii=Ht.getTimezoneOffset(),Ti=Math.min(ii,mn);return 0>pt?te[we+32>>2>>>0]=+(mn!=ii&&Ti==Ot):0<pt!=(Ti==Ot)&&(mn=Math.max(ii,mn),it.setTime(it.getTime()+6e4*((0<pt?Ti:mn)-Ot))),te[we+24>>2>>>0]=it.getDay(),te[we+28>>2>>>0]=(it.getTime()-Ht.getTime())/864e5|0,te[we>>2>>>0]=it.getSeconds(),te[we+4>>2>>>0]=it.getMinutes(),te[we+8>>2>>>0]=it.getHours(),te[we+12>>2>>>0]=it.getDate(),te[we+16>>2>>>0]=it.getMonth(),it.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function we(it,pt,Ot){we.Vb||(we.Vb=!0,(function(Ht,mn,ii){function Ti(Dc){return(Dc=Dc.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Dc[1]:"GMT"}var pi=new Date().getFullYear(),Do=new Date(pi,0,1),Ko=new Date(pi,6,1);pi=Do.getTimezoneOffset();var yc=Ko.getTimezoneOffset();te[Ht>>2>>>0]=60*Math.max(pi,yc),te[mn>>2>>>0]=+(pi!=yc),Ht=Ti(Do),mn=Ti(Ko),Ht=ai(Ht),mn=ai(mn),yc<pi?(q[ii>>2>>>0]=Ht,q[ii+4>>2>>>0]=mn):(q[ii>>2>>>0]=mn,q[ii+4>>2>>>0]=Ht)})(it,pt,Ot))},B:function(){ke("")},ma:function(){return 4294901760},I:T?()=>{var we=process.hrtime();return 1e3*we[0]+we[1]/1e6}:()=>performance.now(),xa:function(we,it,pt){G.copyWithin(we>>>0,it>>>0,it+pt>>>0)},G:function(we){var it=G.length;if(4294901760<(we>>>=0))return!1;for(var pt=1;4>=pt;pt*=2){var Ot=it*(1+.2/pt);Ot=Math.min(Ot,we+100663296);var Ht=Math;Ot=Math.max(we,Ot),Ht=Ht.min.call(Ht,4294901760,Ot+(65536-Ot%65536)%65536);e:{try{R.grow(Ht-Y.byteLength+65535>>>16),Q();var mn=1;break e}catch{}mn=void 0}if(mn)return!0}return!1},va:function(we,it){var pt=0;return fi().forEach((function(Ot,Ht){var mn=it+pt;for(Ht=q[we+4*Ht>>2>>>0]=mn,mn=0;mn<Ot.length;++mn)re[Ht++>>0>>>0]=Ot.charCodeAt(mn);re[Ht>>0>>>0]=0,pt+=Ot.length+1})),0},wa:function(we,it){var pt=fi();q[we>>2>>>0]=pt.length;var Ot=0;return pt.forEach((function(Ht){Ot+=Ht.length+1})),q[it>>2>>>0]=Ot,0},ba:function(we){D||0<bn||(cp(),kn(Pt),rf(0),wi[1].length&&Lo(1,10),wi[2].length&&Lo(2,10)),D||0<bn||(l.onExit&&l.onExit(we),z=!0),y(we,new cn(we))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(we,it,pt,Ot){for(var Ht=0,mn=0;mn<pt;mn++){var ii=q[it>>2>>>0],Ti=q[it+4>>2>>>0];it+=8;for(var pi=0;pi<Ti;pi++)Lo(we,G[ii+pi>>>0]);Ht+=Ti}return q[Ot>>2>>>0]=Ht,0},c:function(){return zi},ja:function we(it,pt){we.Mb||(we.Mb=(function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Ht=new Uint8Array(1);return()=>(crypto.getRandomValues(Ht),Ht[0])}if(T)try{var mn=t(Object((function(){var ii=new Error("Cannot find module 'crypto'");throw ii.code="MODULE_NOT_FOUND",ii})()));return()=>mn.randomBytes(1)[0]}catch{}return()=>ke("randomDevice")})());for(var Ot=0;Ot<pt;Ot++)re[it+Ot>>0>>>0]=we.Mb();return 0},ea:function(we,it,pt){var Ot=si();try{return ir(we)(it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},fa:function(we,it,pt){var Ot=si();try{return ir(we)(it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},J:function(we){var it=si();try{return ir(we)()}catch(pt){if(Ri(it),pt!==pt+0)throw pt;Wi(1,0)}},e:function(we,it){var pt=si();try{return ir(we)(it)}catch(Ot){if(Ri(pt),Ot!==Ot+0)throw Ot;Wi(1,0)}},N:function(we,it,pt){var Ot=si();try{return ir(we)(it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},O:function(we,it,pt){var Ot=si();try{return ir(we)(it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},j:function(we,it,pt){var Ot=si();try{return ir(we)(it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},o:function(we,it,pt,Ot){var Ht=si();try{return ir(we)(it,pt,Ot)}catch(mn){if(Ri(Ht),mn!==mn+0)throw mn;Wi(1,0)}},p:function(we,it,pt,Ot,Ht){var mn=si();try{return ir(we)(it,pt,Ot,Ht)}catch(ii){if(Ri(mn),ii!==ii+0)throw ii;Wi(1,0)}},M:function(we,it,pt,Ot,Ht,mn){var ii=si();try{return ir(we)(it,pt,Ot,Ht,mn)}catch(Ti){if(Ri(ii),Ti!==Ti+0)throw Ti;Wi(1,0)}},r:function(we,it,pt,Ot,Ht,mn){var ii=si();try{return ir(we)(it,pt,Ot,Ht,mn)}catch(Ti){if(Ri(ii),Ti!==Ti+0)throw Ti;Wi(1,0)}},v:function(we,it,pt,Ot,Ht,mn,ii){var Ti=si();try{return ir(we)(it,pt,Ot,Ht,mn,ii)}catch(pi){if(Ri(Ti),pi!==pi+0)throw pi;Wi(1,0)}},K:function(we,it,pt,Ot,Ht,mn,ii,Ti){var pi=si();try{return ir(we)(it,pt,Ot,Ht,mn,ii,Ti)}catch(Do){if(Ri(pi),Do!==Do+0)throw Do;Wi(1,0)}},D:function(we,it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko,yc){var Dc=si();try{return ir(we)(it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko,yc)}catch(En){if(Ri(Dc),En!==En+0)throw En;Wi(1,0)}},X:function(we,it,pt,Ot,Ht,mn,ii,Ti){var pi=si();try{return Pi(we,it,pt,Ot,Ht,mn,ii,Ti)}catch(Do){if(Ri(pi),Do!==Do+0)throw Do;Wi(1,0)}},V:function(we,it,pt,Ot,Ht,mn,ii){var Ti=si();try{return Qe(we,it,pt,Ot,Ht,mn,ii)}catch(pi){if(Ri(Ti),pi!==pi+0)throw pi;Wi(1,0)}},U:function(we,it,pt,Ot,Ht){var mn=si();try{return hi(we,it,pt,Ot,Ht)}catch(ii){if(Ri(mn),ii!==ii+0)throw ii;Wi(1,0)}},Z:function(we,it,pt,Ot){var Ht=si();try{return ar(we,it,pt,Ot)}catch(mn){if(Ri(Ht),mn!==mn+0)throw mn;Wi(1,0)}},W:function(we){var it=si();try{return W(we)}catch(pt){if(Ri(it),pt!==pt+0)throw pt;Wi(1,0)}},Y:function(we,it){var pt=si();try{return vi(we,it)}catch(Ot){if(Ri(pt),Ot!==Ot+0)throw Ot;Wi(1,0)}},T:function(we,it,pt){var Ot=si();try{return ve(we,it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},f:function(we){var it=si();try{ir(we)()}catch(pt){if(Ri(it),pt!==pt+0)throw pt;Wi(1,0)}},q:function(we,it){var pt=si();try{ir(we)(it)}catch(Ot){if(Ri(pt),Ot!==Ot+0)throw Ot;Wi(1,0)}},h:function(we,it,pt){var Ot=si();try{ir(we)(it,pt)}catch(Ht){if(Ri(Ot),Ht!==Ht+0)throw Ht;Wi(1,0)}},da:function(we,it,pt,Ot){var Ht=si();try{ir(we)(it,pt,Ot)}catch(mn){if(Ri(Ht),mn!==mn+0)throw mn;Wi(1,0)}},l:function(we,it,pt,Ot){var Ht=si();try{ir(we)(it,pt,Ot)}catch(mn){if(Ri(Ht),mn!==mn+0)throw mn;Wi(1,0)}},t:function(we,it,pt,Ot,Ht){var mn=si();try{ir(we)(it,pt,Ot,Ht)}catch(ii){if(Ri(mn),ii!==ii+0)throw ii;Wi(1,0)}},u:function(we,it,pt,Ot,Ht,mn){var ii=si();try{ir(we)(it,pt,Ot,Ht,mn)}catch(Ti){if(Ri(ii),Ti!==Ti+0)throw Ti;Wi(1,0)}},x:function(we,it,pt,Ot,Ht,mn,ii){var Ti=si();try{ir(we)(it,pt,Ot,Ht,mn,ii)}catch(pi){if(Ri(Ti),pi!==pi+0)throw pi;Wi(1,0)}},z:function(we,it,pt,Ot,Ht,mn,ii,Ti){var pi=si();try{ir(we)(it,pt,Ot,Ht,mn,ii,Ti)}catch(Do){if(Ri(pi),Do!==Do+0)throw Do;Wi(1,0)}},ga:function(we,it,pt,Ot,Ht,mn,ii,Ti,pi){var Do=si();try{ir(we)(it,pt,Ot,Ht,mn,ii,Ti,pi)}catch(Ko){if(Ri(Do),Ko!==Ko+0)throw Ko;Wi(1,0)}},A:function(we,it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko){var yc=si();try{ir(we)(it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko)}catch(Dc){if(Ri(yc),Dc!==Dc+0)throw Dc;Wi(1,0)}},C:function(we,it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko,yc,Dc,En,Oi,Ro){var bc=si();try{ir(we)(it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko,yc,Dc,En,Oi,Ro)}catch(Oc){if(Ri(bc),Oc!==Oc+0)throw Oc;Wi(1,0)}},aa:function(we,it,pt,Ot,Ht,mn,ii,Ti){var pi=si();try{Ke(we,it,pt,Ot,Ht,mn,ii,Ti)}catch(Do){if(Ri(pi),Do!==Do+0)throw Do;Wi(1,0)}},_:function(we,it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko,yc){var Dc=si();try{_n(we,it,pt,Ot,Ht,mn,ii,Ti,pi,Do,Ko,yc)}catch(En){if(Ri(Dc),En!==En+0)throw En;Wi(1,0)}},$:function(we,it,pt,Ot,Ht,mn){var ii=si();try{lt(we,it,pt,Ot,Ht,mn)}catch(Ti){if(Ri(ii),Ti!==Ti+0)throw Ti;Wi(1,0)}},n:function(we){return we},F:function(we){zi=we},ha:Xc,y:function(we,it,pt,Ot){return Xc(we,it,pt,Ot)}};(function(){function we(Ht){l.asm=Ht.exports,R=l.asm.Ka,Q(),de=l.asm.ib,Ze.unshift(l.asm.La),ze--,l.monitorRunDependencies&&l.monitorRunDependencies(ze),ze==0&&wt&&(Ht=wt,wt=null,Ht())}function it(Ht){we(Ht.instance)}function pt(Ht){return(function(){if(!A&&(x||S)){if(typeof fetch=="function"&&!hn.startsWith("file://"))return fetch(hn,{credentials:"same-origin"}).then((function(mn){if(!mn.ok)throw"failed to load wasm binary file at '"+hn+"'";return mn.arrayBuffer()})).catch((function(){return Tn()}));if(h)return new Promise((function(mn,ii){h(hn,(function(Ti){mn(new Uint8Array(Ti))}),ii)}))}return Promise.resolve().then((function(){return Tn()}))})().then((function(mn){return WebAssembly.instantiate(mn,Ot)})).then((function(mn){return mn})).then(Ht,(function(mn){I("failed to asynchronously prepare wasm: "+mn),ke(mn)}))}var Ot={a:up};if(ze++,l.monitorRunDependencies&&l.monitorRunDependencies(ze),l.instantiateWasm)try{return l.instantiateWasm(Ot,we)}catch(Ht){return I("Module.instantiateWasm callback failed with error: "+Ht),!1}(A||typeof WebAssembly.instantiateStreaming!="function"||Bt()||hn.startsWith("file://")||T||typeof fetch!="function"?pt(it):fetch(hn,{credentials:"same-origin"}).then((function(Ht){return WebAssembly.instantiateStreaming(Ht,Ot).then(it,(function(mn){return I("wasm streaming compile failed: "+mn),I("falling back to ArrayBuffer instantiation"),pt(it)}))}))).catch(m)})(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.La).apply(null,arguments)},l._OrtInit=function(){return(l._OrtInit=l.asm.Ma).apply(null,arguments)},l._OrtCreateSessionOptions=function(){return(l._OrtCreateSessionOptions=l.asm.Na).apply(null,arguments)},l._OrtAppendExecutionProvider=function(){return(l._OrtAppendExecutionProvider=l.asm.Oa).apply(null,arguments)},l._OrtAddSessionConfigEntry=function(){return(l._OrtAddSessionConfigEntry=l.asm.Pa).apply(null,arguments)},l._OrtReleaseSessionOptions=function(){return(l._OrtReleaseSessionOptions=l.asm.Qa).apply(null,arguments)},l._OrtCreateSession=function(){return(l._OrtCreateSession=l.asm.Ra).apply(null,arguments)},l._OrtReleaseSession=function(){return(l._OrtReleaseSession=l.asm.Sa).apply(null,arguments)},l._OrtGetInputCount=function(){return(l._OrtGetInputCount=l.asm.Ta).apply(null,arguments)},l._OrtGetOutputCount=function(){return(l._OrtGetOutputCount=l.asm.Ua).apply(null,arguments)},l._OrtGetInputName=function(){return(l._OrtGetInputName=l.asm.Va).apply(null,arguments)},l._OrtGetOutputName=function(){return(l._OrtGetOutputName=l.asm.Wa).apply(null,arguments)},l._OrtFree=function(){return(l._OrtFree=l.asm.Xa).apply(null,arguments)},l._OrtCreateTensor=function(){return(l._OrtCreateTensor=l.asm.Ya).apply(null,arguments)},l._OrtGetTensorData=function(){return(l._OrtGetTensorData=l.asm.Za).apply(null,arguments)},l._OrtReleaseTensor=function(){return(l._OrtReleaseTensor=l.asm._a).apply(null,arguments)},l._OrtCreateRunOptions=function(){return(l._OrtCreateRunOptions=l.asm.$a).apply(null,arguments)},l._OrtAddRunConfigEntry=function(){return(l._OrtAddRunConfigEntry=l.asm.ab).apply(null,arguments)},l._OrtReleaseRunOptions=function(){return(l._OrtReleaseRunOptions=l.asm.bb).apply(null,arguments)},l._OrtRun=function(){return(l._OrtRun=l.asm.cb).apply(null,arguments)},l._OrtEndProfiling=function(){return(l._OrtEndProfiling=l.asm.db).apply(null,arguments)};var Jo,Mo=l._malloc=function(){return(Mo=l._malloc=l.asm.eb).apply(null,arguments)},$p=l._free=function(){return($p=l._free=l.asm.fb).apply(null,arguments)},rf=l._fflush=function(){return(rf=l._fflush=l.asm.gb).apply(null,arguments)},cp=l.___funcs_on_exit=function(){return(cp=l.___funcs_on_exit=l.asm.hb).apply(null,arguments)},Wi=l._setThrew=function(){return(Wi=l._setThrew=l.asm.jb).apply(null,arguments)},si=l.stackSave=function(){return(si=l.stackSave=l.asm.kb).apply(null,arguments)},Ri=l.stackRestore=function(){return(Ri=l.stackRestore=l.asm.lb).apply(null,arguments)},_c=l.stackAlloc=function(){return(_c=l.stackAlloc=l.asm.mb).apply(null,arguments)},Ui=l.___cxa_can_catch=function(){return(Ui=l.___cxa_can_catch=l.asm.nb).apply(null,arguments)},Rp=l.___cxa_is_pointer_type=function(){return(Rp=l.___cxa_is_pointer_type=l.asm.ob).apply(null,arguments)},W=l.dynCall_j=function(){return(W=l.dynCall_j=l.asm.pb).apply(null,arguments)},Qe=l.dynCall_iiiiij=function(){return(Qe=l.dynCall_iiiiij=l.asm.qb).apply(null,arguments)},ve=l.dynCall_jii=function(){return(ve=l.dynCall_jii=l.asm.rb).apply(null,arguments)},Ke=l.dynCall_viiiiij=function(){return(Ke=l.dynCall_viiiiij=l.asm.sb).apply(null,arguments)},lt=l.dynCall_vjji=function(){return(lt=l.dynCall_vjji=l.asm.tb).apply(null,arguments)},_n=l.dynCall_viiijjjii=function(){return(_n=l.dynCall_viiijjjii=l.asm.ub).apply(null,arguments)},ar=l.dynCall_iij=function(){return(ar=l.dynCall_iij=l.asm.vb).apply(null,arguments)},vi=l.dynCall_ji=function(){return(vi=l.dynCall_ji=l.asm.wb).apply(null,arguments)},Pi=l.dynCall_iiiiiij=function(){return(Pi=l.dynCall_iiiiiij=l.asm.xb).apply(null,arguments)},hi=l.dynCall_iiij=function(){return(hi=l.dynCall_iiij=l.asm.yb).apply(null,arguments)};function Oo(){function we(){if(!Jo&&(Jo=!0,l.calledRun=!0,!z)){if(kn(Ze),_(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;){var it=l.postRun.shift();Gt.unshift(it)}kn(Gt)}}if(!(0<ze)){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)ri();kn(ue),0<ze||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),we()}),1)):we())}}if(l.UTF8ToString=Ce,l.stringToUTF8=function(we,it,pt){return oe(we,G,it,pt)},l.lengthBytesUTF8=K,l.stackSave=si,l.stackRestore=Ri,l.stackAlloc=_c,wt=function we(){Jo||Oo(),Jo||(wt=we)},l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();return Oo(),c.ready});n.exports=a},4537:n=>{n.exports=function(e,t){for(var s=new Array(arguments.length-1),a=0,c=2,l=!0;c<arguments.length;)s[a++]=arguments[c++];return new Promise((function(_,m){s[a]=function(d){if(l)if(l=!1,d)m(d);else{for(var h=new Array(arguments.length-1),i=0;i<h.length;)h[i++]=arguments[i];_.apply(null,h)}};try{e.apply(t||null,s)}catch(d){l&&(l=!1,m(d))}}))}},7419:(n,e)=>{var t=e;t.length=function(_){var m=_.length;if(!m)return 0;for(var d=0;--m%4>1&&_.charAt(m)==="=";)++d;return Math.ceil(3*_.length)/4-d};for(var s=new Array(64),a=new Array(123),c=0;c<64;)a[s[c]=c<26?c+65:c<52?c+71:c<62?c-4:c-59|43]=c++;t.encode=function(_,m,d){for(var h,i=null,r=[],u=0,f=0;m<d;){var g=_[m++];switch(f){case 0:r[u++]=s[g>>2],h=(3&g)<<4,f=1;break;case 1:r[u++]=s[h|g>>4],h=(15&g)<<2,f=2;break;case 2:r[u++]=s[h|g>>6],r[u++]=s[63&g],f=0}u>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,r)),u=0)}return f&&(r[u++]=s[h],r[u++]=61,f===1&&(r[u++]=61)),i?(u&&i.push(String.fromCharCode.apply(String,r.slice(0,u))),i.join("")):String.fromCharCode.apply(String,r.slice(0,u))};var l="invalid encoding";t.decode=function(_,m,d){for(var h,i=d,r=0,u=0;u<_.length;){var f=_.charCodeAt(u++);if(f===61&&r>1)break;if((f=a[f])===void 0)throw Error(l);switch(r){case 0:h=f,r=1;break;case 1:m[d++]=h<<2|(48&f)>>4,h=f,r=2;break;case 2:m[d++]=(15&h)<<4|(60&f)>>2,h=f,r=3;break;case 3:m[d++]=(3&h)<<6|f,r=0}}if(r===1)throw Error(l);return d-i},t.test=function(_){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(_)}},9211:n=>{function e(){this._listeners={}}n.exports=e,e.prototype.on=function(t,s,a){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:s,ctx:a||this}),this},e.prototype.off=function(t,s){if(t===void 0)this._listeners={};else if(s===void 0)this._listeners[t]=[];else for(var a=this._listeners[t],c=0;c<a.length;)a[c].fn===s?a.splice(c,1):++c;return this},e.prototype.emit=function(t){var s=this._listeners[t];if(s){for(var a=[],c=1;c<arguments.length;)a.push(arguments[c++]);for(c=0;c<s.length;)s[c].fn.apply(s[c++].ctx,a)}return this}},945:n=>{function e(l){return typeof Float32Array<"u"?(function(){var _=new Float32Array([-0]),m=new Uint8Array(_.buffer),d=m[3]===128;function h(f,g,w){_[0]=f,g[w]=m[0],g[w+1]=m[1],g[w+2]=m[2],g[w+3]=m[3]}function i(f,g,w){_[0]=f,g[w]=m[3],g[w+1]=m[2],g[w+2]=m[1],g[w+3]=m[0]}function r(f,g){return m[0]=f[g],m[1]=f[g+1],m[2]=f[g+2],m[3]=f[g+3],_[0]}function u(f,g){return m[3]=f[g],m[2]=f[g+1],m[1]=f[g+2],m[0]=f[g+3],_[0]}l.writeFloatLE=d?h:i,l.writeFloatBE=d?i:h,l.readFloatLE=d?r:u,l.readFloatBE=d?u:r})():(function(){function _(d,h,i,r){var u=h<0?1:0;if(u&&(h=-h),h===0)d(1/h>0?0:2147483648,i,r);else if(isNaN(h))d(2143289344,i,r);else if(h>34028234663852886e22)d((u<<31|2139095040)>>>0,i,r);else if(h<11754943508222875e-54)d((u<<31|Math.round(h/1401298464324817e-60))>>>0,i,r);else{var f=Math.floor(Math.log(h)/Math.LN2);d((u<<31|f+127<<23|8388607&Math.round(h*Math.pow(2,-f)*8388608))>>>0,i,r)}}function m(d,h,i){var r=d(h,i),u=2*(r>>31)+1,f=r>>>23&255,g=8388607&r;return f===255?g?NaN:u*(1/0):f===0?1401298464324817e-60*u*g:u*Math.pow(2,f-150)*(g+8388608)}l.writeFloatLE=_.bind(null,t),l.writeFloatBE=_.bind(null,s),l.readFloatLE=m.bind(null,a),l.readFloatBE=m.bind(null,c)})(),typeof Float64Array<"u"?(function(){var _=new Float64Array([-0]),m=new Uint8Array(_.buffer),d=m[7]===128;function h(f,g,w){_[0]=f,g[w]=m[0],g[w+1]=m[1],g[w+2]=m[2],g[w+3]=m[3],g[w+4]=m[4],g[w+5]=m[5],g[w+6]=m[6],g[w+7]=m[7]}function i(f,g,w){_[0]=f,g[w]=m[7],g[w+1]=m[6],g[w+2]=m[5],g[w+3]=m[4],g[w+4]=m[3],g[w+5]=m[2],g[w+6]=m[1],g[w+7]=m[0]}function r(f,g){return m[0]=f[g],m[1]=f[g+1],m[2]=f[g+2],m[3]=f[g+3],m[4]=f[g+4],m[5]=f[g+5],m[6]=f[g+6],m[7]=f[g+7],_[0]}function u(f,g){return m[7]=f[g],m[6]=f[g+1],m[5]=f[g+2],m[4]=f[g+3],m[3]=f[g+4],m[2]=f[g+5],m[1]=f[g+6],m[0]=f[g+7],_[0]}l.writeDoubleLE=d?h:i,l.writeDoubleBE=d?i:h,l.readDoubleLE=d?r:u,l.readDoubleBE=d?u:r})():(function(){function _(d,h,i,r,u,f){var g=r<0?1:0;if(g&&(r=-r),r===0)d(0,u,f+h),d(1/r>0?0:2147483648,u,f+i);else if(isNaN(r))d(0,u,f+h),d(2146959360,u,f+i);else if(r>17976931348623157e292)d(0,u,f+h),d((g<<31|2146435072)>>>0,u,f+i);else{var w;if(r<22250738585072014e-324)d((w=r/5e-324)>>>0,u,f+h),d((g<<31|w/4294967296)>>>0,u,f+i);else{var y=Math.floor(Math.log(r)/Math.LN2);y===1024&&(y=1023),d(4503599627370496*(w=r*Math.pow(2,-y))>>>0,u,f+h),d((g<<31|y+1023<<20|1048576*w&1048575)>>>0,u,f+i)}}}function m(d,h,i,r,u){var f=d(r,u+h),g=d(r,u+i),w=2*(g>>31)+1,y=g>>>20&2047,x=4294967296*(1048575&g)+f;return y===2047?x?NaN:w*(1/0):y===0?5e-324*w*x:w*Math.pow(2,y-1075)*(x+4503599627370496)}l.writeDoubleLE=_.bind(null,t,0,4),l.writeDoubleBE=_.bind(null,s,4,0),l.readDoubleLE=m.bind(null,a,0,4),l.readDoubleBE=m.bind(null,c,4,0)})(),l}function t(l,_,m){_[m]=255&l,_[m+1]=l>>>8&255,_[m+2]=l>>>16&255,_[m+3]=l>>>24}function s(l,_,m){_[m]=l>>>24,_[m+1]=l>>>16&255,_[m+2]=l>>>8&255,_[m+3]=255&l}function a(l,_){return(l[_]|l[_+1]<<8|l[_+2]<<16|l[_+3]<<24)>>>0}function c(l,_){return(l[_]<<24|l[_+1]<<16|l[_+2]<<8|l[_+3])>>>0}n.exports=e(e)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(n){}return null}module.exports=inquire},6662:n=>{n.exports=function(e,t,s){var a=s||8192,c=a>>>1,l=null,_=a;return function(m){if(m<1||m>c)return e(m);_+m>a&&(l=e(a),_=0);var d=t.call(l,_,_+=m);return 7&_&&(_=1+(7|_)),d}}},4997:(n,e)=>{var t=e;t.length=function(s){for(var a=0,c=0,l=0;l<s.length;++l)(c=s.charCodeAt(l))<128?a+=1:c<2048?a+=2:(64512&c)==55296&&(64512&s.charCodeAt(l+1))==56320?(++l,a+=4):a+=3;return a},t.read=function(s,a,c){if(c-a<1)return"";for(var l,_=null,m=[],d=0;a<c;)(l=s[a++])<128?m[d++]=l:l>191&&l<224?m[d++]=(31&l)<<6|63&s[a++]:l>239&&l<365?(l=((7&l)<<18|(63&s[a++])<<12|(63&s[a++])<<6|63&s[a++])-65536,m[d++]=55296+(l>>10),m[d++]=56320+(1023&l)):m[d++]=(15&l)<<12|(63&s[a++])<<6|63&s[a++],d>8191&&((_||(_=[])).push(String.fromCharCode.apply(String,m)),d=0);return _?(d&&_.push(String.fromCharCode.apply(String,m.slice(0,d))),_.join("")):String.fromCharCode.apply(String,m.slice(0,d))},t.write=function(s,a,c){for(var l,_,m=c,d=0;d<s.length;++d)(l=s.charCodeAt(d))<128?a[c++]=l:l<2048?(a[c++]=l>>6|192,a[c++]=63&l|128):(64512&l)==55296&&(64512&(_=s.charCodeAt(d+1)))==56320?(l=65536+((1023&l)<<10)+(1023&_),++d,a[c++]=l>>18|240,a[c++]=l>>12&63|128,a[c++]=l>>6&63|128,a[c++]=63&l|128):(a[c++]=l>>12|224,a[c++]=l>>6&63|128,a[c++]=63&l|128);return c-m}},3442:(n,e)=>{e.__esModule=!0;var t=(function(){function s(a){if(!a)throw new TypeError("Invalid argument; `value` has no value.");this.value=s.EMPTY,a&&s.isGuid(a)&&(this.value=a)}return s.isGuid=function(a){var c=a.toString();return a&&(a instanceof s||s.validator.test(c))},s.create=function(){return new s([s.gen(2),s.gen(1),s.gen(1),s.gen(1),s.gen(3)].join("-"))},s.createEmpty=function(){return new s("emptyguid")},s.parse=function(a){return new s(a)},s.raw=function(){return[s.gen(2),s.gen(1),s.gen(1),s.gen(1),s.gen(3)].join("-")},s.gen=function(a){for(var c="",l=0;l<a;l++)c+=(65536*(1+Math.random())|0).toString(16).substring(1);return c},s.prototype.equals=function(a){return s.isGuid(a)&&this.value===a.toString()},s.prototype.isEmpty=function(){return this.value===s.EMPTY},s.prototype.toString=function(){return this.value},s.prototype.toJSON=function(){return{value:this.value}},s.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),s.EMPTY="00000000-0000-0000-0000-000000000000",s})();e.Guid=t},3720:n=>{n.exports=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(D,R,Y){this.low=0|D,this.high=0|R,this.unsigned=!!Y}function s(D){return(D&&D.__isLong__)===!0}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=s;var a={},c={};function l(D,R){var Y,re,G;return R?(G=0<=(D>>>=0)&&D<256)&&(re=c[D])?re:(Y=m(D,(0|D)<0?-1:0,!0),G&&(c[D]=Y),Y):(G=-128<=(D|=0)&&D<128)&&(re=a[D])?re:(Y=m(D,D<0?-1:0,!1),G&&(a[D]=Y),Y)}function _(D,R){if(isNaN(D))return R?y:w;if(R){if(D<0)return y;if(D>=u)return A}else{if(D<=-f)return C;if(D+1>=f)return E}return D<0?_(-D,R).neg():m(D%r|0,D/r|0,R)}function m(D,R,Y){return new t(D,R,Y)}t.fromInt=l,t.fromNumber=_,t.fromBits=m;var d=Math.pow;function h(D,R,Y){if(D.length===0)throw Error("empty string");if(D==="NaN"||D==="Infinity"||D==="+Infinity"||D==="-Infinity")return w;if(typeof R=="number"?(Y=R,R=!1):R=!!R,(Y=Y||10)<2||36<Y)throw RangeError("radix");var re;if((re=D.indexOf("-"))>0)throw Error("interior hyphen");if(re===0)return h(D.substring(1),R,Y).neg();for(var G=_(d(Y,8)),te=w,q=0;q<D.length;q+=8){var z=Math.min(8,D.length-q),H=parseInt(D.substring(q,q+z),Y);if(z<8){var he=_(d(Y,z));te=te.mul(he).add(_(H))}else te=(te=te.mul(G)).add(_(H))}return te.unsigned=R,te}function i(D,R){return typeof D=="number"?_(D,R):typeof D=="string"?h(D,R):m(D.low,D.high,typeof R=="boolean"?R:D.unsigned)}t.fromString=h,t.fromValue=i;var r=4294967296,u=r*r,f=u/2,g=l(1<<24),w=l(0);t.ZERO=w;var y=l(0,!0);t.UZERO=y;var x=l(1);t.ONE=x;var S=l(1,!0);t.UONE=S;var T=l(-1);t.NEG_ONE=T;var E=m(-1,2147483647,!1);t.MAX_VALUE=E;var A=m(-1,-1,!0);t.MAX_UNSIGNED_VALUE=A;var C=m(0,-2147483648,!1);t.MIN_VALUE=C;var I=t.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*r+(this.low>>>0):this.high*r+(this.low>>>0)},I.toString=function(D){if((D=D||10)<2||36<D)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(C)){var R=_(D),Y=this.div(R),re=Y.mul(R).sub(this);return Y.toString(D)+re.toInt().toString(D)}return"-"+this.neg().toString(D)}for(var G=_(d(D,6),this.unsigned),te=this,q="";;){var z=te.div(G),H=(te.sub(z.mul(G)).toInt()>>>0).toString(D);if((te=z).isZero())return H+q;for(;H.length<6;)H="0"+H;q=""+H+q}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(C)?64:this.neg().getNumBitsAbs();for(var D=this.high!=0?this.high:this.low,R=31;R>0&&(D&1<<R)==0;R--);return this.high!=0?R+33:R+1},I.isZero=function(){return this.high===0&&this.low===0},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return(1&this.low)==1},I.isEven=function(){return(1&this.low)==0},I.equals=function(D){return s(D)||(D=i(D)),(this.unsigned===D.unsigned||this.high>>>31!=1||D.high>>>31!=1)&&this.high===D.high&&this.low===D.low},I.eq=I.equals,I.notEquals=function(D){return!this.eq(D)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(D){return this.comp(D)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(D){return this.comp(D)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(D){return this.comp(D)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(D){return this.comp(D)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(D){if(s(D)||(D=i(D)),this.eq(D))return 0;var R=this.isNegative(),Y=D.isNegative();return R&&!Y?-1:!R&&Y?1:this.unsigned?D.high>>>0>this.high>>>0||D.high===this.high&&D.low>>>0>this.low>>>0?-1:1:this.sub(D).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(C)?C:this.not().add(x)},I.neg=I.negate,I.add=function(D){s(D)||(D=i(D));var R=this.high>>>16,Y=65535&this.high,re=this.low>>>16,G=65535&this.low,te=D.high>>>16,q=65535&D.high,z=D.low>>>16,H=0,he=0,Ce=0,oe=0;return Ce+=(oe+=G+(65535&D.low))>>>16,he+=(Ce+=re+z)>>>16,H+=(he+=Y+q)>>>16,H+=R+te,m((Ce&=65535)<<16|(oe&=65535),(H&=65535)<<16|(he&=65535),this.unsigned)},I.subtract=function(D){return s(D)||(D=i(D)),this.add(D.neg())},I.sub=I.subtract,I.multiply=function(D){if(this.isZero())return w;if(s(D)||(D=i(D)),e)return m(e.mul(this.low,this.high,D.low,D.high),e.get_high(),this.unsigned);if(D.isZero())return w;if(this.eq(C))return D.isOdd()?C:w;if(D.eq(C))return this.isOdd()?C:w;if(this.isNegative())return D.isNegative()?this.neg().mul(D.neg()):this.neg().mul(D).neg();if(D.isNegative())return this.mul(D.neg()).neg();if(this.lt(g)&&D.lt(g))return _(this.toNumber()*D.toNumber(),this.unsigned);var R=this.high>>>16,Y=65535&this.high,re=this.low>>>16,G=65535&this.low,te=D.high>>>16,q=65535&D.high,z=D.low>>>16,H=65535&D.low,he=0,Ce=0,oe=0,K=0;return oe+=(K+=G*H)>>>16,Ce+=(oe+=re*H)>>>16,oe&=65535,Ce+=(oe+=G*z)>>>16,he+=(Ce+=Y*H)>>>16,Ce&=65535,he+=(Ce+=re*z)>>>16,Ce&=65535,he+=(Ce+=G*q)>>>16,he+=R*H+Y*z+re*q+G*te,m((oe&=65535)<<16|(K&=65535),(he&=65535)<<16|(Ce&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(D){if(s(D)||(D=i(D)),D.isZero())throw Error("division by zero");var R,Y,re;if(e)return this.unsigned||this.high!==-2147483648||D.low!==-1||D.high!==-1?m((this.unsigned?e.div_u:e.div_s)(this.low,this.high,D.low,D.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:w;if(this.unsigned){if(D.unsigned||(D=D.toUnsigned()),D.gt(this))return y;if(D.gt(this.shru(1)))return S;re=y}else{if(this.eq(C))return D.eq(x)||D.eq(T)?C:D.eq(C)?x:(R=this.shr(1).div(D).shl(1)).eq(w)?D.isNegative()?x:T:(Y=this.sub(D.mul(R)),re=R.add(Y.div(D)));if(D.eq(C))return this.unsigned?y:w;if(this.isNegative())return D.isNegative()?this.neg().div(D.neg()):this.neg().div(D).neg();if(D.isNegative())return this.div(D.neg()).neg();re=w}for(Y=this;Y.gte(D);){R=Math.max(1,Math.floor(Y.toNumber()/D.toNumber()));for(var G=Math.ceil(Math.log(R)/Math.LN2),te=G<=48?1:d(2,G-48),q=_(R),z=q.mul(D);z.isNegative()||z.gt(Y);)z=(q=_(R-=te,this.unsigned)).mul(D);q.isZero()&&(q=x),re=re.add(q),Y=Y.sub(z)}return re},I.div=I.divide,I.modulo=function(D){return s(D)||(D=i(D)),e?m((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,D.low,D.high),e.get_high(),this.unsigned):this.sub(this.div(D).mul(D))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return m(~this.low,~this.high,this.unsigned)},I.and=function(D){return s(D)||(D=i(D)),m(this.low&D.low,this.high&D.high,this.unsigned)},I.or=function(D){return s(D)||(D=i(D)),m(this.low|D.low,this.high|D.high,this.unsigned)},I.xor=function(D){return s(D)||(D=i(D)),m(this.low^D.low,this.high^D.high,this.unsigned)},I.shiftLeft=function(D){return s(D)&&(D=D.toInt()),(D&=63)==0?this:D<32?m(this.low<<D,this.high<<D|this.low>>>32-D,this.unsigned):m(0,this.low<<D-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(D){return s(D)&&(D=D.toInt()),(D&=63)==0?this:D<32?m(this.low>>>D|this.high<<32-D,this.high>>D,this.unsigned):m(this.high>>D-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(D){if(s(D)&&(D=D.toInt()),(D&=63)==0)return this;var R=this.high;return D<32?m(this.low>>>D|R<<32-D,R>>>D,this.unsigned):m(D===32?R:R>>>D-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?m(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:m(this.low,this.high,!0)},I.toBytes=function(D){return D?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var D=this.high,R=this.low;return[255&R,R>>>8&255,R>>>16&255,R>>>24,255&D,D>>>8&255,D>>>16&255,D>>>24]},I.toBytesBE=function(){var D=this.high,R=this.low;return[D>>>24,D>>>16&255,D>>>8&255,255&D,R>>>24,R>>>16&255,R>>>8&255,255&R]},t.fromBytes=function(D,R,Y){return Y?t.fromBytesLE(D,R):t.fromBytesBE(D,R)},t.fromBytesLE=function(D,R){return new t(D[0]|D[1]<<8|D[2]<<16|D[3]<<24,D[4]|D[5]<<8|D[6]<<16|D[7]<<24,R)},t.fromBytesBE=function(D,R){return new t(D[4]<<24|D[5]<<16|D[6]<<8|D[7],D[0]<<24|D[1]<<16|D[2]<<8|D[3],R)}},1446:(n,e,t)=>{var s,a,c,l=t(2100),_=l.Reader,m=l.Writer,d=l.util,h=l.roots.default||(l.roots.default={});h.onnx=((c={}).Version=(s={},(a=Object.create(s))[s[0]="_START_VERSION"]=0,a[s[1]="IR_VERSION_2017_10_10"]=1,a[s[2]="IR_VERSION_2017_10_30"]=2,a[s[3]="IR_VERSION_2017_11_3"]=3,a[s[4]="IR_VERSION_2019_1_22"]=4,a[s[5]="IR_VERSION"]=5,a),c.AttributeProto=(function(){function i(r){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.name="",i.prototype.refAttrName="",i.prototype.docString="",i.prototype.type=0,i.prototype.f=0,i.prototype.i=d.Long?d.Long.fromBits(0,0,!1):0,i.prototype.s=d.newBuffer([]),i.prototype.t=null,i.prototype.g=null,i.prototype.floats=d.emptyArray,i.prototype.ints=d.emptyArray,i.prototype.strings=d.emptyArray,i.prototype.tensors=d.emptyArray,i.prototype.graphs=d.emptyArray,i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.name!=null&&r.hasOwnProperty("name")&&u.uint32(10).string(r.name),r.f!=null&&r.hasOwnProperty("f")&&u.uint32(21).float(r.f),r.i!=null&&r.hasOwnProperty("i")&&u.uint32(24).int64(r.i),r.s!=null&&r.hasOwnProperty("s")&&u.uint32(34).bytes(r.s),r.t!=null&&r.hasOwnProperty("t")&&h.onnx.TensorProto.encode(r.t,u.uint32(42).fork()).ldelim(),r.g!=null&&r.hasOwnProperty("g")&&h.onnx.GraphProto.encode(r.g,u.uint32(50).fork()).ldelim(),r.floats!=null&&r.floats.length){u.uint32(58).fork();for(var f=0;f<r.floats.length;++f)u.float(r.floats[f]);u.ldelim()}if(r.ints!=null&&r.ints.length){for(u.uint32(66).fork(),f=0;f<r.ints.length;++f)u.int64(r.ints[f]);u.ldelim()}if(r.strings!=null&&r.strings.length)for(f=0;f<r.strings.length;++f)u.uint32(74).bytes(r.strings[f]);if(r.tensors!=null&&r.tensors.length)for(f=0;f<r.tensors.length;++f)h.onnx.TensorProto.encode(r.tensors[f],u.uint32(82).fork()).ldelim();if(r.graphs!=null&&r.graphs.length)for(f=0;f<r.graphs.length;++f)h.onnx.GraphProto.encode(r.graphs[f],u.uint32(90).fork()).ldelim();return r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(106).string(r.docString),r.type!=null&&r.hasOwnProperty("type")&&u.uint32(160).int32(r.type),r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&u.uint32(170).string(r.refAttrName),u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.AttributeProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.name=r.string();break;case 21:g.refAttrName=r.string();break;case 13:g.docString=r.string();break;case 20:g.type=r.int32();break;case 2:g.f=r.float();break;case 3:g.i=r.int64();break;case 4:g.s=r.bytes();break;case 5:g.t=h.onnx.TensorProto.decode(r,r.uint32());break;case 6:g.g=h.onnx.GraphProto.decode(r,r.uint32());break;case 7:if(g.floats&&g.floats.length||(g.floats=[]),(7&w)==2)for(var y=r.uint32()+r.pos;r.pos<y;)g.floats.push(r.float());else g.floats.push(r.float());break;case 8:if(g.ints&&g.ints.length||(g.ints=[]),(7&w)==2)for(y=r.uint32()+r.pos;r.pos<y;)g.ints.push(r.int64());else g.ints.push(r.int64());break;case 9:g.strings&&g.strings.length||(g.strings=[]),g.strings.push(r.bytes());break;case 10:g.tensors&&g.tensors.length||(g.tensors=[]),g.tensors.push(h.onnx.TensorProto.decode(r,r.uint32()));break;case 11:g.graphs&&g.graphs.length||(g.graphs=[]),g.graphs.push(h.onnx.GraphProto.decode(r,r.uint32()));break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!d.isString(r.name))return"name: string expected";if(r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&!d.isString(r.refAttrName))return"refAttrName: string expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!d.isString(r.docString))return"docString: string expected";if(r.type!=null&&r.hasOwnProperty("type"))switch(r.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(r.f!=null&&r.hasOwnProperty("f")&&typeof r.f!="number")return"f: number expected";if(r.i!=null&&r.hasOwnProperty("i")&&!(d.isInteger(r.i)||r.i&&d.isInteger(r.i.low)&&d.isInteger(r.i.high)))return"i: integer|Long expected";if(r.s!=null&&r.hasOwnProperty("s")&&!(r.s&&typeof r.s.length=="number"||d.isString(r.s)))return"s: buffer expected";if(r.t!=null&&r.hasOwnProperty("t")&&(f=h.onnx.TensorProto.verify(r.t)))return"t."+f;if(r.g!=null&&r.hasOwnProperty("g")&&(f=h.onnx.GraphProto.verify(r.g)))return"g."+f;if(r.floats!=null&&r.hasOwnProperty("floats")){if(!Array.isArray(r.floats))return"floats: array expected";for(var u=0;u<r.floats.length;++u)if(typeof r.floats[u]!="number")return"floats: number[] expected"}if(r.ints!=null&&r.hasOwnProperty("ints")){if(!Array.isArray(r.ints))return"ints: array expected";for(u=0;u<r.ints.length;++u)if(!(d.isInteger(r.ints[u])||r.ints[u]&&d.isInteger(r.ints[u].low)&&d.isInteger(r.ints[u].high)))return"ints: integer|Long[] expected"}if(r.strings!=null&&r.hasOwnProperty("strings")){if(!Array.isArray(r.strings))return"strings: array expected";for(u=0;u<r.strings.length;++u)if(!(r.strings[u]&&typeof r.strings[u].length=="number"||d.isString(r.strings[u])))return"strings: buffer[] expected"}if(r.tensors!=null&&r.hasOwnProperty("tensors")){if(!Array.isArray(r.tensors))return"tensors: array expected";for(u=0;u<r.tensors.length;++u)if(f=h.onnx.TensorProto.verify(r.tensors[u]))return"tensors."+f}if(r.graphs!=null&&r.hasOwnProperty("graphs")){if(!Array.isArray(r.graphs))return"graphs: array expected";for(u=0;u<r.graphs.length;++u){var f;if(f=h.onnx.GraphProto.verify(r.graphs[u]))return"graphs."+f}}return null},i.fromObject=function(r){if(r instanceof h.onnx.AttributeProto)return r;var u=new h.onnx.AttributeProto;switch(r.name!=null&&(u.name=String(r.name)),r.refAttrName!=null&&(u.refAttrName=String(r.refAttrName)),r.docString!=null&&(u.docString=String(r.docString)),r.type){case"UNDEFINED":case 0:u.type=0;break;case"FLOAT":case 1:u.type=1;break;case"INT":case 2:u.type=2;break;case"STRING":case 3:u.type=3;break;case"TENSOR":case 4:u.type=4;break;case"GRAPH":case 5:u.type=5;break;case"FLOATS":case 6:u.type=6;break;case"INTS":case 7:u.type=7;break;case"STRINGS":case 8:u.type=8;break;case"TENSORS":case 9:u.type=9;break;case"GRAPHS":case 10:u.type=10}if(r.f!=null&&(u.f=Number(r.f)),r.i!=null&&(d.Long?(u.i=d.Long.fromValue(r.i)).unsigned=!1:typeof r.i=="string"?u.i=parseInt(r.i,10):typeof r.i=="number"?u.i=r.i:typeof r.i=="object"&&(u.i=new d.LongBits(r.i.low>>>0,r.i.high>>>0).toNumber())),r.s!=null&&(typeof r.s=="string"?d.base64.decode(r.s,u.s=d.newBuffer(d.base64.length(r.s)),0):r.s.length&&(u.s=r.s)),r.t!=null){if(typeof r.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");u.t=h.onnx.TensorProto.fromObject(r.t)}if(r.g!=null){if(typeof r.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");u.g=h.onnx.GraphProto.fromObject(r.g)}if(r.floats){if(!Array.isArray(r.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");u.floats=[];for(var f=0;f<r.floats.length;++f)u.floats[f]=Number(r.floats[f])}if(r.ints){if(!Array.isArray(r.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(u.ints=[],f=0;f<r.ints.length;++f)d.Long?(u.ints[f]=d.Long.fromValue(r.ints[f])).unsigned=!1:typeof r.ints[f]=="string"?u.ints[f]=parseInt(r.ints[f],10):typeof r.ints[f]=="number"?u.ints[f]=r.ints[f]:typeof r.ints[f]=="object"&&(u.ints[f]=new d.LongBits(r.ints[f].low>>>0,r.ints[f].high>>>0).toNumber())}if(r.strings){if(!Array.isArray(r.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(u.strings=[],f=0;f<r.strings.length;++f)typeof r.strings[f]=="string"?d.base64.decode(r.strings[f],u.strings[f]=d.newBuffer(d.base64.length(r.strings[f])),0):r.strings[f].length&&(u.strings[f]=r.strings[f])}if(r.tensors){if(!Array.isArray(r.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(u.tensors=[],f=0;f<r.tensors.length;++f){if(typeof r.tensors[f]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");u.tensors[f]=h.onnx.TensorProto.fromObject(r.tensors[f])}}if(r.graphs){if(!Array.isArray(r.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(u.graphs=[],f=0;f<r.graphs.length;++f){if(typeof r.graphs[f]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");u.graphs[f]=h.onnx.GraphProto.fromObject(r.graphs[f])}}return u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.floats=[],f.ints=[],f.strings=[],f.tensors=[],f.graphs=[]),u.defaults){if(f.name="",f.f=0,d.Long){var g=new d.Long(0,0,!1);f.i=u.longs===String?g.toString():u.longs===Number?g.toNumber():g}else f.i=u.longs===String?"0":0;u.bytes===String?f.s="":(f.s=[],u.bytes!==Array&&(f.s=d.newBuffer(f.s))),f.t=null,f.g=null,f.docString="",f.type=u.enums===String?"UNDEFINED":0,f.refAttrName=""}if(r.name!=null&&r.hasOwnProperty("name")&&(f.name=r.name),r.f!=null&&r.hasOwnProperty("f")&&(f.f=u.json&&!isFinite(r.f)?String(r.f):r.f),r.i!=null&&r.hasOwnProperty("i")&&(typeof r.i=="number"?f.i=u.longs===String?String(r.i):r.i:f.i=u.longs===String?d.Long.prototype.toString.call(r.i):u.longs===Number?new d.LongBits(r.i.low>>>0,r.i.high>>>0).toNumber():r.i),r.s!=null&&r.hasOwnProperty("s")&&(f.s=u.bytes===String?d.base64.encode(r.s,0,r.s.length):u.bytes===Array?Array.prototype.slice.call(r.s):r.s),r.t!=null&&r.hasOwnProperty("t")&&(f.t=h.onnx.TensorProto.toObject(r.t,u)),r.g!=null&&r.hasOwnProperty("g")&&(f.g=h.onnx.GraphProto.toObject(r.g,u)),r.floats&&r.floats.length){f.floats=[];for(var w=0;w<r.floats.length;++w)f.floats[w]=u.json&&!isFinite(r.floats[w])?String(r.floats[w]):r.floats[w]}if(r.ints&&r.ints.length)for(f.ints=[],w=0;w<r.ints.length;++w)typeof r.ints[w]=="number"?f.ints[w]=u.longs===String?String(r.ints[w]):r.ints[w]:f.ints[w]=u.longs===String?d.Long.prototype.toString.call(r.ints[w]):u.longs===Number?new d.LongBits(r.ints[w].low>>>0,r.ints[w].high>>>0).toNumber():r.ints[w];if(r.strings&&r.strings.length)for(f.strings=[],w=0;w<r.strings.length;++w)f.strings[w]=u.bytes===String?d.base64.encode(r.strings[w],0,r.strings[w].length):u.bytes===Array?Array.prototype.slice.call(r.strings[w]):r.strings[w];if(r.tensors&&r.tensors.length)for(f.tensors=[],w=0;w<r.tensors.length;++w)f.tensors[w]=h.onnx.TensorProto.toObject(r.tensors[w],u);if(r.graphs&&r.graphs.length)for(f.graphs=[],w=0;w<r.graphs.length;++w)f.graphs[w]=h.onnx.GraphProto.toObject(r.graphs[w],u);return r.docString!=null&&r.hasOwnProperty("docString")&&(f.docString=r.docString),r.type!=null&&r.hasOwnProperty("type")&&(f.type=u.enums===String?h.onnx.AttributeProto.AttributeType[r.type]:r.type),r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&(f.refAttrName=r.refAttrName),f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i.AttributeType=(function(){var r={},u=Object.create(r);return u[r[0]="UNDEFINED"]=0,u[r[1]="FLOAT"]=1,u[r[2]="INT"]=2,u[r[3]="STRING"]=3,u[r[4]="TENSOR"]=4,u[r[5]="GRAPH"]=5,u[r[6]="FLOATS"]=6,u[r[7]="INTS"]=7,u[r[8]="STRINGS"]=8,u[r[9]="TENSORS"]=9,u[r[10]="GRAPHS"]=10,u})(),i})(),c.ValueInfoProto=(function(){function i(r){if(r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.name="",i.prototype.type=null,i.prototype.docString="",i.create=function(r){return new i(r)},i.encode=function(r,u){return u||(u=m.create()),r.name!=null&&r.hasOwnProperty("name")&&u.uint32(10).string(r.name),r.type!=null&&r.hasOwnProperty("type")&&h.onnx.TypeProto.encode(r.type,u.uint32(18).fork()).ldelim(),r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(26).string(r.docString),u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.ValueInfoProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.name=r.string();break;case 2:g.type=h.onnx.TypeProto.decode(r,r.uint32());break;case 3:g.docString=r.string();break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!d.isString(r.name))return"name: string expected";if(r.type!=null&&r.hasOwnProperty("type")){var u=h.onnx.TypeProto.verify(r.type);if(u)return"type."+u}return r.docString!=null&&r.hasOwnProperty("docString")&&!d.isString(r.docString)?"docString: string expected":null},i.fromObject=function(r){if(r instanceof h.onnx.ValueInfoProto)return r;var u=new h.onnx.ValueInfoProto;if(r.name!=null&&(u.name=String(r.name)),r.type!=null){if(typeof r.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");u.type=h.onnx.TypeProto.fromObject(r.type)}return r.docString!=null&&(u.docString=String(r.docString)),u},i.toObject=function(r,u){u||(u={});var f={};return u.defaults&&(f.name="",f.type=null,f.docString=""),r.name!=null&&r.hasOwnProperty("name")&&(f.name=r.name),r.type!=null&&r.hasOwnProperty("type")&&(f.type=h.onnx.TypeProto.toObject(r.type,u)),r.docString!=null&&r.hasOwnProperty("docString")&&(f.docString=r.docString),f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c.NodeProto=(function(){function i(r){if(this.input=[],this.output=[],this.attribute=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.input=d.emptyArray,i.prototype.output=d.emptyArray,i.prototype.name="",i.prototype.opType="",i.prototype.domain="",i.prototype.attribute=d.emptyArray,i.prototype.docString="",i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.input!=null&&r.input.length)for(var f=0;f<r.input.length;++f)u.uint32(10).string(r.input[f]);if(r.output!=null&&r.output.length)for(f=0;f<r.output.length;++f)u.uint32(18).string(r.output[f]);if(r.name!=null&&r.hasOwnProperty("name")&&u.uint32(26).string(r.name),r.opType!=null&&r.hasOwnProperty("opType")&&u.uint32(34).string(r.opType),r.attribute!=null&&r.attribute.length)for(f=0;f<r.attribute.length;++f)h.onnx.AttributeProto.encode(r.attribute[f],u.uint32(42).fork()).ldelim();return r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(50).string(r.docString),r.domain!=null&&r.hasOwnProperty("domain")&&u.uint32(58).string(r.domain),u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.NodeProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.input&&g.input.length||(g.input=[]),g.input.push(r.string());break;case 2:g.output&&g.output.length||(g.output=[]),g.output.push(r.string());break;case 3:g.name=r.string();break;case 4:g.opType=r.string();break;case 7:g.domain=r.string();break;case 5:g.attribute&&g.attribute.length||(g.attribute=[]),g.attribute.push(h.onnx.AttributeProto.decode(r,r.uint32()));break;case 6:g.docString=r.string();break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(var u=0;u<r.input.length;++u)if(!d.isString(r.input[u]))return"input: string[] expected"}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(u=0;u<r.output.length;++u)if(!d.isString(r.output[u]))return"output: string[] expected"}if(r.name!=null&&r.hasOwnProperty("name")&&!d.isString(r.name))return"name: string expected";if(r.opType!=null&&r.hasOwnProperty("opType")&&!d.isString(r.opType))return"opType: string expected";if(r.domain!=null&&r.hasOwnProperty("domain")&&!d.isString(r.domain))return"domain: string expected";if(r.attribute!=null&&r.hasOwnProperty("attribute")){if(!Array.isArray(r.attribute))return"attribute: array expected";for(u=0;u<r.attribute.length;++u){var f=h.onnx.AttributeProto.verify(r.attribute[u]);if(f)return"attribute."+f}}return r.docString!=null&&r.hasOwnProperty("docString")&&!d.isString(r.docString)?"docString: string expected":null},i.fromObject=function(r){if(r instanceof h.onnx.NodeProto)return r;var u=new h.onnx.NodeProto;if(r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.NodeProto.input: array expected");u.input=[];for(var f=0;f<r.input.length;++f)u.input[f]=String(r.input[f])}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.NodeProto.output: array expected");for(u.output=[],f=0;f<r.output.length;++f)u.output[f]=String(r.output[f])}if(r.name!=null&&(u.name=String(r.name)),r.opType!=null&&(u.opType=String(r.opType)),r.domain!=null&&(u.domain=String(r.domain)),r.attribute){if(!Array.isArray(r.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(u.attribute=[],f=0;f<r.attribute.length;++f){if(typeof r.attribute[f]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");u.attribute[f]=h.onnx.AttributeProto.fromObject(r.attribute[f])}}return r.docString!=null&&(u.docString=String(r.docString)),u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.input=[],f.output=[],f.attribute=[]),u.defaults&&(f.name="",f.opType="",f.docString="",f.domain=""),r.input&&r.input.length){f.input=[];for(var g=0;g<r.input.length;++g)f.input[g]=r.input[g]}if(r.output&&r.output.length)for(f.output=[],g=0;g<r.output.length;++g)f.output[g]=r.output[g];if(r.name!=null&&r.hasOwnProperty("name")&&(f.name=r.name),r.opType!=null&&r.hasOwnProperty("opType")&&(f.opType=r.opType),r.attribute&&r.attribute.length)for(f.attribute=[],g=0;g<r.attribute.length;++g)f.attribute[g]=h.onnx.AttributeProto.toObject(r.attribute[g],u);return r.docString!=null&&r.hasOwnProperty("docString")&&(f.docString=r.docString),r.domain!=null&&r.hasOwnProperty("domain")&&(f.domain=r.domain),f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c.ModelProto=(function(){function i(r){if(this.opsetImport=[],this.metadataProps=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.irVersion=d.Long?d.Long.fromBits(0,0,!1):0,i.prototype.opsetImport=d.emptyArray,i.prototype.producerName="",i.prototype.producerVersion="",i.prototype.domain="",i.prototype.modelVersion=d.Long?d.Long.fromBits(0,0,!1):0,i.prototype.docString="",i.prototype.graph=null,i.prototype.metadataProps=d.emptyArray,i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.irVersion!=null&&r.hasOwnProperty("irVersion")&&u.uint32(8).int64(r.irVersion),r.producerName!=null&&r.hasOwnProperty("producerName")&&u.uint32(18).string(r.producerName),r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&u.uint32(26).string(r.producerVersion),r.domain!=null&&r.hasOwnProperty("domain")&&u.uint32(34).string(r.domain),r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&u.uint32(40).int64(r.modelVersion),r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(50).string(r.docString),r.graph!=null&&r.hasOwnProperty("graph")&&h.onnx.GraphProto.encode(r.graph,u.uint32(58).fork()).ldelim(),r.opsetImport!=null&&r.opsetImport.length)for(var f=0;f<r.opsetImport.length;++f)h.onnx.OperatorSetIdProto.encode(r.opsetImport[f],u.uint32(66).fork()).ldelim();if(r.metadataProps!=null&&r.metadataProps.length)for(f=0;f<r.metadataProps.length;++f)h.onnx.StringStringEntryProto.encode(r.metadataProps[f],u.uint32(114).fork()).ldelim();return u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.ModelProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.irVersion=r.int64();break;case 8:g.opsetImport&&g.opsetImport.length||(g.opsetImport=[]),g.opsetImport.push(h.onnx.OperatorSetIdProto.decode(r,r.uint32()));break;case 2:g.producerName=r.string();break;case 3:g.producerVersion=r.string();break;case 4:g.domain=r.string();break;case 5:g.modelVersion=r.int64();break;case 6:g.docString=r.string();break;case 7:g.graph=h.onnx.GraphProto.decode(r,r.uint32());break;case 14:g.metadataProps&&g.metadataProps.length||(g.metadataProps=[]),g.metadataProps.push(h.onnx.StringStringEntryProto.decode(r,r.uint32()));break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.irVersion!=null&&r.hasOwnProperty("irVersion")&&!(d.isInteger(r.irVersion)||r.irVersion&&d.isInteger(r.irVersion.low)&&d.isInteger(r.irVersion.high)))return"irVersion: integer|Long expected";if(r.opsetImport!=null&&r.hasOwnProperty("opsetImport")){if(!Array.isArray(r.opsetImport))return"opsetImport: array expected";for(var u=0;u<r.opsetImport.length;++u)if(f=h.onnx.OperatorSetIdProto.verify(r.opsetImport[u]))return"opsetImport."+f}if(r.producerName!=null&&r.hasOwnProperty("producerName")&&!d.isString(r.producerName))return"producerName: string expected";if(r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&!d.isString(r.producerVersion))return"producerVersion: string expected";if(r.domain!=null&&r.hasOwnProperty("domain")&&!d.isString(r.domain))return"domain: string expected";if(r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&!(d.isInteger(r.modelVersion)||r.modelVersion&&d.isInteger(r.modelVersion.low)&&d.isInteger(r.modelVersion.high)))return"modelVersion: integer|Long expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!d.isString(r.docString))return"docString: string expected";if(r.graph!=null&&r.hasOwnProperty("graph")&&(f=h.onnx.GraphProto.verify(r.graph)))return"graph."+f;if(r.metadataProps!=null&&r.hasOwnProperty("metadataProps")){if(!Array.isArray(r.metadataProps))return"metadataProps: array expected";for(u=0;u<r.metadataProps.length;++u){var f;if(f=h.onnx.StringStringEntryProto.verify(r.metadataProps[u]))return"metadataProps."+f}}return null},i.fromObject=function(r){if(r instanceof h.onnx.ModelProto)return r;var u=new h.onnx.ModelProto;if(r.irVersion!=null&&(d.Long?(u.irVersion=d.Long.fromValue(r.irVersion)).unsigned=!1:typeof r.irVersion=="string"?u.irVersion=parseInt(r.irVersion,10):typeof r.irVersion=="number"?u.irVersion=r.irVersion:typeof r.irVersion=="object"&&(u.irVersion=new d.LongBits(r.irVersion.low>>>0,r.irVersion.high>>>0).toNumber())),r.opsetImport){if(!Array.isArray(r.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");u.opsetImport=[];for(var f=0;f<r.opsetImport.length;++f){if(typeof r.opsetImport[f]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");u.opsetImport[f]=h.onnx.OperatorSetIdProto.fromObject(r.opsetImport[f])}}if(r.producerName!=null&&(u.producerName=String(r.producerName)),r.producerVersion!=null&&(u.producerVersion=String(r.producerVersion)),r.domain!=null&&(u.domain=String(r.domain)),r.modelVersion!=null&&(d.Long?(u.modelVersion=d.Long.fromValue(r.modelVersion)).unsigned=!1:typeof r.modelVersion=="string"?u.modelVersion=parseInt(r.modelVersion,10):typeof r.modelVersion=="number"?u.modelVersion=r.modelVersion:typeof r.modelVersion=="object"&&(u.modelVersion=new d.LongBits(r.modelVersion.low>>>0,r.modelVersion.high>>>0).toNumber())),r.docString!=null&&(u.docString=String(r.docString)),r.graph!=null){if(typeof r.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");u.graph=h.onnx.GraphProto.fromObject(r.graph)}if(r.metadataProps){if(!Array.isArray(r.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(u.metadataProps=[],f=0;f<r.metadataProps.length;++f){if(typeof r.metadataProps[f]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");u.metadataProps[f]=h.onnx.StringStringEntryProto.fromObject(r.metadataProps[f])}}return u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.opsetImport=[],f.metadataProps=[]),u.defaults){if(d.Long){var g=new d.Long(0,0,!1);f.irVersion=u.longs===String?g.toString():u.longs===Number?g.toNumber():g}else f.irVersion=u.longs===String?"0":0;f.producerName="",f.producerVersion="",f.domain="",d.Long?(g=new d.Long(0,0,!1),f.modelVersion=u.longs===String?g.toString():u.longs===Number?g.toNumber():g):f.modelVersion=u.longs===String?"0":0,f.docString="",f.graph=null}if(r.irVersion!=null&&r.hasOwnProperty("irVersion")&&(typeof r.irVersion=="number"?f.irVersion=u.longs===String?String(r.irVersion):r.irVersion:f.irVersion=u.longs===String?d.Long.prototype.toString.call(r.irVersion):u.longs===Number?new d.LongBits(r.irVersion.low>>>0,r.irVersion.high>>>0).toNumber():r.irVersion),r.producerName!=null&&r.hasOwnProperty("producerName")&&(f.producerName=r.producerName),r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&(f.producerVersion=r.producerVersion),r.domain!=null&&r.hasOwnProperty("domain")&&(f.domain=r.domain),r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&(typeof r.modelVersion=="number"?f.modelVersion=u.longs===String?String(r.modelVersion):r.modelVersion:f.modelVersion=u.longs===String?d.Long.prototype.toString.call(r.modelVersion):u.longs===Number?new d.LongBits(r.modelVersion.low>>>0,r.modelVersion.high>>>0).toNumber():r.modelVersion),r.docString!=null&&r.hasOwnProperty("docString")&&(f.docString=r.docString),r.graph!=null&&r.hasOwnProperty("graph")&&(f.graph=h.onnx.GraphProto.toObject(r.graph,u)),r.opsetImport&&r.opsetImport.length){f.opsetImport=[];for(var w=0;w<r.opsetImport.length;++w)f.opsetImport[w]=h.onnx.OperatorSetIdProto.toObject(r.opsetImport[w],u)}if(r.metadataProps&&r.metadataProps.length)for(f.metadataProps=[],w=0;w<r.metadataProps.length;++w)f.metadataProps[w]=h.onnx.StringStringEntryProto.toObject(r.metadataProps[w],u);return f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c.StringStringEntryProto=(function(){function i(r){if(r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.key="",i.prototype.value="",i.create=function(r){return new i(r)},i.encode=function(r,u){return u||(u=m.create()),r.key!=null&&r.hasOwnProperty("key")&&u.uint32(10).string(r.key),r.value!=null&&r.hasOwnProperty("value")&&u.uint32(18).string(r.value),u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.StringStringEntryProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.key=r.string();break;case 2:g.value=r.string();break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){return typeof r!="object"||r===null?"object expected":r.key!=null&&r.hasOwnProperty("key")&&!d.isString(r.key)?"key: string expected":r.value!=null&&r.hasOwnProperty("value")&&!d.isString(r.value)?"value: string expected":null},i.fromObject=function(r){if(r instanceof h.onnx.StringStringEntryProto)return r;var u=new h.onnx.StringStringEntryProto;return r.key!=null&&(u.key=String(r.key)),r.value!=null&&(u.value=String(r.value)),u},i.toObject=function(r,u){u||(u={});var f={};return u.defaults&&(f.key="",f.value=""),r.key!=null&&r.hasOwnProperty("key")&&(f.key=r.key),r.value!=null&&r.hasOwnProperty("value")&&(f.value=r.value),f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c.TensorAnnotation=(function(){function i(r){if(this.quantParameterTensorNames=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.tensorName="",i.prototype.quantParameterTensorNames=d.emptyArray,i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.tensorName!=null&&r.hasOwnProperty("tensorName")&&u.uint32(10).string(r.tensorName),r.quantParameterTensorNames!=null&&r.quantParameterTensorNames.length)for(var f=0;f<r.quantParameterTensorNames.length;++f)h.onnx.StringStringEntryProto.encode(r.quantParameterTensorNames[f],u.uint32(18).fork()).ldelim();return u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.TensorAnnotation;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.tensorName=r.string();break;case 2:g.quantParameterTensorNames&&g.quantParameterTensorNames.length||(g.quantParameterTensorNames=[]),g.quantParameterTensorNames.push(h.onnx.StringStringEntryProto.decode(r,r.uint32()));break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.tensorName!=null&&r.hasOwnProperty("tensorName")&&!d.isString(r.tensorName))return"tensorName: string expected";if(r.quantParameterTensorNames!=null&&r.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(r.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var u=0;u<r.quantParameterTensorNames.length;++u){var f=h.onnx.StringStringEntryProto.verify(r.quantParameterTensorNames[u]);if(f)return"quantParameterTensorNames."+f}}return null},i.fromObject=function(r){if(r instanceof h.onnx.TensorAnnotation)return r;var u=new h.onnx.TensorAnnotation;if(r.tensorName!=null&&(u.tensorName=String(r.tensorName)),r.quantParameterTensorNames){if(!Array.isArray(r.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");u.quantParameterTensorNames=[];for(var f=0;f<r.quantParameterTensorNames.length;++f){if(typeof r.quantParameterTensorNames[f]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");u.quantParameterTensorNames[f]=h.onnx.StringStringEntryProto.fromObject(r.quantParameterTensorNames[f])}}return u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.quantParameterTensorNames=[]),u.defaults&&(f.tensorName=""),r.tensorName!=null&&r.hasOwnProperty("tensorName")&&(f.tensorName=r.tensorName),r.quantParameterTensorNames&&r.quantParameterTensorNames.length){f.quantParameterTensorNames=[];for(var g=0;g<r.quantParameterTensorNames.length;++g)f.quantParameterTensorNames[g]=h.onnx.StringStringEntryProto.toObject(r.quantParameterTensorNames[g],u)}return f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c.GraphProto=(function(){function i(r){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.node=d.emptyArray,i.prototype.name="",i.prototype.initializer=d.emptyArray,i.prototype.docString="",i.prototype.input=d.emptyArray,i.prototype.output=d.emptyArray,i.prototype.valueInfo=d.emptyArray,i.prototype.quantizationAnnotation=d.emptyArray,i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.node!=null&&r.node.length)for(var f=0;f<r.node.length;++f)h.onnx.NodeProto.encode(r.node[f],u.uint32(10).fork()).ldelim();if(r.name!=null&&r.hasOwnProperty("name")&&u.uint32(18).string(r.name),r.initializer!=null&&r.initializer.length)for(f=0;f<r.initializer.length;++f)h.onnx.TensorProto.encode(r.initializer[f],u.uint32(42).fork()).ldelim();if(r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(82).string(r.docString),r.input!=null&&r.input.length)for(f=0;f<r.input.length;++f)h.onnx.ValueInfoProto.encode(r.input[f],u.uint32(90).fork()).ldelim();if(r.output!=null&&r.output.length)for(f=0;f<r.output.length;++f)h.onnx.ValueInfoProto.encode(r.output[f],u.uint32(98).fork()).ldelim();if(r.valueInfo!=null&&r.valueInfo.length)for(f=0;f<r.valueInfo.length;++f)h.onnx.ValueInfoProto.encode(r.valueInfo[f],u.uint32(106).fork()).ldelim();if(r.quantizationAnnotation!=null&&r.quantizationAnnotation.length)for(f=0;f<r.quantizationAnnotation.length;++f)h.onnx.TensorAnnotation.encode(r.quantizationAnnotation[f],u.uint32(114).fork()).ldelim();return u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.GraphProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.node&&g.node.length||(g.node=[]),g.node.push(h.onnx.NodeProto.decode(r,r.uint32()));break;case 2:g.name=r.string();break;case 5:g.initializer&&g.initializer.length||(g.initializer=[]),g.initializer.push(h.onnx.TensorProto.decode(r,r.uint32()));break;case 10:g.docString=r.string();break;case 11:g.input&&g.input.length||(g.input=[]),g.input.push(h.onnx.ValueInfoProto.decode(r,r.uint32()));break;case 12:g.output&&g.output.length||(g.output=[]),g.output.push(h.onnx.ValueInfoProto.decode(r,r.uint32()));break;case 13:g.valueInfo&&g.valueInfo.length||(g.valueInfo=[]),g.valueInfo.push(h.onnx.ValueInfoProto.decode(r,r.uint32()));break;case 14:g.quantizationAnnotation&&g.quantizationAnnotation.length||(g.quantizationAnnotation=[]),g.quantizationAnnotation.push(h.onnx.TensorAnnotation.decode(r,r.uint32()));break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.node!=null&&r.hasOwnProperty("node")){if(!Array.isArray(r.node))return"node: array expected";for(var u=0;u<r.node.length;++u)if(f=h.onnx.NodeProto.verify(r.node[u]))return"node."+f}if(r.name!=null&&r.hasOwnProperty("name")&&!d.isString(r.name))return"name: string expected";if(r.initializer!=null&&r.hasOwnProperty("initializer")){if(!Array.isArray(r.initializer))return"initializer: array expected";for(u=0;u<r.initializer.length;++u)if(f=h.onnx.TensorProto.verify(r.initializer[u]))return"initializer."+f}if(r.docString!=null&&r.hasOwnProperty("docString")&&!d.isString(r.docString))return"docString: string expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(u=0;u<r.input.length;++u)if(f=h.onnx.ValueInfoProto.verify(r.input[u]))return"input."+f}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(u=0;u<r.output.length;++u)if(f=h.onnx.ValueInfoProto.verify(r.output[u]))return"output."+f}if(r.valueInfo!=null&&r.hasOwnProperty("valueInfo")){if(!Array.isArray(r.valueInfo))return"valueInfo: array expected";for(u=0;u<r.valueInfo.length;++u)if(f=h.onnx.ValueInfoProto.verify(r.valueInfo[u]))return"valueInfo."+f}if(r.quantizationAnnotation!=null&&r.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(r.quantizationAnnotation))return"quantizationAnnotation: array expected";for(u=0;u<r.quantizationAnnotation.length;++u){var f;if(f=h.onnx.TensorAnnotation.verify(r.quantizationAnnotation[u]))return"quantizationAnnotation."+f}}return null},i.fromObject=function(r){if(r instanceof h.onnx.GraphProto)return r;var u=new h.onnx.GraphProto;if(r.node){if(!Array.isArray(r.node))throw TypeError(".onnx.GraphProto.node: array expected");u.node=[];for(var f=0;f<r.node.length;++f){if(typeof r.node[f]!="object")throw TypeError(".onnx.GraphProto.node: object expected");u.node[f]=h.onnx.NodeProto.fromObject(r.node[f])}}if(r.name!=null&&(u.name=String(r.name)),r.initializer){if(!Array.isArray(r.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(u.initializer=[],f=0;f<r.initializer.length;++f){if(typeof r.initializer[f]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");u.initializer[f]=h.onnx.TensorProto.fromObject(r.initializer[f])}}if(r.docString!=null&&(u.docString=String(r.docString)),r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.GraphProto.input: array expected");for(u.input=[],f=0;f<r.input.length;++f){if(typeof r.input[f]!="object")throw TypeError(".onnx.GraphProto.input: object expected");u.input[f]=h.onnx.ValueInfoProto.fromObject(r.input[f])}}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.GraphProto.output: array expected");for(u.output=[],f=0;f<r.output.length;++f){if(typeof r.output[f]!="object")throw TypeError(".onnx.GraphProto.output: object expected");u.output[f]=h.onnx.ValueInfoProto.fromObject(r.output[f])}}if(r.valueInfo){if(!Array.isArray(r.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(u.valueInfo=[],f=0;f<r.valueInfo.length;++f){if(typeof r.valueInfo[f]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");u.valueInfo[f]=h.onnx.ValueInfoProto.fromObject(r.valueInfo[f])}}if(r.quantizationAnnotation){if(!Array.isArray(r.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(u.quantizationAnnotation=[],f=0;f<r.quantizationAnnotation.length;++f){if(typeof r.quantizationAnnotation[f]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");u.quantizationAnnotation[f]=h.onnx.TensorAnnotation.fromObject(r.quantizationAnnotation[f])}}return u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.node=[],f.initializer=[],f.input=[],f.output=[],f.valueInfo=[],f.quantizationAnnotation=[]),u.defaults&&(f.name="",f.docString=""),r.node&&r.node.length){f.node=[];for(var g=0;g<r.node.length;++g)f.node[g]=h.onnx.NodeProto.toObject(r.node[g],u)}if(r.name!=null&&r.hasOwnProperty("name")&&(f.name=r.name),r.initializer&&r.initializer.length)for(f.initializer=[],g=0;g<r.initializer.length;++g)f.initializer[g]=h.onnx.TensorProto.toObject(r.initializer[g],u);if(r.docString!=null&&r.hasOwnProperty("docString")&&(f.docString=r.docString),r.input&&r.input.length)for(f.input=[],g=0;g<r.input.length;++g)f.input[g]=h.onnx.ValueInfoProto.toObject(r.input[g],u);if(r.output&&r.output.length)for(f.output=[],g=0;g<r.output.length;++g)f.output[g]=h.onnx.ValueInfoProto.toObject(r.output[g],u);if(r.valueInfo&&r.valueInfo.length)for(f.valueInfo=[],g=0;g<r.valueInfo.length;++g)f.valueInfo[g]=h.onnx.ValueInfoProto.toObject(r.valueInfo[g],u);if(r.quantizationAnnotation&&r.quantizationAnnotation.length)for(f.quantizationAnnotation=[],g=0;g<r.quantizationAnnotation.length;++g)f.quantizationAnnotation[g]=h.onnx.TensorAnnotation.toObject(r.quantizationAnnotation[g],u);return f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c.TensorProto=(function(){function i(r){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.dims=d.emptyArray,i.prototype.dataType=0,i.prototype.segment=null,i.prototype.floatData=d.emptyArray,i.prototype.int32Data=d.emptyArray,i.prototype.stringData=d.emptyArray,i.prototype.int64Data=d.emptyArray,i.prototype.name="",i.prototype.docString="",i.prototype.rawData=d.newBuffer([]),i.prototype.externalData=d.emptyArray,i.prototype.dataLocation=0,i.prototype.doubleData=d.emptyArray,i.prototype.uint64Data=d.emptyArray,i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.dims!=null&&r.dims.length){u.uint32(10).fork();for(var f=0;f<r.dims.length;++f)u.int64(r.dims[f]);u.ldelim()}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&u.uint32(16).int32(r.dataType),r.segment!=null&&r.hasOwnProperty("segment")&&h.onnx.TensorProto.Segment.encode(r.segment,u.uint32(26).fork()).ldelim(),r.floatData!=null&&r.floatData.length){for(u.uint32(34).fork(),f=0;f<r.floatData.length;++f)u.float(r.floatData[f]);u.ldelim()}if(r.int32Data!=null&&r.int32Data.length){for(u.uint32(42).fork(),f=0;f<r.int32Data.length;++f)u.int32(r.int32Data[f]);u.ldelim()}if(r.stringData!=null&&r.stringData.length)for(f=0;f<r.stringData.length;++f)u.uint32(50).bytes(r.stringData[f]);if(r.int64Data!=null&&r.int64Data.length){for(u.uint32(58).fork(),f=0;f<r.int64Data.length;++f)u.int64(r.int64Data[f]);u.ldelim()}if(r.name!=null&&r.hasOwnProperty("name")&&u.uint32(66).string(r.name),r.rawData!=null&&r.hasOwnProperty("rawData")&&u.uint32(74).bytes(r.rawData),r.doubleData!=null&&r.doubleData.length){for(u.uint32(82).fork(),f=0;f<r.doubleData.length;++f)u.double(r.doubleData[f]);u.ldelim()}if(r.uint64Data!=null&&r.uint64Data.length){for(u.uint32(90).fork(),f=0;f<r.uint64Data.length;++f)u.uint64(r.uint64Data[f]);u.ldelim()}if(r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(98).string(r.docString),r.externalData!=null&&r.externalData.length)for(f=0;f<r.externalData.length;++f)h.onnx.StringStringEntryProto.encode(r.externalData[f],u.uint32(106).fork()).ldelim();return r.dataLocation!=null&&r.hasOwnProperty("dataLocation")&&u.uint32(112).int32(r.dataLocation),u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.TensorProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:if(g.dims&&g.dims.length||(g.dims=[]),(7&w)==2)for(var y=r.uint32()+r.pos;r.pos<y;)g.dims.push(r.int64());else g.dims.push(r.int64());break;case 2:g.dataType=r.int32();break;case 3:g.segment=h.onnx.TensorProto.Segment.decode(r,r.uint32());break;case 4:if(g.floatData&&g.floatData.length||(g.floatData=[]),(7&w)==2)for(y=r.uint32()+r.pos;r.pos<y;)g.floatData.push(r.float());else g.floatData.push(r.float());break;case 5:if(g.int32Data&&g.int32Data.length||(g.int32Data=[]),(7&w)==2)for(y=r.uint32()+r.pos;r.pos<y;)g.int32Data.push(r.int32());else g.int32Data.push(r.int32());break;case 6:g.stringData&&g.stringData.length||(g.stringData=[]),g.stringData.push(r.bytes());break;case 7:if(g.int64Data&&g.int64Data.length||(g.int64Data=[]),(7&w)==2)for(y=r.uint32()+r.pos;r.pos<y;)g.int64Data.push(r.int64());else g.int64Data.push(r.int64());break;case 8:g.name=r.string();break;case 12:g.docString=r.string();break;case 9:g.rawData=r.bytes();break;case 13:g.externalData&&g.externalData.length||(g.externalData=[]),g.externalData.push(h.onnx.StringStringEntryProto.decode(r,r.uint32()));break;case 14:g.dataLocation=r.int32();break;case 10:if(g.doubleData&&g.doubleData.length||(g.doubleData=[]),(7&w)==2)for(y=r.uint32()+r.pos;r.pos<y;)g.doubleData.push(r.double());else g.doubleData.push(r.double());break;case 11:if(g.uint64Data&&g.uint64Data.length||(g.uint64Data=[]),(7&w)==2)for(y=r.uint32()+r.pos;r.pos<y;)g.uint64Data.push(r.uint64());else g.uint64Data.push(r.uint64());break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.dims!=null&&r.hasOwnProperty("dims")){if(!Array.isArray(r.dims))return"dims: array expected";for(var u=0;u<r.dims.length;++u)if(!(d.isInteger(r.dims[u])||r.dims[u]&&d.isInteger(r.dims[u].low)&&d.isInteger(r.dims[u].high)))return"dims: integer|Long[] expected"}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&!d.isInteger(r.dataType))return"dataType: integer expected";if(r.segment!=null&&r.hasOwnProperty("segment")&&(f=h.onnx.TensorProto.Segment.verify(r.segment)))return"segment."+f;if(r.floatData!=null&&r.hasOwnProperty("floatData")){if(!Array.isArray(r.floatData))return"floatData: array expected";for(u=0;u<r.floatData.length;++u)if(typeof r.floatData[u]!="number")return"floatData: number[] expected"}if(r.int32Data!=null&&r.hasOwnProperty("int32Data")){if(!Array.isArray(r.int32Data))return"int32Data: array expected";for(u=0;u<r.int32Data.length;++u)if(!d.isInteger(r.int32Data[u]))return"int32Data: integer[] expected"}if(r.stringData!=null&&r.hasOwnProperty("stringData")){if(!Array.isArray(r.stringData))return"stringData: array expected";for(u=0;u<r.stringData.length;++u)if(!(r.stringData[u]&&typeof r.stringData[u].length=="number"||d.isString(r.stringData[u])))return"stringData: buffer[] expected"}if(r.int64Data!=null&&r.hasOwnProperty("int64Data")){if(!Array.isArray(r.int64Data))return"int64Data: array expected";for(u=0;u<r.int64Data.length;++u)if(!(d.isInteger(r.int64Data[u])||r.int64Data[u]&&d.isInteger(r.int64Data[u].low)&&d.isInteger(r.int64Data[u].high)))return"int64Data: integer|Long[] expected"}if(r.name!=null&&r.hasOwnProperty("name")&&!d.isString(r.name))return"name: string expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!d.isString(r.docString))return"docString: string expected";if(r.rawData!=null&&r.hasOwnProperty("rawData")&&!(r.rawData&&typeof r.rawData.length=="number"||d.isString(r.rawData)))return"rawData: buffer expected";if(r.externalData!=null&&r.hasOwnProperty("externalData")){if(!Array.isArray(r.externalData))return"externalData: array expected";for(u=0;u<r.externalData.length;++u){var f;if(f=h.onnx.StringStringEntryProto.verify(r.externalData[u]))return"externalData."+f}}if(r.dataLocation!=null&&r.hasOwnProperty("dataLocation"))switch(r.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(r.doubleData!=null&&r.hasOwnProperty("doubleData")){if(!Array.isArray(r.doubleData))return"doubleData: array expected";for(u=0;u<r.doubleData.length;++u)if(typeof r.doubleData[u]!="number")return"doubleData: number[] expected"}if(r.uint64Data!=null&&r.hasOwnProperty("uint64Data")){if(!Array.isArray(r.uint64Data))return"uint64Data: array expected";for(u=0;u<r.uint64Data.length;++u)if(!(d.isInteger(r.uint64Data[u])||r.uint64Data[u]&&d.isInteger(r.uint64Data[u].low)&&d.isInteger(r.uint64Data[u].high)))return"uint64Data: integer|Long[] expected"}return null},i.fromObject=function(r){if(r instanceof h.onnx.TensorProto)return r;var u=new h.onnx.TensorProto;if(r.dims){if(!Array.isArray(r.dims))throw TypeError(".onnx.TensorProto.dims: array expected");u.dims=[];for(var f=0;f<r.dims.length;++f)d.Long?(u.dims[f]=d.Long.fromValue(r.dims[f])).unsigned=!1:typeof r.dims[f]=="string"?u.dims[f]=parseInt(r.dims[f],10):typeof r.dims[f]=="number"?u.dims[f]=r.dims[f]:typeof r.dims[f]=="object"&&(u.dims[f]=new d.LongBits(r.dims[f].low>>>0,r.dims[f].high>>>0).toNumber())}if(r.dataType!=null&&(u.dataType=0|r.dataType),r.segment!=null){if(typeof r.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");u.segment=h.onnx.TensorProto.Segment.fromObject(r.segment)}if(r.floatData){if(!Array.isArray(r.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(u.floatData=[],f=0;f<r.floatData.length;++f)u.floatData[f]=Number(r.floatData[f])}if(r.int32Data){if(!Array.isArray(r.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(u.int32Data=[],f=0;f<r.int32Data.length;++f)u.int32Data[f]=0|r.int32Data[f]}if(r.stringData){if(!Array.isArray(r.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(u.stringData=[],f=0;f<r.stringData.length;++f)typeof r.stringData[f]=="string"?d.base64.decode(r.stringData[f],u.stringData[f]=d.newBuffer(d.base64.length(r.stringData[f])),0):r.stringData[f].length&&(u.stringData[f]=r.stringData[f])}if(r.int64Data){if(!Array.isArray(r.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(u.int64Data=[],f=0;f<r.int64Data.length;++f)d.Long?(u.int64Data[f]=d.Long.fromValue(r.int64Data[f])).unsigned=!1:typeof r.int64Data[f]=="string"?u.int64Data[f]=parseInt(r.int64Data[f],10):typeof r.int64Data[f]=="number"?u.int64Data[f]=r.int64Data[f]:typeof r.int64Data[f]=="object"&&(u.int64Data[f]=new d.LongBits(r.int64Data[f].low>>>0,r.int64Data[f].high>>>0).toNumber())}if(r.name!=null&&(u.name=String(r.name)),r.docString!=null&&(u.docString=String(r.docString)),r.rawData!=null&&(typeof r.rawData=="string"?d.base64.decode(r.rawData,u.rawData=d.newBuffer(d.base64.length(r.rawData)),0):r.rawData.length&&(u.rawData=r.rawData)),r.externalData){if(!Array.isArray(r.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(u.externalData=[],f=0;f<r.externalData.length;++f){if(typeof r.externalData[f]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");u.externalData[f]=h.onnx.StringStringEntryProto.fromObject(r.externalData[f])}}switch(r.dataLocation){case"DEFAULT":case 0:u.dataLocation=0;break;case"EXTERNAL":case 1:u.dataLocation=1}if(r.doubleData){if(!Array.isArray(r.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(u.doubleData=[],f=0;f<r.doubleData.length;++f)u.doubleData[f]=Number(r.doubleData[f])}if(r.uint64Data){if(!Array.isArray(r.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(u.uint64Data=[],f=0;f<r.uint64Data.length;++f)d.Long?(u.uint64Data[f]=d.Long.fromValue(r.uint64Data[f])).unsigned=!0:typeof r.uint64Data[f]=="string"?u.uint64Data[f]=parseInt(r.uint64Data[f],10):typeof r.uint64Data[f]=="number"?u.uint64Data[f]=r.uint64Data[f]:typeof r.uint64Data[f]=="object"&&(u.uint64Data[f]=new d.LongBits(r.uint64Data[f].low>>>0,r.uint64Data[f].high>>>0).toNumber(!0))}return u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.dims=[],f.floatData=[],f.int32Data=[],f.stringData=[],f.int64Data=[],f.doubleData=[],f.uint64Data=[],f.externalData=[]),u.defaults&&(f.dataType=0,f.segment=null,f.name="",u.bytes===String?f.rawData="":(f.rawData=[],u.bytes!==Array&&(f.rawData=d.newBuffer(f.rawData))),f.docString="",f.dataLocation=u.enums===String?"DEFAULT":0),r.dims&&r.dims.length){f.dims=[];for(var g=0;g<r.dims.length;++g)typeof r.dims[g]=="number"?f.dims[g]=u.longs===String?String(r.dims[g]):r.dims[g]:f.dims[g]=u.longs===String?d.Long.prototype.toString.call(r.dims[g]):u.longs===Number?new d.LongBits(r.dims[g].low>>>0,r.dims[g].high>>>0).toNumber():r.dims[g]}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&(f.dataType=r.dataType),r.segment!=null&&r.hasOwnProperty("segment")&&(f.segment=h.onnx.TensorProto.Segment.toObject(r.segment,u)),r.floatData&&r.floatData.length)for(f.floatData=[],g=0;g<r.floatData.length;++g)f.floatData[g]=u.json&&!isFinite(r.floatData[g])?String(r.floatData[g]):r.floatData[g];if(r.int32Data&&r.int32Data.length)for(f.int32Data=[],g=0;g<r.int32Data.length;++g)f.int32Data[g]=r.int32Data[g];if(r.stringData&&r.stringData.length)for(f.stringData=[],g=0;g<r.stringData.length;++g)f.stringData[g]=u.bytes===String?d.base64.encode(r.stringData[g],0,r.stringData[g].length):u.bytes===Array?Array.prototype.slice.call(r.stringData[g]):r.stringData[g];if(r.int64Data&&r.int64Data.length)for(f.int64Data=[],g=0;g<r.int64Data.length;++g)typeof r.int64Data[g]=="number"?f.int64Data[g]=u.longs===String?String(r.int64Data[g]):r.int64Data[g]:f.int64Data[g]=u.longs===String?d.Long.prototype.toString.call(r.int64Data[g]):u.longs===Number?new d.LongBits(r.int64Data[g].low>>>0,r.int64Data[g].high>>>0).toNumber():r.int64Data[g];if(r.name!=null&&r.hasOwnProperty("name")&&(f.name=r.name),r.rawData!=null&&r.hasOwnProperty("rawData")&&(f.rawData=u.bytes===String?d.base64.encode(r.rawData,0,r.rawData.length):u.bytes===Array?Array.prototype.slice.call(r.rawData):r.rawData),r.doubleData&&r.doubleData.length)for(f.doubleData=[],g=0;g<r.doubleData.length;++g)f.doubleData[g]=u.json&&!isFinite(r.doubleData[g])?String(r.doubleData[g]):r.doubleData[g];if(r.uint64Data&&r.uint64Data.length)for(f.uint64Data=[],g=0;g<r.uint64Data.length;++g)typeof r.uint64Data[g]=="number"?f.uint64Data[g]=u.longs===String?String(r.uint64Data[g]):r.uint64Data[g]:f.uint64Data[g]=u.longs===String?d.Long.prototype.toString.call(r.uint64Data[g]):u.longs===Number?new d.LongBits(r.uint64Data[g].low>>>0,r.uint64Data[g].high>>>0).toNumber(!0):r.uint64Data[g];if(r.docString!=null&&r.hasOwnProperty("docString")&&(f.docString=r.docString),r.externalData&&r.externalData.length)for(f.externalData=[],g=0;g<r.externalData.length;++g)f.externalData[g]=h.onnx.StringStringEntryProto.toObject(r.externalData[g],u);return r.dataLocation!=null&&r.hasOwnProperty("dataLocation")&&(f.dataLocation=u.enums===String?h.onnx.TensorProto.DataLocation[r.dataLocation]:r.dataLocation),f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i.DataType=(function(){var r={},u=Object.create(r);return u[r[0]="UNDEFINED"]=0,u[r[1]="FLOAT"]=1,u[r[2]="UINT8"]=2,u[r[3]="INT8"]=3,u[r[4]="UINT16"]=4,u[r[5]="INT16"]=5,u[r[6]="INT32"]=6,u[r[7]="INT64"]=7,u[r[8]="STRING"]=8,u[r[9]="BOOL"]=9,u[r[10]="FLOAT16"]=10,u[r[11]="DOUBLE"]=11,u[r[12]="UINT32"]=12,u[r[13]="UINT64"]=13,u[r[14]="COMPLEX64"]=14,u[r[15]="COMPLEX128"]=15,u[r[16]="BFLOAT16"]=16,u})(),i.Segment=(function(){function r(u){if(u)for(var f=Object.keys(u),g=0;g<f.length;++g)u[f[g]]!=null&&(this[f[g]]=u[f[g]])}return r.prototype.begin=d.Long?d.Long.fromBits(0,0,!1):0,r.prototype.end=d.Long?d.Long.fromBits(0,0,!1):0,r.create=function(u){return new r(u)},r.encode=function(u,f){return f||(f=m.create()),u.begin!=null&&u.hasOwnProperty("begin")&&f.uint32(8).int64(u.begin),u.end!=null&&u.hasOwnProperty("end")&&f.uint32(16).int64(u.end),f},r.encodeDelimited=function(u,f){return this.encode(u,f).ldelim()},r.decode=function(u,f){u instanceof _||(u=_.create(u));for(var g=f===void 0?u.len:u.pos+f,w=new h.onnx.TensorProto.Segment;u.pos<g;){var y=u.uint32();switch(y>>>3){case 1:w.begin=u.int64();break;case 2:w.end=u.int64();break;default:u.skipType(7&y)}}return w},r.decodeDelimited=function(u){return u instanceof _||(u=new _(u)),this.decode(u,u.uint32())},r.verify=function(u){return typeof u!="object"||u===null?"object expected":u.begin!=null&&u.hasOwnProperty("begin")&&!(d.isInteger(u.begin)||u.begin&&d.isInteger(u.begin.low)&&d.isInteger(u.begin.high))?"begin: integer|Long expected":u.end!=null&&u.hasOwnProperty("end")&&!(d.isInteger(u.end)||u.end&&d.isInteger(u.end.low)&&d.isInteger(u.end.high))?"end: integer|Long expected":null},r.fromObject=function(u){if(u instanceof h.onnx.TensorProto.Segment)return u;var f=new h.onnx.TensorProto.Segment;return u.begin!=null&&(d.Long?(f.begin=d.Long.fromValue(u.begin)).unsigned=!1:typeof u.begin=="string"?f.begin=parseInt(u.begin,10):typeof u.begin=="number"?f.begin=u.begin:typeof u.begin=="object"&&(f.begin=new d.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber())),u.end!=null&&(d.Long?(f.end=d.Long.fromValue(u.end)).unsigned=!1:typeof u.end=="string"?f.end=parseInt(u.end,10):typeof u.end=="number"?f.end=u.end:typeof u.end=="object"&&(f.end=new d.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber())),f},r.toObject=function(u,f){f||(f={});var g={};if(f.defaults){if(d.Long){var w=new d.Long(0,0,!1);g.begin=f.longs===String?w.toString():f.longs===Number?w.toNumber():w}else g.begin=f.longs===String?"0":0;d.Long?(w=new d.Long(0,0,!1),g.end=f.longs===String?w.toString():f.longs===Number?w.toNumber():w):g.end=f.longs===String?"0":0}return u.begin!=null&&u.hasOwnProperty("begin")&&(typeof u.begin=="number"?g.begin=f.longs===String?String(u.begin):u.begin:g.begin=f.longs===String?d.Long.prototype.toString.call(u.begin):f.longs===Number?new d.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber():u.begin),u.end!=null&&u.hasOwnProperty("end")&&(typeof u.end=="number"?g.end=f.longs===String?String(u.end):u.end:g.end=f.longs===String?d.Long.prototype.toString.call(u.end):f.longs===Number?new d.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber():u.end),g},r.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},r})(),i.DataLocation=(function(){var r={},u=Object.create(r);return u[r[0]="DEFAULT"]=0,u[r[1]="EXTERNAL"]=1,u})(),i})(),c.TensorShapeProto=(function(){function i(r){if(this.dim=[],r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.dim=d.emptyArray,i.create=function(r){return new i(r)},i.encode=function(r,u){if(u||(u=m.create()),r.dim!=null&&r.dim.length)for(var f=0;f<r.dim.length;++f)h.onnx.TensorShapeProto.Dimension.encode(r.dim[f],u.uint32(10).fork()).ldelim();return u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.TensorShapeProto;r.pos<f;){var w=r.uint32();w>>>3==1?(g.dim&&g.dim.length||(g.dim=[]),g.dim.push(h.onnx.TensorShapeProto.Dimension.decode(r,r.uint32()))):r.skipType(7&w)}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.dim!=null&&r.hasOwnProperty("dim")){if(!Array.isArray(r.dim))return"dim: array expected";for(var u=0;u<r.dim.length;++u){var f=h.onnx.TensorShapeProto.Dimension.verify(r.dim[u]);if(f)return"dim."+f}}return null},i.fromObject=function(r){if(r instanceof h.onnx.TensorShapeProto)return r;var u=new h.onnx.TensorShapeProto;if(r.dim){if(!Array.isArray(r.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");u.dim=[];for(var f=0;f<r.dim.length;++f){if(typeof r.dim[f]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");u.dim[f]=h.onnx.TensorShapeProto.Dimension.fromObject(r.dim[f])}}return u},i.toObject=function(r,u){u||(u={});var f={};if((u.arrays||u.defaults)&&(f.dim=[]),r.dim&&r.dim.length){f.dim=[];for(var g=0;g<r.dim.length;++g)f.dim[g]=h.onnx.TensorShapeProto.Dimension.toObject(r.dim[g],u)}return f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i.Dimension=(function(){function r(f){if(f)for(var g=Object.keys(f),w=0;w<g.length;++w)f[g[w]]!=null&&(this[g[w]]=f[g[w]])}var u;return r.prototype.dimValue=d.Long?d.Long.fromBits(0,0,!1):0,r.prototype.dimParam="",r.prototype.denotation="",Object.defineProperty(r.prototype,"value",{get:d.oneOfGetter(u=["dimValue","dimParam"]),set:d.oneOfSetter(u)}),r.create=function(f){return new r(f)},r.encode=function(f,g){return g||(g=m.create()),f.dimValue!=null&&f.hasOwnProperty("dimValue")&&g.uint32(8).int64(f.dimValue),f.dimParam!=null&&f.hasOwnProperty("dimParam")&&g.uint32(18).string(f.dimParam),f.denotation!=null&&f.hasOwnProperty("denotation")&&g.uint32(26).string(f.denotation),g},r.encodeDelimited=function(f,g){return this.encode(f,g).ldelim()},r.decode=function(f,g){f instanceof _||(f=_.create(f));for(var w=g===void 0?f.len:f.pos+g,y=new h.onnx.TensorShapeProto.Dimension;f.pos<w;){var x=f.uint32();switch(x>>>3){case 1:y.dimValue=f.int64();break;case 2:y.dimParam=f.string();break;case 3:y.denotation=f.string();break;default:f.skipType(7&x)}}return y},r.decodeDelimited=function(f){return f instanceof _||(f=new _(f)),this.decode(f,f.uint32())},r.verify=function(f){if(typeof f!="object"||f===null)return"object expected";var g={};if(f.dimValue!=null&&f.hasOwnProperty("dimValue")&&(g.value=1,!(d.isInteger(f.dimValue)||f.dimValue&&d.isInteger(f.dimValue.low)&&d.isInteger(f.dimValue.high))))return"dimValue: integer|Long expected";if(f.dimParam!=null&&f.hasOwnProperty("dimParam")){if(g.value===1)return"value: multiple values";if(g.value=1,!d.isString(f.dimParam))return"dimParam: string expected"}return f.denotation!=null&&f.hasOwnProperty("denotation")&&!d.isString(f.denotation)?"denotation: string expected":null},r.fromObject=function(f){if(f instanceof h.onnx.TensorShapeProto.Dimension)return f;var g=new h.onnx.TensorShapeProto.Dimension;return f.dimValue!=null&&(d.Long?(g.dimValue=d.Long.fromValue(f.dimValue)).unsigned=!1:typeof f.dimValue=="string"?g.dimValue=parseInt(f.dimValue,10):typeof f.dimValue=="number"?g.dimValue=f.dimValue:typeof f.dimValue=="object"&&(g.dimValue=new d.LongBits(f.dimValue.low>>>0,f.dimValue.high>>>0).toNumber())),f.dimParam!=null&&(g.dimParam=String(f.dimParam)),f.denotation!=null&&(g.denotation=String(f.denotation)),g},r.toObject=function(f,g){g||(g={});var w={};return g.defaults&&(w.denotation=""),f.dimValue!=null&&f.hasOwnProperty("dimValue")&&(typeof f.dimValue=="number"?w.dimValue=g.longs===String?String(f.dimValue):f.dimValue:w.dimValue=g.longs===String?d.Long.prototype.toString.call(f.dimValue):g.longs===Number?new d.LongBits(f.dimValue.low>>>0,f.dimValue.high>>>0).toNumber():f.dimValue,g.oneofs&&(w.value="dimValue")),f.dimParam!=null&&f.hasOwnProperty("dimParam")&&(w.dimParam=f.dimParam,g.oneofs&&(w.value="dimParam")),f.denotation!=null&&f.hasOwnProperty("denotation")&&(w.denotation=f.denotation),w},r.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},r})(),i})(),c.TypeProto=(function(){function i(u){if(u)for(var f=Object.keys(u),g=0;g<f.length;++g)u[f[g]]!=null&&(this[f[g]]=u[f[g]])}var r;return i.prototype.tensorType=null,i.prototype.denotation="",Object.defineProperty(i.prototype,"value",{get:d.oneOfGetter(r=["tensorType"]),set:d.oneOfSetter(r)}),i.create=function(u){return new i(u)},i.encode=function(u,f){return f||(f=m.create()),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&h.onnx.TypeProto.Tensor.encode(u.tensorType,f.uint32(10).fork()).ldelim(),u.denotation!=null&&u.hasOwnProperty("denotation")&&f.uint32(50).string(u.denotation),f},i.encodeDelimited=function(u,f){return this.encode(u,f).ldelim()},i.decode=function(u,f){u instanceof _||(u=_.create(u));for(var g=f===void 0?u.len:u.pos+f,w=new h.onnx.TypeProto;u.pos<g;){var y=u.uint32();switch(y>>>3){case 1:w.tensorType=h.onnx.TypeProto.Tensor.decode(u,u.uint32());break;case 6:w.denotation=u.string();break;default:u.skipType(7&y)}}return w},i.decodeDelimited=function(u){return u instanceof _||(u=new _(u)),this.decode(u,u.uint32())},i.verify=function(u){if(typeof u!="object"||u===null)return"object expected";if(u.tensorType!=null&&u.hasOwnProperty("tensorType")){var f=h.onnx.TypeProto.Tensor.verify(u.tensorType);if(f)return"tensorType."+f}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!d.isString(u.denotation)?"denotation: string expected":null},i.fromObject=function(u){if(u instanceof h.onnx.TypeProto)return u;var f=new h.onnx.TypeProto;if(u.tensorType!=null){if(typeof u.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");f.tensorType=h.onnx.TypeProto.Tensor.fromObject(u.tensorType)}return u.denotation!=null&&(f.denotation=String(u.denotation)),f},i.toObject=function(u,f){f||(f={});var g={};return f.defaults&&(g.denotation=""),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&(g.tensorType=h.onnx.TypeProto.Tensor.toObject(u.tensorType,f),f.oneofs&&(g.value="tensorType")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(g.denotation=u.denotation),g},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i.Tensor=(function(){function u(f){if(f)for(var g=Object.keys(f),w=0;w<g.length;++w)f[g[w]]!=null&&(this[g[w]]=f[g[w]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(f){return new u(f)},u.encode=function(f,g){return g||(g=m.create()),f.elemType!=null&&f.hasOwnProperty("elemType")&&g.uint32(8).int32(f.elemType),f.shape!=null&&f.hasOwnProperty("shape")&&h.onnx.TensorShapeProto.encode(f.shape,g.uint32(18).fork()).ldelim(),g},u.encodeDelimited=function(f,g){return this.encode(f,g).ldelim()},u.decode=function(f,g){f instanceof _||(f=_.create(f));for(var w=g===void 0?f.len:f.pos+g,y=new h.onnx.TypeProto.Tensor;f.pos<w;){var x=f.uint32();switch(x>>>3){case 1:y.elemType=f.int32();break;case 2:y.shape=h.onnx.TensorShapeProto.decode(f,f.uint32());break;default:f.skipType(7&x)}}return y},u.decodeDelimited=function(f){return f instanceof _||(f=new _(f)),this.decode(f,f.uint32())},u.verify=function(f){if(typeof f!="object"||f===null)return"object expected";if(f.elemType!=null&&f.hasOwnProperty("elemType")&&!d.isInteger(f.elemType))return"elemType: integer expected";if(f.shape!=null&&f.hasOwnProperty("shape")){var g=h.onnx.TensorShapeProto.verify(f.shape);if(g)return"shape."+g}return null},u.fromObject=function(f){if(f instanceof h.onnx.TypeProto.Tensor)return f;var g=new h.onnx.TypeProto.Tensor;if(f.elemType!=null&&(g.elemType=0|f.elemType),f.shape!=null){if(typeof f.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");g.shape=h.onnx.TensorShapeProto.fromObject(f.shape)}return g},u.toObject=function(f,g){g||(g={});var w={};return g.defaults&&(w.elemType=0,w.shape=null),f.elemType!=null&&f.hasOwnProperty("elemType")&&(w.elemType=f.elemType),f.shape!=null&&f.hasOwnProperty("shape")&&(w.shape=h.onnx.TensorShapeProto.toObject(f.shape,g)),w},u.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},u})(),i})(),c.OperatorSetIdProto=(function(){function i(r){if(r)for(var u=Object.keys(r),f=0;f<u.length;++f)r[u[f]]!=null&&(this[u[f]]=r[u[f]])}return i.prototype.domain="",i.prototype.version=d.Long?d.Long.fromBits(0,0,!1):0,i.create=function(r){return new i(r)},i.encode=function(r,u){return u||(u=m.create()),r.domain!=null&&r.hasOwnProperty("domain")&&u.uint32(10).string(r.domain),r.version!=null&&r.hasOwnProperty("version")&&u.uint32(16).int64(r.version),u},i.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},i.decode=function(r,u){r instanceof _||(r=_.create(r));for(var f=u===void 0?r.len:r.pos+u,g=new h.onnx.OperatorSetIdProto;r.pos<f;){var w=r.uint32();switch(w>>>3){case 1:g.domain=r.string();break;case 2:g.version=r.int64();break;default:r.skipType(7&w)}}return g},i.decodeDelimited=function(r){return r instanceof _||(r=new _(r)),this.decode(r,r.uint32())},i.verify=function(r){return typeof r!="object"||r===null?"object expected":r.domain!=null&&r.hasOwnProperty("domain")&&!d.isString(r.domain)?"domain: string expected":r.version!=null&&r.hasOwnProperty("version")&&!(d.isInteger(r.version)||r.version&&d.isInteger(r.version.low)&&d.isInteger(r.version.high))?"version: integer|Long expected":null},i.fromObject=function(r){if(r instanceof h.onnx.OperatorSetIdProto)return r;var u=new h.onnx.OperatorSetIdProto;return r.domain!=null&&(u.domain=String(r.domain)),r.version!=null&&(d.Long?(u.version=d.Long.fromValue(r.version)).unsigned=!1:typeof r.version=="string"?u.version=parseInt(r.version,10):typeof r.version=="number"?u.version=r.version:typeof r.version=="object"&&(u.version=new d.LongBits(r.version.low>>>0,r.version.high>>>0).toNumber())),u},i.toObject=function(r,u){u||(u={});var f={};if(u.defaults)if(f.domain="",d.Long){var g=new d.Long(0,0,!1);f.version=u.longs===String?g.toString():u.longs===Number?g.toNumber():g}else f.version=u.longs===String?"0":0;return r.domain!=null&&r.hasOwnProperty("domain")&&(f.domain=r.domain),r.version!=null&&r.hasOwnProperty("version")&&(typeof r.version=="number"?f.version=u.longs===String?String(r.version):r.version:f.version=u.longs===String?d.Long.prototype.toString.call(r.version):u.longs===Number?new d.LongBits(r.version.low>>>0,r.version.high>>>0).toNumber():r.version),f},i.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},i})(),c),n.exports=h},2100:(n,e,t)=>{n.exports=t(9482)},9482:(n,e,t)=>{var s=e;function a(){s.util._configure(),s.Writer._configure(s.BufferWriter),s.Reader._configure(s.BufferReader)}s.build="minimal",s.Writer=t(1173),s.BufferWriter=t(3155),s.Reader=t(1408),s.BufferReader=t(593),s.util=t(9693),s.rpc=t(5994),s.roots=t(5054),s.configure=a,a()},1408:(n,e,t)=>{n.exports=m;var s,a=t(9693),c=a.LongBits,l=a.utf8;function _(g,w){return RangeError("index out of range: "+g.pos+" + "+(w||1)+" > "+g.len)}function m(g){this.buf=g,this.pos=0,this.len=g.length}var d,h=typeof Uint8Array<"u"?function(g){if(g instanceof Uint8Array||Array.isArray(g))return new m(g);throw Error("illegal buffer")}:function(g){if(Array.isArray(g))return new m(g);throw Error("illegal buffer")},i=function(){return a.Buffer?function(g){return(m.create=function(w){return a.Buffer.isBuffer(w)?new s(w):h(w)})(g)}:h};function r(){var g=new c(0,0),w=0;if(!(this.len-this.pos>4)){for(;w<3;++w){if(this.pos>=this.len)throw _(this);if(g.lo=(g.lo|(127&this.buf[this.pos])<<7*w)>>>0,this.buf[this.pos++]<128)return g}return g.lo=(g.lo|(127&this.buf[this.pos++])<<7*w)>>>0,g}for(;w<4;++w)if(g.lo=(g.lo|(127&this.buf[this.pos])<<7*w)>>>0,this.buf[this.pos++]<128)return g;if(g.lo=(g.lo|(127&this.buf[this.pos])<<28)>>>0,g.hi=(g.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return g;if(w=0,this.len-this.pos>4){for(;w<5;++w)if(g.hi=(g.hi|(127&this.buf[this.pos])<<7*w+3)>>>0,this.buf[this.pos++]<128)return g}else for(;w<5;++w){if(this.pos>=this.len)throw _(this);if(g.hi=(g.hi|(127&this.buf[this.pos])<<7*w+3)>>>0,this.buf[this.pos++]<128)return g}throw Error("invalid varint encoding")}function u(g,w){return(g[w-4]|g[w-3]<<8|g[w-2]<<16|g[w-1]<<24)>>>0}function f(){if(this.pos+8>this.len)throw _(this,8);return new c(u(this.buf,this.pos+=4),u(this.buf,this.pos+=4))}m.create=i(),m.prototype._slice=a.Array.prototype.subarray||a.Array.prototype.slice,m.prototype.uint32=(d=4294967295,function(){if(d=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(d=(d|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(d=(d|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(d=(d|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(d=(d|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return d;if((this.pos+=5)>this.len)throw this.pos=this.len,_(this,10);return d}),m.prototype.int32=function(){return 0|this.uint32()},m.prototype.sint32=function(){var g=this.uint32();return g>>>1^-(1&g)|0},m.prototype.bool=function(){return this.uint32()!==0},m.prototype.fixed32=function(){if(this.pos+4>this.len)throw _(this,4);return u(this.buf,this.pos+=4)},m.prototype.sfixed32=function(){if(this.pos+4>this.len)throw _(this,4);return 0|u(this.buf,this.pos+=4)},m.prototype.float=function(){if(this.pos+4>this.len)throw _(this,4);var g=a.float.readFloatLE(this.buf,this.pos);return this.pos+=4,g},m.prototype.double=function(){if(this.pos+8>this.len)throw _(this,4);var g=a.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,g},m.prototype.bytes=function(){var g=this.uint32(),w=this.pos,y=this.pos+g;if(y>this.len)throw _(this,g);return this.pos+=g,Array.isArray(this.buf)?this.buf.slice(w,y):w===y?new this.buf.constructor(0):this._slice.call(this.buf,w,y)},m.prototype.string=function(){var g=this.bytes();return l.read(g,0,g.length)},m.prototype.skip=function(g){if(typeof g=="number"){if(this.pos+g>this.len)throw _(this,g);this.pos+=g}else do if(this.pos>=this.len)throw _(this);while(128&this.buf[this.pos++]);return this},m.prototype.skipType=function(g){switch(g){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(g=7&this.uint32())!=4;)this.skipType(g);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+g+" at offset "+this.pos)}return this},m._configure=function(g){s=g,m.create=i(),s._configure();var w=a.Long?"toLong":"toNumber";a.merge(m.prototype,{int64:function(){return r.call(this)[w](!1)},uint64:function(){return r.call(this)[w](!0)},sint64:function(){return r.call(this).zzDecode()[w](!1)},fixed64:function(){return f.call(this)[w](!0)},sfixed64:function(){return f.call(this)[w](!1)}})}},593:(n,e,t)=>{n.exports=c;var s=t(1408);(c.prototype=Object.create(s.prototype)).constructor=c;var a=t(9693);function c(l){s.call(this,l)}c._configure=function(){a.Buffer&&(c.prototype._slice=a.Buffer.prototype.slice)},c.prototype.string=function(){var l=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+l,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+l,this.len))},c._configure()},5054:n=>{n.exports={}},5994:(n,e,t)=>{e.Service=t(7948)},7948:(n,e,t)=>{n.exports=a;var s=t(9693);function a(c,l,_){if(typeof c!="function")throw TypeError("rpcImpl must be a function");s.EventEmitter.call(this),this.rpcImpl=c,this.requestDelimited=!!l,this.responseDelimited=!!_}(a.prototype=Object.create(s.EventEmitter.prototype)).constructor=a,a.prototype.rpcCall=function c(l,_,m,d,h){if(!d)throw TypeError("request must be specified");var i=this;if(!h)return s.asPromise(c,i,l,_,m,d);if(i.rpcImpl)try{return i.rpcImpl(l,_[i.requestDelimited?"encodeDelimited":"encode"](d).finish(),(function(r,u){if(r)return i.emit("error",r,l),h(r);if(u!==null){if(!(u instanceof m))try{u=m[i.responseDelimited?"decodeDelimited":"decode"](u)}catch(f){return i.emit("error",f,l),h(f)}return i.emit("data",u,l),h(null,u)}i.end(!0)}))}catch(r){return i.emit("error",r,l),void setTimeout((function(){h(r)}),0)}else setTimeout((function(){h(Error("already ended"))}),0)},a.prototype.end=function(c){return this.rpcImpl&&(c||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(n,e,t)=>{n.exports=a;var s=t(9693);function a(m,d){this.lo=m>>>0,this.hi=d>>>0}var c=a.zero=new a(0,0);c.toNumber=function(){return 0},c.zzEncode=c.zzDecode=function(){return this},c.length=function(){return 1};var l=a.zeroHash="\0\0\0\0\0\0\0\0";a.fromNumber=function(m){if(m===0)return c;var d=m<0;d&&(m=-m);var h=m>>>0,i=(m-h)/4294967296>>>0;return d&&(i=~i>>>0,h=~h>>>0,++h>4294967295&&(h=0,++i>4294967295&&(i=0))),new a(h,i)},a.from=function(m){if(typeof m=="number")return a.fromNumber(m);if(s.isString(m)){if(!s.Long)return a.fromNumber(parseInt(m,10));m=s.Long.fromString(m)}return m.low||m.high?new a(m.low>>>0,m.high>>>0):c},a.prototype.toNumber=function(m){if(!m&&this.hi>>>31){var d=1+~this.lo>>>0,h=~this.hi>>>0;return d||(h=h+1>>>0),-(d+4294967296*h)}return this.lo+4294967296*this.hi},a.prototype.toLong=function(m){return s.Long?new s.Long(0|this.lo,0|this.hi,!!m):{low:0|this.lo,high:0|this.hi,unsigned:!!m}};var _=String.prototype.charCodeAt;a.fromHash=function(m){return m===l?c:new a((_.call(m,0)|_.call(m,1)<<8|_.call(m,2)<<16|_.call(m,3)<<24)>>>0,(_.call(m,4)|_.call(m,5)<<8|_.call(m,6)<<16|_.call(m,7)<<24)>>>0)},a.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},a.prototype.zzEncode=function(){var m=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^m)>>>0,this.lo=(this.lo<<1^m)>>>0,this},a.prototype.zzDecode=function(){var m=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^m)>>>0,this.hi=(this.hi>>>1^m)>>>0,this},a.prototype.length=function(){var m=this.lo,d=(this.lo>>>28|this.hi<<4)>>>0,h=this.hi>>>24;return h===0?d===0?m<16384?m<128?1:2:m<2097152?3:4:d<16384?d<128?5:6:d<2097152?7:8:h<128?9:10}},9693:function(n,e,t){var s=e;function a(l,_,m){for(var d=Object.keys(_),h=0;h<d.length;++h)l[d[h]]!==void 0&&m||(l[d[h]]=_[d[h]]);return l}function c(l){function _(m,d){if(!(this instanceof _))return new _(m,d);Object.defineProperty(this,"message",{get:function(){return m}}),Error.captureStackTrace?Error.captureStackTrace(this,_):Object.defineProperty(this,"stack",{value:new Error().stack||""}),d&&a(this,d)}return(_.prototype=Object.create(Error.prototype)).constructor=_,Object.defineProperty(_.prototype,"name",{get:function(){return l}}),_.prototype.toString=function(){return this.name+": "+this.message},_}s.asPromise=t(4537),s.base64=t(7419),s.EventEmitter=t(9211),s.float=t(945),s.inquire=t(7199),s.utf8=t(4997),s.pool=t(6662),s.LongBits=t(1945),s.isNode=!!(t.g!==void 0&&t.g&&t.g.process&&t.g.process.versions&&t.g.process.versions.node),s.global=s.isNode&&t.g||typeof window<"u"&&window||typeof self<"u"&&self||this,s.emptyArray=Object.freeze?Object.freeze([]):[],s.emptyObject=Object.freeze?Object.freeze({}):{},s.isInteger=Number.isInteger||function(l){return typeof l=="number"&&isFinite(l)&&Math.floor(l)===l},s.isString=function(l){return typeof l=="string"||l instanceof String},s.isObject=function(l){return l&&typeof l=="object"},s.isset=s.isSet=function(l,_){var m=l[_];return!(m==null||!l.hasOwnProperty(_))&&(typeof m!="object"||(Array.isArray(m)?m.length:Object.keys(m).length)>0)},s.Buffer=(function(){try{var l=s.inquire("buffer").Buffer;return l.prototype.utf8Write?l:null}catch{return null}})(),s._Buffer_from=null,s._Buffer_allocUnsafe=null,s.newBuffer=function(l){return typeof l=="number"?s.Buffer?s._Buffer_allocUnsafe(l):new s.Array(l):s.Buffer?s._Buffer_from(l):typeof Uint8Array>"u"?l:new Uint8Array(l)},s.Array=typeof Uint8Array<"u"?Uint8Array:Array,s.Long=s.global.dcodeIO&&s.global.dcodeIO.Long||s.global.Long||s.inquire("long"),s.key2Re=/^true|false|0|1$/,s.key32Re=/^-?(?:0|[1-9][0-9]*)$/,s.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,s.longToHash=function(l){return l?s.LongBits.from(l).toHash():s.LongBits.zeroHash},s.longFromHash=function(l,_){var m=s.LongBits.fromHash(l);return s.Long?s.Long.fromBits(m.lo,m.hi,_):m.toNumber(!!_)},s.merge=a,s.lcFirst=function(l){return l.charAt(0).toLowerCase()+l.substring(1)},s.newError=c,s.ProtocolError=c("ProtocolError"),s.oneOfGetter=function(l){for(var _={},m=0;m<l.length;++m)_[l[m]]=1;return function(){for(var d=Object.keys(this),h=d.length-1;h>-1;--h)if(_[d[h]]===1&&this[d[h]]!==void 0&&this[d[h]]!==null)return d[h]}},s.oneOfSetter=function(l){return function(_){for(var m=0;m<l.length;++m)l[m]!==_&&delete this[l[m]]}},s.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},s._configure=function(){var l=s.Buffer;l?(s._Buffer_from=l.from!==Uint8Array.from&&l.from||function(_,m){return new l(_,m)},s._Buffer_allocUnsafe=l.allocUnsafe||function(_){return new l(_)}):s._Buffer_from=s._Buffer_allocUnsafe=null}},1173:(n,e,t)=>{n.exports=i;var s,a=t(9693),c=a.LongBits,l=a.base64,_=a.utf8;function m(x,S,T){this.fn=x,this.len=S,this.next=void 0,this.val=T}function d(){}function h(x){this.head=x.head,this.tail=x.tail,this.len=x.len,this.next=x.states}function i(){this.len=0,this.head=new m(d,0,0),this.tail=this.head,this.states=null}var r=function(){return a.Buffer?function(){return(i.create=function(){return new s})()}:function(){return new i}};function u(x,S,T){S[T]=255&x}function f(x,S){this.len=x,this.next=void 0,this.val=S}function g(x,S,T){for(;x.hi;)S[T++]=127&x.lo|128,x.lo=(x.lo>>>7|x.hi<<25)>>>0,x.hi>>>=7;for(;x.lo>127;)S[T++]=127&x.lo|128,x.lo=x.lo>>>7;S[T++]=x.lo}function w(x,S,T){S[T]=255&x,S[T+1]=x>>>8&255,S[T+2]=x>>>16&255,S[T+3]=x>>>24}i.create=r(),i.alloc=function(x){return new a.Array(x)},a.Array!==Array&&(i.alloc=a.pool(i.alloc,a.Array.prototype.subarray)),i.prototype._push=function(x,S,T){return this.tail=this.tail.next=new m(x,S,T),this.len+=S,this},f.prototype=Object.create(m.prototype),f.prototype.fn=function(x,S,T){for(;x>127;)S[T++]=127&x|128,x>>>=7;S[T]=x},i.prototype.uint32=function(x){return this.len+=(this.tail=this.tail.next=new f((x>>>=0)<128?1:x<16384?2:x<2097152?3:x<268435456?4:5,x)).len,this},i.prototype.int32=function(x){return x<0?this._push(g,10,c.fromNumber(x)):this.uint32(x)},i.prototype.sint32=function(x){return this.uint32((x<<1^x>>31)>>>0)},i.prototype.uint64=function(x){var S=c.from(x);return this._push(g,S.length(),S)},i.prototype.int64=i.prototype.uint64,i.prototype.sint64=function(x){var S=c.from(x).zzEncode();return this._push(g,S.length(),S)},i.prototype.bool=function(x){return this._push(u,1,x?1:0)},i.prototype.fixed32=function(x){return this._push(w,4,x>>>0)},i.prototype.sfixed32=i.prototype.fixed32,i.prototype.fixed64=function(x){var S=c.from(x);return this._push(w,4,S.lo)._push(w,4,S.hi)},i.prototype.sfixed64=i.prototype.fixed64,i.prototype.float=function(x){return this._push(a.float.writeFloatLE,4,x)},i.prototype.double=function(x){return this._push(a.float.writeDoubleLE,8,x)};var y=a.Array.prototype.set?function(x,S,T){S.set(x,T)}:function(x,S,T){for(var E=0;E<x.length;++E)S[T+E]=x[E]};i.prototype.bytes=function(x){var S=x.length>>>0;if(!S)return this._push(u,1,0);if(a.isString(x)){var T=i.alloc(S=l.length(x));l.decode(x,T,0),x=T}return this.uint32(S)._push(y,S,x)},i.prototype.string=function(x){var S=_.length(x);return S?this.uint32(S)._push(_.write,S,x):this._push(u,1,0)},i.prototype.fork=function(){return this.states=new h(this),this.head=this.tail=new m(d,0,0),this.len=0,this},i.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new m(d,0,0),this.len=0),this},i.prototype.ldelim=function(){var x=this.head,S=this.tail,T=this.len;return this.reset().uint32(T),T&&(this.tail.next=x.next,this.tail=S,this.len+=T),this},i.prototype.finish=function(){for(var x=this.head.next,S=this.constructor.alloc(this.len),T=0;x;)x.fn(x.val,S,T),T+=x.len,x=x.next;return S},i._configure=function(x){s=x,i.create=r(),s._configure()}},3155:(n,e,t)=>{n.exports=c;var s=t(1173);(c.prototype=Object.create(s.prototype)).constructor=c;var a=t(9693);function c(){s.call(this)}function l(_,m,d){_.length<40?a.utf8.write(_,m,d):m.utf8Write?m.utf8Write(_,d):m.write(_,d)}c._configure=function(){c.alloc=a._Buffer_allocUnsafe,c.writeBytesBuffer=a.Buffer&&a.Buffer.prototype instanceof Uint8Array&&a.Buffer.prototype.set.name==="set"?function(_,m,d){m.set(_,d)}:function(_,m,d){if(_.copy)_.copy(m,d,0,_.length);else for(var h=0;h<_.length;)m[d++]=_[h++]}},c.prototype.bytes=function(_){a.isString(_)&&(_=a._Buffer_from(_,"base64"));var m=_.length>>>0;return this.uint32(m),m&&this._push(c.writeBytesBuffer,m,_),this},c.prototype.string=function(_){var m=a.Buffer.byteLength(_);return this.uint32(m),m&&this._push(l,m,_),this},c._configure()},7714:(n,e,t)=>{e.R=void 0;const s=t(6919),a=t(7448);e.R=new class{async init(){}async createSessionHandler(c,l){const _=new s.Session(l);return await _.loadModel(c),new a.OnnxjsSessionHandler(_)}}},4200:(n,e,t)=>{e.c8=e.rX=void 0;const s=t(1670),a=t(5381),c=t(2157),l=t(2306);e.rX=()=>{if((typeof s.env.wasm.initTimeout!="number"||s.env.wasm.initTimeout<0)&&(s.env.wasm.initTimeout=0),typeof s.env.wasm.simd!="boolean"&&(s.env.wasm.simd=!0),typeof s.env.wasm.proxy!="boolean"&&(s.env.wasm.proxy=!1),typeof s.env.wasm.numThreads!="number"||!Number.isInteger(s.env.wasm.numThreads)||s.env.wasm.numThreads<=0){const _=typeof navigator>"u"?(0,a.cpus)().length:navigator.hardwareConcurrency;s.env.wasm.numThreads=Math.min(4,Math.ceil((_||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,c.initWasm)()}async createSessionHandler(_,m){const d=new l.OnnxruntimeWebAssemblySessionHandler;return await d.loadModel(_,m),Promise.resolve(d)}}},6018:function(n,e,t){var s=this&&this.__createBinding||(Object.create?function(l,_,m,d){d===void 0&&(d=m);var h=Object.getOwnPropertyDescriptor(_,m);h&&!("get"in h?!_.__esModule:h.writable||h.configurable)||(h={enumerable:!0,get:function(){return _[m]}}),Object.defineProperty(l,d,h)}:function(l,_,m,d){d===void 0&&(d=m),l[d]=_[m]}),a=this&&this.__exportStar||function(l,_){for(var m in l)m==="default"||Object.prototype.hasOwnProperty.call(_,m)||s(_,l,m)};Object.defineProperty(e,"__esModule",{value:!0}),a(t(1670),e);const c=t(1670);{const l=t(7714).R;(0,c.registerBackend)("webgl",l,-10)}{const l=t(4200).c8;(0,c.registerBackend)("cpu",l,10),(0,c.registerBackend)("wasm",l,10),(0,c.registerBackend)("xnnpack",l,9)}},246:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createAttributeWithCacheKey=void 0;class t{constructor(a){Object.assign(this,a)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((a=>`${this[a]}`)).join(";")),this._cacheKey}}e.createAttributeWithCacheKey=s=>new t(s)},7778:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Attribute=void 0;const s=t(1446),a=t(9395),c=t(9162),l=t(2517);var _=a.onnxruntime.experimental.fbs;class m{constructor(h){if(this._attributes=new Map,h!=null){for(const i of h)i instanceof s.onnx.AttributeProto?this._attributes.set(i.name,[m.getValue(i),m.getType(i)]):i instanceof _.Attribute&&this._attributes.set(i.name(),[m.getValue(i),m.getType(i)]);if(this._attributes.size<h.length)throw new Error("duplicated attribute names")}}set(h,i,r){this._attributes.set(h,[r,i])}delete(h){this._attributes.delete(h)}getFloat(h,i){return this.get(h,"float",i)}getInt(h,i){return this.get(h,"int",i)}getString(h,i){return this.get(h,"string",i)}getTensor(h,i){return this.get(h,"tensor",i)}getFloats(h,i){return this.get(h,"floats",i)}getInts(h,i){return this.get(h,"ints",i)}getStrings(h,i){return this.get(h,"strings",i)}getTensors(h,i){return this.get(h,"tensors",i)}get(h,i,r){const u=this._attributes.get(h);if(u===void 0){if(r!==void 0)return r;throw new Error(`required attribute not found: ${h}`)}if(u[1]!==i)throw new Error(`type mismatch: expected ${i} but got ${u[1]}`);return u[0]}static getType(h){const i=h instanceof s.onnx.AttributeProto?h.type:h.type();switch(i){case s.onnx.AttributeProto.AttributeType.FLOAT:return"float";case s.onnx.AttributeProto.AttributeType.INT:return"int";case s.onnx.AttributeProto.AttributeType.STRING:return"string";case s.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case s.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case s.onnx.AttributeProto.AttributeType.INTS:return"ints";case s.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case s.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${s.onnx.AttributeProto.AttributeType[i]}`)}}static getValue(h){const i=h instanceof s.onnx.AttributeProto?h.type:h.type();if(i===s.onnx.AttributeProto.AttributeType.GRAPH||i===s.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const r=this.getValueNoCheck(h);if(i===s.onnx.AttributeProto.AttributeType.INT&&l.LongUtil.isLong(r))return l.LongUtil.longToNumber(r);if(i===s.onnx.AttributeProto.AttributeType.INTS){const u=r,f=new Array(u.length);for(let g=0;g<u.length;g++){const w=u[g];f[g]=l.LongUtil.longToNumber(w)}return f}if(i===s.onnx.AttributeProto.AttributeType.TENSOR)return h instanceof s.onnx.AttributeProto?c.Tensor.fromProto(r):c.Tensor.fromOrtTensor(r);if(i===s.onnx.AttributeProto.AttributeType.TENSORS){if(h instanceof s.onnx.AttributeProto)return r.map((u=>c.Tensor.fromProto(u)));if(h instanceof _.Attribute)return r.map((u=>c.Tensor.fromOrtTensor(u)))}if(i===s.onnx.AttributeProto.AttributeType.STRING&&h instanceof s.onnx.AttributeProto){const u=r;return(0,l.decodeUtf8String)(u)}return i===s.onnx.AttributeProto.AttributeType.STRINGS&&h instanceof s.onnx.AttributeProto?r.map(l.decodeUtf8String):r}static getValueNoCheck(h){return h instanceof s.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(h):this.getValueNoCheckFromOrtFormat(h)}static getValueNoCheckFromOnnxFormat(h){switch(h.type){case s.onnx.AttributeProto.AttributeType.FLOAT:return h.f;case s.onnx.AttributeProto.AttributeType.INT:return h.i;case s.onnx.AttributeProto.AttributeType.STRING:return h.s;case s.onnx.AttributeProto.AttributeType.TENSOR:return h.t;case s.onnx.AttributeProto.AttributeType.GRAPH:return h.g;case s.onnx.AttributeProto.AttributeType.FLOATS:return h.floats;case s.onnx.AttributeProto.AttributeType.INTS:return h.ints;case s.onnx.AttributeProto.AttributeType.STRINGS:return h.strings;case s.onnx.AttributeProto.AttributeType.TENSORS:return h.tensors;case s.onnx.AttributeProto.AttributeType.GRAPHS:return h.graphs;default:throw new Error(`unsupported attribute type: ${s.onnx.AttributeProto.AttributeType[h.type]}`)}}static getValueNoCheckFromOrtFormat(h){switch(h.type()){case _.AttributeType.FLOAT:return h.f();case _.AttributeType.INT:return h.i();case _.AttributeType.STRING:return h.s();case _.AttributeType.TENSOR:return h.t();case _.AttributeType.GRAPH:return h.g();case _.AttributeType.FLOATS:return h.floatsArray();case _.AttributeType.INTS:{const i=[];for(let r=0;r<h.intsLength();r++)i.push(h.ints(r));return i}case _.AttributeType.STRINGS:{const i=[];for(let r=0;r<h.stringsLength();r++)i.push(h.strings(r));return i}case _.AttributeType.TENSORS:{const i=[];for(let r=0;r<h.tensorsLength();r++)i.push(h.tensors(r));return i}default:throw new Error(`unsupported attribute type: ${_.AttributeType[h.type()]}`)}}}e.Attribute=m},7091:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.resolveBackend=e.backend=void 0;const s=t(5038),a=new Map;async function c(l){const _=e.backend;if(_[l]!==void 0&&(function(m){const d=m;return"initialize"in d&&typeof d.initialize=="function"&&"createSessionHandler"in d&&typeof d.createSessionHandler=="function"&&"dispose"in d&&typeof d.dispose=="function"})(_[l])){const m=_[l];let d=m.initialize();if(typeof d=="object"&&"then"in d&&(d=await d),d)return a.set(l,m),m}}e.backend={webgl:new s.WebGLBackend},e.resolveBackend=async function l(_){if(!_)return l(["webgl"]);{const m=typeof _=="string"?[_]:_;for(const d of m){const h=a.get(d);if(h)return h;const i=await c(d);if(i)return i}}throw new Error("no available backend to use")}},5038:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLBackend=void 0;const s=t(1670),a=t(6231),c=t(6416),l=t(7305);e.WebGLBackend=class{get contextId(){return s.env.webgl.contextId}set contextId(_){s.env.webgl.contextId=_}get matmulMaxBatchSize(){return s.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(_){s.env.webgl.matmulMaxBatchSize=_}get textureCacheMode(){return s.env.webgl.textureCacheMode}set textureCacheMode(_){s.env.webgl.textureCacheMode=_}get pack(){return s.env.webgl.pack}set pack(_){s.env.webgl.pack=_}get async(){return s.env.webgl.async}set async(_){s.env.webgl.async=_}initialize(){try{return this.glContext=(0,l.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),a.Logger.setWithEnv(s.env),a.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(_){return a.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${_}`),!1}}createSessionHandler(_){return new c.WebGLSessionHandler(this,_)}dispose(){this.glContext.dispose()}}},5107:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.CoordsGlslLib=void 0;const s=t(2517),a=t(8520),c=t(5060),l=t(7859),_=t(9390);class m extends a.GlslLib{constructor(h){super(h)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new a.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new a.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const h=this.context.outputTextureLayout;return h.isPacked?this.getPackedOutputSamplingSnippet(h):this.getUnpackedOutputSamplingSnippet(h)}getPackedOutputSamplingSnippet(h){const i=h.unpackedShape,r=[h.width,h.height],u={},f="getOutputCoords";switch(i.length){case 0:u[f]=this.getOutputScalarCoords();break;case 1:u[f]=this.getOutputPacked1DCoords(i,r);break;case 2:u[f]=this.getOutputPacked2DCoords(i,r);break;case 3:u[f]=this.getOutputPacked3DCoords(i,r);break;default:u[f]=this.getOutputPackedNDCoords(i,r)}const g=`
      void setOutput(vec4 val) {
        ${(0,c.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return u.floatTextureSetRGBA=new a.GlslLibRoutine(g),u}getUnpackedOutputSamplingSnippet(h){const i=h.unpackedShape,r=[h.width,h.height],u={},f="getOutputCoords";switch(i.length){case 0:u[f]=this.getOutputScalarCoords();break;case 1:u[f]=this.getOutputUnpacked1DCoords(i,r);break;case 2:u[f]=this.getOutputUnpacked2DCoords(i,r);break;case 3:u[f]=this.getOutputUnpacked3DCoords(i,r);break;case 4:u[f]=this.getOutputUnpacked4DCoords(i,r);break;case 5:u[f]=this.getOutputUnpacked5DCoords(i,r);break;case 6:u[f]=this.getOutputUnpacked6DCoords(i,r);break;default:throw new Error(`Unsupported output dimensionality: ${i.length}`)}const g=`
        void setOutput(float val) {
          ${(0,c.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return u.floatTextureSetR=new a.GlslLibRoutine(g),u}getOutputScalarCoords(){return new a.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(h,i){const r=i;let u="";return r[0]===1?(u=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${r[1]}.0);
          }
        `,new a.GlslLibRoutine(u)):r[1]===1?(u=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${r[0]}.0);
          }
        `,new a.GlslLibRoutine(u)):(u=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${r[0]}, ${r[1]}));
          return 2 * (resTexRC.y * ${r[0]} + resTexRC.x);
        }
      `,new a.GlslLibRoutine(u))}getOutputPacked2DCoords(h,i){let r="";if(s.ArrayUtil.arraysEqual(h,i))return r=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${i[0]}, ${i[1]}));
        }
      `,new a.GlslLibRoutine(r);const u=i,f=Math.ceil(h[1]/2);return r=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${u[0]}, ${u[1]}));

          int index = resTexRC.y * ${u[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${f}) * 2;
          int c = 2 * (index / ${f});

          return ivec2(r, c);
        }
      `,new a.GlslLibRoutine(r)}getOutputPacked3DCoords(h,i){const r=[i[0],i[1]],u=Math.ceil(h[2]/2),f=u*Math.ceil(h[1]/2),g=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;

          int b = index / ${f};
          index -= b * ${f};

          // reverse r and c order for packed texture
          int r = imod(index, ${u}) * 2;
          int c = 2 * (index / ${u});

          return ivec3(b, r, c);
        }
      `;return new a.GlslLibRoutine(g)}getOutputPackedNDCoords(h,i){const r=[i[0],i[1]],u=Math.ceil(h[h.length-1]/2),f=u*Math.ceil(h[h.length-2]/2);let g=f,w="",y="b, r, c";for(let S=2;S<h.length-1;S++)g*=h[h.length-S-1],w=`
      int b${S} = index / ${g};
      index -= b${S} * ${g};
    `+w,y=`b${S}, `+y;const x=`
      ivec${h.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${r[0]}, ${r[1]}));
        int index = resTexRC.y * ${r[0]} + resTexRC.x;

        ${w}

        int b = index / ${f};
        index -= b * ${f};

        // reverse r and c order for packed texture
        int r = imod(index, ${u}) * 2;
        int c = 2 * (index / ${u});

        return ivec${h.length}(${y});
      }
    `;return new a.GlslLibRoutine(x)}getOutputUnpacked1DCoords(h,i){const r=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          return resTexRC.y * ${i[0]} + resTexRC.x;
        }
      `;return new a.GlslLibRoutine(r)}getOutputUnpacked2DCoords(h,i){const r=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;
          int r = index / ${h[1]};
          int c = index - r * ${h[1]};
          return ivec2(r, c);
        }
      `;return new a.GlslLibRoutine(r)}getOutputUnpacked3DCoords(h,i){let r="";const u=h.length;let f=null;u<2&&(f=[]),f=new Array(u-1),f[u-2]=h[u-1];for(let y=u-3;y>=0;--y)f[y]=f[y+1]*h[y+1];const g=["r","c","d"],w=f.map(((y,x)=>`int ${g[x]} = index / ${y}; ${x===f.length-1?`int ${g[x+1]} = index - ${g[x]} * ${y}`:`index -= ${g[x]} * ${y}`};`)).join("");return r=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;
          ${w}
          return ivec3(r, c, d);
        }
      `,new a.GlslLibRoutine(r)}getOutputUnpacked4DCoords(h,i){let r="";const u=h.length;let f=null;u<2&&(f=[]),f=new Array(u-1),f[u-2]=h[u-1];for(let y=u-3;y>=0;--y)f[y]=f[y+1]*h[y+1];const g=["r","c","d","d2"],w=f.map(((y,x)=>`int ${g[x]} = index / ${y}; ${x===f.length-1?`int ${g[x+1]} = index - ${g[x]} * ${y}`:`index -= ${g[x]} * ${y}`};`)).join("");return r=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;
          ${w}
          return ivec4(r, c, d, d2);
        }
      `,new a.GlslLibRoutine(r)}getOutputUnpacked5DCoords(h,i){let r="";const u=h.length;let f=null;u<2&&(f=[]),f=new Array(u-1),f[u-2]=h[u-1];for(let y=u-3;y>=0;--y)f[y]=f[y+1]*h[y+1];const g=["r","c","d","d2","d3"],w=f.map(((y,x)=>`int ${g[x]} = index / ${y}; ${x===f.length-1?`int ${g[x+1]} = index - ${g[x]} * ${y}`:`index -= ${g[x]} * ${y}`};`)).join("");return r=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;
          ${w}
          return ivec5(r, c, d, d2, d3);
        }
      `,new a.GlslLibRoutine(r)}getOutputUnpacked6DCoords(h,i){let r="";const u=h.length;let f=null;u<2&&(f=[]),f=new Array(u-1),f[u-2]=h[u-1];for(let y=u-3;y>=0;--y)f[y]=f[y+1]*h[y+1];const g=["r","c","d","d2","d3","d4"],w=f.map(((y,x)=>`int ${g[x]} = index / ${y}; ${x===f.length-1?`int ${g[x+1]} = index - ${g[x]} * ${y}`:`index -= ${g[x]} * ${y}`};`)).join("");return r=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${i[0]}, ${i[1]}));
         int index = resTexRC.y * ${i[0]} + resTexRC.x;
         ${w}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new a.GlslLibRoutine(r)}getCommonUtilFuncs(){const h={};let i="uvFromFlat";h[i]=new a.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),i="packedUVfrom1D",h[i]=new a.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),i="packedUVfrom2D",h[i]=new a.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),i="packedUVfrom3D",h[i]=new a.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),i="sampleTexture";const r=(0,c.getGlsl)(this.context.glContext.version);return h[i]=new a.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${r.texture2D}(textureSampler, uv).r;
        }`),h}getInputsSamplingSnippets(){const h={},i=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((r,u)=>{const f=this.context.inputTextureLayouts[u],g=(0,_.generateShaderFuncNameFromInputSamplerName)(r);f.isPacked?h[g]=this.getPackedSamplerFromInput(g,r,f):h[g]=this.getUnpackedSamplerFromInput(g,r,f);const w=(0,_.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(r);f.unpackedShape.length<=i.unpackedShape.length&&(f.isPacked?h[w]=this.getPackedSamplerAtOutputCoords(w,f,i,r):h[w]=this.getUnpackedSamplerAtOutputCoords(w,f,i,r))})),h}getPackedSamplerAtOutputCoords(h,i,r,u){const f=i.unpackedShape,g=r.unpackedShape,w=u,y=(0,_.generateShaderFuncNameFromInputSamplerName)(w),x=f.length,S=g.length,T=s.BroadcastUtil.getBroadcastDims(f,g),E=(0,_.getCoordsDataType)(S),A=S-x;let C;const I=(0,_.getGlChannels)();C=x===0?"":S<2&&T.length>=1?"coords = 0;":T.map((te=>`coords.${I[te+A]} = 0;`)).join(`
`);let D="";D=S<2&&x>0?"coords":f.map(((te,q)=>`coords.${I[q+A]}`)).join(", ");let R="return outputValue;";const Y=s.ShapeUtil.size(f)===1,re=s.ShapeUtil.size(g)===1;if(x!==1||Y||re){if(Y&&!re)R=S===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(T.length){const te=x-2,q=x-1;T.indexOf(te)>-1&&T.indexOf(q)>-1?R="return vec4(outputValue.x);":T.indexOf(te)>-1?R="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":T.indexOf(q)>-1&&(R="return vec4(outputValue.xx, outputValue.zz);")}}else R=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const G=`
      vec4 ${h}() {
        ${E} coords = getOutputCoords();
        
        int lastDim = coords.${I[S-1]};
        coords.${I[S-1]} = coords.${I[S-2]};
        coords.${I[S-2]} = lastDim;
      
        ${C}
        vec4 outputValue = ${y}(${D});
        ${R}
      }
    `;return new a.GlslLibRoutine(G,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(h,i,r,u){const f=[r.width,r.height],g=[i.width,i.height],w=i.unpackedShape.length,y=r.unpackedShape.length,x=i.unpackedShape,S=r.unpackedShape,T=(0,_.generateShaderFuncNameFromInputSamplerName)(u);if(w===y&&s.ArrayUtil.arraysEqual(g,f)){const re=`
          float ${h}() {
            return sampleTexture(${u}, TexCoords);
          }
        `;return new a.GlslLibRoutine(re,["coordinates.sampleTexture"])}const E=(0,_.getCoordsDataType)(y),A=s.BroadcastUtil.getBroadcastDims(x,S),C=y-w;let I;const D=(0,_.getGlChannels)();I=w===0?"":y<2&&A.length>=1?"coords = 0;":A.map((re=>`coords.${D[re+C]} = 0;`)).join(`
`);let R="";R=y<2&&w>0?"coords":i.unpackedShape.map(((re,G)=>`coords.${D[G+C]}`)).join(", ");const Y=`
        float ${h}() {
          ${E} coords = getOutputCoords();
          ${I}
          return ${T}(${R});
        }
      `;return new a.GlslLibRoutine(Y,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(h,i,r){switch(r.unpackedShape.length){case 0:return this.getPackedSamplerScalar(h,i);case 1:return this.getPackedSampler1D(h,i,r);case 2:return this.getPackedSampler2D(h,i,r);case 3:return this.getPackedSampler3D(h,i,r);default:return this.getPackedSamplerND(h,i,r)}}getUnpackedSamplerFromInput(h,i,r){const u=r.unpackedShape;switch(u.length){case 0:return this.getUnpackedSamplerScalar(h,i,r);case 1:return this.getUnpackedSampler1D(h,i,r);case 2:return this.getUnpackedSampler2D(h,i,r);case 3:return this.getUnpackedSampler3D(h,i,r);case 4:return this.getUnpackedSampler4D(h,i,r);case 5:return this.getUnpackedSampler5D(h,i,r);case 6:return this.getUnpackedSampler6D(h,i,r);default:throw new Error(`Unsupported dimension ${u.length}-D`)}}getPackedSamplerScalar(h,i){const r=`
          vec4 ${h}() {
            return ${(0,c.getGlsl)(this.context.glContext.version).texture2D}(${i}, halfCR);
          }
        `;return new a.GlslLibRoutine(r)}getPackedSampler1D(h,i,r){const u=[r.width,r.height],f=[u[1],u[0]],g=(0,c.getGlsl)(this.context.glContext.version),w=`vec4 ${h}(int index) {
      vec2 uv = packedUVfrom1D(
      ${f[0]}, ${f[1]}, index);
      return ${g.texture2D}(${i}, uv);
    }`;return new a.GlslLibRoutine(w,["coordinates.packedUVfrom1D"])}getPackedSampler2D(h,i,r){const u=r.unpackedShape,f=[r.width,r.height],g=(0,c.getGlsl)(this.context.glContext.version),w=f[0],y=f[1];if(f!=null&&s.ArrayUtil.arraysEqual(u,f)){const E=`vec4 ${h}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${w}.0);
        return ${g.texture2D}(${i}, uv);
      }`;return new a.GlslLibRoutine(E)}const x=f,S=Math.ceil(u[1]/2),T=`vec4 ${h}(int row, int col) {
      vec2 uv = packedUVfrom2D(${x[1]}, ${x[0]}, ${S}, row, col);
      return ${g.texture2D}(${i}, uv);
    }`;return new a.GlslLibRoutine(T,["coordinates.packedUVfrom2D"])}getPackedSampler3D(h,i,r){const u=r.unpackedShape,f=[r.width,r.height],g=[f[0],f[1]],w=(0,c.getGlsl)(this.context.glContext.version);if(u[0]===1){const E=u.slice(1),A=[1,2],C=(0,_.squeezeInputShape)(u,E),I=["b","row","col"],D=JSON.parse(JSON.stringify(r));D.unpackedShape=C;const R=this.getPackedSamplerFromInput(h,i,D),Y=`${R.routineBody}
      vec4 ${h}(int b, int row, int col) {
        return ${h}(${(0,_.getSqueezedParams)(I,A)});
      } `;return new a.GlslLibRoutine(Y,R.dependencies)}const y=g[0],x=g[1],S=Math.ceil(u[2]/2),T=`vec4 ${h}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${x}, ${y}, ${S*Math.ceil(u[1]/2)}, ${S}, b, row, col);
      return ${w.texture2D}(${i}, uv);}`;return new a.GlslLibRoutine(T,["coordinates.packedUVfrom3D"])}getPackedSamplerND(h,i,r){const u=r.unpackedShape,f=u.length,g=[r.width,r.height],w=(0,c.getGlsl)(this.context.glContext.version),y=[g[0],g[1]],x=y[1],S=y[0],T=Math.ceil(u[f-1]/2);let E=T*Math.ceil(u[f-2]/2),A="int b, int row, int col",C=`b * ${E} + (row / 2) * ${T} + (col / 2)`;for(let D=2;D<f-1;D++)A=`int b${D}, `+A,E*=u[f-D-1],C=`b${D} * ${E} + `+C;const I=`vec4 ${h}(${A}) {
      int index = ${C};
      int texR = index / ${S};
      int texC = index - texR * ${S};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${S}, ${x});
      return ${w.texture2D}(${i}, uv);
    }`;return new a.GlslLibRoutine(I)}getUnpackedSamplerScalar(h,i,r){const[u,f]=[r.width,r.height];if(u===1&&f===1){const w=`
          float ${h}() {
            return sampleTexture(${i}, halfCR);
          }
        `;return new a.GlslLibRoutine(w,["coordinates.sampleTexture"])}const g=`
        float ${h}() {
          int offset_${i} = coordsToOffset(TexCoords, ${u}, ${f});
          vec2 uv = uvFromFlat(${u}, ${f}, offset_${i});
          return sampleTexture(${i}, uv);
        }
      `;return new a.GlslLibRoutine(g,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(h,i,r){const u=r.width,f=r.height;if(f===1&&u===1){const w=`
        float ${h}(int index) {
          return sampleTexture(${i}, halfCR);
        }
      `;return new a.GlslLibRoutine(w,["coordinates.sampleTexture"])}if(f===1){const w=`
          float ${h}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${u}.0, 0.5);
            return sampleTexture(${i}, uv);
          }
        `;return new a.GlslLibRoutine(w,["coordinates.sampleTexture"])}if(u===1){const w=`
          float ${h}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${f}.0);
            return sampleTexture(${i}, uv);
          }
        `;return new a.GlslLibRoutine(w,["coordinates.sampleTexture"])}const g=`
        float ${h}(int index) {
          vec2 uv = uvFromFlat(${u}, ${f}, index);
          return sampleTexture(${i}, uv);
        }
      `;return new a.GlslLibRoutine(g,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(h,i,r){const u=r.unpackedShape,f=[r.height,r.width];if(f!=null&&s.ArrayUtil.arraysEqual(u,f)){const E=`
          float ${h}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${f[1]}.0, ${f[0]}.0);
            return sampleTexture(${i}, uv);
          }
        `;return new a.GlslLibRoutine(E,["coordinates.sampleTexture"])}const{newShape:g,keptDims:w}=(0,l.squeezeShape)(u),y=g;if(y.length<u.length){const E=(0,_.squeezeInputShape)(u,y),A=JSON.parse(JSON.stringify(r));A.unpackedShape=E;const C=["col","row"],I=`
          ${this.getUnpackedSamplerFromInput(h,i,A).routineBody}
          float ${h}(int row, int col) {
            return ${h}(${(0,_.getSqueezedParams)(C,w)});
          }
        `;return new a.GlslLibRoutine(I,["coordinates.sampleTexture"])}const x=f[1],S=f[0];if(S===1){const E=`
          float ${h}(int row, int col) {
            int offset_${i} = coordsToOffset(TexCoords, ${x}, ${S});
            float index = dot(vec3(row, col, offset_${i}), vec3(${u[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${x}.0);
            return sampleTexture(${i}, uv);
          }
        `;return new a.GlslLibRoutine(E,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(x===1){const E=`
          float ${h}(int row, int col) {
            int offset_${i} = coordsToOffset(TexCoords, ${x}, ${S});
            float index = dot(vec3(row, col, offset_${i}), vec3(${u[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${S}.0, 0.5);
            return sampleTexture(${i}, uv);
          }
        `;return new a.GlslLibRoutine(E,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const T=`
        float ${h}(int row, int col) {
          int index = col * ${u[1]} + row;
          vec2 uv = uvFromFlat(${x}, ${S}, index);
          return sampleTexture(${i}, uv);
        }
      `;return new a.GlslLibRoutine(T,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(h,i,r){const u=r.unpackedShape,f=u[1]*u[2],g=u[2],{newShape:w,keptDims:y}=(0,l.squeezeShape)(u),x=w;if(x.length<u.length){const T=(0,_.squeezeInputShape)(u,x),E=["batch","col","row"],A=JSON.parse(JSON.stringify(r));A.unpackedShape=T;const C=this.getUnpackedSamplerFromInput(h,i,A),I=y.reverse(),D=`
          ${C.routineBody}
          float ${h}(int batch, int row, int col) {
            return ${h}(${(0,_.getSqueezedParams)(E,I)});
          }
        `;return new a.GlslLibRoutine(D,C.dependencies)}const S=`
          float ${h}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${f} + col * ${g} + row;
            vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
            return sampleTexture(${i}, uv);
          }
      `;return new a.GlslLibRoutine(S,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(h,i,r){const u=r.unpackedShape,f=u[3],g=u[2]*f,w=`
        float ${h}(int row, int col, int depth, int depth2) {
          int index = row * ${u[1]*g} + col * ${g} +
              depth2 * ${f} + depth;
          vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
          return sampleTexture(${i}, uv);
        }
      `;return new a.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(h,i,r){const u=r.unpackedShape,f=u[4],g=u[3]*f,w=u[2]*g,y=u[1]*w,{newShape:x,keptDims:S}=(0,l.squeezeShape)(u);if(x.length<u.length){const E=(0,_.squeezeInputShape)(u,x),A=["row","col","depth","depth2","depth3"],C=JSON.parse(JSON.stringify(r));C.unpackedShape=E;const I=`
          ${this.getUnpackedSamplerFromInput(h,i,C).routineBody}
          float ${h}(int row, int col, int depth, int depth2, int depth3) {
            return ${h}(${(0,_.getSqueezedParams)(A,S)});
          }
        `;return new a.GlslLibRoutine(I,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const T=`
        float ${h}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${y} + col * ${w} + depth * ${g} +
          depth3 * ${f} + depth2;
          vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
          return sampleTexture(${i}, uv);
        }
      `;return new a.GlslLibRoutine(T,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(h,i,r){const u=r.unpackedShape,f=u[5],g=u[4]*f,w=u[3]*g,y=u[2]*w,x=u[1]*y,{newShape:S,keptDims:T}=(0,l.squeezeShape)(u);if(S.length<u.length){const A=(0,_.squeezeInputShape)(u,S),C=["row","col","depth","depth2","depth3","depth4"],I=JSON.parse(JSON.stringify(r));I.unpackedShape=A;const D=`
            ${this.getUnpackedSamplerFromInput(h,i,I).routineBody}
            float ${h}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${h}(${(0,_.getSqueezedParams)(C,T)});
            }
          `;return new a.GlslLibRoutine(D,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const E=`
          float ${h}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${x} + col * ${y} + depth * ${w} +
            depth2 * ${g} + depth3 * ${f} + depth4;
            vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
            return sampleTexture(${i}, uv);
          }
        `;return new a.GlslLibRoutine(E,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const h=this.context.outputTextureLayout,i=h.shape.length,r=h.strides,u=h.width,f=h.height,g=[];for(let y=0;y<i-1;++y)g.push(`
        c[${y}] = offset / ${r[y]};`),g.push(`
        offset -= c[${y}] * ${r[y]};`);g.push(`
        c[${i-1}] = offset;`);const w=`
      void toVec(vec2 texCoords, out int c[${i}]) {
        int offset = coordsToOffset(texCoords, ${u}, ${f});
        ${g.join("")}
      }
      void toVec(int offset, out int c[${i}]) {
        ${g.join("")}
      }
    `;return{toVec:new a.GlslLibRoutine(w,["coordinates.coordsToOffset"])}}valueFrom(){const h={};return this.context.programInfo.inputNames.forEach(((i,r)=>{const u=this.context.inputTextureLayouts[r],f=(u.unpackedShape.length>0?u.unpackedShape:u.shape).length;let g=`_${i}`;h[g]=new a.GlslLibRoutine(this.getValueFromSingle(i,f,u.width,u.height,!1),[`shapeUtils.indicesToOffset${g}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),g+="_T",h[g]=new a.GlslLibRoutine(this.getValueFromSingle(i,f,u.width,u.height,!0),[`shapeUtils.indicesToOffset${g}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),h}getValueFromSingle(h,i,r,u,f){let g=`_${h}`;return f&&(g+="_T"),`
        float ${g}(int m[${i}]) {
          int offset = indicesToOffset${g}(m);
          vec2 coords = offsetToCoords(offset, ${r}, ${u});
          float value = getColorAsFloat(${(0,c.getGlsl)(this.context.glContext.version).texture2D}(${h}, coords));
          return value;
        }
        `}getPackedValueFrom(h,i,r,u,f){let g=`_${h}_Pack`;return f&&(g+="_T"),`
        vec4 ${g}(int m[${i}]) {
          int offset = indicesToOffset_${h}(m);
          vec2 coords = offsetToCoords(offset, ${r}, ${u});
          return ${(0,c.getGlsl)(this.context.glContext.version).texture2D}(${h}, coords);
        }
        `}}e.CoordsGlslLib=m},8520:(n,e)=>{var t;Object.defineProperty(e,"__esModule",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(t=e.FunctionType||(e.FunctionType={}))[t.ValueBased=0]="ValueBased",t[t.Positional=1]="Positional",e.GlslContext=class{constructor(s,a,c,l){this.glContext=s,this.programInfo=a,this.inputTextureLayouts=c,this.outputTextureLayout=l}},e.GlslLib=class{constructor(s){this.context=s}},e.GlslLibRoutine=class{constructor(s,a){this.routineBody=s,this.dependencies=a}},e.GlslLibRoutineNode=class{constructor(s,a,c){this.name=s,this.dependencies=c||[],a&&(this.routineBody=a)}addDependency(s){s&&this.dependencies.push(s)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(s){if(!s||s.length===0)return[];if(s.length===1)return s;const a=new Set,c=new Set,l=new Array;return this.createOrderedNodes(s,a,c,l),l}static createOrderedNodes(s,a,c,l){for(let _=0;_<s.length;++_)this.dfsTraverse(s[_],a,c,l)}static dfsTraverse(s,a,c,l){if(!s||c.has(s.name))return;if(a.has(s.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");a.add(s.name);const _=s.dependencies;if(_&&_.length>0)for(let m=0;m<_.length;++m)this.dfsTraverse(_[m],a,c,l);l.push(s),c.add(s.name),a.delete(s.name)}}},7341:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.EncodingGlslLib=void 0;const s=t(8520);class a extends s.GlslLib{constructor(l){super(l)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new s.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new s.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const l=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new s.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${l}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const l=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new s.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${l}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const l=new ArrayBuffer(4),_=new Uint32Array(l),m=new Uint8Array(l);if(_[0]=3735928559,m[0]===239)return!0;if(m[0]===222)return!1;throw new Error("unknown endianness")}}e.EncodingGlslLib=a},9894:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.FragColorGlslLib=void 0;const s=t(8520),a=t(5060);class c extends s.GlslLib{constructor(_){super(_)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const _=(0,a.getGlsl)(this.context.glContext.version);return{setFragColor:new s.GlslLibRoutine(`
        void setFragColor(float value) {
            ${_.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new s.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}e.FragColorGlslLib=c},2848:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.replaceInlines=void 0;const t=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;e.replaceInlines=function(s){const a={};let c;for(;(c=t.exec(s))!==null;){const l=c[3].split(",").map((_=>{const m=_.trim().split(" ");return m&&m.length===2?{type:m[0],name:m[1]}:null})).filter((_=>_!==null));a[c[2]]={params:l,body:c[4]}}for(const l in a){const _="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",l),m=new RegExp(_,"gm");for(;(c=m.exec(s))!==null;){const d=c[1],h=c[2],i=c[3].split(","),r=d?`${d} ${h};`:"";let u=a[l].body,f="";a[l].params.forEach(((w,y)=>{w&&(f+=`${w.type} ${w.name} = ${i[y]};
`)})),u=`${f}
 ${u}`,u=u.replace("return",`${h} = `);const g=`
      ${r}
      {
        ${u}
      }
      `;s=s.replace(c[0],g)}}return s.replace(t,"")}},8879:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.GlslPreprocessor=void 0;const s=t(8520),a=t(2848),c=t(5483),l=t(5060);e.GlslPreprocessor=class{constructor(_,m,d,h){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new s.GlslContext(_,m,d,h),Object.keys(c.glslRegistry).forEach((r=>{const u=new c.glslRegistry[r](this.context);this.libs[r]=u}));const i=this.glslLibRoutineDependencyGraph;for(const r in this.libs){const u=this.libs[r].getFunctions();for(const f in u){const g=r+"."+f;let w;i[g]?(w=i[g],w.routineBody=u[f].routineBody):(w=new s.GlslLibRoutineNode(g,u[f].routineBody),i[g]=w);const y=u[f].dependencies;if(y)for(let x=0;x<y.length;++x)if(i[y[x]])w.addDependency(i[y[x]]);else{const S=new s.GlslLibRoutineNode(y[x]);i[y[x]]=S,w.addDependency(S)}}}}preprocess(){const _=this.context.programInfo;let m=_.shaderSource;return this.context.programInfo.hasMain||(m=`${m}
      ${(0,l.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),m=(0,a.replaceInlines)(m),`${(0,l.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(_.inputNames,_.variables)}
    ${this.getImports(m)}
    ${m}`}getImports(_){const m=this.selectGlslLibRoutinesToBeIncluded(_);if(m.length===0)return"";let d="";for(let h=0;h<m.length;++h){if(!m[h].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${m[h].name}`);d+=m[h].routineBody+`
`}return d}selectGlslLibRoutinesToBeIncluded(_){const m=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((d=>{const h=d.split(".")[1];_.indexOf(h)!==-1&&m.push(this.glslLibRoutineDependencyGraph[d])})),s.TopologicalSortGlslRoutines.returnOrderedNodes(m)}getUniforms(_,m){const d=[];if(_)for(const h of _)d.push(`uniform sampler2D ${h};`);if(m)for(const h of m)d.push(`uniform ${h.type} ${h.name}${h.arrayLength?`[${h.arrayLength}]`:""};`);return d.join(`
`)}}},5483:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.glslRegistry=void 0;const s=t(5107),a=t(7341),c=t(9894),l=t(2655),_=t(3891);e.glslRegistry={encoding:a.EncodingGlslLib,fragcolor:c.FragColorGlslLib,vec:_.VecGlslLib,shapeUtils:l.ShapeUtilsGlslLib,coordinates:s.CoordsGlslLib}},2655:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ShapeUtilsGlslLib=void 0;const s=t(8520);class a extends s.GlslLib{constructor(l){super(l)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const l=this.context.outputTextureLayout.shape.length,_={};return this.context.programInfo.inputNames.forEach(((m,d)=>{const h=this.context.inputTextureLayouts[d].unpackedShape;if(h.length<=l){const i=h.length,r=l-i,u=`bcastIndices_${m}`;let f="";for(let w=0;w<i;++w)f+=`
          realIndices[${w}] = int( mod(float(bcastedIndices[${r+w}]), ${h[w]}.0) );
          `;const g=`
        void ${u} (int bcastedIndices[${l}], out int realIndices[${i}]) {
          ${f}
        }
        `;_[u]=new s.GlslLibRoutine(g)}})),_}bcastMatmulIndex(){const l=this.context.outputTextureLayout.shape.length,_={};return this.context.programInfo.inputNames.forEach(((m,d)=>{const h=this.context.inputTextureLayouts[d].shape;if(!(h.length<2||h.length>l)){const i=h.length,r=l-i,u=`bcastMatmulIndices_${m}`;let f="";for(let w=0;w<i-2;++w)f+=`
          realIndices[${w}] = int( mod(float(bcastedIndices[${r+w}]), ${h[w]}.0) );
          `;const g=`
        void ${u}(int bcastedIndices[${l}], out int realIndices[${i}]) {
          ${f}
          realIndices[${i-1}] = bcastedIndices[${l-1}];
          realIndices[${i-2}] = bcastedIndices[${l-2}];
        }
        `;_[u]=new s.GlslLibRoutine(g)}})),_}indicesToOffset(){const l={};return this.context.programInfo.inputNames.forEach(((_,m)=>{const d=this.context.inputTextureLayouts[m].shape,h=this.context.inputTextureLayouts[m].strides,i=d.length;let r=`indicesToOffset_${_}`;l[r]=new s.GlslLibRoutine(a.indexToOffsetSingle(r,i,h)),r=`indicesToOffset_${_}_T`,l[r]=new s.GlslLibRoutine(a.indexToOffsetSingle(r,i,h.slice().reverse()))})),l}static indexToOffsetSingle(l,_,m){let d="";for(let h=_-1;h>=0;--h)d+=`
        offset += indices[${h}] * ${m[h]};
        `;return`
      int ${l}(int indices[${_}]) {
        int offset = 0;
        ${d}
        return offset;
      }
      `}offsetToIndices(){const l={};return this.context.programInfo.inputNames.forEach(((_,m)=>{const d=this.context.inputTextureLayouts[m].shape,h=this.context.inputTextureLayouts[m].strides,i=d.length;let r=`offsetToIndices_${_}`;l[r]=new s.GlslLibRoutine(a.offsetToIndicesSingle(r,i,h)),r=`offsetToIndices_${_}_T`,l[r]=new s.GlslLibRoutine(a.offsetToIndicesSingle(r,i,h.slice().reverse()))})),l}static offsetToIndicesSingle(l,_,m){const d=[];for(let h=0;h<_-1;++h)d.push(`
      indices[${h}] = offset / ${m[h]};`),d.push(`
        offset -= indices[${h}] * ${m[h]};`);return d.push(`
      indices[${_-1}] = offset;`),`
      void ${l}(int offset, out int indices[${_}]) {
        ${d.join("")}
      }
      `}incrementIndices(){const l={};return this.context.programInfo.inputNames.forEach(((_,m)=>{const d=this.context.inputTextureLayouts[m].shape,h=d.length,i=`incrementIndices_${_}`;let r="";for(let f=0;f<h;++f)r+=`
        shape[${f}] = ${d[f]};`;const u=`
        void ${i}(int axis, out int indices[${h}]) {
          int shape[${h}];
          ${r};
          for(int i = ${h} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;l[i]=new s.GlslLibRoutine(u)})),l}}e.ShapeUtilsGlslLib=a},5060:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const t={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},s={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function a(c){return c===1?t:s}e.getGlsl=a,e.getVertexShaderSource=function(c){const l=a(c);return`${l.version}
      precision highp float;
      ${l.attribute} vec3 position;
      ${l.attribute} vec2 textureCoord;

      ${l.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},e.getFragShaderPreamble=function(c){const l=a(c);return`${l.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${l.varyingFrag} vec2 TexCoords;
    ${l.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},e.getDefaultFragShaderMain=function(c,l){return`
  void main() {
    int indices[${l}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${a(c).output} = result;
  }
  `}},3891:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VecGlslLib=void 0;const s=t(8520);class a extends s.GlslLib{constructor(l){super(l)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const l=this.context.outputTextureLayout.shape.length,_={add:"+=",sub:"-=",mul:"*=",div:"/="},m={};for(const d in _){const h=`${d}Vec`;let i="";for(let u=0;u<l;++u)i+=`
          dest[${u}] ${_[d]} src[${u}];
          `;const r=`
        void ${h}(int src[${l}], out int dest[${l}]) {
          ${i}
        }
        `;m[h]=new s.GlslLibRoutine(r)}return m}copyVec(){const l=this.context.outputTextureLayout.shape.length;let _="";for(let d=0;d<l;++d)_+=`
        dest[${d}] = src[${d}];
        `;const m=`
      void copyVec(int src[${l}], out int dest[${l}]) {
        ${_}
      }
      `;return{copyVec:new s.GlslLibRoutine(m)}}setVecItem(){const l=this.context.outputTextureLayout.shape.length;let _=`
        if(index < 0)
            index =${l} + index;
        if (index == 0)
            m[0] = value;
        `;for(let d=1;d<l-1;++d)_+=`
        else if (index == ${d})
            m[${d}] = value;
            `;_+=`
        else
            m[${l-1}] = value;
        `;const m=`
      void setVecItem(out int m[${l}], int index, int value) {
        ${_}
      }
        `;return{setVecItem:new s.GlslLibRoutine(m)}}getVecItem(){const l=this.context.outputTextureLayout.shape.length;let _=`
        if(index < 0)
            index = ${l} + index;
        if (index == 0)
            return m[0];
      `;for(let d=1;d<l-1;++d)_+=`
        else if (index == ${d})
            return m[${d}];
      `;_+=`
        else
            return m[${l-1}];
        `;const m=`
      int getVecItem(int m[${l}], int index) {
        ${_}
      }
    `;return{getVecItem:new s.GlslLibRoutine(m)}}}e.VecGlslLib=a},8316:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLInferenceHandler=void 0;const s=t(6231),a=t(9162),c=t(2517),l=t(2403),_=t(7019),m=t(8710),d=t(5611),h=t(4057),i=t(2039);e.WebGLInferenceHandler=class{constructor(r){this.session=r,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(r,u){return(0,h.calculateTextureWidthAndHeight)(this.session.layoutStrategy,r,u)}executeProgram(r,u){if(u.length<r.inputNames.length)throw new Error(`Input size mustn't be less than ${r.inputNames.length}.`);if(r.inputNames.length!==r.inputTypes.length)throw new Error("input names size does not match input types");const f=[];for(let T=0;T<r.inputNames.length;++T)f[T]=this.getOrCreateTextureData(u[T],r.inputTypes[T]);const g=((T,E)=>{const A=E.map((I=>`${I.unpackedShape.join(",")};${I.width}x${I.height}`)).join("_");let C=T.name;return T.cacheHint&&(C+="["+T.cacheHint+"]"),C+=":"+A,C})(r,f);let w=this.session.programManager.getArtifact(g);const y=w?w.programInfo:typeof r.get=="function"?r.get():r,x=(0,h.createTextureLayoutFromTextureType)(this.session.layoutStrategy,y.output.dims,y.output.textureType),S=this.createTextureData(x,y.output.type);return w||(w=this.session.programManager.build(y,f,S),this.session.programManager.setArtifact(g,w)),this.runProgram(w,f,S),S}run(r,u){return this.executeProgram(r,u).tensor}runProgram(r,u,f){for(let g=0;g<u.length;++g)if(!!u[g].isPacked!=(r.programInfo.inputTypes[g]===i.TextureType.packed))throw new Error(`input[${g}] property packed inconsistent`);if(!!f.isPacked!=(r.programInfo.output.textureType===i.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(r,u,f)}getOrCreateTextureData(r,u){let f=this.getTextureData(r.dataId,u===i.TextureType.packed);if(!f&&(f=this.getTextureData(r.dataId,u!==i.TextureType.packed),f))return u===i.TextureType.packed?this.pack(f):this.unpack(f);if(!f){const g=(0,h.createTextureLayoutFromTextureType)(this.session.layoutStrategy,r.dims,u);if(u===i.TextureType.packedLastDimension){const x=r.dims;if(x.length===4){const S=[x[0],Math.ceil(x[1]*x[2]*x[3]/4)],T=(0,h.createTextureLayoutFromTextureType)(this.session.layoutStrategy,S,u);let E=r.numberData;if(x[1]*x[2]*x[3]%4!=0){const A=x[0],C=x[1]*x[2]*x[3],I=Math.ceil(C*1/4)*4;E=new Float32Array(A*I);for(let D=0;D<A;++D){const R=D*C,Y=D*I+D%1*C;E.set(r.numberData.subarray(R,R+C),Y)}}return this.createTextureData(T,r.type,E,r,1)}}if(u===i.TextureType.packed){const w=(0,h.createTextureLayoutFromShape)(this.session.layoutStrategy,r.dims,1,[],{reverseWH:!0}),y=this.createTextureData(w,r.type,r.numberData,r,1);f=this.pack(y)}else f=this.createTextureData(g,r.type,r.numberData,r,1)}return f}createTextureDataFromLayoutBindTensor(r,u,f,g){return this.createTextureData(r,u,f,g,1)}createTextureData(r,u,f,g,w){s.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(r)}]`);const y=this.session.textureManager.createTextureFromLayout(u,r,f,w);return this.createTextureDataFromTexture(r,u,y,g)}reshapeUnpacked(r,u){const f=this.getOrCreateTextureData(r,i.TextureType.unpacked),g={channels:f.channels,height:f.height,width:f.width,shape:u.length!==0?u:[1],strides:c.ShapeUtil.computeStrides(u),unpackedShape:u};return this.createTextureDataFromTexture(g,r.type,f.texture).tensor}reshapePacked(r,u){const f=this.getOrCreateTextureData(r,i.TextureType.packed);if((0,_.isReshapeCheap)(r.dims,u)){const S={channels:f.channels,height:f.height,width:f.width,shape:u.length!==0?u:[1],strides:c.ShapeUtil.computeStrides(u),unpackedShape:u,isPacked:!0};return this.createTextureDataFromTexture(S,r.type,f.texture).tensor}const g=(0,_.processDims3D)(r.dims),w=(0,_.processDims3D)(u),y=this.reshapePacked(r,g),x=this.run((0,_.createPackedReshape3DProgramInfoLoader)(this,y,w),[y]);return this.reshapePacked(x,u)}cast(r,u){const f=this.getOrCreateTextureData(r,i.TextureType.unpacked);return this.createTextureDataFromTexture(f,u,f.texture).tensor}createTextureDataFromTexture(r,u,f,g,w){const y=Object.assign(Object.assign({},r),{tensor:g||new a.Tensor(r.unpackedShape,u,(x=>this.readTexture(y)),(async x=>this.readTextureAsync(y)),void 0,w),texture:f});return this.setTextureData(y.tensor.dataId,y,r.isPacked),y}getTextureData(r,u=!1){return this.session.isInitializer(r)?this.session.getTextureData(r,u):u?this.packedTextureDataCache.get(r):this.unpackedTextureDataCache.get(r)}setTextureData(r,u,f=!1){this.session.isInitializer(r)?this.session.setTextureData(r,u,f):(f?this.packedTextureDataCache:this.unpackedTextureDataCache).set(r,u)}isTextureLayoutCached(r,u=!1){return!!this.getTextureData(r.dataId,u)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((r=>this.session.textureManager.releaseTexture(r))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((r=>this.session.textureManager.releaseTexture(r))),this.unpackedTextureDataCache=new Map}readTexture(r){return r.isPacked?this.readTexture(this.unpack(r)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(r,r.tensor.type,r.channels):this.session.textureManager.readUint8TextureAsFloat((0,m.encodeAsUint8)(this,r))}async readTextureAsync(r){return r.isPacked?this.readTextureAsync(this.unpack(r)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(r,r.tensor.type,r.channels):this.session.textureManager.readUint8TextureAsFloat((0,m.encodeAsUint8)(this,r))}pack(r){return this.executeProgram((0,l.createPackProgramInfoLoader)(this,r.tensor),[r.tensor])}unpack(r){return this.executeProgram((0,d.createUnpackProgramInfoLoader)(this,r.tensor),[r.tensor])}}},1640:function(n,e,t){var s=this&&this.__createBinding||(Object.create?function(Ce,oe,K,Q){Q===void 0&&(Q=K);var de=Object.getOwnPropertyDescriptor(oe,K);de&&!("get"in de?!oe.__esModule:de.writable||de.configurable)||(de={enumerable:!0,get:function(){return oe[K]}}),Object.defineProperty(Ce,Q,de)}:function(Ce,oe,K,Q){Q===void 0&&(Q=K),Ce[Q]=oe[K]}),a=this&&this.__setModuleDefault||(Object.create?function(Ce,oe){Object.defineProperty(Ce,"default",{enumerable:!0,value:oe})}:function(Ce,oe){Ce.default=oe}),c=this&&this.__importStar||function(Ce){if(Ce&&Ce.__esModule)return Ce;var oe={};if(Ce!=null)for(var K in Ce)K!=="default"&&Object.prototype.hasOwnProperty.call(Ce,K)&&s(oe,Ce,K);return a(oe,Ce),oe};Object.defineProperty(e,"__esModule",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const l=t(2898),_=c(t(7839)),m=t(4196),d=t(2069),h=t(8138),i=t(9663),r=t(5193),u=t(7992),f=t(1253),g=t(4776),w=t(6572),y=t(3346),x=t(5623),S=t(2870),T=t(2143),E=t(4939),A=t(718),C=t(2268),I=t(8117),D=t(2278),R=t(5524),Y=t(5975),re=t(3933),G=t(6558),te=t(5723),q=t(3738),z=c(t(4909)),H=t(8428),he=t(9793);e.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",z.abs],["Acos","","7+",z.acos],["Add","","7+",_.add],["And","","7+",_.and],["Asin","","7+",z.asin],["Atan","","7+",z.atan],["AveragePool","","7+",T.averagePool,T.parseAveragePoolAttributes],["BatchNormalization","","7+",l.batchNormalization,l.parseBatchNormalizationAttributes],["Cast","","6+",m.cast,m.parseCastAttributes],["Ceil","","6+",z.ceil],["Clip","","6-10",z.clip,z.parseClipAttributes],["Clip","","11+",z.clipV11],["Concat","","4+",d.concat,d.parseConcatAttributes],["Conv","","1+",h.conv,h.parseConvAttributes],["ConvTranspose","","1+",i.convTranspose,i.parseConvTransposeAttributes],["Cos","","7+",z.cos],["Div","","7+",_.div],["Dropout","","7+",z.identity],["DepthToSpace","","1+",r.depthToSpace,r.parseDepthToSpaceAttributes],["Equal","","7+",_.equal],["Elu","","6+",z.elu,z.parseEluAttributes],["Exp","","6+",z.exp],["Flatten","","1+",u.flatten,u.parseFlattenAttributes],["Floor","","6+",z.floor],["FusedConv","com.microsoft","1+",h.conv,h.parseConvAttributes],["Gather","","1+",f.gather,f.parseGatherAttributes],["Gemm","","7-10",g.gemm,g.parseGemmAttributesV7],["Gemm","","11+",g.gemm,g.parseGemmAttributesV11],["GlobalAveragePool","","1+",T.globalAveragePool,T.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",T.globalMaxPool],["Greater","","7+",_.greater],["Identity","","1+",z.identity],["ImageScaler","","1+",w.imageScaler,w.parseImageScalerAttributes],["InstanceNormalization","","6+",y.instanceNormalization,y.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",z.leakyRelu,z.parseLeakyReluAttributes],["Less","","7+",_.less],["Log","","6+",z.log],["MatMul","","1+",x.matMul,x.parseMatMulAttributes],["MaxPool","","1+",T.maxPool,T.parseMaxPoolAttributes],["Mul","","7+",_.mul],["Neg","","6+",z.neg],["Not","","1+",z.not],["Or","","7+",_.or],["Pad","","2-10",S.padV2,S.parsePadAttributesV2],["Pad","","11+",S.padV11,S.parsePadAttributesV11],["Pow","","7+",_.pow],["PRelu","","7+",_.pRelu],["ReduceLogSum","","1+",E.reduceLogSum,E.parseReduceAttributes],["ReduceMax","","1+",E.reduceMax,E.parseReduceAttributes],["ReduceMean","","1+",E.reduceMean,E.parseReduceAttributes],["ReduceMin","","1+",E.reduceMin,E.parseReduceAttributes],["ReduceProd","","1+",E.reduceProd,E.parseReduceAttributes],["ReduceSum","","1-12",E.reduceSum,E.parseReduceAttributes],["ReduceSumSquare","","1+",E.reduceLogSumSquare,E.parseReduceAttributes],["Relu","","6+",z.relu],["Reshape","","5+",A.reshape],["Resize","","10",C.resize,C.parseResizeAttributesV10],["Resize","","11+",C.resize,C.parseResizeAttributesV11],["Shape","","1+",I.shape],["Sigmoid","","6+",z.sigmoid],["Sin","","7+",z.sin],["Slice","","10+",D.sliceV10],["Slice","","1-9",D.slice,D.parseSliceAttributes],["Softmax","","1-12",R.softmax,R.parseSoftmaxAttributes],["Softmax","","13+",R.softmaxV13,R.parseSoftmaxAttributesV13],["Split","","2-12",Y.split,Y.parseSplitAttributes],["Sqrt","","6+",z.sqrt],["Squeeze","","1-12",re.squeeze,re.parseSqueezeAttributes],["Squeeze","","13+",re.squeezeV13],["Sub","","7+",_.sub],["Sum","","6+",G.sum],["Tan","","7+",z.tan],["Tanh","","6+",z.tanh],["Tile","","6+",te.tile],["Transpose","","1+",q.transpose,q.parseTransposeAttributes],["Upsample","","7-8",he.upsample,he.parseUpsampleAttributesV7],["Upsample","","9",he.upsample,he.parseUpsampleAttributesV9],["Unsqueeze","","1-12",H.unsqueeze,H.parseUnsqueezeAttributes],["Unsqueeze","","13+",H.unsqueezeV13],["Xor","","7+",_.xor]]},2898:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const s=t(246),a=t(5060),c=t(2039),l={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked]};e.batchNormalization=(d,h,i)=>(m(h),[d.run(Object.assign(Object.assign({},l),{cacheHint:i.cacheKey,get:()=>_(d,h,i)}),h)]),e.parseBatchNormalizationAttributes=d=>{const h=d.attributes.getFloat("epsilon",1e-5),i=d.attributes.getFloat("momentum",.9),r=d.attributes.getInt("spatial",1);return(0,s.createAttributeWithCacheKey)({epsilon:h,momentum:i,spatial:r})};const _=(d,h,i)=>{const r=(0,a.getGlsl)(d.session.backend.glContext.version),u=h[0].dims.length,[f,g]=d.calculateTextureWidthAndHeight(h[1].dims,c.TextureType.unpacked),w=`
  float process(int[${u}] indices) {
    vec2 position = offsetToCoords(indices[1], ${f}, ${g});
    float scale = getColorAsFloat(${r.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r.texture2D}(Variance, position));
    float b = getColorAsFloat(${r.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},l),{output:{dims:h[0].dims,type:h[0].type,textureType:c.TextureType.unpacked},shaderSource:w})},m=d=>{if(!d||d.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const h=d[0],i=d[1],r=d[2],u=d[3],f=d[4];if(h.dims.length<3||i.dims.length!==1||r.dims.length!==1||u.dims.length!==1||f.dims.length!==1)throw new Error("invalid input shape.");if(i.dims[0]!==h.dims[1]||r.dims[0]!==h.dims[1]||u.dims[0]!==h.dims[1]||f.dims[0]!==h.dims[1])throw new Error("invalid input shape.");if(h.type!=="float32"&&h.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||u.type!=="float32"&&u.type!=="float64"||f.type!=="float32"&&f.type!=="float64")throw new Error("invalid input tensor types.")}},7839:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const s=t(2517),a=t(8520),c=t(5060),l=t(2039);function _(){const E="add_";return{body:`
  float ${E}(float a, float b) {
    return a + b;
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:E,type:a.FunctionType.ValueBased}}function m(){const E="div_";return{body:`
  float ${E}(float a, float b) {
    return a / b;
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:E,type:a.FunctionType.ValueBased}}function d(){const E="mul_";return{body:`
  float ${E}(float a, float b) {
    return a * b;
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:E,type:a.FunctionType.ValueBased}}function h(){const E="sub_";return{body:`
  float ${E}(float a, float b) {
    return a - b;
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:E,type:a.FunctionType.ValueBased}}function i(){const E="equal_";return{body:`
  float ${E}(float a, float b) {
    return float(a == b);
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:E,type:a.FunctionType.ValueBased}}function r(){const E="greater_";return{body:`
  float ${E}(float a, float b) {
    return float(a > b);
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:E,type:a.FunctionType.ValueBased}}function u(){const E="less_";return{body:`
  float ${E}(float a, float b) {
    return float(a < b);
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:E,type:a.FunctionType.ValueBased}}function f(){const E="and_";return{body:`
  float ${E}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:E,type:a.FunctionType.ValueBased}}function g(){return{body:`
  float or_(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 or_(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:"or_",type:a.FunctionType.ValueBased}}function w(){const E="xor_";return{body:`
  float ${E}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:E,type:a.FunctionType.ValueBased}}function y(){return(function(E){const A=`${E}_`;return{body:`
  float ${A}(float a, float b) {
    return ${E}(a, b);
  }
  vec4 ${A}(vec4 v1, vec4 v2) {
    return ${E}(v1, v2);
  }
  `,name:A,type:a.FunctionType.ValueBased}})("pow")}function x(){const E="prelu_";return{body:`
  float ${E}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:E,type:a.FunctionType.ValueBased}}e.glslAdd=_,e.glslDiv=m,e.glslMul=d,e.glslSub=h,e.glslEqual=i,e.glslGreater=r,e.glslLess=u,e.glslAnd=f,e.glslOr=g,e.glslXor=w,e.glslPow=y,e.glslPRelu=x;const S=(E,A,C,I=A[0].type,D)=>{const R=E.session.pack?l.TextureType.packed:l.TextureType.unpacked;return{name:C.name,inputNames:["A","B"],inputTypes:[R,R],cacheHint:D,get:()=>T(E,A,C,I)}},T=(E,A,C,I=A[0].type)=>{const D=E.session.pack?l.TextureType.packed:l.TextureType.unpacked,R=!s.ShapeUtil.areEqual(A[0].dims,A[1].dims);let Y=A[0].dims;const re=E.session.pack;if(R){const q=s.BroadcastUtil.calcShape(A[0].dims,A[1].dims,!1);if(!q)throw new Error("Can't perform binary op on the given tensors");Y=q;const z=Y.length,H=A[0].dims.length!==0?A[0].dims.length:1,he=A[1].dims.length!==0?A[1].dims.length:1,Ce=A[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",oe=A[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",K=(0,c.getGlsl)(E.session.backend.glContext.version),Q=re?`
      ${C.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${C.name}(a, b);
        ${K.output} = result;
      }`:`
      ${C.body}
      float process(int indices[${z}]) {
        int aindices[${H}];
        int bindices[${he}];
        ${Ce}
        ${oe}
        return ${C.name}(_A(aindices), _B(bindices));
      }`;return{name:C.name,inputNames:["A","B"],inputTypes:[D,D],output:{dims:Y,type:I,textureType:D},shaderSource:Q,hasMain:re}}const G=(0,c.getGlsl)(E.session.backend.glContext.version),te=`
    ${C.body}
    void main() {
      vec4 v1 = ${G.texture2D}(A, TexCoords);
      vec4 v2 = ${G.texture2D}(B, TexCoords);
      vec4 result = ${C.name}(v1, v2);
      ${G.output} = result;
    }
    `;return{name:C.name,inputNames:["A","B"],inputTypes:[D,D],output:{dims:A[0].dims,type:I,textureType:D},shaderSource:te,hasMain:!0}};e.add=(E,A)=>[E.run(S(E,A,_()),A)],e.and=(E,A)=>[E.run(S(E,A,f(),"bool"),A)],e.div=(E,A)=>[E.run(S(E,A,m()),A)],e.equal=(E,A)=>[E.run(S(E,A,i(),"bool"),A)],e.greater=(E,A)=>[E.run(S(E,A,r(),"bool"),A)],e.less=(E,A)=>[E.run(S(E,A,u(),"bool"),A)],e.mul=(E,A)=>[E.run(S(E,A,d()),A)],e.or=(E,A)=>[E.run(S(E,A,g(),"bool"),A)],e.pow=(E,A)=>[E.run(S(E,A,y()),A)],e.pRelu=(E,A)=>[E.run(S(E,A,x()),A)],e.sub=(E,A)=>[E.run(S(E,A,h()),A)],e.xor=(E,A)=>[E.run(S(E,A,w(),"bool"),A)]},4196:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseCastAttributes=e.cast=void 0;const s=t(2517);e.cast=(c,l,_)=>(a(l),[c.cast(l[0],_)]),e.parseCastAttributes=c=>s.ProtoUtil.tensorDataTypeFromProto(c.attributes.getInt("to"));const a=c=>{if(!c||c.length!==1)throw new Error("Cast requires 1 input.");if(c[0].type==="string")throw new Error("Invalid input type.")}},1163:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const s=t(5060),a=t(2039),c=t(9390),l=t(2827);e.createPackedConcatProgramInfoLoader=(m,d,h)=>{const i=(r=d.length,u=h.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:r},((f,g)=>`X${g}`)),inputTypes:Array(r).fill(a.TextureType.packed),cacheHint:u});var r,u;return Object.assign(Object.assign({},i),{get:()=>((f,g,w,y)=>{const x=w[0].dims.slice();if(y>=x.length||y<-1*x.length)throw new Error("axis specified for concat doesn't match input dimensionality");y<0&&(y=x.length+y);const S=x.slice(0);for(let Ce=1;Ce<w.length;Ce++){const oe=w[Ce].dims.slice();for(let K=0;K<x.length;K++)if(K===y)S[y]+=oe[K];else if(x[K]!==oe[K])throw new Error("non concat dimensions must match")}const T=S.length,E=(0,l.getChannels)("coords",T),A=(0,c.getCoordsDataType)(T),C=(0,l.unpackFromChannel)(),I=w.map((Ce=>Ce.dims)),D=(0,c.getGlChannels)(T),R=new Array(I.length-1);R[0]=I[0][y];for(let Ce=1;Ce<R.length;Ce++)R[Ce]=R[Ce-1]+I[Ce][y];const Y=D[y],re=D.slice(-2),G=D.join();let te=`if (${Y} < ${R[0]}) {
        return getChannel(
            getX0(${G}), vec2(${re.join()}));
        }`;for(let Ce=1;Ce<R.length;Ce++){const oe=R[Ce-1];te+=`
            if (${Y} < ${R[Ce]}  && ${Y} >= ${R[Ce-1]}) {
              return getChannel(
                getX${Ce}(${_(D,Y,oe)}),
                vec2(${_(re,Y,oe)}));
            }`}const q=R.length,z=R[R.length-1];te+=`
            return getChannel(
              getX${q}(${_(D,Y,z)}),
              vec2(${_(re,Y,z)}));`;const H=(0,s.getGlsl)(f.session.backend.glContext.version),he=`
          ${C}
          float getValue(${D.map((Ce=>"int "+Ce))}) {
            ${te}
          }

          void main() {
            ${A} coords = getOutputCoords();
            int lastDim = coords.${D[T-1]};
            coords.${D[T-1]} = coords.${D[T-2]};
            coords.${D[T-2]} = lastDim;

            vec4 result = vec4(getValue(${E}), 0., 0., 0.);

            ${E[T-1]} = ${E[T-1]} + 1;
            if (${E[T-1]} < ${S[T-1]}) {
              result.g = getValue(${E});
            }

            ${E[T-2]} = ${E[T-2]} + 1;
            if (${E[T-2]} < ${S[T-2]}) {
              result.a = getValue(${E});
            }

            ${E[T-1]} = ${E[T-1]} - 1;
            if (${E[T-2]} < ${S[T-2]} &&
                ${E[T-1]} < ${S[T-1]}) {
              result.b = getValue(${E});
            }
            ${H.output} = result;
          }
        `;return Object.assign(Object.assign({},g),{output:{dims:S,type:w[0].type,textureType:a.TextureType.packed},shaderSource:he,hasMain:!0})})(m,i,d,h.axis)})};const _=(m,d,h)=>{const i=m.indexOf(d);return m.map(((r,u)=>u===i?`${r} - ${h}`:r)).join()}},2069:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const s=t(246),a=t(2039),c=t(1163);e.concat=(r,u,f)=>(i(u),r.session.pack&&u[0].dims.length>1?[r.run((0,c.createPackedConcatProgramInfoLoader)(r,u,f),u)]:[r.run(l(r,u,f),u)]);const l=(r,u,f)=>{const g=(w=u.length,y=f.cacheKey,{name:"Concat",inputNames:Array.from({length:w},((x,S)=>`X${S}`)),inputTypes:Array(w).fill(a.TextureType.unpacked),cacheHint:y});var w,y;return Object.assign(Object.assign({},g),{get:()=>((x,S,T,E)=>{const A=T[0].dims.slice();if(E>=A.length||E<-1*A.length)throw new Error("axis specified for concat doesn't match input dimensionality");E<0&&(E=A.length+E);const C=A.slice(0);for(let G=1;G<T.length;G++){const te=T[G].dims.slice();for(let q=0;q<A.length;q++)if(q===E)C[E]+=te[q];else if(A[q]!==te[q])throw new Error("non concat dimensions must match")}const I=C.length,D=new Array(T.length);let R=0;for(let G=0;G<D.length;++G)R+=T[G].dims[E],D[G]=R;let Y="";Y=T.length<5?_(D):m(D);const re=`
        ${d(T.length,I)}
        ${h(D)}
        ${Y}
        float process(int indices[${I}]) {
          int textureIndex = getTextureWhereDataResides (indices[${E}]);

          if(textureIndex != 0) {
            indices[${E}] = indices[${E}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},S),{output:{dims:C,type:T[0].type,textureType:a.TextureType.unpacked},shaderSource:re})})(0,g,u,f.axis)})},_=r=>`int getTextureWhereDataResides(int index) {
      ${r.map(((u,f)=>`if(index<${u}) {return ${f};}
`)).join("")}
    }`,m=r=>_(r),d=(r,u)=>{const f=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${u}]) {`];for(let g=0;g<r;++g)g===0?f.push(`	if (textureIndex == ${g}) { return _X${g}(indices); }`):g===r-1?f.push(`	else { return _X${g}(indices); }`):f.push(`	else if (textureIndex == ${g}) { return _X${g}(indices); }`);return f.push("	}"),f.join(`
`)},h=r=>{const u=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let f=0;f<r.length;++f)f===0?u.push(`	if (index == ${f}) { return ${r[f]}; }`):f===r.length-1?u.push(`	else { return ${r[f]}; }`):u.push(`	else if (index == ${f}) { return ${r[f]}; }`);return u.push("	}"),u.join(`
`)};e.parseConcatAttributes=r=>(0,s.createAttributeWithCacheKey)({axis:r.attributes.getInt("axis")});const i=r=>{if(!r||r.length<1)throw new Error("too few inputs");const u=r[0].type,f=r[0].dims.length;if(u==="string")throw new Error("string tensor is not supported yet");for(const g of r){if(g.type!==u)throw new Error("input tensors should be one type");if(g.dims.length!==f)throw new Error("input tensors should have the same shape")}}},4770:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const s=t(6231),a=t(5060),c=t(2039),l=t(8138),_=t(2823);e.createUnpackedGroupedConvProgramInfoLoader=(m,d,h)=>{const i=(r=d.length>2,u=h.cacheKey,{name:"GroupedConv",inputNames:r?["X","W","Bias"]:["X","W"],inputTypes:r?[c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked]:[c.TextureType.unpacked,c.TextureType.unpacked],cacheHint:u});var r,u;return Object.assign(Object.assign({},i),{get:()=>((f,g,w,y)=>{const x=g.length>2?"value += getBias(output_channel);":"",S=g[0].dims.slice(),T=g[1].dims.slice(),E=T[0]/y.group;s.Logger.verbose("GroupedConv",`autpPad:${y.autoPad}, dilations:${y.dilations}, group:${y.group}, kernelShape:${y.kernelShape}, pads:${y.pads}, strides:${y.strides}`);const A=(0,l.calculateOutputShape)(S,T,y.dilations,y.pads,y.strides),C=(0,a.getGlsl)(f.session.backend.glContext.version),{activationFunction:I,applyActivation:D}=(0,_.getActivationSnippet)(y),R=`
  const ivec2 strides = ivec2(${y.strides[0]}, ${y.strides[1]});
  const ivec2 pads = ivec2(${y.pads[0]}, ${y.pads[1]});
  ${I}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${E};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${T[1]}; wInChannel++) {
      int input_channel = group_id * ${T[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${T[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${y.dilations[0]};

        if (xHeight < 0 || xHeight >= ${S[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${T[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${y.dilations[1]};
          if (xWidth < 0 || xWidth >= ${S[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${x}
    ${D}
    ${C.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},w),{output:{dims:A,type:g[0].type,textureType:c.TextureType.unpacked},shaderSource:R,hasMain:!0})})(m,d,i,h)})}},1386:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const s=t(8138),a=t(8555),c=t(708);e.conv2DPackedPointwise=(l,_,m)=>{const d=_[0].dims,h=_[1].dims,i=(0,s.calculateOutputShape)(d,h,m.dilations,m.pads,m.strides),r=l.reshapePacked(_[0],[d[1],d[2]*d[3]]),u=l.reshapePacked(_[1],[h[0],h[1]]),f=_.length>2?[u,r,_[2]]:[u,r],g=l.run((0,c.createPackedMatmulProgramInfoLoader)(l,f,m),f);return l.reshapePacked(g,i)},e.conv2DPacked=(l,_,m)=>{const d=_[0].dims,h=_[1].dims,i=(0,s.calculateOutputShape)(d,h,m.dilations,m.pads,m.strides),r=l.run((0,a.createPackedIm2ColProgramInfoLoader)(l,_[0],_[1],i,m),[_[0]]),u=l.reshapePacked(_[1],[h[0],h[1]*h[2]*h[3]]),f=_.length===3?[u,r,_[2]]:[u,r],g=l.run((0,c.createPackedMatmulProgramInfoLoader)(l,f,m),f);return l.reshapePacked(g,i)}},9663:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const s=t(246),a=t(5060),c=t(2039),l=t(2823),_=(u,f,g,w,y,x)=>(u-1)*f+g+(w-1)*y+1-x,m=(u,f,g,w,y)=>{const x=Math.floor(u/2);f==="SAME_UPPER"?(g[w]=x,g[y]=u-x):f==="SAME_LOWER"&&(g[w]=u-x,g[y]=x)};e.convTranspose=(u,f,g)=>(r(f,g),d(u,f,g));const d=(u,f,g)=>{const w=i(g,f);return[h(u,f,w)]},h=(u,f,g)=>u.run(((w,y,x)=>{const S=(T=y.length>2,E=x.cacheKey,{name:"ConvTranspose",inputNames:T?["X","W","B"]:["X","W"],inputTypes:T?[c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked]:[c.TextureType.unpacked,c.TextureType.unpacked],cacheHint:E});var T,E;return Object.assign(Object.assign({},S),{get:()=>((A,C,I,D)=>{const R=C.length>2?"getB(output_channel)":"0.0",Y=C[0].dims,re=C[1].dims,G=re[1],te=re[0]/D.group,q=[C[0].dims[0],C[1].dims[1]*D.group,...D.outputShape],z=(0,a.getGlsl)(A.session.backend.glContext.version),{activationFunction:H,applyActivation:he}=(0,l.getActivationSnippet)(D),Ce=`
  const ivec2 strides = ivec2(${D.strides[0]}, ${D.strides[1]});
  const ivec2 pads = ivec2(${D.pads[0]}, ${D.pads[1]});
  ${H}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${G};
    int wOutChannel = output_channel - group_id * ${G};

    float value = ${R};
    for (int inChannelOffset = 0; inChannelOffset < ${te}; inChannelOffset++) {
      int input_channel = group_id * ${te} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${re[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${re[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${D.dilations[0]}, wHOff * ${D.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${Y[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${Y[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${he}
    ${z.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},I),{output:{dims:q,type:C[0].type,textureType:c.TextureType.unpacked},shaderSource:Ce,hasMain:!0})})(w,y,S,x)})})(u,f,g),f),i=(u,f)=>{const g=u.kernelShape.slice();if(u.kernelShape.length===0)for(let S=2;S<f[1].dims.length;++S)g.push(f[1].dims[S]);const w=u.pads.slice(),y=u.outputShape.slice();((S,T,E,A,C,I,D,R)=>{const Y=S.length-2,re=R.length===0;for(let G=0;G<Y;++G){const te=re?S[G+2]*I[G]:R[G],q=_(S[G+2],I[G],C[G],T[G],E[G],te);m(q,A,C,G,G+Y),re&&R.push(I[G]*(S[G+2]-1)+D[G]+(T[G]-1)*E[G]+1-C[G]-C[G+Y])}})(f[0].dims,g,u.dilations,u.autoPad,w,u.strides,u.outputPadding,y);const x=Object.assign({},u);return Object.assign(x,{kernelShape:g,pads:w,outputShape:y,cacheKey:u.cacheKey}),x};e.parseConvTransposeAttributes=u=>{const f=u.attributes,g=(0,l.parseInternalActivationAttributes)(f),w=f.getString("auto_pad","NOTSET"),y=f.getInts("dilations",[1,1]),x=f.getInt("group",1),S=f.getInts("kernel_shape",[]),T=f.getInts("output_padding",[0,0]),E=f.getInts("output_shape",[]),A=f.getInts("pads",[0,0,0,0]),C=f.getInts("strides",[1,1]);return(0,s.createAttributeWithCacheKey)(Object.assign({autoPad:w,dilations:y,group:x,kernelShape:S,outputPadding:T,outputShape:E,pads:A,strides:C},g))};const r=(u,f)=>{if(!u||u.length!==2&&u.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(u[0].dims.length!==4||u[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(u[0].dims[1]!==u[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const g=u[1].dims[1]*f.group;if(u.length===3&&(u[2].dims.length!==1||u[2].dims[0]!==g))throw new Error("invalid bias");const w=u[0].dims.length-2;if(f.dilations.length!==w)throw new Error(`dilations should be ${w}D`);if(f.strides.length!==w)throw new Error(`strides should be ${w}D`);if(f.pads.length!==2*w)throw new Error(`pads should be ${2*w}D`);if(f.outputPadding.length!==w)throw new Error(`output_padding should be ${w}D`);if(f.kernelShape.length!==0&&f.kernelShape.length!==u[1].dims.length-2)throw new Error("invalid kernel shape");if(f.outputShape.length!==0&&f.outputShape.length!==u[0].dims.length-2)throw new Error("invalid output shape");if(u[0].type!=="float32"||u[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(u.length===3&&u[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const s=t(246),a=t(2517),c=t(4770),l=t(1386),_=t(9828),m=t(2823),d=t(3248),h=t(5623);e.calculateOutputShape=(w,y,x,S,T)=>{const E=w[0],A=w.slice(2),C=A.length,I=y[0],D=y.slice(2).map(((Y,re)=>Y+(Y-1)*(x[re]-1))),R=A.map(((Y,re)=>Y+S[re]+S[re+C])).map(((Y,re)=>Math.floor((Y-D[re]+T[re])/T[re])));return[E,I].concat(...R)},e.conv=(w,y,x)=>(g(y,x),i(w,y,x));const i=(w,y,x)=>{const S=f(x,y),T=w.session.pack,E=S.kernelShape[0]===1&&S.kernelShape[1]===1;return S.group>1?[w.run((0,c.createUnpackedGroupedConvProgramInfoLoader)(w,y,S),y)]:E&&T?[r(w,y,S)]:T&&y[0].dims.length===4&&y[0].dims[0]===1&&!E?[(0,l.conv2DPacked)(w,y,S)]:[u(w,y,S)]},r=(w,y,x)=>{const S=y[0].dims,T=y[1].dims,E=(0,e.calculateOutputShape)(S,T,x.dilations,x.pads,x.strides),A=w.reshapeUnpacked(y[0],[S[1],S[2]*S[3]]),C=w.reshapeUnpacked(y[1],[T[0],T[1]]),I=y.length>2?[C,A,y[2]]:[C,A],D=w.run((0,h.createMatmulProgramInfoLoader)(I,x),I);return w.reshapeUnpacked(D,E)},u=(w,y,x)=>{const S=y[0].dims,T=y[1].dims,E=(0,e.calculateOutputShape)(S,T,x.dilations,x.pads,x.strides),A=w.run((0,d.createIm2ColProgramInfoLoader)(w,y[0],y[1],E,x),[y[0]]),C=y.length===3?[A,y[1],y[2]]:[A,y[1]];return w.run((0,_.createDotProductProgramInfoLoader)(w,y,E,x),C)},f=(w,y)=>{const x=w.kernelShape.slice();if(w.kernelShape.length===0)for(let E=2;E<y[1].dims.length;++E)x.push(y[1].dims[E]);const S=w.pads.slice();a.PoolConvUtil.adjustPadsBasedOnAutoPad(y[0].dims,w.strides,w.dilations,x,S,w.autoPad);const T=Object.assign({},w);return Object.assign(T,{kernelShape:x,pads:S,cacheKey:w.cacheKey}),T};e.parseConvAttributes=w=>{const y=w.attributes,x=(0,m.parseInternalActivationAttributes)(y),S=y.getString("auto_pad","NOTSET"),T=y.getInts("dilations",[1,1]),E=y.getInt("group",1),A=y.getInts("kernel_shape",[]),C=y.getInts("pads",[0,0,0,0]),I=y.getInts("strides",[1,1]);return(0,s.createAttributeWithCacheKey)(Object.assign({autoPad:S,dilations:T,group:E,kernelShape:A,pads:C,strides:I},x))};const g=(w,y)=>{if(!w||w.length!==2&&w.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(w[0].dims.length!==4||w[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(w[0].dims[1]!==w[1].dims[1]*y.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(w.length===3&&(w[2].dims.length!==1||w[1].dims[0]!==w[2].dims[0]))throw new Error("invalid bias");const x=w[0].dims.length-2;if(y.dilations.length!==x)throw new Error(`dilations should be ${x}D`);if(y.strides.length!==x)throw new Error(`strides should be ${x}D`);if(y.pads.length!==2*x)throw new Error(`pads should be ${2*x}D`);if(y.kernelShape.length!==0&&y.kernelShape.length!==w[1].dims.length-2)throw new Error("invalid kernel shape");if(w[0].type!=="float32"||w[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(w.length===3&&w[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},5193:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const s=t(3738);e.depthToSpace=(c,l,_)=>{a(l);const m=_.blocksize,d=m*m,h=_.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],i=_.mode==="DCR"?[l[0].dims[0],m,m,l[0].dims[1]/d,l[0].dims[2],l[0].dims[3]]:[l[0].dims[0],l[0].dims[1]/d,m,m,l[0].dims[2],l[0].dims[3]],r=c.reshapeUnpacked(l[0],i),u={perm:h,cacheKey:`${h}`},[f]=(0,s.transpose)(c,[r],u),g=[l[0].dims[0],l[0].dims[1]/d,l[0].dims[2]*m,l[0].dims[3]*m];return[c.reshapeUnpacked(f,g)]},e.parseDepthToSpaceAttributes=c=>{const l=c.attributes.getInt("blocksize");if(l<1)throw new Error(`blocksize must be >= 1, but got : ${l} for DepthToSpace`);const _=c.attributes.getString("mode","DCR");if(_!=="DCR"&&_!=="CRD")throw new Error(`unrecognized mode: ${_} for DepthToSpace`);return{mode:_,blocksize:l}};const a=c=>{if(c.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${c.length}`);if(c[0].type==="string"||c[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const s=t(2517),a=t(5060),c=t(2039),l=t(2823),_=t(3248);e.createDotProductProgramInfoLoader=(m,d,h,i)=>{const r=((u,f)=>({name:"ConvDotProduct",inputNames:u?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:u?[c.TextureType.unpacked,c.TextureType.packedLastDimension,c.TextureType.unpacked]:[c.TextureType.unpacked,c.TextureType.packedLastDimension],cacheKey:f.activationCacheKey}))(d.length>2,i);return Object.assign(Object.assign({},r),{get:()=>((u,f,g,w,y)=>{const x=g[0].dims,S=g[1].dims,T=[S[0],Math.ceil(x[1]*S[2]*S[3]/4)],E=(0,_.calculateIm2ColDims)(x,S,w),[A,C]=u.calculateTextureWidthAndHeight(T,c.TextureType.packedLastDimension),I=s.ShapeUtil.computeStrides(E),[D,R]=u.calculateTextureWidthAndHeight(E,c.TextureType.packedLastDimension),Y=w.length,re=g.length<3?"0.0":"_B(b)",G=Math.ceil(x[1]*S[2]*S[3]/4),{activationFunction:te,applyActivation:q}=(0,l.getActivationSnippet)(y),z=(0,a.getGlsl)(u.session.backend.glContext.version),H=`
${te}
float process(int indices[${Y}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${I[0]} + im2col[1] * ${I[1]} + im2col[2] * ${I[2]};
  int kernelOffset = indices[1] * ${T[1]};
  float value = ${re};
  for (int i = 0; i < ${G}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${D}, ${R});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${A}, ${C});
    value += dot(${z.texture2D}(Im2Col, im2colCoords), ${z.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${q}
  return value;
}`;return Object.assign(Object.assign({},f),{output:{dims:w,type:g[0].type,textureType:c.TextureType.unpacked},shaderSource:H})})(m,r,d,h,i)})}},7992:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const s=t(2517);e.flatten=(c,l,_)=>{a(l,_);const m=s.ShapeUtil.flattenShape(l[0].dims,_);return[c.reshapeUnpacked(l[0],m)]},e.parseFlattenAttributes=c=>c.attributes.getInt("axis",1);const a=(c,l)=>{if(!c||c.length!==1)throw new Error("Flatten requires 1 input.");const _=c[0].dims.length;if(_===0)throw new Error("scalar tensor is not supported.");if(l<-_||l>_)throw new Error("Invalid axis");if(c[0].type==="string")throw new Error("string tensor is not supported.")}},2823:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const s=t(2517),a=t(4909);e.getActivationSnippet=function(c){let l;switch(c.activation){case"Relu":l=(0,a.glslRelu)();break;case"Sigmoid":l=(0,a.glslSigmoid)();break;case"Clip":l=(0,a.glslClip)(c.clipMin,c.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const _=l.name;return{activationFunction:l.body,applyActivation:`value = ${_}_(value);`}},e.parseInternalActivationAttributes=c=>{const l=c.getString("activation","");if(l==="Clip"){const[_,m]=c.getFloats("activation_params",[s.MIN_CLIP,s.MAX_CLIP]);return{activation:l,clipMax:m,clipMin:_,activationCacheKey:`${l}:${_},${m}`}}return{activation:l,activationCacheKey:l}}},1253:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const s=t(246),a=t(782),c=t(2517),l=t(2039);e.gather=(h,i,r)=>(d(i,r.axis),[h.run(m(h,i,r),i)]),e.parseGatherAttributes=h=>(0,s.createAttributeWithCacheKey)({axis:h.attributes.getInt("axis",0)});const _={name:"Gather",inputNames:["A","B"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked]},m=(h,i,r)=>{const u=Object.assign(Object.assign({},_),{cacheHint:r.cacheKey});return Object.assign(Object.assign({},u),{get:()=>((f,g,w,y)=>{const x=w[0].dims.slice(),S=w[1].dims.slice(),T=new Array(x.length+S.length-1);y=c.ShapeUtil.normalizeAxis(y,x.length);const E=[];for(let C=0;C<T.length;C++)C<y?(T[C]=x[C],E.push(`inputIdx[${C}] = outputIdx[${C}];`)):C<y+S.length?(T[C]=S[C-y],E.push(`indexDataIdx[${C-y}] = outputIdx[${C}];`)):(T[C]=x[C-S.length+1],E.push(`inputIdx[${C-S.length+1}] = outputIdx[${C}];`));const A=`
      float process(int outputIdx[${T.length||1}]) {
        int inputIdx[${x.length}];
        int indexDataIdx[${S.length||1}];
        indexDataIdx[0] = 0;
        ${E.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${y}] = idx < 0 ? idx + ${x[y]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},g),{output:{dims:T,type:w[0].type,textureType:l.TextureType.unpacked},shaderSource:A})})(0,u,i,r.axis)})},d=(h,i)=>{if(!h||h.length!==2)throw new Error("Gather requires 2 inputs.");const r=h[0].dims.length;if(r<1)throw new Error("Invalid input shape.");if(i<-r||i>r-1)throw new Error("Invalid axis.");if(a.NUMBER_TYPES.indexOf(h[0].type)===-1)throw new Error("Invaid input type.");if(h[1].type!=="int32"&&h[1].type!=="int16")throw new Error("Invaid input type.")}},4776:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const s=t(246),a=t(2517),c=t(2039);e.gemm=(h,i,r)=>(d(i,r),[h.run(_(i,r),i)]);const l=(h,i)=>{const r=h.attributes.getInt("transA",0)!==0,u=h.attributes.getInt("transB",0)!==0,f=h.attributes.getFloat("alpha",1),g=h.attributes.getFloat("beta",1);return(0,s.createAttributeWithCacheKey)({transA:r,transB:u,alpha:f,beta:g,isOptionalC:i})};e.parseGemmAttributesV7=h=>l(h,!1),e.parseGemmAttributesV11=h=>l(h,!0);const _=(h,i)=>{const r={name:"Gemm",inputNames:h.length===3?["A","B","C"]:["A","B"],inputTypes:h.length===3?[c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked]:[c.TextureType.unpacked,c.TextureType.unpacked],key:i.cacheKey};return Object.assign(Object.assign({},r),{get:()=>m(r,h,i)})},m=(h,i,r)=>{const u=i[0].dims.slice(),f=i[1].dims.slice(),[g,w]=a.GemmUtil.getShapeOfGemmResult(u,r.transA,f,r.transB,i.length===3?i[2].dims:void 0),y=[g,w];if(!y)throw new Error("Can't use gemm on the given tensors");let x=u[u.length-1],S="";r.transA&&(x=u[0]),r.transA&&r.transB?S="value += _A_T(a) * _B_T(b);":r.transA&&!r.transB?S="value += _A_T(a) * _B(b);":!r.transA&&r.transB?S="value += _A(a) * _B_T(b);":r.transA||r.transB||(S="value += _A(a) * _B(b);");const T=y.length,E=`
      float process(int indices[${T}]) {
          int a[${T}];
          int b[${T}];
          ${i.length===3?`int c[${i[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${i.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${x}; ++k) {
              a[${T-1}] = k;
              b[${T-2}] = k;
              ${S}
          }

          value = value * alpha;
          ${i.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},h),{output:{dims:y,type:i[0].type,textureType:c.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:r.alpha},{name:"beta",type:"float",data:r.beta}],shaderSource:E})},d=(h,i)=>{if(!h)throw new Error("Input is missing");if(i.isOptionalC&&(h.length<2||h.length>3))throw new Error("Invaid input shape.");if(!i.isOptionalC&&h.length!==3)throw new Error("Gemm requires 3 inputs");if(h.length===3&&h[2].dims.length!==1&&h[2].dims.length!==2)throw new Error("Invalid input shape of C");if(h[0].type!=="float32"&&h[0].type!=="float64"||h[1].type!=="float32"&&h[1].type!=="float64"||h.length===3&&h[2].type!=="float32"&&h[2].type!=="float64")throw new Error("Invalid input type.");if(h[0].type!==h[1].type||h.length===3&&h[0].type!==h[2].type)throw new Error("Input types are mismatched")}},8555:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const s=t(5060),a=t(2039),c=t(2827);e.createPackedIm2ColProgramInfoLoader=(l,_,m,d,h)=>{const i=(r=h.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[a.TextureType.packed],cacheHint:r});var r;return Object.assign(Object.assign({},i),{get:()=>((u,f,g,w,y,x)=>{const S=g.dims,T=w.dims,E=y.length,A=[T[1]*T[2]*T[3],y[2]*y[3]],C=T[2]*T[3],I=(0,c.unpackFromChannel)(),D=(0,s.getGlsl)(u.session.backend.glContext.version);let R="";for(let re=0;re<=1;re++)for(let G=0;G<=1;G++)R+=`
            blockIndex = rc.x + ${G};
            pos = rc.y + ${re};

            if(blockIndex < ${A[1]} && pos < ${A[0]}) {
              offsetY = int(blockIndex / (${y[E-1]})) * ${x.strides[0]} -
                ${x.pads[0]};
              d0 = offsetY + ${x.dilations[0]} * (imod(pos, ${C}) / ${T[2]});

              if(d0 < ${S[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${y[E-1]}) * ${x.strides[1]} -
                  ${x.pads[1]};
                d1 = offsetX + ${x.dilations[1]} * imod(imod(pos, ${C}), ${T[2]});

                if(d1 < ${S[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${C}.);
                    innerDims = vec2(d0, d1);
                    result[${2*re+G}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const Y=`
      ${I}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${R}
          ${D.output} = result;
      }
            `;return Object.assign(Object.assign({},f),{output:{dims:A,type:g.type,textureType:a.TextureType.packed},shaderSource:Y,hasMain:!0})})(l,i,_,m,d,h)})}},3248:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const s=t(2039);e.createIm2ColProgramInfoLoader=(a,c,l,_,m)=>{const d=(h=m.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[s.TextureType.unpacked],cacheHint:h});var h;return Object.assign(Object.assign({},d),{get:()=>((i,r,u,f,g,w)=>{const y=u.dims,x=f.dims,S=g.length,T=(0,e.calculateIm2ColDims)(y,x,g,4),E=`
        const int XC = ${y[1]};
        const int XH = ${y[2]};
        const int XW = ${y[3]};
        const int KH = ${w.kernelShape[0]};
        const int KW = ${w.kernelShape[1]};
        const int dilationH = ${w.dilations[0]};
        const int dilationW = ${w.dilations[1]};
        const int strideH = ${w.strides[0]};
        const int strideW = ${w.strides[1]};
        const int padH = ${w.pads[0]};
        const int padW = ${w.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${S}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${y.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},r),{output:{dims:T,type:u.type,textureType:s.TextureType.packedLastDimension},shaderSource:E})})(0,d,c,l,_,m)})},e.calculateIm2ColDims=(a,c,l,_=4)=>[l[0],l[2],l[3],Math.ceil(a[1]*c[2]*c[3]/_)]},6572:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const s=t(246),a=t(2039);e.imageScaler=(d,h,i)=>(m(h),[d.run(l(d,h,i),h)]),e.parseImageScalerAttributes=d=>{const h=d.attributes.getFloat("scale"),i=d.attributes.getFloats("bias");return(0,s.createAttributeWithCacheKey)({scale:h,bias:i})};const c={name:"ImageScaler",inputNames:["X"],inputTypes:[a.TextureType.unpacked]},l=(d,h,i)=>{const r=Object.assign(Object.assign({},c),{cacheHint:i.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((u,f,g,w)=>{const y=g[0].dims.slice(),x=y.length,S=`
      ${_(w.bias.length)}
      float process(int indices[${x}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},f),{output:{dims:y,type:g[0].type,textureType:a.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:w.bias.length,data:w.bias},{name:"scale",type:"float",data:w.scale}],shaderSource:S})})(0,r,h,i)})},_=d=>{const h=[`float getBias(float bias[${d}], int channel) {`];for(let i=0;i<d;++i)i===0?h.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===d-1?h.push(`	else { return bias[${i}]; }`):h.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return h.push("	}"),h.join(`
`)},m=d=>{if(!d||d.length!==1)throw new Error("ImageScaler requires 1 input.");if(d[0].dims.length!==4)throw new Error("Invalid input shape.");if(d[0].type!=="float32"&&d[0].type!=="float64")throw new Error("Invalid input type.")}},3346:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const s=t(5060),a=t(2039);e.instanceNormalization=(h,i,r)=>{d(i);const u=h.run(l(i[0]),i);return[h.run(m(h,i[0],r,u.dims),[i[0],u,i[1],i[2]])]},e.parseInstanceNormalizationAttributes=h=>h.attributes.getFloat("epsilon",1e-5);const c={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[a.TextureType.unpacked]},l=h=>Object.assign(Object.assign({},c),{get:()=>((i,r)=>{const u=r.dims.slice(),f=u[1],g=u[2]*u[3],w=[u[0],f],y=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${u[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${u[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${g});
        temp = 0.0;
        for(int a2=0; a2<${u[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${u[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${g});

        return v;
      }`;return Object.assign(Object.assign({},i),{output:{dims:w,type:r.type,textureType:a.TextureType.packedLastDimension},shaderSource:y})})(c,h)}),_={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.packedLastDimension,a.TextureType.unpacked,a.TextureType.unpacked]},m=(h,i,r,u)=>{const f=Object.assign(Object.assign({},_),{cacheHint:`${r}`});return Object.assign(Object.assign({},f),{get:()=>((g,w,y,x,S)=>{const T=(0,s.getGlsl)(g.session.backend.glContext.version),[E,A]=g.calculateTextureWidthAndHeight(S,a.TextureType.packedLastDimension),[C,I]=[E/4,A],D=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${C}, ${I});
        return ${T.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},w),{output:{dims:y.dims,type:y.type,textureType:a.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:x}],shaderSource:D})})(h,f,i,r,u)})},d=h=>{if(!h||h.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const i=h[0],r=h[1],u=h[2];if(i.dims.length<3||r.dims.length!==1||u.dims.length!==1)throw new Error("Invalid input shape.");if(r.dims[0]!==i.dims[1]||u.dims[0]!==i.dims[1])throw new Error("Input shapes are mismatched.");if(i.type!=="float32"&&i.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||u.type!=="float32"&&u.type!=="float64")throw new Error("Invalid input type.");if(h[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},708:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const s=t(2517),a=t(5060),c=t(2039),l=t(9390),_=t(2823),m=t(5623);e.createPackedMatmulProgramInfoLoader=(d,h,i)=>{const r=(u=h.length>2,f=i.activationCacheKey,{name:"MatMul (packed)",inputNames:u?["A","B","Bias"]:["A","B"],inputTypes:u?[c.TextureType.packed,c.TextureType.packed,c.TextureType.packed]:[c.TextureType.packed,c.TextureType.packed],cacheHint:f});var u,f;return Object.assign(Object.assign({},r),{get:()=>((g,w,y,x)=>{const S=y.length>2,T=S?"value += getBiasForMatmul();":"",E=y[0].dims,A=y[1].dims,C=s.BroadcastUtil.calcShape(E,A,!0),I=!s.ShapeUtil.areEqual(y[0].dims,y[1].dims);if(!C)throw new Error("Can't use matmul on the given tensors");const D=E[E.length-1],R=Math.ceil(D/2),Y=E.length,re=A.length,G=(0,a.getGlsl)(g.session.backend.glContext.version),te=(0,l.getCoordsDataType)(C.length),q=C.length,z=(0,l.getGlChannels)(),{activationFunction:H,applyActivation:he}=(0,_.getActivationSnippet)(x),Ce=S?`${(0,m.getBiasForMatmul)(te,z,y[2].dims,C,!0)}`:"",oe=I?`${(function(ue,Ze,Pt,Gt){let bn=[],ri=[];const hn=Pt[0].dims,ze=Pt[1].dims,wt=hn.length,ke=ze.length,Bt=Gt.length,In=Bt-wt,Tn=Bt-ke;bn=hn.map(((ti,vn)=>`coords.${Ze[vn+In]}`)),bn[wt-1]="i*2",bn.join(", "),ri=ze.map(((ti,vn)=>`coords.${Ze[vn+Tn]}`)),ri[ke-2]="i*2",ri.join(", ");const cn=s.BroadcastUtil.getBroadcastDims(hn,Gt),kn=s.BroadcastUtil.getBroadcastDims(ze,Gt),yn=cn.map((ti=>`coords.${Ze[ti+In]} = 0;`)).join(`
`),$n=kn.map((ti=>`coords.${Ze[ti+Tn]} = 0;`)).join(`
`),cr=`int lastDim = coords.${Ze[Bt-1]};
  coords.${Ze[Bt-1]} = coords.${Ze[Bt-2]};
  coords.${Ze[Bt-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${ue} coords = getOutputCoords();
  ${cr}
  ${yn}
  vec4 outputValue = getA(${bn});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${ue} coords = getOutputCoords();
  ${cr}
  ${$n}
  vec4 outputValue = getB(${ri});
  return outputValue;
}`})(te,z,y,C)}`:"",K=I?"getAAtOutCoordsMatmul(i)":`getA(${(function(ue,Ze){let Pt="";for(let Gt=0;Gt<Ze-2;Gt++)Pt+=`rc.${ue[Gt]}, `;return Pt+=`rc.${ue[Ze-2]}, i*2`,Pt})(z,Y)})`,Q=I?"getBAtOutCoordsMatmul(i)":`getB(${(function(ue,Ze){let Pt="";for(let Gt=0;Gt<Ze-2;Gt++)Pt+=`rc.${ue[Gt]}, `;return Pt+=`i*2, rc.${ue[Ze-1]}`,Pt})(z,re)})`,de=`
            ${oe}
            ${Ce}
            ${H}
            void main() {
              ${I?"":`${te} rc =
          getOutputCoords(); int lastDim = rc.${z[q-1]}; rc.${z[q-1]} =
          rc.${z[q-2]}; rc.${z[q-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${R}; i++) {
                vec4 a = ${K};
                vec4 b = ${Q};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${T}
              ${he}
              ${G.output} = value;
            }`;return Object.assign(Object.assign({},w),{output:{dims:C,type:y[0].type,textureType:c.TextureType.packed},shaderSource:de,hasMain:!0})})(d,r,h,i)})}},5623:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const s=t(2517),a=t(2039),c=t(9390),l=t(2823),_=t(708);function m(i,r){const u=(f=i.length>2,g=r.activationCacheKey,{name:"MatMul",inputNames:f?["A","B","Bias"]:["A","B"],inputTypes:f?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:g});var f,g;return Object.assign(Object.assign({},u),{get:()=>(function(w,y,x){const S=y[0].dims,T=y[1].dims,E=s.BroadcastUtil.calcShape(S,T,!0);if(!E)throw new Error("Can't use matmul on the given tensors");const A=(0,c.getCoordsDataType)(E.length),C=(0,c.getGlChannels)(),{activationFunction:I,applyActivation:D}=(0,l.getActivationSnippet)(x),R=y.length>2,Y=R?"value += getBiasForMatmul();":"",re=R?`${h(A,C,y[2].dims,E,!1)}`:"",G=E.length,te=S.length,q=T.length,z=`
    ${I}
    ${re}
    float process(int indices[${G}]) {
        int a[${te}];
        int b[${q}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${S[S.length-1]}; ++k) {
            a[${te-1}] = k;
            b[${q-2}] = k;
            value += _A(a) * _B(b);
        }
        ${Y}
        ${D}
        return value;
    }`;return Object.assign(Object.assign({},w),{output:{dims:E,type:y[0].type,textureType:a.TextureType.unpacked},shaderSource:z})})(u,i,r)})}e.matMul=(i,r,u)=>(d(r),i.session.pack?[i.run((0,_.createPackedMatmulProgramInfoLoader)(i,r,u),r)]:[i.run(m(r,u),r)]),e.parseMatMulAttributes=i=>(0,l.parseInternalActivationAttributes)(i.attributes),e.createMatmulProgramInfoLoader=m;const d=i=>{if(!i||i.length!==2)throw new Error("MatMul requires 2 inputs.");if(i[0].dims[i[0].dims.length-1]!==i[1].dims[i[1].dims.length-2])throw new Error("shared dimension does not match.");if(i[0].type!=="float32"&&i[0].type!=="float64"||i[1].type!=="float32"&&i[1].type!=="float64")throw new Error("inputs should be float type");if(i[0].type!==i[1].type)throw new Error("inputs types should match")};function h(i,r,u,f,g){let w="";const y=u.length,x=f.length,S=x-y;w=x<2&&y>0?"coords":u.map(((A,C)=>`coords.${r[C+S]}`)).join(", ");const T=s.BroadcastUtil.getBroadcastDims(u,f).map((A=>`coords.${r[A+S]} = 0;`)).join(`
`);let E="vec4(outputValue.xx, outputValue.yy)";return s.ShapeUtil.size(u)===1&&(E="vec4(outputValue.x)"),g?`
vec4 getBiasForMatmul() {
  ${i} coords = getOutputCoords();
  ${T}
  vec4 outputValue = getBias(${w});
  return ${E};
}`:`
float getBiasForMatmul() {
  ${i} coords = getOutputCoords();
  ${T}
  return getBias(coords.x);
}`}e.getBiasForMatmul=h},2403:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackProgramInfoLoader=void 0;const s=t(5060),a=t(2039),c=t(9390),l=t(2827),_={name:"pack",inputNames:["A"],inputTypes:[a.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(m,d)=>Object.assign(Object.assign({},_),{get:()=>((h,i)=>{const r=(0,s.getGlsl)(h.session.backend.glContext.version),u=i.dims,f=u.length,g=i.dims.length,w=(0,c.getCoordsDataType)(g),y=(0,l.getChannels)("rc",g),x=(S=g,T=y,E=u[u.length-2],A=u[u.length-1],S===0||S===1?"":`
    int r = ${T[S-2]};
    int c = ${T[S-1]};
    int rp1 = ${T[S-2]} + 1;
    int cp1 = ${T[S-1]} + 1;
    bool rEdge = rp1 >= ${A};
    bool cEdge = cp1 >= ${E};
    `);var S,T,E,A;let C;C=f===0?[1,1]:f===1?[u[0],1]:[u[g-1],u[g-2]];const I=(function(Y,re,G){if(Y===0)return"false";if(Y===1)return`rc > ${re[0]}`;let te="";for(let q=Y-2;q<Y;q++)te+=`${G[q]} >= ${re[q-Y+2]}`,q<Y-1&&(te+="||");return te})(g,C,y),D=(function(Y,re){const G=Y.length;if(G===0)return"getA(), 0, 0, 0";if(G===1)return`getA(rc),
            rc + 1 >= ${Y[0]} ? 0. : getA(rc + 1),
            0, 0`;let te="";if(G>2)for(let q=0;q<G-2;++q)te+=`${re[q]},`;return`getA(${te}r, c),
          rEdge ? 0. : getA(${te}rp1, c),
          cEdge ? 0. : getA(${te}r, cp1),
          rEdge || cEdge ? 0. : getA(${te}rp1, cp1)`})(u,y),R=`
        void main() {
          ${w} rc = getOutputCoords();

          if(${I}) {
            ${r.output} = vec4(0);
          } else {
            ${x}

            ${r.output} = vec4(${D});
          }
        }
      `;return Object.assign(Object.assign({},_),{hasMain:!0,output:{dims:i.dims,type:i.type,textureType:a.TextureType.packed},shaderSource:R})})(m,d)})},2827:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const s=t(9390);function a(c,l){return(0,s.getGlChannels)(l).map((_=>`${c}.${_}`))}e.getVecChannels=a,e.getChannels=function(c,l){return l===1?[c]:a(c,l)},e.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},2870:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const s=t(246),a=t(2517),c=t(5060),l=t(2039),_={name:"Pad",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};e.padV2=(w,y,x)=>(h(y),[w.run(Object.assign(Object.assign({},_),{cacheHint:x.cacheKey,get:()=>d(w,y[0],x)}),y)]),e.parsePadAttributesV2=w=>{const y=w.attributes.getString("mode","constant"),x=w.attributes.getFloat("value",0),S=w.attributes.getInts("pads");return(0,s.createAttributeWithCacheKey)({mode:y,value:x,pads:S})},e.padV11=(w,y,x)=>{i(y);const S=m(w,y,x);return(0,e.padV2)(w,[y[0]],S)},e.parsePadAttributesV11=w=>w.attributes.getString("mode","constant");const m=(w,y,x)=>{if(!w.session.isInitializer(y[1].dataId)||y.length>=3&&!w.session.isInitializer(y[2].dataId))throw new Error("dynamic pad attributes are not allowed");const S=Array.from(y[1].integerData),T=y.length>=3?y[2].floatData[0]:0;return(0,s.createAttributeWithCacheKey)({mode:x,pads:S,value:T})},d=(w,y,x)=>{const S=a.ShapeUtil.padShape(y.dims.slice(),x.pads),T=S.length,E=`
      ${r(w,y,x)}
      float process(int[${T}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[l.TextureType.unpacked],output:{dims:S,type:y.type,textureType:l.TextureType.unpacked},shaderSource:E}},h=w=>{if(!w||w.length!==1)throw new Error("Pad requires 1 input");if(w[0].type!=="float32"&&w[0].type!=="float64")throw new Error("Invalid input type.")},i=w=>{if(!w||w.length!==2&&w.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(w[1].type!=="int32")throw new Error("Invalid input type.");if(w.length>=3&&w[2].type==="string")throw new Error("Invalid input type.")},r=(w,y,x)=>{const S=(0,c.getGlsl)(w.session.backend.glContext.version),[T,E]=w.calculateTextureWidthAndHeight(y.dims,l.TextureType.unpacked),A=a.ShapeUtil.computeStrides(y.dims);switch(x.mode){case"constant":return u(S,y.dims,A,T,E,x.pads,x.value);case"reflect":return f(S,y.dims,A,T,E,x.pads);case"edge":return g(S,y.dims,A,T,E,x.pads);default:throw new Error("Invalid mode")}},u=(w,y,x,S,T,E,A)=>{const C=y.length;let I="";for(let D=C-1;D>=0;--D)I+=`
        k = m[${D}] - ${E[D]};
        if (k < 0)  return constant;
        if (k >= ${y[D]}) return constant;
        offset += k * ${x[D]};
        `;return`
      float padA(int m[${C}]) {
        const float constant = float(${A});
        int offset = 0;
        int k = 0;
        ${I}
        vec2 coords = offsetToCoords(offset, ${S}, ${T});
        float value = getColorAsFloat(${w.texture2D}(A, coords));
        return value;
      }
      `},f=(w,y,x,S,T,E)=>{const A=y.length;let C="";for(let I=A-1;I>=0;--I)C+=`
        k = m[${I}] - ${E[I]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(y[I]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${y[I]}) { k = _2n_1 - k; }
        }
        offset += k * ${x[I]};
        `;return`
      float padA(int m[${A}]) {
        int offset = 0;
        int k = 0;
        ${C}
        vec2 coords = offsetToCoords(offset, ${S}, ${T});
        float value = getColorAsFloat(${w.texture2D}(A, coords));
        return value;
      }
      `},g=(w,y,x,S,T,E)=>{const A=y.length;let C="";for(let I=A-1;I>=0;--I)C+=`
        k = m[${I}] - ${E[I]};
        if (k < 0)  k = 0;
        if (k >= ${y[I]}) k = ${y[I]-1};
        offset += k * ${x[I]};
      `;return`
      float padA(int m[${A}]) {
        int offset = 0;
        int k = 0;
        ${C}
        vec2 coords = offsetToCoords(offset, ${S}, ${T});
        float value = getColorAsFloat(${w.texture2D}(A, coords));
        return value;
      }
      `}},2143:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const s=t(246),a=t(2517),c=t(2039);e.averagePool=(g,w,y)=>{i(w);const x={name:"AveragePool",inputNames:["X"],inputTypes:[c.TextureType.unpacked],cacheHint:y.cacheKey};return[g.run(Object.assign(Object.assign({},x),{get:()=>l(w,x,!1,y)}),w)]},e.parseAveragePoolAttributes=g=>{const w=g.attributes.getString("auto_pad","NOTSET"),y=g.attributes.getInt("ceil_mode",0),x=g.attributes.getInt("count_include_pad",0)!==0,S=g.attributes.getInts("kernel_shape"),T=g.attributes.getInts("strides",[]),E=g.attributes.getInts("pads",[]);if(y!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,s.createAttributeWithCacheKey)({autoPad:w,ceilMode:y,countIncludePad:x,kernelShape:S,strides:T,pads:E})};const l=(g,w,y,x)=>{const[S,T]=m(g,x,y),E=a.ShapeUtil.size(S.kernelShape);let A="";S.countIncludePad?A+=`value /= float(${E});`:A+=`value /= float(${E} - pad);`;const C=`
        ${r(g[0].dims,S,"value += _X(x);",A,"0.0")}
      `;return Object.assign(Object.assign({},w),{output:{dims:T,type:g[0].type,textureType:c.TextureType.unpacked},shaderSource:C})};e.globalAveragePool=(g,w,y)=>{i(w);const x={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[c.TextureType.unpacked],cacheHint:`${y.countIncludePad}`};return[g.run(Object.assign(Object.assign({},x),{get:()=>l(w,x,!0,y)}),w)]},e.parseGlobalAveragePoolAttributes=g=>{const w=g.attributes.getInt("count_include_pad",0)!==0;return(0,s.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:w,kernelShape:[],strides:[],pads:[]})},e.maxPool=(g,w,y)=>{i(w);const x={name:"MaxPool",inputNames:["X"],inputTypes:[c.TextureType.unpacked],cacheHint:y.cacheKey};return[g.run(Object.assign(Object.assign({},x),{get:()=>_(w,x,!1,y)}),w)]},e.parseMaxPoolAttributes=g=>{const w=g.attributes.getString("auto_pad","NOTSET"),y=g.attributes.getInt("ceil_mode",0),x=g.attributes.getInts("kernel_shape"),S=g.attributes.getInts("strides",[]),T=g.attributes.getInts("pads",[]),E=g.attributes.getInt("storage_order",0),A=g.attributes.getInts("dilations",[]);if(E!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(y!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,s.createAttributeWithCacheKey)({autoPad:w,ceilMode:y,countIncludePad:!1,kernelShape:x,strides:S,pads:T,storageOrder:E,dilations:A})};const _=(g,w,y,x)=>{const[S,T]=m(g,x,y),E=`
      ${r(g[0].dims,S,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},w),{output:{dims:T,type:g[0].type,textureType:c.TextureType.unpacked},shaderSource:E})},m=(g,w,y)=>{const x=g[0].dims.slice(),S=Object.hasOwnProperty.call(w,"dilations"),T=w.kernelShape.slice(),E=w.strides.slice(),A=S?w.dilations.slice():[],C=w.pads.slice();a.PoolConvUtil.adjustPoolAttributes(y,x,T,E,A,C);const I=a.PoolConvUtil.computePoolOutputShape(y,x,E,A,T,C,w.autoPad),D=Object.assign({},w);return S?Object.assign(D,{kernelShape:T,strides:E,pads:C,dilations:A,cacheKey:w.cacheKey}):Object.assign(D,{kernelShape:T,strides:E,pads:C,cacheKey:w.cacheKey}),[D,I]},d={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},h={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[c.TextureType.unpacked]};e.globalMaxPool=(g,w)=>(i(w),[g.run(Object.assign(Object.assign({},h),{get:()=>_(w,h,!0,d)}),w)]);const i=g=>{if(!g||g.length!==1)throw new Error("Pool ops requires 1 input.");if(g[0].type!=="float32"&&g[0].type!=="float64")throw new Error("Invalid input type.")},r=(g,w,y,x,S)=>{const T=g.length;if(w.kernelShape.length<=2){const E=w.kernelShape[w.kernelShape.length-1],A=w.strides[w.strides.length-1],C=w.pads[w.pads.length/2-1],I=w.pads[w.pads.length-1],D=g[T-1];let R="",Y="",re="";if(R=C+I!==0?`
          for (int i = 0; i < ${E}; i++) {
            x[${T} - 1] = indices[${T} - 1] * ${A} - ${C} + i;
            if (x[${T} - 1] < 0 || x[${T} - 1] >= ${D}) {
              pad++;
              continue;
            }
            ${y}
          }`:`
          for (int i = 0; i < ${E}; i++) {
            x[${T} - 1] = indices[${T} - 1] * ${A} - ${C} + i;
            ${y}
          }`,w.kernelShape.length===2){const G=w.kernelShape[w.kernelShape.length-2],te=w.strides[w.strides.length-2],q=w.pads[w.pads.length/2-2],z=w.pads[w.pads.length-2],H=g[T-2];Y=q+z!==0?`
            for (int j = 0; j < ${G}; j++) {
              x[${T} - 2] = indices[${T} - 2] * ${te} - ${q} + j;
              if (x[${T} - 2] < 0 || x[${T} - 2] >= ${H}) {
                pad+= ${E};
                continue;
              }
          `:`
            for (int j = 0; j < ${G}; j++) {
              x[${T} - 2] = indices[${T} - 2] * ${te} - ${q} + j;
            `,re=`
          }
        `}return`
        float process(int indices[${T}]) {
          int x[${T}];
          copyVec(indices, x);

          float value = ${S};
          int pad = 0;
          ${Y}
          ${R}
          ${re}
          ${x}
          return value;
        }
      `}{const E=a.ShapeUtil.size(w.kernelShape),A=a.ShapeUtil.computeStrides(w.kernelShape),C=A.length,I=w.pads.length,D=f(C),R=u(g,"inputDims"),Y=u(w.pads,"pads"),re=u(A,"kernelStrides"),G=u(w.strides,"strides");let te="";return te=w.pads.reduce(((q,z)=>q+z))?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${y}
          }`:`
          }
          ${y}
        `,`
        ${D}
        float process(int indices[${T}]) {
          int x[${T}];
          copyVec(indices, x);
          int offset[${C}];
          int pads[${I}];
          int inputDims[${T}];
          int kernelStrides[${C}];
          int strides[${C}];
          ${Y}
          ${R}
          ${G}
          ${re}

          float value = ${S};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${E}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${T} - ${C}; j < ${T}; j++) {
              x[j] = indices[j] * strides[j - ${T} + ${C}]
                + offset[j - ${T} + ${C}] - pads[j - 2];
              ${te}
          }
          ${x}

          return value;
        }
      `}},u=(g,w)=>{let y="";for(let x=0;x<g.length;x++)y+=`
      ${w}[${x}] = ${g[x]};
    `;return y},f=g=>`
  void offsetToIndices(int offset, int[${g}] strides, out int[${g}] indices) {
    if (${g} == 0) {
      return;
    }
    for (int i = 0; i < ${g} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${g} - 1] = offset;
  }`},4939:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const s=t(246),a=t(782),c=t(2517),l=t(2039),_=(h,i,r,u,f)=>{d(i);const g={name:u,inputNames:["A"],inputTypes:[l.TextureType.unpacked]};return[h.run(Object.assign(Object.assign({},g),{cacheHint:r.cacheKey,get:()=>m(h,i,r,u,f,g)}),i)]};e.parseReduceAttributes=h=>{const i=h.attributes.getInts("axes",[]),r=h.attributes.getInt("keepdims",1)===1;return(0,s.createAttributeWithCacheKey)({axes:i,keepDims:r})};const m=(h,i,r,u,f,g)=>{const w=[],y=i[0].dims.length||1,x=[],S=c.ShapeUtil.normalizeAxes(r.axes,i[0].dims.length),T=f(i,S);let E=T[1];for(let C=0;C<i[0].dims.length;C++)S.indexOf(C)>=0||S.length===0?(r.keepDims&&w.push(1),E=`
          for(int j${C} = 0; j${C} < ${i[0].dims[C]}; j${C}++) {
            inputIdx[${C}] = j${C};
            ${E}
          }`):(x.push(`inputIdx[${C}] = outputIdx[${w.length}];`),w.push(i[0].dims[C]));const A=`
      float process(int outputIdx[${w.length||1}]) {
        float value;                 // final result
        int inputIdx[${y}];      // addressing input data
        ${x.join(`
`)}
        ${T[0]}       // init ops for reduce max/min
        ${E}
        ${T[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},g),{output:{dims:w,type:i[0].type,textureType:l.TextureType.unpacked},shaderSource:A})},d=h=>{if(!h||h.length!==1)throw new Error("Reduce op requires 1 input.");if(a.NUMBER_TYPES.indexOf(h[0].type)===-1)throw new Error("Invalid input type.")};e.reduceSum=(h,i,r)=>_(h,i,r,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),e.reduceMean=(h,i,r)=>_(h,i,r,"ReduceMean",((u,f)=>{let g=1;for(let w=0;w<u[0].dims.length;w++)(f.indexOf(w)>=0||f.length===0)&&(g*=u[0].dims[w]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${g}.;`]})),e.reduceMax=(h,i,r)=>_(h,i,r,"ReduceMax",((u,f)=>{const g=[];for(let w=0;w<u[0].dims.length;w++)(f.indexOf(w)>=0||f.length===0)&&g.push(`inputIdx[${w}] = 0;`);return[`${g.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),e.reduceMin=(h,i,r)=>_(h,i,r,"ReduceMin",((u,f)=>{const g=[];for(let w=0;w<u[0].dims.length;w++)(f.indexOf(w)>=0||f.length===0)&&g.push(`inputIdx[${w}] = 0;`);return[`${g.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),e.reduceProd=(h,i,r)=>_(h,i,r,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),e.reduceLogSum=(h,i,r)=>_(h,i,r,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),e.reduceLogSumSquare=(h,i,r)=>_(h,i,r,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7019:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const s=t(2517),a=t(5060),c=t(2039),l=t(2827);e.createPackedReshape3DProgramInfoLoader=(_,m,d)=>{const h=(i=>({name:"Reshape (packed)",inputTypes:[c.TextureType.packed],inputNames:["A"],cacheHint:`${i}`}))(d);return Object.assign(Object.assign({},h),{get:()=>((i,r,u,f)=>{const g=r.dims,w=f;let y="";for(let T=0;T<4;T++){let E="";switch(T){case 0:E="outputCoords = rc;";break;case 1:E="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:E="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:E="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}y+=`
        ${E}
        ${T>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${T}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${T>0?"}":""}
      `}const x=(0,a.getGlsl)(i.session.backend.glContext.version),S=`
      ${(function(T){const E=s.ShapeUtil.computeStrides(T),A=["b","r","c"],C="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${E.map(((I,D)=>`int ${A[D]} = ${C} / ${I}; ${D===E.length-1?`int ${A[D+1]} = ${C} - ${A[D]} * ${I}`:`index -= ${A[D]} * ${I}`};`)).join("")}
      return ivec3(b, r, c);
    }
  `})(g)}
      ${(function(T){const E=s.ShapeUtil.computeStrides(T);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${E[0]} + coords.z * ${E[1]} + coords.y;
  }
`})(w)}
      ${(0,l.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${w[2]};
        int cols = ${w[1]};

        ${y}
        ${x.output} = result;
      }
    `;return Object.assign(Object.assign({},u),{output:{dims:w,type:r.type,textureType:c.TextureType.packed},shaderSource:S,hasMain:!0})})(_,m,h,d)})},e.processDims3D=function(_){if(_.length===0)return[1,1,1];let m=1;for(let d=0;d<_.length-2;++d)m*=_[d];return[m,_.length>1?_[_.length-2]:1,_[_.length-1]]},e.isReshapeCheap=function(_,m){let d=!1;return d=_.length===0||m.length===0||(_.length<2||m.length<2?_[_.length-1]===m[m.length-1]:_[_.length-1]===m[m.length-1]&&_[_.length-2]===m[m.length-2]),d}},718:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.reshape=void 0;const s=t(2517);e.reshape=(a,c)=>{const l=s.ShapeUtil.calculateReshapedDims(c[0].dims,c[1].integerData);return a.session.pack?[a.reshapePacked(c[0],l)]:[a.reshapeUnpacked(c[0],l)]}},2268:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const s=t(5060),a=t(2039),c=t(9390),l=t(2827),_=t(9793),m={name:"Resize",inputNames:["A"],inputTypes:[a.TextureType.packed]};e.resize=(u,f,g)=>((0,_.validateInputs)(f,g),[u.run(Object.assign(Object.assign({},m),{cacheHint:g.cacheKey,get:()=>d(u,f,g)}),f)]),e.parseResizeAttributesV10=u=>(0,_.parseUpsampleAttributes)(u,10),e.parseResizeAttributesV11=u=>(0,_.parseUpsampleAttributes)(u,11);const d=(u,f,g)=>{const w=(0,s.getGlsl)(u.session.backend.glContext.version),[y,x]=h(f,g);if(y.every((te=>te===1))&&g.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},m),{output:{dims:x,type:f[0].type,textureType:a.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${w.texture2D}(X, TexCoords);
                    ${w.output} = v;
                }`});const S=x.length;if(S<2)throw new Error(`output dimension should be at least 2, but got ${S}`);const T=x[S-2],E=x[S-1],A=f[0].dims;if(S!==A.length)throw new Error(`output dimension should match input ${A.length}, but got ${S}`);const C=A[S-2],I=A[S-1],D=y[S-2],R=y[S-1];let Y="";if(g.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${g.mode}'`);switch(g.coordinateTransformMode){case"asymmetric":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${E}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${T}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${E}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${T}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":Y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${E}.0 - 1.0, ${T}.0 - 1.0, ${E}.0 - 1.0,
                            ${T}.0 - 1.0);
                        vec4 original = vec4(${I}.0 - 1.0, ${C}.0 - 1.0, ${I}.0 - 1.0,
                            ${C}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${g.coordinateTransformMode}'`)}const re=(0,c.getCoordsDataType)(S),G=`
            const vec2 inputWH = vec2(${C}.0, ${I}.0);
            const vec4 scaleWHWH = vec4(float(${D}), float(${R}), float(${D}), float(${R}));
            ${(0,l.unpackFromChannel)()}
            ${Y}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${re} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${T-1};
                bool hasNextCol = rc.z < ${E-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${w.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},m),{output:{dims:x,type:f[0].type,textureType:a.TextureType.packed},hasMain:!0,shaderSource:G})},h=(u,f)=>{const g=u[0].dims;let w,y=f.scales;if(y.length===0){const S=u[f.scalesInputIdx];if(S&&S.size!==0){if(u[f.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");y=i(S,f.mode,f.isResize)}else{const T=u[f.sizesInputIdx];if(!T||T.size===0)throw new Error("Either scales or sizes MUST be provided as input.");w=Array.from(T.integerData),y=r(w,g,f.mode,f.isResize)}}else if(u[f.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const x=w||g.map(((S,T)=>Math.floor(S*y[T])));return[y,x]},i=(u,f,g)=>{const w=Array.from(u.floatData);return(0,_.scalesValidation)(w,f,g),w},r=(u,f,g,w)=>{const y=f.length,x=new Array(y);for(let S=0,T=y;S<T;S++)if(f[S]===0){if(u[S]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");x[S]=1}else x[S]=u[S]/f[S];return(0,_.scalesValidation)(x,g,w),x}},8117:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.shape=void 0;const s=t(9162);e.shape=(c,l)=>(a(l),[new s.Tensor([l[0].dims.length],"int32",void 0,void 0,new Int32Array(l[0].dims))]);const a=c=>{if(!c||c.length!==1)throw new Error("Shape requires 1 input.")}},2278:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const s=t(246),a=t(782),c=t(2517),l=t(2039),_={name:"Slice",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};e.slice=(r,u,f)=>(d(u),[r.run(Object.assign(Object.assign({},_),{cacheHint:f.cacheKey,get:()=>m(r,u[0],f)}),u)]),e.parseSliceAttributes=r=>{const u=r.attributes.getInts("starts"),f=r.attributes.getInts("ends"),g=r.attributes.getInts("axes",[]);return(0,s.createAttributeWithCacheKey)({starts:u,ends:f,axes:g})};const m=(r,u,f)=>{const g=f.axes.length===0?u.dims.slice(0).map(((A,C)=>C)):f.axes,w=c.ShapeUtil.normalizeAxes(g,u.dims.length),y=f.starts.map(((A,C)=>A>u.dims[w[C]]-1?u.dims[w[C]]:c.ShapeUtil.normalizeAxis(A,u.dims[w[C]]))),x=f.ends.map(((A,C)=>A>u.dims[w[C]]-1?u.dims[w[C]]:c.ShapeUtil.normalizeAxis(A,u.dims[w[C]]))),S=u.dims.slice(),T=[];for(let A=0;A<w.length;A++)S[w[A]]=x[A]-y[A],y[A]>0&&T.push(`outputIdx[${w[A]}] += ${y[A]};`);const E=`
      float process(int outputIdx[${S.length}]) {
        ${T.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},_),{output:{dims:S,type:u.type,textureType:l.TextureType.unpacked},shaderSource:E})},d=r=>{if(!r||r.length!==1)throw new Error("Slice requires 1 input.");if(a.NUMBER_TYPES.indexOf(r[0].type)===-1)throw new Error("Invalid input type.")};e.sliceV10=(r,u)=>{i(u);const f=h(r,u);return[r.run(Object.assign(Object.assign({},_),{cacheHint:f.cacheKey,get:()=>m(r,u[0],f)}),[u[0]])]};const h=(r,u)=>{if(!r.session.isInitializer(u[1].dataId)||!r.session.isInitializer(u[2].dataId)||u.length>=4&&!r.session.isInitializer(u[3].dataId)||u.length>=5&&!r.session.isInitializer(u[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(u.length>=5&&u[4].integerData.some((y=>y!==1)))throw new Error("currently non-1 steps is not supported for Slice");const f=Array.from(u[1].integerData),g=Array.from(u[2].integerData),w=u.length>=4?Array.from(u[3].integerData):[];return{starts:f,ends:g,axes:w,cacheKey:`${w};${f};${g}`}},i=r=>{if(!r||r.length<3||r.length>5)throw new Error("Invalid input number.");if(r[1].type!=="int32"||r[1].dims.length!==1)throw new Error("Invalid input type.");if(r[2].type!=="int32"||r[2].dims.length!==1)throw new Error("Invalid input type.");if(r.length>=4&&(r[3].type!=="int32"||r[3].dims.length!==1))throw new Error("Invalid input type.");if(r.length>=5&&(r[4].type!=="int32"||r[4].dims.length!==1))throw new Error("Invalid input type.")}},5524:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const s=t(246),a=t(2517),c=t(5060),l=t(2039),_=t(3738),m={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[l.TextureType.unpacked]},d={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked]},h={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]};e.softmax=(w,y,x)=>{g(y);const S=y[0].dims.slice(),T=a.ShapeUtil.normalizeAxis(x.axis,S.length),E=a.ShapeUtil.sizeToDimension(S,T),A=a.ShapeUtil.sizeFromDimension(S,T);return i(w,y,x,E,A)},e.parseSoftmaxAttributes=w=>(0,s.createAttributeWithCacheKey)({axis:w.attributes.getInt("axis",1)}),e.parseSoftmaxAttributesV13=w=>(0,s.createAttributeWithCacheKey)({axis:w.attributes.getInt("axis",-1)}),e.softmaxV13=(w,y,x)=>{g(y);const S=y[0].dims.slice(),T=a.ShapeUtil.normalizeAxis(x.axis,S.length),E=S.length,A=T!==E-1,C=[];let I,D=[],R=[];A&&(D=Array.from({length:E}).map(((te,q)=>q)),D[T]=E-1,D[E-1]=T,D.map((te=>C.push(S[te]))),I=(0,s.createAttributeWithCacheKey)({perm:D}),R=(0,_.transpose)(w,y,I));const Y=A?a.ShapeUtil.sizeToDimension(C,E-1):a.ShapeUtil.sizeToDimension(S,E-1),re=A?a.ShapeUtil.sizeFromDimension(C,E-1):a.ShapeUtil.sizeFromDimension(S,E-1),G=i(w,A?R:y,x,Y,re);return A?(0,_.transpose)(w,G,I):G};const i=(w,y,x,S,T)=>{const E=r(w,y[0],S,T,[S]),A=w.run(Object.assign(Object.assign({},m),{cacheHint:x.cacheKey,get:()=>E}),y),C=u(w,y[0],S,T,E.output.dims,[S]),I=w.run(Object.assign(Object.assign({},d),{cacheHint:x.cacheKey,get:()=>C}),[y[0],A]),D=f(w,y[0],S,T,E.output.dims,C.output.dims);return[w.run(Object.assign(Object.assign({},h),{cacheHint:x.cacheKey,get:()=>D}),[y[0],A,I])]},r=(w,y,x,S,T)=>{const[E,A]=w.calculateTextureWidthAndHeight(y.dims,l.TextureType.unpacked),C=T.length;if(x<1||S<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(T.length!==1)throw new Error("Dimensionality of the output should be 1");if(T[0]!==x)throw new Error("Shape of the output should be equal to logical row count");const I=(0,c.getGlsl)(w.session.backend.glContext.version),D=`
      float process(int[${C}] indices) {
        int logical_row_start_offset = indices[0] * ${S};

        float max = getColorAsFloat(${I.texture2D}(A, offsetToCoords(logical_row_start_offset, ${E},
        ${A} )));
        for(int i=1; i<${S}; ++i)
        {
          float current = getColorAsFloat(${I.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${E}, ${A})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},m),{output:{dims:T,type:y.type,textureType:l.TextureType.unpacked},shaderSource:D})},u=(w,y,x,S,T,E)=>{const[A,C]=w.calculateTextureWidthAndHeight(y.dims,l.TextureType.unpacked),I=E.length;if(x<1||S<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(E.length!==1)throw new Error("Dimensionality of the output should be 1");if(E[0]!==x)throw new Error("Shape of the output should be equal to logical row count");if(T.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(T[0]!==x)throw new Error("Shape of the intermediate results should be equal to logical row count");const D=`
      float process(int[${I}] indices) {
        int logical_row_start_offset = indices[0] * ${S};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${S}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,c.getGlsl)(w.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${A}, ${C}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},d),{output:{dims:E,type:y.type,textureType:l.TextureType.unpacked},shaderSource:D})},f=(w,y,x,S,T,E)=>{const[A,C]=w.calculateTextureWidthAndHeight(y.dims,l.TextureType.unpacked),I=y.dims.length;if(x<1||S<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(T.length!==1||E.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(T[0]!==x||E[0]!==x)throw new Error("Shape of the intermediate results should be equal to logical row count");const D=`
      float process(int[${I}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${A}, ${C});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${S};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},h),{output:{dims:y.dims,type:y.type,textureType:l.TextureType.unpacked},shaderSource:D})},g=w=>{if(!w||w.length!==1)throw new Error("Softmax requires 1 input.");if(w[0].type!=="float32"&&w[0].type!=="float64")throw new Error("Invalid input type")}},5975:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseSplitAttributes=e.split=void 0;const s=t(246),a=t(2517),c=t(2039),l={name:"Split",inputNames:["A"],inputTypes:[c.TextureType.unpacked]};e.split=(h,i,r)=>{d(i);const u=a.ShapeUtil.normalizeAxis(r.axis,i[0].dims.length),f=_(h,i,u,r),g=[];for(let w=0;w<f;++w)g.push(h.run(Object.assign(Object.assign({},l),{cacheHint:`${r.cacheKey};${w}`,get:()=>m(h,i[0],r,u,w)}),i));return g},e.parseSplitAttributes=h=>{const i=h.attributes.getInt("axis",0),r=h.attributes.getInts("split",[]),u=h.outputs.length;return(0,s.createAttributeWithCacheKey)({axis:i,split:r,numOutputs:u})};const _=(h,i,r,u)=>{const[,f]=a.SplitUtil.splitShape(i[0].dims,r,u.split,u.numOutputs);return f.length},m=(h,i,r,u,f)=>{const[g,w]=a.SplitUtil.splitShape(i.dims,u,r.split,r.numOutputs),y=w[f],x=g[f],S=`
      float process(int indices[${x.length}]) {
        indices[${u}] += ${y};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},l),{cacheHint:`${r.cacheKey}:${f}`,output:{dims:x,type:i.type,textureType:c.TextureType.unpacked},shaderSource:S})},d=h=>{if(!h||h.length!==1)throw new Error("Split requires one input.");if(h[0].type!=="int8"&&h[0].type!=="uint8"&&h[0].type!=="int16"&&h[0].type!=="uint16"&&h[0].type!=="int32"&&h[0].type!=="uint32"&&h[0].type!=="float32"&&h[0].type!=="float64"&&h[0].type!=="bool")throw new Error("Invalid input type.")}},3933:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const s=t(2517);e.squeeze=(l,_,m)=>{a(_);const d=s.ShapeUtil.squeezeShape(_[0].dims,m);return[l.reshapeUnpacked(_[0],d)]},e.squeezeV13=(l,_)=>(c(_),(0,e.squeeze)(l,[_[0]],Array.from(_[1].integerData))),e.parseSqueezeAttributes=l=>l.attributes.getInts("axes");const a=l=>{if(!l||l.length!==1)throw new Error("Squeeze requires 1 input.");if(l[0].type==="string")throw new Error("invalid input tensor types.")},c=l=>{if(!l||l.length!==2)throw new Error("Squeeze requires 2 inputs.");if(l[1].type!=="int32")throw new Error("Invalid input type.")}},6558:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sum=void 0;const s=t(5060),a=t(2039);e.sum=(_,m)=>{l(m);const d={name:"Sum",inputNames:m.map(((h,i)=>`X${i}`)),inputTypes:new Array(m.length).fill(a.TextureType.unpacked)};return[_.run(Object.assign(Object.assign({},d),{get:()=>c(_,m,d)}),m)]};const c=(_,m,d)=>{const h=(0,s.getGlsl)(_.session.backend.glContext.version),i=m[0].dims.slice(),r=`
      void main() {
        vec4 result = ${m.map(((u,f)=>`${h.texture2D}(X${f},TexCoords)`)).join(" + ")};
        ${h.output} = result;
      }
    `;return Object.assign(Object.assign({},d),{output:{dims:i,type:m[0].type,textureType:a.TextureType.unpacked},hasMain:!0,shaderSource:r})},l=_=>{if(!_||_.length===0)throw new Error("Sum requires inputs.");const m=_[0].dims.length;for(let d=1;d<_.length;d++){if(m!==_[d].dims.length)throw new Error("Input shapes are mismatched.");for(let h=0;h<m;h++)if(_[0].dims[h]!==_[d].dims[h])throw new Error("Input shapes are not matched.")}if(_[0].type!=="float32"&&_[0].type!=="float64")throw new Error("Invalid input type.");for(let d=1;d<_.length;d++)if(_[0].type!==_[d].type)throw new Error("Input types are not matched.")}},5723:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tile=void 0;const s=t(782),a=t(2039);e.tile=(_,m)=>{l(m);const d={name:"Tile",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[_.run(Object.assign(Object.assign({},d),{get:()=>c(_,m,d)}),m)]};const c=(_,m,d)=>{const h=m[0].dims.slice(),i=new Array(h.length),r=[];for(let g=0;g<h.length;g++)i[g]=h[g]*m[1].numberData[g],r.push(`inputIdx[${g}] = int(mod(float(outputIdx[${g}]), ${h[g]}.));`);const u=i.length,f=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${u}];
        ${r.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},d),{output:{dims:i,type:m[0].type,textureType:a.TextureType.unpacked},shaderSource:f})},l=_=>{if(!_||_.length!==2)throw new Error("Tile requires 2 input.");if(_[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(_[1].dims[0]!==_[0].dims.length)throw new Error("Invalid input shape.");if(s.NUMBER_TYPES.indexOf(_[0].type)===-1)throw new Error("Invalid input type.");if(_[1].type!=="int32"&&_[1].type!=="int16")throw new Error("Invalid repeat type.")}},3738:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const s=t(246),a=t(2517),c=t(2039),l={name:"Transpose",inputNames:["A"],inputTypes:[c.TextureType.unpacked]};e.transpose=(r,u,f)=>(i(u),[r.run(Object.assign(Object.assign({},l),{cacheHint:f.cacheKey,get:()=>_(r,u[0],f.perm)}),u)]),e.parseTransposeAttributes=r=>(0,s.createAttributeWithCacheKey)({perm:r.attributes.getInts("perm",[])});const _=(r,u,f)=>{const g=u.dims;f=m(g,f);const w=d(g,f),y=g.length,x=`
      ${h("perm",f,y)}
      float process(int indices[${y}]) {
        int a[${y}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},l),{output:{dims:w,type:u.type,textureType:c.TextureType.unpacked},shaderSource:x})},m=(r,u)=>(u&&u.length!==r.length&&(u=[...r.keys()].reverse()),u),d=(r,u)=>(u=m(r,u),a.ShapeUtil.sortBasedOnPerm(r,u)),h=(r,u,f)=>{const g=[];g.push(`void ${r}(out int a[${f}], int src[${f}]) {`);for(let w=0;w<f;++w)g.push(`	a[${u[w]}]=src[${w}];`);return g.push("	}"),g.join(`
`)},i=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("input should be float tensor")}},8710:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.encodeAsUint8=void 0;const s=t(5060),a=t(2039);e.encodeAsUint8=(c,l)=>{const _=l.shape,m=(0,s.getGlsl)(c.session.backend.glContext.version),d=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${m.texture2D}(X,TexCoords).r;
      ${m.output} = encodeAsUint8(value);
    }`,h={name:"Uint8Encode",inputTypes:[a.TextureType.unpacked],inputNames:["X"],output:{dims:_,type:l.tensor.type,textureType:a.TextureType.downloadUint8AsFloat},shaderSource:d,hasMain:!0};return c.executeProgram(h,[l.tensor])}},4909:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const s=t(246),a=t(2517),c=t(8520),l=t(5060),_=t(2039);function m(){return G("abs")}function d(){return G("acos")}function h(){return G("asin")}function i(){return G("atan")}function r(){return G("ceil")}function u(){return G("cos")}function f(z){return{body:`
  const float alpha = float(${z});

  float elu_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 elu_(vec4 v) {
    return vec4(elu_(v.x), elu_(v.y), elu_(v.z), elu_(v.w));
  }
  `,name:"elu",type:c.FunctionType.ValueBased}}function g(){return G("exp")}function w(){return G("floor")}function y(z,H){const he="clip";return{body:`
  const float min = float(${z});
  const float max = float(${H});

  float ${he}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${he}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:he,type:c.FunctionType.ValueBased}}function x(){const z="indentity";return{body:`
  float ${z}_(float a) {
    return a;
  }
  vec4 ${z}_(vec4 v) {
    return v;
  }
  `,name:z,type:c.FunctionType.ValueBased}}function S(z){const H="leakyRelu";return{body:`
  const float alpha = float(${z});

  float ${H}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${H}_(vec4 v) {
    return vec4(${H}_(v.x), ${H}_(v.y), ${H}_(v.z), ${H}_(v.w));
  }
  `,name:H,type:c.FunctionType.ValueBased}}function T(){return G("log")}function E(){return{body:`
  float neg_(float a) {
    return -a;
  }
  vec4 neg_(vec4 v) {
    return -v;
  }
  `,name:"neg",type:c.FunctionType.ValueBased}}function A(){return{body:`
  float not_(float a) {
    return float( ! bool(a) );
  }
  bool not_(bool a) {
    return !a;
  }
  vec4 not_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 not_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:"not",type:c.FunctionType.ValueBased}}function C(){return G("sin")}function I(){const z="relu";return{body:`
  float ${z}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${z}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:z,type:c.FunctionType.ValueBased}}function D(){const z="sigmoid";return{body:`
  float ${z}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${z}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:z,type:c.FunctionType.ValueBased}}function R(){return G("sqrt")}function Y(){return G("tan")}function re(){const z="tanh";return{body:`
  float ${z}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${z}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:z,type:c.FunctionType.ValueBased}}function G(z){return{body:`
  float ${z}_(float a) {
    return ${z}(a);
  }
  vec4 ${z}_(vec4 v) {
    return ${z}(v);
  }
  `,name:z,type:c.FunctionType.ValueBased}}e.glslAbs=m,e.glslAcos=d,e.glslAsin=h,e.glslAtan=i,e.glslCeil=r,e.glslCos=u,e.glslElu=f,e.glslExp=g,e.glslFloor=w,e.glslClip=y,e.glslIdentity=x,e.glslLeakyRelu=S,e.glslLog=T,e.glslNeg=E,e.glslNot=A,e.glslSin=C,e.glslRelu=I,e.glslSigmoid=D,e.glslSqrt=R,e.glslTan=Y,e.glslTanh=re;const te=(z,H,he,Ce)=>{const oe=z.session.pack?_.TextureType.packed:_.TextureType.unpacked,K={name:he.name,inputTypes:[oe],inputNames:["A"],cacheHint:Ce};return Object.assign(Object.assign({},K),{get:()=>((Q,de,ue,Ze)=>{const Pt=Q.session.pack?_.TextureType.packed:_.TextureType.unpacked,Gt=(0,l.getGlsl)(Q.session.backend.glContext.version);return Object.assign(Object.assign({},de),{output:{dims:ue.dims,type:ue.type,textureType:Pt},shaderSource:`
     ${Ze.body}
     void main() {
       vec4 v = ${Gt.texture2D}(A, TexCoords);
       v = ${Ze.name}_(v);
       ${Gt.output} = v;
     }
     `,hasMain:!0})})(z,K,H,he)})};e.abs=(z,H)=>[z.run(te(z,H[0],m()),H)],e.acos=(z,H)=>[z.run(te(z,H[0],d()),H)],e.asin=(z,H)=>[z.run(te(z,H[0],h()),H)],e.atan=(z,H)=>[z.run(te(z,H[0],i()),H)],e.clip=(z,H,he)=>[z.run(te(z,H[0],y(he.min,he.max),he.cacheKey),H)],e.parseClipAttributes=z=>(0,s.createAttributeWithCacheKey)({min:z.attributes.getFloat("min",a.MIN_CLIP),max:z.attributes.getFloat("max",a.MAX_CLIP)}),e.clipV11=(z,H)=>{const he=q(z,H);return(0,e.clip)(z,[H[0]],he)};const q=(z,H)=>{if(H.length>=3&&(!z.session.isInitializer(H[1].dataId)||!z.session.isInitializer(H[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const he=H.length>=3?H[1].numberData[0]:a.MIN_CLIP,Ce=H.length>=3?H[2].numberData[0]:a.MAX_CLIP;return(0,s.createAttributeWithCacheKey)({min:he,max:Ce})};e.ceil=(z,H)=>[z.run(te(z,H[0],r()),H)],e.cos=(z,H)=>[z.run(te(z,H[0],u()),H)],e.elu=(z,H,he)=>[z.run(te(z,H[0],f(he.alpha),he.cacheKey),H)],e.parseEluAttributes=z=>(0,s.createAttributeWithCacheKey)({alpha:z.attributes.getFloat("alpha",1)}),e.exp=(z,H)=>[z.run(te(z,H[0],g()),H)],e.floor=(z,H)=>[z.run(te(z,H[0],w()),H)],e.identity=(z,H)=>[z.run(te(z,H[0],x()),H)],e.leakyRelu=(z,H,he)=>[z.run(te(z,H[0],S(he.alpha),he.cacheKey),H)],e.parseLeakyReluAttributes=z=>(0,s.createAttributeWithCacheKey)({alpha:z.attributes.getFloat("alpha",.01)}),e.log=(z,H)=>[z.run(te(z,H[0],T()),H)],e.neg=(z,H)=>[z.run(te(z,H[0],E()),H)],e.not=(z,H)=>[z.run(te(z,H[0],A()),H)],e.relu=(z,H)=>[z.run(te(z,H[0],I()),H)],e.sigmoid=(z,H)=>[z.run(te(z,H[0],D()),H)],e.sin=(z,H)=>[z.run(te(z,H[0],C()),H)],e.sqrt=(z,H)=>[z.run(te(z,H[0],R()),H)],e.tan=(z,H)=>[z.run(te(z,H[0],Y()),H)],e.tanh=(z,H)=>[z.run(te(z,H[0],re()),H)]},5611:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const s=t(5060),a=t(2039),c=t(9390),l=t(2827),_={name:"unpack",inputNames:["A"],inputTypes:[a.TextureType.packed]};e.createUnpackProgramInfo=(m,d)=>{const h=d.dims.length,i=(0,l.getChannels)("rc",h),r=i.slice(-2),u=(0,c.getCoordsDataType)(h),f=(0,l.unpackFromChannel)(),g=d.dims.length===0?"":(function(x,S){if(x===1)return"rc";let T="";for(let E=0;E<x;E++)T+=S[E],E<x-1&&(T+=",");return T})(h,i),w=h<=1?"rc":`vec2(${r.join(",")})`,y=`
    ${f}
    void main() {
      ${u} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${g});

       ${(0,s.getGlsl)(m.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${w}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},_),{hasMain:!0,output:{dims:d.dims,type:d.type,textureType:a.TextureType.unpacked},shaderSource:y})},e.createUnpackProgramInfoLoader=(m,d)=>Object.assign(Object.assign({},_),{get:()=>(0,e.createUnpackProgramInfo)(m,d)})},8428:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const s=t(2517);e.unsqueeze=(l,_,m)=>{a(_);const d=s.ShapeUtil.unsqueezeShape(_[0].dims,m);return[l.reshapeUnpacked(_[0],d)]},e.unsqueezeV13=(l,_)=>(c(_),(0,e.unsqueeze)(l,[_[0]],Array.from(_[1].integerData))),e.parseUnsqueezeAttributes=l=>l.attributes.getInts("axes");const a=l=>{if(!l||l.length!==1)throw new Error("Unsqueeze requires 1 input.");if(l[0].type==="string")throw new Error("invalid input tensor types.")},c=l=>{if(!l||l.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(l[1].type!=="int32")throw new Error("Invalid input type.")}},9793:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const s=t(246),a=t(5060),c=t(2039),l={name:"Upsample",inputNames:["X"],inputTypes:[c.TextureType.unpacked]};e.upsample=(m,d,h)=>((0,e.validateInputs)(d,h),[m.run(Object.assign(Object.assign({},l),{cacheHint:h.cacheKey,get:()=>_(m,d,h)}),d)]),e.parseUpsampleAttributesV7=m=>(0,e.parseUpsampleAttributes)(m,7),e.parseUpsampleAttributesV9=m=>(0,e.parseUpsampleAttributes)(m,9),e.parseUpsampleAttributes=(m,d)=>{const h=d>=10,i=m.attributes.getString("mode","nearest");if(i!=="nearest"&&i!=="linear"&&(d<11||i!=="cubic"))throw new Error(`unrecognized mode: ${i}`);let r=[];d<9&&(r=m.attributes.getFloats("scales"),(0,e.scalesValidation)(r,i,h));const u=m.attributes.getFloat("extrapolation_value",0),f=d>10?m.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(f)===-1)throw new Error(`coordinate_transform_mode '${f}' is not supported`);const g=f==="tf_crop_and_resize",w=g,y=i==="nearest"&&d>=11?m.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(y)===-1)throw new Error(`nearest_mode '${y}' is not supported`);const x=m.attributes.getFloat("cubic_coeff_a",-.75),S=m.attributes.getInt("exclude_outside",0)!==0;if(S&&i!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const T=d<11||i==="nearest"&&f==="asymmetric"&&y==="floor";let E=0,A=0,C=0;return d>10?m.inputs.length>2?(E=1,A=2,C=3):(A=1,C=2):d===9&&(A=1),(0,s.createAttributeWithCacheKey)({opset:d,isResize:h,mode:i,scales:r,extrapolationValue:u,coordinateTransformMode:f,useExtrapolation:w,needRoiInput:g,nearestMode:y,cubicCoefficientA:x,excludeOutside:S,useNearest2xOptimization:T,roiInputIdx:E,scalesInputIdx:A,sizesInputIdx:C})};const _=(m,d,h)=>{const i=(0,a.getGlsl)(m.session.backend.glContext.version),[r,u]=m.calculateTextureWidthAndHeight(d[0].dims,c.TextureType.unpacked),f=d[0].dims.map(((C,I)=>Math.floor(C*h.scales[I]))),[g,w]=m.calculateTextureWidthAndHeight(f,c.TextureType.unpacked),y=f.length,x=new Array(y),S=new Array(y);let T=`
      int output_pitches[${y}];
      int input_pitches[${y}];
      `;for(let C=y-1;C>=0;C--)x[C]=C===y-1?1:x[C+1]*f[C+1],S[C]=C===y-1?1:S[C+1]*d[0].dims[C+1],T+=`
        output_pitches[${C}] = ${x[C]};
        input_pitches[${C}] = ${S[C]};
        `;const E=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${r}, ${u});
        float value = getColorAsFloat(${i.texture2D}(X, coords));
        return value;
      }
      `,A=h.mode==="nearest"?`
    ${E}
    float process(int indices[${y}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${g}, ${w});

      ${T}

      int d, m;
      for (int dim = 0; dim < ${y}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:y===4?`
    ${E}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${g}, ${w});

      ${T}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${d[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${E}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${g}, ${w});

      ${T}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${d[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},l),{output:{dims:f,type:d[0].type,textureType:c.TextureType.unpacked},shaderSource:A,variables:[{name:"scales",type:"int",arrayLength:h.scales.length,data:h.scales.map((C=>Math.ceil(C)))}]})};e.validateInputs=(m,d)=>{if(!m||d.opset<9&&m.length!==1||d.opset>=9&&d.opset<11&&m.length!==2||d.opset>=11&&m.length<2)throw new Error("invalid inputs.");if(d.scales.length>0&&m[0].dims.length!==d.scales.length)throw new Error("Invalid input shape.");if(m[0].type==="string")throw new Error("Invalid input tensor types.")},e.scalesValidation=(m,d,h)=>{if(h){for(const i of m)if(i<=0)throw new Error("Scale value should be greater than 0.")}else for(const i of m)if(i<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(d!=="linear"&&d!=="cubic"||m.length===2||m.length===4&&m[0]===1&&m[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${h?"Resize":"Upsample"} opeartor.`)}},1958:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ProgramManager=void 0;const s=t(1670),a=t(6231),c=t(8879),l=t(5060);e.ProgramManager=class{constructor(_,m,d){this.profiler=_,this.glContext=m,this.textureLayoutStrategy=d,this.repo=new Map,this.attributesBound=!1}getArtifact(_){return this.repo.get(_)}setArtifact(_,m){this.repo.set(_,m)}run(_,m,d){var h;this.profiler.event("op",`ProgramManager.run ${(h=_.programInfo.name)!==null&&h!==void 0?h:"unknown kernel"}`,(()=>{var i;const r=this.glContext.gl,u=_.program;r.useProgram(u);try{this.bindOutput(d),this.attributesBound||this.bindAttributes(_.attribLocations),this.bindUniforms(_.uniformLocations,(i=_.programInfo.variables)!==null&&i!==void 0?i:[],m)}catch(f){throw a.Logger.error("ProgramManager",_.programInfo.shaderSource),f}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((_=>this.glContext.deleteProgram(_.program)))}build(_,m,d){return this.profiler.event("backend","ProgramManager.build",(()=>{const h=new c.GlslPreprocessor(this.glContext,_,m,d),i=h.preprocess(),r=this.compile(i);return{programInfo:_,program:r,uniformLocations:this.getUniformLocations(r,h.context.programInfo.inputNames,h.context.programInfo.variables),attribLocations:this.getAttribLocations(r)}}))}compile(_){if(!this.vertexShader){a.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const h=(0,l.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(h,this.glContext.gl.VERTEX_SHADER)}s.env.debug&&a.Logger.verbose("ProrgramManager",`FragShader:
${_}
`);const m=this.glContext.compileShader(_,this.glContext.gl.FRAGMENT_SHADER),d=this.glContext.createProgram(this.vertexShader,m);return this.glContext.deleteShader(m),d}bindOutput(_){const m=_.width,d=_.height;a.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${m}/${d}, shape=${_.shape}, type=${_.tensor.type}`),this.glContext.attachFramebuffer(_.texture,m,d)}bindAttributes(_){const m=_.position,d=_.textureCoord;this.glContext.setVertexAttributes(m,d),this.attributesBound=!0}bindUniforms(_,m,d){var h;const i=this.glContext.gl;let r=0;for(const{name:u,type:f,location:g,arrayLength:w}of _){const y=(h=m.find((x=>x.name===u)))===null||h===void 0?void 0:h.data;if(f!=="sampler2D"&&!y)throw new Error(`variable '${u}' does not have data defined in program info`);switch(f){case"sampler2D":this.bindTexture(d[r],g,r),r++;break;case"float":w?i.uniform1fv(g,y):i.uniform1f(g,y);break;case"int":w?i.uniform1iv(g,y):i.uniform1i(g,y);break;default:throw new Error(`Uniform not implemented: ${f}`)}}}bindTexture(_,m,d){this.glContext.bindTextureToUniform(_.texture,d,m)}getAttribLocations(_){return{position:this.getAttribLocation(_,"position"),textureCoord:this.getAttribLocation(_,"textureCoord")}}getUniformLocations(_,m,d){const h=[];if(m)for(const i of m)h.push({name:i,type:"sampler2D",location:this.getUniformLocation(_,i)});if(d)for(const i of d)h.push(Object.assign(Object.assign({},i),{location:this.getUniformLocation(_,i.name)}));return h}getUniformLocation(_,m){const d=this.glContext.gl.getUniformLocation(_,m);if(d===null)throw new Error(`Uniform ${m} not found.`);return d}getAttribLocation(_,m){return this.glContext.gl.getAttribLocation(_,m)}}},6416:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLSessionHandler=void 0;const s=t(6231),a=t(1047),c=t(8316),l=t(1640),_=t(1958),m=t(7859),d=t(5702);e.WebGLSessionHandler=class{constructor(h,i){this.backend=h,this.context=i,this.layoutStrategy=new m.PreferLogicalStrategy(h.glContext.maxTextureSize),this.programManager=new _.ProgramManager(this.context.profiler,h.glContext,this.layoutStrategy),this.textureManager=new d.TextureManager(h.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:h.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=h.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new c.WebGLInferenceHandler(this)}onGraphInitialized(h){const i=h.getValues().filter((r=>r.from===-1&&r.tensor)).map((r=>r.tensor.dataId));this.initializers=new Set(i)}isInitializer(h){return!!this.initializers&&this.initializers.has(h)}addInitializer(h){this.initializers.add(h)}getTextureData(h,i){return i?this.packedTextureDataCache.get(h):this.unpackedTextureDataCache.get(h)}setTextureData(h,i,r=!1){s.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),r?this.packedTextureDataCache.set(h,i):this.unpackedTextureDataCache.set(h,i)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((h=>this.textureManager.releaseTexture(h,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((h=>this.textureManager.releaseTexture(h,!0))),this.unpackedTextureDataCache=new Map}resolve(h,i,r){const u=(0,a.resolveOperator)(h,i,l.WEBGL_OP_RESOLVE_RULES);return{impl:u.opImpl,context:u.opInit?u.opInit(h,r):h}}}},7769:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const s=t(6231);e.RedFloat32DataEncoder=class{constructor(a,c=1){if(c===1)this.internalFormat=a.R32F,this.format=a.RED,this.textureType=a.FLOAT,this.channelSize=c;else{if(c!==4)throw new Error(`Invalid number of channels: ${c}`);this.internalFormat=a.RGBA32F,this.format=a.RGBA,this.textureType=a.FLOAT,this.channelSize=c}}encode(a,c){let l,_;return a.constructor!==Float32Array&&(s.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),_=new Float32Array(a)),c*this.channelSize>a.length?(s.Logger.warning("Encoder","Source data too small. Allocating larger array"),_=a,l=this.allocate(c*this.channelSize),_.forEach(((m,d)=>l[d]=m))):(_=a,l=_),l}allocate(a){return new Float32Array(4*a)}decode(a,c){return this.channelSize===1?a.filter(((l,_)=>_%4==0)).subarray(0,c):a.subarray(0,c)}},e.RGBAFloatDataEncoder=class{constructor(a,c=1,l){if(c!==1&&c!==4)throw new Error(`Invalid number of channels: ${c}`);this.internalFormat=a.RGBA,this.format=a.RGBA,this.channelSize=c,this.textureType=l||a.FLOAT}encode(a,c){let l=a;return this.channelSize===1&&(s.Logger.verbose("Encoder","Exploding into a larger array"),l=this.allocate(c),a.forEach(((_,m)=>l[4*m]=_))),l}allocate(a){return new Float32Array(4*a)}decode(a,c){return this.channelSize===1?a.filter(((l,_)=>_%4==0)).subarray(0,c):a.subarray(0,c)}},e.Uint8DataEncoder=class{constructor(a,c=1){if(this.channelSize=4,c===1)this.internalFormat=a.ALPHA,this.format=a.ALPHA,this.textureType=a.UNSIGNED_BYTE,this.channelSize=c;else{if(c!==4)throw new Error(`Invalid number of channels: ${c}`);this.internalFormat=a.RGBA,this.format=a.RGBA,this.textureType=a.UNSIGNED_BYTE,this.channelSize=c}}encode(a,c){return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}allocate(a){return new Uint8Array(a*this.channelSize)}decode(a,c){if(a instanceof Uint8Array)return a.subarray(0,c);throw new Error(`Invalid array type: ${a.constructor}`)}}},7859:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const s=t(6231),a=t(2517);function c(h,i){const r=[],u=[],f=i!=null&&Array.isArray(i)&&i.length===0,g=i==null||f?null:l(i,h).sort();let w=0;for(let y=0;y<h.length;++y){if(g!=null){if(g[w]===y&&h[y]!==1)throw new Error(`Can't squeeze axis ${y} since its dim '${h[y]}' is not 1`);(g[w]==null||g[w]>y)&&h[y]===1&&(r.push(h[y]),u.push(y)),g[w]<=y&&w++}h[y]!==1&&(r.push(h[y]),u.push(y))}return{newShape:r,keptDims:u}}function l(h,i){const r=i.length;return h=h==null?i.map(((u,f)=>f)):[].concat(h),(0,a.assert)(h.every((u=>u>=-r&&u<r)),(()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${h}`)),(0,a.assert)(h.every(_),(()=>`All values in axis param must be integers but got axis ${h}`)),h.map((u=>u<0?r+u:u))}function _(h){return h%1==0}function m(h){if(h.length===0)return 1;let i=h[0];for(let r=1;r<h.length;r++)i*=h[r];return i}function d(h){const i=Math.ceil(Math.sqrt(h));return[i,Math.ceil(h/i)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor(h){this.maxTextureSize=h}computeTextureWH(h,i){if(h.length===0)return[1,1];const r=this.maxTextureSize;if(i&&i.breakAxis!==void 0){const g=i.breakAxis>=h.length?1:h.slice(i.breakAxis).reduce(((y,x)=>y*x)),w=i.breakAxis<=0?1:h.slice(0,i.breakAxis).reduce(((y,x)=>y*x));if(!(g>r||w>r))return[g,w];s.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${h}, breakAxis:${i.breakAxis}`)}const u=h.reduce(((g,w)=>g*w));let f=Math.floor(Math.sqrt(u));for(;f<r&&f<u&&u%f!=0;f++);if(f>=r||u%f!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${h}`);return[f,u/f]}},e.PreferLogicalStrategy=class{constructor(h){this.maxTextureSize=h}computeTextureWH(h,i){const r=this.computeTexture(h,i);return i&&i.isPacked&&(r[0]/=2,r[1]/=2),i&&i.reverseWH?[r[1],r[0]]:r}computeTexture(h,i){const r=i&&i.isPacked;if(h.length===0)return r?[2,2]:[1,1];let u=this.maxTextureSize;if(i&&i.breakAxis!==void 0){const w=i.breakAxis>=h.length?1:h.slice(i.breakAxis).reduce(((x,S)=>x*S)),y=i.breakAxis<=0?1:h.slice(0,i.breakAxis).reduce(((x,S)=>x*S));if(!(w>u||y>u))return[w,y];s.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${h}, breakAxis:${i.breakAxis}`)}let f=h.slice(0);r&&(u*=2,f=f.map(((w,y)=>y>=f.length-2?f[y]%2==0?f[y]:f[y]+1:f[y])),f.length===1&&(f=[2,f[0]])),f.length!==2&&(f=c(f).newShape);const g=m(f);return f.length<=1&&g<=u?[1,g]:f.length===2&&f[0]<=u&&f[1]<=u?f:f.length===3&&f[0]*f[1]<=u&&f[2]<=u?[f[0]*f[1],f[2]]:f.length===3&&f[0]<=u&&f[1]*f[2]<=u?[f[0],f[1]*f[2]]:f.length===4&&f[0]*f[1]*f[2]<=u&&f[3]<=u?[f[0]*f[1]*f[2],f[3]]:f.length===4&&f[0]<=u&&f[1]*f[2]*f[3]<=u?[f[0],f[1]*f[2]*f[3]]:r?d(g/4).map((w=>2*w)):d(g)}},e.squeezeShape=c,e.parseAxisParam=l,e.isInt=_,e.sizeFromShape=m,e.getRowsCols=function(h){if(h.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[h.length>1?h[h.length-2]:1,h[h.length-1]]},e.sizeToSquarishShape=d,e.getBatchDim=function(h,i=2){return m(h.slice(0,h.length-i))}},4057:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const s=t(2517),a=t(2039);e.createTextureLayoutFromTextureType=(c,l,_)=>{const m=_===a.TextureType.unpacked||_===a.TextureType.unpackedReversed?1:4,d=_===a.TextureType.packed,h=_===a.TextureType.unpackedReversed||_===a.TextureType.packed,i=_===a.TextureType.packedLastDimension?l.length-1:void 0,r=_===a.TextureType.packedLastDimension?l.map(((u,f)=>f===l.length-1?4*u:u)):void 0;return(0,e.createTextureLayoutFromShape)(c,l,m,r,{isPacked:d,reverseWH:h,breakAxis:i})},e.calculateTextureWidthAndHeight=(c,l,_)=>{const m=(0,e.createTextureLayoutFromTextureType)(c,l,_);return[m.width,m.height]},e.createTextureLayoutFromShape=(c,l,_=1,m,d)=>{const h=!(!d||!d.isPacked),[i,r]=c.computeTextureWH(h&&m||l,d),u=l.length;let f=l.slice(0);if(u===0&&(f=[1]),_===1)m=l;else if(h){if(_!==4)throw new Error("a packed texture must be 4-channel");m=l,u>0&&(f[u-1]=Math.ceil(f[u-1]/2)),u>1&&(f[u-2]=Math.ceil(f[u-2]/2))}else if(!m)throw new Error("Unpacked shape is needed when using channels > 1");return{width:i,height:r,channels:_,isPacked:h,shape:f,strides:s.ShapeUtil.computeStrides(f),unpackedShape:m,reversedWH:d&&d.reverseWH}}},5702:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TextureManager=void 0;const s=t(6231);e.TextureManager=class{constructor(a,c,l,_){this.glContext=a,this.layoutStrategy=c,this.profiler=l,this.config=_,this.pendingRead=new Map,_.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(a,c,l,_){const m=this.toEncoderType(a),d=this.glContext.getEncoder(m,c.channels||1,_);if(c.isPacked&&_===1)throw new Error("not implemented");const h=c.width,i=c.height;let r,u;if(this.config.reuseTextures){r=`${h}x${i}_${d.format}_${d.internalFormat}_${d.textureType}`,u=this.inUseTextures.get(r),u||(u=[],this.inUseTextures.set(r,u));const g=this.idleTextures.get(r);if(g&&g.length>0){const w=g.pop();return u.push(w),_===1&&this.glContext.updateTexture(w,h,i,d,this.toTextureData(a,l)),w}}s.Logger.verbose("TextureManager",`Creating new texture of size ${c.width}x${c.height}`);const f=this.glContext.allocateTexture(h,i,d,this.toTextureData(a,l));return this.config.reuseTextures&&(u.push(f),this.textureLookup.set(f,r)),f}readTexture(a,c,l){return l||(l=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const _=a.shape.reduce(((d,h)=>d*h))*l,m=this.glContext.readTexture(a.texture,a.width,a.height,_,this.toEncoderType(c),l);return this.toTensorData(c,m)}))}async readTextureAsync(a,c,l){const _=a.tensor.dataId;if(l||(l=1),this.pendingRead.has(_)){const m=this.pendingRead.get(_);return new Promise((d=>m?.push(d)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(_,[]);const m=a.shape.reduce(((r,u)=>r*u))*l;await this.glContext.createAndWaitForFence();const d=this.glContext.readTexture(a.texture,a.width,a.height,m,this.toEncoderType(c),l),h=this.toTensorData(c,d),i=this.pendingRead.get(_);return this.pendingRead.delete(_),i?.forEach((r=>r(h))),h}))}readUint8TextureAsFloat(a){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const c=a.shape.reduce(((_,m)=>_*m)),l=this.glContext.readTexture(a.texture,a.width,a.height,4*c,"byte",4);return new Float32Array(l.buffer,l.byteOffset,c)}))}releaseTexture(a,c){let l;if(this.config.reuseTextures&&(l=this.textureLookup.get(a.texture),l)){c&&this.textureLookup.delete(l);const _=this.inUseTextures.get(l);if(_){const m=_.indexOf(a.texture);if(m!==-1){_.splice(m,1);let d=this.idleTextures.get(l);d||(d=[],this.idleTextures.set(l,d)),d.push(a.texture)}}}l&&!c||(s.Logger.verbose("TextureManager",`Deleting texture of size ${a.width}x${a.height}`),this.glContext.deleteTexture(a.texture))}toTensorData(a,c){switch(a){case"int16":return c instanceof Int16Array?c:Int16Array.from(c);case"int32":return c instanceof Int32Array?c:Int32Array.from(c);case"int8":return c instanceof Int8Array?c:Int8Array.from(c);case"uint16":return c instanceof Uint16Array?c:Uint16Array.from(c);case"uint32":return c instanceof Uint32Array?c:Uint32Array.from(c);case"uint8":case"bool":return c instanceof Uint8Array?c:Uint8Array.from(c);case"float32":return c instanceof Float32Array?c:Float32Array.from(c);case"float64":return c instanceof Float64Array?c:Float64Array.from(c);default:throw new Error(`TensorData type ${a} is not supported`)}}toTextureData(a,c){if(c)return c instanceof Float32Array?c:new Float32Array(c)}toEncoderType(a){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(n,e)=>{var t;Object.defineProperty(e,"__esModule",{value:!0}),e.TextureType=void 0,(t=e.TextureType||(e.TextureType={}))[t.unpacked=0]="unpacked",t[t.unpackedReversed=1]="unpackedReversed",t[t.packed=2]="packed",t[t.downloadUint8AsFloat=3]="downloadUint8AsFloat",t[t.packedLastDimension=4]="packedLastDimension"},9390:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const s=t(2517);e.getPackedShape=function(a){const c=a.length;return a.slice(0,c-1).concat(a[c-1]/4)},e.repeatedTry=async function(a,c=(_=>0),l){return new Promise(((_,m)=>{let d=0;const h=()=>{if(a())return void _();d++;const i=c(d);l!=null&&d>=l?m():setTimeout(h,i)};h()}))},e.generateShaderFuncNameFromInputSamplerName=function(a){return(0,s.assert)(a!==void 0&&a.length!==0,(()=>"empty string found for sampler name")),"get"+a.charAt(0).toUpperCase()+a.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(a){return(0,s.assert)(a!==void 0&&a.length!==0,(()=>"empty string found for sampler name")),"get"+a.charAt(0).toUpperCase()+a.slice(1)+"AtOutCoords"},e.squeezeInputShape=function(a,c){let l=JSON.parse(JSON.stringify(a));return l=c,l},e.getSqueezedParams=function(a,c){return c.map((l=>a[l])).join(", ")},e.getCoordsDataType=function(a){if(a<=1)return"int";if(a===2)return"ivec2";if(a===3)return"ivec3";if(a===4)return"ivec4";if(a===5)return"ivec5";if(a===6)return"ivec6";throw Error(`GPU for rank ${a} is not yet supported`)},e.getGlChannels=function(a=6){return["x","y","z","w","u","v"].slice(0,a)}},7305:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const s=t(6231),a=t(1713),c={};function l(_){const m=(function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const i=document.createElement("canvas");return i.width=1,i.height=1,i})();let d;const h={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!_||_==="webgl2")&&(d=m.getContext("webgl2",h),d))try{return new a.WebGLContext(d,2)}catch(i){s.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${i}`)}if((!_||_==="webgl")&&(d=m.getContext("webgl",h)||m.getContext("experimental-webgl",h),d))try{return new a.WebGLContext(d,1)}catch(i){s.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${i}`)}throw new Error("WebGL is not supported")}e.createWebGLContext=function _(m){let d;m&&m!=="webgl2"||!("webgl2"in c)?m&&m!=="webgl"||!("webgl"in c)||(d=c.webgl):d=c.webgl2,d=d||l(m),m=m||d.version===1?"webgl":"webgl2";const h=d.gl;return c[m]=d,h.isContextLost()?(delete c[m],_(m)):(h.disable(h.DEPTH_TEST),h.disable(h.STENCIL_TEST),h.disable(h.BLEND),h.disable(h.DITHER),h.disable(h.POLYGON_OFFSET_FILL),h.disable(h.SAMPLE_COVERAGE),h.enable(h.SCISSOR_TEST),h.enable(h.CULL_FACE),h.cullFace(h.BACK),d)},e.createNewWebGLContext=l},1713:function(n,e,t){var s=this&&this.__createBinding||(Object.create?function(h,i,r,u){u===void 0&&(u=r);var f=Object.getOwnPropertyDescriptor(i,r);f&&!("get"in f?!i.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return i[r]}}),Object.defineProperty(h,u,f)}:function(h,i,r,u){u===void 0&&(u=r),h[u]=i[r]}),a=this&&this.__setModuleDefault||(Object.create?function(h,i){Object.defineProperty(h,"default",{enumerable:!0,value:i})}:function(h,i){h.default=i}),c=this&&this.__importStar||function(h){if(h&&h.__esModule)return h;var i={};if(h!=null)for(var r in h)r!=="default"&&Object.prototype.hasOwnProperty.call(h,r)&&s(i,h,r);return a(i,h),i};Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const l=t(1670),_=c(t(7769)),m=t(9390);function d(h){let i=0;for(;i<h.length&&h[i]();++i);return i-1}e.linearSearchLastTrue=d,e.WebGLContext=class{constructor(h,i){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=h,this.version=i,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(h,i,r,u){const f=this.gl,g=f.createTexture();f.bindTexture(f.TEXTURE_2D,g),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,f.CLAMP_TO_EDGE),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,f.CLAMP_TO_EDGE);const w=u?r.encode(u,h*i):null;return f.texImage2D(f.TEXTURE_2D,0,r.internalFormat,h,i,0,r.format,r.textureType,w),this.checkError(),g}updateTexture(h,i,r,u,f){const g=this.gl;g.bindTexture(g.TEXTURE_2D,h);const w=u.encode(f,i*r);g.texSubImage2D(g.TEXTURE_2D,0,0,0,i,r,u.format,u.textureType,w),this.checkError()}attachFramebuffer(h,i,r){const u=this.gl;u.bindTexture(u.TEXTURE_2D,h),u.bindFramebuffer(u.FRAMEBUFFER,this.framebuffer),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,h,0),this.checkError(),u.viewport(0,0,i,r),u.scissor(0,0,i,r)}readTexture(h,i,r,u,f,g){const w=this.gl;g||(g=1),this.frameBufferBound||this.attachFramebuffer(h,i,r);const y=this.getEncoder(f,g),x=y.allocate(i*r);return w.bindTexture(w.TEXTURE_2D,h),w.framebufferTexture2D(w.FRAMEBUFFER,w.COLOR_ATTACHMENT0,w.TEXTURE_2D,h,0),w.readPixels(0,0,i,r,w.RGBA,y.textureType,x),this.checkError(),y.decode(x,u)}isFramebufferReady(){return!0}getActiveTexture(){const h=this.gl;return"TEXTURE"+(h.getParameter(this.gl.ACTIVE_TEXTURE)-h.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(h,i){const r=this.gl;r.vertexAttribPointer(h,3,r.FLOAT,!1,20,0),r.enableVertexAttribArray(h),i!==-1&&(r.vertexAttribPointer(i,2,r.FLOAT,!1,20,12),r.enableVertexAttribArray(i)),this.checkError()}createProgram(h,i){const r=this.gl,u=r.createProgram();return r.attachShader(u,h),r.attachShader(u,i),r.linkProgram(u),u}compileShader(h,i){const r=this.gl,u=r.createShader(i);if(!u)throw new Error(`createShader() returned null with type ${i}`);if(r.shaderSource(u,h),r.compileShader(u),r.getShaderParameter(u,r.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${r.getShaderInfoLog(u)}
Shader source:
${h}`);return u}deleteShader(h){this.gl.deleteShader(h)}bindTextureToUniform(h,i,r){const u=this.gl;u.activeTexture(u.TEXTURE0+i),this.checkError(),u.bindTexture(u.TEXTURE_2D,h),this.checkError(),u.uniform1i(r,i),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(l.env.debug){const h=this.gl,i=h.getError();let r="";switch(i){case h.NO_ERROR:return;case h.INVALID_ENUM:r="INVALID_ENUM";break;case h.INVALID_VALUE:r="INVALID_VALUE";break;case h.INVALID_OPERATION:r="INVALID_OPERATION";break;case h.INVALID_FRAMEBUFFER_OPERATION:r="INVALID_FRAMEBUFFER_OPERATION";break;case h.OUT_OF_MEMORY:r="OUT_OF_MEMORY";break;case h.CONTEXT_LOST_WEBGL:r="CONTEXT_LOST_WEBGL";break;default:r=`Unknown WebGL Error: ${i.toString(16)}`}throw new Error(r)}}deleteTexture(h){this.gl.deleteTexture(h)}deleteProgram(h){this.gl.deleteProgram(h)}getEncoder(h,i,r=0){if(this.version===2)return new _.RedFloat32DataEncoder(this.gl,i);switch(h){case"float":return r===1||this.isRenderFloat32Supported?new _.RGBAFloatDataEncoder(this.gl,i):new _.RGBAFloatDataEncoder(this.gl,i,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new _.Uint8DataEncoder(this.gl,i);default:throw new Error(`Invalid dataType: ${h}`)}}clearActiveTextures(){const h=this.gl;for(let i=0;i<this.maxTextureImageUnits;++i)h.activeTexture(h.TEXTURE0+i),h.bindTexture(h.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const h=this.gl;h.bindFramebuffer(h.FRAMEBUFFER,null),h.deleteFramebuffer(this.framebuffer),h.bindBuffer(h.ARRAY_BUFFER,null),h.deleteBuffer(this.vertexbuffer),h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,null),h.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const h=this.gl,i=h.createBuffer();if(!i)throw new Error("createBuffer() returned null");const r=this.createDefaultGeometry();return h.bindBuffer(h.ARRAY_BUFFER,i),h.bufferData(h.ARRAY_BUFFER,r,h.STATIC_DRAW),this.checkError(),i}createFramebuffer(){const h=this.gl.createFramebuffer();if(!h)throw new Error("createFramebuffer returned null");return h}queryVitalParameters(){const h=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=h.getParameter(h.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=h.getParameter(h.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const h=this.gl,i=h.createTexture();h.bindTexture(h.TEXTURE_2D,i);const r=this.version===2?h.RGBA32F:h.RGBA;h.texImage2D(h.TEXTURE_2D,0,r,1,1,0,h.RGBA,h.FLOAT,null);const u=h.createFramebuffer();h.bindFramebuffer(h.FRAMEBUFFER,u),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,i,0);const f=h.checkFramebufferStatus(h.FRAMEBUFFER)===h.FRAMEBUFFER_COMPLETE;return h.bindTexture(h.TEXTURE_2D,null),h.bindFramebuffer(h.FRAMEBUFFER,null),h.deleteTexture(i),h.deleteFramebuffer(u),f}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const h=this.gl;let i,r,u,f,g;try{i=h.createTexture(),r=h.createFramebuffer(),h.bindTexture(h.TEXTURE_2D,i);const w=this.version===2?h.RGBA32F:h.RGBA;return h.texImage2D(h.TEXTURE_2D,0,w,1,1,0,h.RGBA,h.FLOAT,null),h.bindFramebuffer(h.FRAMEBUFFER,r),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,i,0),h.enable(h.BLEND),u=h.createShader(h.VERTEX_SHADER),!!u&&(h.shaderSource(u,"void main(){}"),h.compileShader(u),f=h.createShader(h.FRAGMENT_SHADER),!!f&&(h.shaderSource(f,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),h.compileShader(f),g=h.createProgram(),!!g&&(h.attachShader(g,u),h.attachShader(g,f),h.linkProgram(g),h.useProgram(g),h.drawArrays(h.POINTS,0,1),h.getError()===h.NO_ERROR)))}finally{h.disable(h.BLEND),g&&h.deleteProgram(g),u&&h.deleteShader(u),f&&h.deleteShader(f),r&&(h.bindFramebuffer(h.FRAMEBUFFER,null),h.deleteFramebuffer(r)),i&&(h.bindTexture(h.TEXTURE_2D,null),h.deleteTexture(i))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const h=this.gl,i=this.disjointTimerQueryWebgl2Extension,r=h.createQuery();return h.beginQuery(i.TIME_ELAPSED_EXT,r),r}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const h=this.gl,i=this.disjointTimerQueryWebgl2Extension;h.endQuery(i.TIME_ELAPSED_EXT)}}isTimerResultAvailable(h){let i=!1,r=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const u=this.gl,f=this.disjointTimerQueryWebgl2Extension;i=u.getQueryParameter(h,u.QUERY_RESULT_AVAILABLE),r=u.getParameter(f.GPU_DISJOINT_EXT)}return i&&!r}getTimerResult(h){let i=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl;i=r.getQueryParameter(h,r.QUERY_RESULT),r.deleteQuery(h)}return i/1e6}async waitForQueryAndGetTime(h){return await(0,m.repeatedTry)((()=>this.isTimerResultAvailable(h))),this.getTimerResult(h)}async createAndWaitForFence(){const h=this.createFence(this.gl);return this.pollFence(h)}createFence(h){let i;const r=h,u=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);return h.flush(),i=u===null?()=>!0:()=>{const f=r.clientWaitSync(u,0,0);return f===r.ALREADY_SIGNALED||f===r.CONDITION_SATISFIED},{query:u,isFencePassed:i}}async pollFence(h){return new Promise((i=>{this.addItemToPoll((()=>h.isFencePassed()),(()=>i()))}))}pollItems(){const h=d(this.itemsToPoll.map((i=>i.isDoneFn)));for(let i=0;i<=h;++i){const{resolveFn:r}=this.itemsToPoll[i];r()}this.itemsToPoll=this.itemsToPoll.slice(h+1)}async addItemToPoll(h,i){this.itemsToPoll.push({isDoneFn:h,resolveFn:i}),this.itemsToPoll.length>1||await(0,m.repeatedTry)((()=>(this.pollItems(),this.itemsToPoll.length===0)))}}},1036:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExecutionPlan=void 0;const s=t(6231);class a{constructor(l,_){this.op=l,this.node=_}}e.ExecutionPlan=class{constructor(c,l,_){this.graph=c,this.profiler=_,this.initialize(l)}initialize(c){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const l=this.graph.getNodes();if(l.length!==c.length)throw new Error("The size of nodes and OPs do not match.");this._ops=c.map(((_,m)=>new a(_,l[m]))),this.reset(),this._starter=[],this._ops.forEach(((_,m)=>{let d=!0;for(const h of _.node.inputs)if(!this._values[h]&&this.graph.getInputIndices().indexOf(h)===-1){d=!1;break}d&&this._starter.push(m)}))}))}reset(){this._values=this.graph.getValues().map((c=>c.tensor))}async execute(c,l){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const _=c.createInferenceHandler(),m=this.graph.getInputIndices();if(l.length!==m.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${l.length} expected: ${m.length}`);l.forEach(((f,g)=>{const w=m[g];this._values[w]=f}));const d=this._starter.slice(0),h=this.graph.getValues(),i=this.graph.getNodes();let r=0;for(;r<d.length;){const f=d[r++],g=this._ops[f],w=g.node.inputs.map((T=>this._values[T]));if(w.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${g.node}`);const y=w;s.Logger.verbose("ExecPlan",`Runing op:${g.node.name} (${y.map(((T,E)=>`'${g.node.inputs[E]}': ${T.type}[${T.dims.join(",")}]`)).join(", ")})`);const x=await this.profiler.event("node",g.node.name,(async()=>g.op.impl(_,y,g.op.context)));if(x.length!==g.node.outputs.length)throw new Error("the size of output does not match model definition.");x.forEach(((T,E)=>{const A=g.node.outputs[E];if(this._values[A])throw new Error(`output [${A}] already has value: op:${g.node.name}`);this._values[A]=T}));const S=new Set;x.forEach(((T,E)=>{const A=g.node.outputs[E];for(const C of h[A].to){const I=i[C];let D=!0;for(const R of I.inputs)if(!this._values[R]){D=!1;break}D&&S.add(C)}})),d.push(...S)}const u=[];for(let f=0;f<this.graph.getOutputIndices().length;f++){const g=this.graph.getOutputIndices()[f],w=this._values[g];if(w===void 0)throw new Error(`required output [${g}] does not have value`);g===0?await w.getData():w.data,u.push(w)}return s.Logger.verbose("ExecPlan","disposing of inferenceHandler"),_.dispose(),u}))}}},7070:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Graph=void 0;const s=t(1446),a=t(7778),c=t(9395),l=t(9162),_=t(2517);var m=c.onnxruntime.experimental.fbs;e.Graph={from:(r,u)=>new i(r,u)};class d{constructor(u){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,u&&(this.type=_.ProtoUtil.tensorValueTypeFromProto(u.type.tensorType))}get from(){return this._from}get to(){return this._to}}class h{constructor(u,f){u instanceof s.onnx.NodeProto?(this.name=u.name,this.opType=u.opType,this.attributes=new a.Attribute(u.attribute)):u instanceof m.Node&&(this.name=f??u.name(),this.opType=u.opType(),this.attributes=new a.Attribute(_.ProtoUtil.tensorAttributesFromORTFormat(u))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class i{constructor(u,f){if(!u)throw new TypeError("graph is empty");this.buildGraph(u),this.transformGraph(f),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(u){if(u instanceof s.onnx.GraphProto)this.buildGraphFromOnnxFormat(u);else{if(!(u instanceof m.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(u)}}buildGraphFromOnnxFormat(u){const f=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const g=new Map;if(!u.input)throw new Error("missing information in graph: input");const w=[];for(const y of u.input){if(f.has(y.name))throw new Error(`duplicated input name: ${y.name}`);const x=this._allData.push(new d(y))-1;f.set(y.name,x),w.push(y.name)}if(!u.initializer)throw new Error("missing information in graph: initializer");for(const y of u.initializer){let x=f.get(y.name);if(x===void 0){const S=new d;S.type={shape:{dims:_.ProtoUtil.tensorDimsFromProto(y.dims)},tensorType:_.ProtoUtil.tensorDataTypeFromProto(y.dataType)},x=this._allData.push(S)-1,f.set(y.name,x)}this._allData[x]._from=-1,this._allData[x].tensor=l.Tensor.fromProto(y)}for(let y=0;y<this._allData.length;y++)this._allData[y].tensor||(this._allInputIndices.push(y),this._allInputNames.push(w[y]));if(!u.output)throw new Error("missing information in graph: output");for(const y of u.output){if(f.has(y.name))throw new Error(`duplicated output name: ${y.name}`);const x=this._allData.push(new d(y))-1;f.set(y.name,x),this._allOutputIndices.push(x),this._allOutputNames.push(y.name)}if(!u.node)throw new Error("missing information in graph: node");for(const y of u.node){if(!y.name)for(let S=0;;S++){const T=`unnamed_${y.opType}_${S}`;if(!g.has(T)){y.name=T;break}}if(g.has(y.name))throw new Error(`duplicated node name: ${y.name}`);const x=this._nodes.push(new h(y))-1;g.set(y.name,x)}for(let y=0;y<this._nodes.length;y++){const x=this._nodes[y],S=u.node[y];if(!S.output)throw new Error(`missing output for node: ${S.name}`);for(const T of S.output){let E=f.get(T);if(E===void 0&&(E=this._allData.push(new d)-1,f.set(T,E)),x.outputs.push(E),this._allData[E]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${E}`);if(this._allData[E]._from=y,S.opType==="Constant"){if(!S.attribute||S.attribute.length!==1||!S.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!S.output||S.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");x.outputs.pop(),x.executeNode=!1,this._allData[E]._from=-1,this._allData[E].tensor=l.Tensor.fromProto(S.attribute[0].t)}}}for(let y=0;y<this._nodes.length;y++){const x=this._nodes[y],S=u.node[y];if(!S.input)throw new Error(`missing input for node: ${S.name}`);for(const T of S.input){const E=f.get(T);if(E===void 0){if(T===""&&S.input.length===3&&S.opType==="Resize")continue;throw new Error(`unrecognized input '${T}' for node: ${S.name}`)}x.inputs.push(E),this._allData[E]._to.push(y)}}return!0}buildGraphFromOrtFormat(u){var f,g,w;const y=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const x=new Map,S=[];for(let T=0;T<u.inputsLength();T++){const E=u.inputs(T);if(y.has(E))throw new Error(`duplicated input name: ${E}`);for(let A=0;A<u.nodeArgsLength();A++)if(((f=u.nodeArgs(A))===null||f===void 0?void 0:f.name())===E){const C=new d;if(((w=(g=u.nodeArgs(A))===null||g===void 0?void 0:g.type())===null||w===void 0?void 0:w.valueType())!==m.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const I=u.nodeArgs(A).type().value(new m.TensorTypeAndShape),D=_.ProtoUtil.tensorDataTypeFromProto(I.elemType()),R=I.shape(),Y=[];for(let G=0;G<R.dimLength();G++)Y.push(_.LongUtil.longToNumber(R.dim(G).value().dimValue()));C.type={shape:{dims:Y},tensorType:D};const re=this._allData.push(C)-1;y.set(E,re),S.push(E)}}for(let T=0;T<u.initializersLength();T++){const E=u.initializers(T);let A=y.get(E.name());if(A===void 0){const C=new d,I=_.ProtoUtil.tensorDimsFromORTFormat(E),D=_.ProtoUtil.tensorDataTypeFromProto(E.dataType());C.type={shape:{dims:I},tensorType:D},A=this._allData.push(C)-1,y.set(E.name(),A)}this._allData[A]._from=-1,this._allData[A].tensor=l.Tensor.fromOrtTensor(E)}for(let T=0;T<this._allData.length;T++)this._allData[T].tensor||(this._allInputIndices.push(T),this._allInputNames.push(S[T]));for(let T=0;T<u.outputsLength();T++){const E=u.outputs(T);if(y.has(E))throw new Error(`duplicated output name: ${E}`);const A=this._allData.push(new d)-1;y.set(E,A),this._allOutputIndices.push(A),this._allOutputNames.push(E)}if(!u.nodes)throw new Error("missing information in graph: node");for(let T=0;T<u.nodesLength();T++){const E=u.nodes(T);let A=E.name();if(!A)for(let I=0;A=`unnamed_${E.opType()}_${I}`,x.has(A);I++);if(x.has(A))throw new Error(`duplicated node name: ${A}`);const C=this._nodes.push(new h(E,A))-1;x.set(A,C)}for(let T=0;T<this._nodes.length;T++){const E=this._nodes[T],A=u.nodes(T);if(A==null)throw new Error(`No node exists at index ${T}`);if(A?.outputsLength()===0)throw new Error(`missing output for node: ${A.name}`);for(let C=0;C<A?.outputsLength();C++){const I=A?.outputs(C);let D=y.get(I);if(D===void 0&&(D=this._allData.push(new d)-1,y.set(I,D)),E.outputs.push(D),this._allData[D]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${D}`);if(this._allData[D]._from=T,A.opType()==="Constant"){if(A.attributesLength()!==1||!A.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(A.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");E.outputs.pop(),E.executeNode=!1,this._allData[D]._from=-1,this._allData[D].tensor=l.Tensor.fromOrtTensor(A.attributes(0).t())}}}for(let T=0;T<this._nodes.length;T++){const E=this._nodes[T],A=u.nodes(T);if(A.inputsLength()===0)throw new Error(`missing input for node: ${A.name}`);for(let C=0;C<A.inputsLength();C++){const I=A.inputs(C),D=y.get(I);if(D===void 0)throw new Error(`unrecognized input '${I}' for node: ${A.name()}`);E.inputs.push(D),this._allData[D]._to.push(T)}}}checkIsAcyclic(){const u=new Set;this._allInputIndices.forEach((w=>{this._allData[w]._to.forEach((y=>{u.add(y)}))}));const f=Array.from(u),g=new Array(this._nodes.length).fill("white");for(;f.length>0;){const w=f.pop();g[w]==="gray"?g[w]="black":(f.push(w),g[w]="gray",this._nodes[w].outputs.forEach((y=>{const x=this._allData[y];if(x.tensor!==void 0)throw new Error("node outputs should not be initialized");if(x._from!==w)throw new Error("from property of the Value object doesn't match index of Node being processed");x._to.forEach((S=>{if(g[S]==="gray")throw new Error("model graph is cyclic");g[S]==="white"&&f.push(S)}))})))}}transformGraph(u){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),u&&u.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let u=0;for(let f=0;f<this._nodes.length;f++)this._nodes[f].executeNode?u>0&&(this._nodes[f].inputs.forEach((g=>{const w=this._allData[g]._to.indexOf(f+u);w!==-1&&(this._allData[g]._to[w]=f)})),this._nodes[f].outputs.forEach((g=>{this._allData[g]._from&&this._allData[g]._from===f+u&&(this._allData[g]._from=f)}))):(u++,this._nodes[f].outputs.forEach((g=>{this._allData[g]._from=-2})),this._nodes.splice(f,1),f--);u=0;for(let f=0;f<this._allData.length;f++)if(this._allData[f].from!==-2||this._allOutputIndices.indexOf(f+u)!==-1){if(u>0){let g=-1;this._allData[f].from!==void 0&&this._allData[f].from!==-1?(g=this._nodes[this._allData[f].from].outputs.indexOf(f+u),g!==-1&&(this._nodes[this._allData[f].from].outputs[g]=f)):(g=this._allInputIndices.indexOf(f+u),g!==-1&&(this._allInputIndices[g]=f)),this._allData[f].to.forEach((w=>{g=this._nodes[w].inputs.indexOf(f+u),g!==-1&&(this._nodes[w].inputs[g]=f)})),this._allData[f].to.length===0&&(g=this._allOutputIndices.indexOf(f+u),g!==-1&&(this._allOutputIndices[g]=f))}}else u++,this._allData.splice(f,1),f--}deleteNode(u){const f=this._nodes[u];if(f.outputs.length>1){for(let T=1;T<f.outputs.length;T++)if(this._allData[f.outputs[T]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}f.executeNode=!1;const g=f.inputs[0],w=f.outputs[0],y=this._allData[w].to,x=this._allData[g].to.indexOf(u);if(x===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[g].to.splice(x,1),this._allData[w]._to=[];const S=this._allOutputIndices.indexOf(w);if(S!==-1&&(this._allOutputIndices[S]=g),y&&y.length>0)for(const T of y){const E=this._nodes[T].inputs.indexOf(w);if(E===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[T].inputs[E]=g,this._allData[g].to.push(T)}}removeAllDropoutNodes(){let u=0;for(const f of this._nodes){if(f.opType==="Dropout"){if(f.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(f.outputs.length!==1&&f.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(f.outputs.length===2&&this._allData[f.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(u)}u++}}removeAllIdentityNodes(){let u=0;for(const f of this._nodes)f.opType==="Identity"&&this.deleteNode(u),u++}isActivation(u){switch(u.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const u of this._nodes)if(u.opType==="Conv"){const f=this._allData[u.outputs[0]]._to;if(f.length===1&&this.isActivation(this._nodes[f[0]])){const g=this._nodes[f[0]];if(g.opType==="Clip")if(g.inputs.length===1)try{u.attributes.set("activation_params","floats",[g.attributes.getFloat("min"),g.attributes.getFloat("max")])}catch{u.attributes.set("activation_params","floats",[_.MIN_CLIP,_.MAX_CLIP])}else{if(!(g.inputs.length>=3&&this._allData[g.inputs[1]].tensor!==void 0&&this._allData[g.inputs[2]].tensor!==void 0))continue;u.attributes.set("activation_params","floats",[this._allData[g.inputs[1]].tensor.floatData[0],this._allData[g.inputs[2]].tensor.floatData[0]])}u.attributes.set("activation","string",g.opType),this.deleteNode(f[0])}}}}},6231:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const t={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},s={none:new class{log(h,i,r){}},console:new class{log(h,i,r){console.log(`${this.color(h)} ${r?"\x1B[35m"+r+"\x1B[0m ":""}${i}`)}color(h){switch(h){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${h}`)}}}},a={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let c={"":a};function l(h,i,r,u){if(i===void 0)return f=h,{verbose:l.verbose.bind(null,f),info:l.info.bind(null,f),warning:l.warning.bind(null,f),error:l.error.bind(null,f),fatal:l.fatal.bind(null,f)};if(r===void 0)_(h,i);else if(typeof r=="number"&&u===void 0)_(h,i);else if(typeof r=="string"&&u===void 0)_(h,r,0,i);else{if(typeof r!="string"||typeof u!="number")throw new TypeError("input is valid");_(h,r,0,i)}var f}function _(h,i,r,u){const f=c[u||""]||c[""];t[h]<t[f.minimalSeverity]||(f.logDateTime&&(i=`${new Date().toISOString()}|${i}`),f.logSourceLocation,s[f.provider].log(h,i,u))}(function(h){function i(u){c={},r("",u||{})}function r(u,f){if(u==="*")i(f);else{const g=c[u]||a;c[u]={provider:f.provider||g.provider,minimalSeverity:f.minimalSeverity||g.minimalSeverity,logDateTime:f.logDateTime===void 0?g.logDateTime:f.logDateTime,logSourceLocation:f.logSourceLocation===void 0?g.logSourceLocation:f.logSourceLocation}}}h.verbose=function(u,f){h("verbose",u,f)},h.info=function(u,f){h("info",u,f)},h.warning=function(u,f){h("warning",u,f)},h.error=function(u,f){h("error",u,f)},h.fatal=function(u,f){h("fatal",u,f)},h.reset=i,h.set=r,h.setWithEnv=function(u){const f={};u.logLevel&&(f.minimalSeverity=u.logLevel),r("",f)}})(l||(l={})),e.Logger=l;class m{constructor(i,r,u,f,g,w){this.category=i,this.name=r,this.startTime=u,this.endCallback=f,this.timer=g,this.ctx=w}end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class d{constructor(i,r,u,f){this.category=i,this.name=r,this.startTime=u,this.endTime=f}}e.Profiler=class{static create(h){return h===void 0?new this:new this(h.maxNumberEvents,h.flushBatchSize,h.flushIntervalInMilliseconds)}constructor(h,i,r){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=h===void 0?1e4:h,this._flushBatchSize=i===void 0?10:i,this._flushIntervalInMilliseconds=r===void 0?5e3:r}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(h,i,r,u){const f=this._started?this.begin(h,i,u):void 0;let g=!1;const w=r();if(w&&typeof w.then=="function")return g=!0,new Promise(((y,x)=>{w.then((async S=>{f&&await f.end(),y(S)}),(async S=>{f&&await f.end(),x(S)}))}));if(!g&&f){const y=f.end();if(y&&typeof y.then=="function")return new Promise(((x,S)=>{y.then((()=>{x(w)}),(T=>{S(T)}))}))}return w}begin(h,i,r){if(!this._started)throw new Error("profiler is not started yet");if(r===void 0){const u=(0,e.now)();return this.flush(u),new m(h,i,u,(f=>this.endSync(f)))}{const u=r.beginTimer();return new m(h,i,0,(async f=>this.end(f)),u,r)}}async end(h){const i=await h.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new d(h.category,h.name,h.startTime,i)),this.flush(i))}endSync(h){const i=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new d(h.category,h.name,h.startTime,i)),this.flush(i))}logOneEvent(h){e.Logger.verbose(`Profiler.${h.category}`,`${(h.endTime-h.startTime).toFixed(2)}ms on event '${h.name}' at ${h.endTime.toFixed(2)}`)}flush(h){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||h-this._flushTime>=this._flushIntervalInMilliseconds){for(const i=this._flushPointer;this._flushPointer<i+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},2644:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Model=void 0;const s=t(5686),a=t(1446),c=t(7070),l=t(9395),_=t(2517);var m=l.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load(d,h,i){if(!i)try{return void this.loadFromOnnxFormat(d,h)}catch(r){if(i!==void 0)throw r}this.loadFromOrtFormat(d,h)}loadFromOnnxFormat(d,h){const i=a.onnx.ModelProto.decode(d);if(_.LongUtil.longToNumber(i.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map((r=>({domain:r.domain,version:_.LongUtil.longToNumber(r.version)}))),this._graph=c.Graph.from(i.graph,h)}loadFromOrtFormat(d,h){const i=new s.flatbuffers.ByteBuffer(d),r=m.InferenceSession.getRootAsInferenceSession(i).model();if(_.LongUtil.longToNumber(r.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let u=0;u<r.opsetImportLength();u++){const f=r.opsetImport(u);this._opsets.push({domain:f?.domain(),version:_.LongUtil.longToNumber(f.version())})}this._graph=c.Graph.from(r.graph(),h)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],e.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],e.FLOAT_TYPES=["float32","float64"]},1047:(n,e)=>{function t(s,a){if(a.endsWith("+")){const c=Number.parseInt(a.substring(0,a.length-1),10);return!isNaN(c)&&c<=s}if(a.split("-").length===2){const c=a.split("-"),l=Number.parseInt(c[0],10),_=Number.parseInt(c[1],10);return!isNaN(l)&&!isNaN(_)&&l<=s&&s<=_}return Number.parseInt(a,10)===s}Object.defineProperty(e,"__esModule",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(s,a,c){for(const l of c){const _=l[0],m=l[1],d=l[2],h=l[3],i=l[4];if(s.opType===_){for(const r of a)if((r.domain===m||r.domain==="ai.onnx"&&m==="")&&t(r.version,d))return{opImpl:h,opInit:i}}}throw new TypeError(`cannot resolve operator '${s.opType}' with opsets: ${a.map((l=>`${l.domain||"ai.onnx"} v${l.version}`)).join(", ")}`)}},9395:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.onnxruntime=void 0;const s=t(5686);var a,c;a=e.onnxruntime||(e.onnxruntime={}),(function(l){(function(_){_[_.UNDEFINED=0]="UNDEFINED",_[_.FLOAT=1]="FLOAT",_[_.INT=2]="INT",_[_.STRING=3]="STRING",_[_.TENSOR=4]="TENSOR",_[_.GRAPH=5]="GRAPH",_[_.FLOATS=6]="FLOATS",_[_.INTS=7]="INTS",_[_.STRINGS=8]="STRINGS",_[_.TENSORS=9]="TENSORS",_[_.GRAPHS=10]="GRAPHS",_[_.SPARSE_TENSOR=11]="SPARSE_TENSOR",_[_.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(l.AttributeType||(l.AttributeType={}))})((c=a.experimental||(a.experimental={})).fbs||(c.fbs={})),(function(l){(function(_){(function(m){(function(d){d[d.UNKNOWN=0]="UNKNOWN",d[d.VALUE=1]="VALUE",d[d.PARAM=2]="PARAM"})(m.DimensionValueType||(m.DimensionValueType={}))})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){(function(d){d[d.UNDEFINED=0]="UNDEFINED",d[d.FLOAT=1]="FLOAT",d[d.UINT8=2]="UINT8",d[d.INT8=3]="INT8",d[d.UINT16=4]="UINT16",d[d.INT16=5]="INT16",d[d.INT32=6]="INT32",d[d.INT64=7]="INT64",d[d.STRING=8]="STRING",d[d.BOOL=9]="BOOL",d[d.FLOAT16=10]="FLOAT16",d[d.DOUBLE=11]="DOUBLE",d[d.UINT32=12]="UINT32",d[d.UINT64=13]="UINT64",d[d.COMPLEX64=14]="COMPLEX64",d[d.COMPLEX128=15]="COMPLEX128",d[d.BFLOAT16=16]="BFLOAT16"})(m.TensorDataType||(m.TensorDataType={}))})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){(function(d){d[d.Primitive=0]="Primitive",d[d.Fused=1]="Fused"})(m.NodeType||(m.NodeType={}))})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){(function(d){d[d.NONE=0]="NONE",d[d.tensor_type=1]="tensor_type",d[d.sequence_type=2]="sequence_type",d[d.map_type=3]="map_type"})(m.TypeInfoValue||(m.TypeInfoValue={}))})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsShape(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsShape(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}dim(i,r){let u=this.bb.__offset(this.bb_pos,4);return u?(r||new l.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}dimLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}static startShape(i){i.startObject(1)}static addDim(i,r){i.addFieldOffset(0,r,0)}static createDimVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startDimVector(i,r){i.startVector(4,r,4)}static endShape(i){return i.endObject()}static createShape(i,r){return d.startShape(i),d.addDim(i,r),d.endShape(i)}}m.Shape=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsDimension(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsDimension(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}value(i){let r=this.bb.__offset(this.bb_pos,4);return r?(i||new l.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}denotation(i){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,i):null}static startDimension(i){i.startObject(2)}static addValue(i,r){i.addFieldOffset(0,r,0)}static addDenotation(i,r){i.addFieldOffset(1,r,0)}static endDimension(i){return i.endObject()}static createDimension(i,r,u){return d.startDimension(i),d.addValue(i,r),d.addDenotation(i,u),d.endDimension(i)}}m.Dimension=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsDimensionValue(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsDimensionValue(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}dimType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt8(this.bb_pos+i):l.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}dimParam(i){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,i):null}static startDimensionValue(i){i.startObject(3)}static addDimType(i,r){i.addFieldInt8(0,r,l.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(i,r){i.addFieldInt64(1,r,i.createLong(0,0))}static addDimParam(i,r){i.addFieldOffset(2,r,0)}static endDimensionValue(i){return i.endObject()}static createDimensionValue(i,r,u,f){return d.startDimensionValue(i),d.addDimType(i,r),d.addDimValue(i,u),d.addDimParam(i,f),d.endDimensionValue(i)}}m.DimensionValue=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsTensorTypeAndShape(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTensorTypeAndShape(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}elemType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt32(this.bb_pos+i):l.experimental.fbs.TensorDataType.UNDEFINED}shape(i){let r=this.bb.__offset(this.bb_pos,6);return r?(i||new l.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startTensorTypeAndShape(i){i.startObject(2)}static addElemType(i,r){i.addFieldInt32(0,r,l.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(i,r){i.addFieldOffset(1,r,0)}static endTensorTypeAndShape(i){return i.endObject()}static createTensorTypeAndShape(i,r,u){return d.startTensorTypeAndShape(i),d.addElemType(i,r),d.addShape(i,u),d.endTensorTypeAndShape(i)}}m.TensorTypeAndShape=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsMapType(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsMapType(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}keyType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt32(this.bb_pos+i):l.experimental.fbs.TensorDataType.UNDEFINED}valueType(i){let r=this.bb.__offset(this.bb_pos,6);return r?(i||new l.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startMapType(i){i.startObject(2)}static addKeyType(i,r){i.addFieldInt32(0,r,l.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(i,r){i.addFieldOffset(1,r,0)}static endMapType(i){return i.endObject()}static createMapType(i,r,u){return d.startMapType(i),d.addKeyType(i,r),d.addValueType(i,u),d.endMapType(i)}}m.MapType=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsSequenceType(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSequenceType(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}elemType(i){let r=this.bb.__offset(this.bb_pos,4);return r?(i||new l.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startSequenceType(i){i.startObject(1)}static addElemType(i,r){i.addFieldOffset(0,r,0)}static endSequenceType(i){return i.endObject()}static createSequenceType(i,r){return d.startSequenceType(i),d.addElemType(i,r),d.endSequenceType(i)}}m.SequenceType=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(_.fbs||(_.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(m,d){return this.bb_pos=m,this.bb=d,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(m,d,h,i){return m.prep(4,12),m.writeInt32(i),m.writeInt32(h),m.writeInt32(d),m.offset()}}})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsNodeEdge(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsNodeEdge(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}nodeIndex(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readUint32(this.bb_pos+i):0}inputEdges(i,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new l.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+u)+12*i,this.bb):null}inputEdgesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}outputEdges(i,r){let u=this.bb.__offset(this.bb_pos,8);return u?(r||new l.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+u)+12*i,this.bb):null}outputEdgesLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}static startNodeEdge(i){i.startObject(3)}static addNodeIndex(i,r){i.addFieldInt32(0,r,0)}static addInputEdges(i,r){i.addFieldOffset(1,r,0)}static startInputEdgesVector(i,r){i.startVector(12,r,4)}static addOutputEdges(i,r){i.addFieldOffset(2,r,0)}static startOutputEdgesVector(i,r){i.startVector(12,r,4)}static endNodeEdge(i){return i.endObject()}static createNodeEdge(i,r,u,f){return d.startNodeEdge(i),d.addNodeIndex(i,r),d.addInputEdges(i,u),d.addOutputEdges(i,f),d.endNodeEdge(i)}}m.NodeEdge=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsNode(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsNode(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}name(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}docString(i){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,i):null}domain(i){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,i):null}sinceVersion(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readInt32(this.bb_pos+i):0}index(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.readUint32(this.bb_pos+i):0}opType(i){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb_pos+r,i):null}type(){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.readInt32(this.bb_pos+i):l.experimental.fbs.NodeType.Primitive}executionProviderType(i){let r=this.bb.__offset(this.bb_pos,18);return r?this.bb.__string(this.bb_pos+r,i):null}inputs(i,r){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}inputsLength(){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__vector_len(this.bb_pos+i):0}outputs(i,r){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}outputsLength(){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__vector_len(this.bb_pos+i):0}attributes(i,r){let u=this.bb.__offset(this.bb_pos,24);return u?(r||new l.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}attributesLength(){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__vector_len(this.bb_pos+i):0}inputArgCounts(i){let r=this.bb.__offset(this.bb_pos,26);return r?this.bb.readInt32(this.bb.__vector(this.bb_pos+r)+4*i):0}inputArgCountsLength(){let i=this.bb.__offset(this.bb_pos,26);return i?this.bb.__vector_len(this.bb_pos+i):0}inputArgCountsArray(){let i=this.bb.__offset(this.bb_pos,26);return i?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}implicitInputs(i,r){let u=this.bb.__offset(this.bb_pos,28);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}implicitInputsLength(){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__vector_len(this.bb_pos+i):0}static startNode(i){i.startObject(13)}static addName(i,r){i.addFieldOffset(0,r,0)}static addDocString(i,r){i.addFieldOffset(1,r,0)}static addDomain(i,r){i.addFieldOffset(2,r,0)}static addSinceVersion(i,r){i.addFieldInt32(3,r,0)}static addIndex(i,r){i.addFieldInt32(4,r,0)}static addOpType(i,r){i.addFieldOffset(5,r,0)}static addType(i,r){i.addFieldInt32(6,r,l.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(i,r){i.addFieldOffset(7,r,0)}static addInputs(i,r){i.addFieldOffset(8,r,0)}static createInputsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startInputsVector(i,r){i.startVector(4,r,4)}static addOutputs(i,r){i.addFieldOffset(9,r,0)}static createOutputsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startOutputsVector(i,r){i.startVector(4,r,4)}static addAttributes(i,r){i.addFieldOffset(10,r,0)}static createAttributesVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startAttributesVector(i,r){i.startVector(4,r,4)}static addInputArgCounts(i,r){i.addFieldOffset(11,r,0)}static createInputArgCountsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addInt32(r[u]);return i.endVector()}static startInputArgCountsVector(i,r){i.startVector(4,r,4)}static addImplicitInputs(i,r){i.addFieldOffset(12,r,0)}static createImplicitInputsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startImplicitInputsVector(i,r){i.startVector(4,r,4)}static endNode(i){return i.endObject()}static createNode(i,r,u,f,g,w,y,x,S,T,E,A,C,I){return d.startNode(i),d.addName(i,r),d.addDocString(i,u),d.addDomain(i,f),d.addSinceVersion(i,g),d.addIndex(i,w),d.addOpType(i,y),d.addType(i,x),d.addExecutionProviderType(i,S),d.addInputs(i,T),d.addOutputs(i,E),d.addAttributes(i,A),d.addInputArgCounts(i,C),d.addImplicitInputs(i,I),d.endNode(i)}}m.Node=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsValueInfo(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsValueInfo(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}name(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}docString(i){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,i):null}type(i){let r=this.bb.__offset(this.bb_pos,8);return r?(i||new l.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startValueInfo(i){i.startObject(3)}static addName(i,r){i.addFieldOffset(0,r,0)}static addDocString(i,r){i.addFieldOffset(1,r,0)}static addType(i,r){i.addFieldOffset(2,r,0)}static endValueInfo(i){return i.endObject()}static createValueInfo(i,r,u,f){return d.startValueInfo(i),d.addName(i,r),d.addDocString(i,u),d.addType(i,f),d.endValueInfo(i)}}m.ValueInfo=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsTypeInfo(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTypeInfo(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}denotation(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}valueType(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readUint8(this.bb_pos+i):l.experimental.fbs.TypeInfoValue.NONE}value(i){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__union(i,this.bb_pos+r):null}static startTypeInfo(i){i.startObject(3)}static addDenotation(i,r){i.addFieldOffset(0,r,0)}static addValueType(i,r){i.addFieldInt8(1,r,l.experimental.fbs.TypeInfoValue.NONE)}static addValue(i,r){i.addFieldOffset(2,r,0)}static endTypeInfo(i){return i.endObject()}static createTypeInfo(i,r,u,f){return d.startTypeInfo(i),d.addDenotation(i,r),d.addValueType(i,u),d.addValue(i,f),d.endTypeInfo(i)}}m.TypeInfo=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsOperatorSetId(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsOperatorSetId(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}domain(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}version(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}static startOperatorSetId(i){i.startObject(2)}static addDomain(i,r){i.addFieldOffset(0,r,0)}static addVersion(i,r){i.addFieldInt64(1,r,i.createLong(0,0))}static endOperatorSetId(i){return i.endObject()}static createOperatorSetId(i,r,u){return d.startOperatorSetId(i),d.addDomain(i,r),d.addVersion(i,u),d.endOperatorSetId(i)}}m.OperatorSetId=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsTensor(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTensor(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}name(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}docString(i){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,i):null}dims(i){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*i):this.bb.createLong(0,0)}dimsLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}dataType(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readInt32(this.bb_pos+i):l.experimental.fbs.TensorDataType.UNDEFINED}rawData(i){let r=this.bb.__offset(this.bb_pos,12);return r?this.bb.readUint8(this.bb.__vector(this.bb_pos+r)+i):0}rawDataLength(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.__vector_len(this.bb_pos+i):0}rawDataArray(){let i=this.bb.__offset(this.bb_pos,12);return i?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}stringData(i,r){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}stringDataLength(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__vector_len(this.bb_pos+i):0}static startTensor(i){i.startObject(6)}static addName(i,r){i.addFieldOffset(0,r,0)}static addDocString(i,r){i.addFieldOffset(1,r,0)}static addDims(i,r){i.addFieldOffset(2,r,0)}static createDimsVector(i,r){i.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)i.addInt64(r[u]);return i.endVector()}static startDimsVector(i,r){i.startVector(8,r,8)}static addDataType(i,r){i.addFieldInt32(3,r,l.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(i,r){i.addFieldOffset(4,r,0)}static createRawDataVector(i,r){i.startVector(1,r.length,1);for(let u=r.length-1;u>=0;u--)i.addInt8(r[u]);return i.endVector()}static startRawDataVector(i,r){i.startVector(1,r,1)}static addStringData(i,r){i.addFieldOffset(5,r,0)}static createStringDataVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startStringDataVector(i,r){i.startVector(4,r,4)}static endTensor(i){return i.endObject()}static createTensor(i,r,u,f,g,w,y){return d.startTensor(i),d.addName(i,r),d.addDocString(i,u),d.addDims(i,f),d.addDataType(i,g),d.addRawData(i,w),d.addStringData(i,y),d.endTensor(i)}}m.Tensor=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsSparseTensor(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSparseTensor(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}values(i){let r=this.bb.__offset(this.bb_pos,4);return r?(i||new l.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}indices(i){let r=this.bb.__offset(this.bb_pos,6);return r?(i||new l.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}dims(i){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*i):this.bb.createLong(0,0)}dimsLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}static startSparseTensor(i){i.startObject(3)}static addValues(i,r){i.addFieldOffset(0,r,0)}static addIndices(i,r){i.addFieldOffset(1,r,0)}static addDims(i,r){i.addFieldOffset(2,r,0)}static createDimsVector(i,r){i.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)i.addInt64(r[u]);return i.endVector()}static startDimsVector(i,r){i.startVector(8,r,8)}static endSparseTensor(i){return i.endObject()}static createSparseTensor(i,r,u,f){return d.startSparseTensor(i),d.addValues(i,r),d.addIndices(i,u),d.addDims(i,f),d.endSparseTensor(i)}}m.SparseTensor=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsAttribute(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsAttribute(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}name(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}docString(i){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,i):null}type(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.readInt32(this.bb_pos+i):l.experimental.fbs.AttributeType.UNDEFINED}f(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readFloat32(this.bb_pos+i):0}i(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}s(i){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb_pos+r,i):null}t(i){let r=this.bb.__offset(this.bb_pos,16);return r?(i||new l.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}g(i){let r=this.bb.__offset(this.bb_pos,18);return r?(i||new l.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}floats(i){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.readFloat32(this.bb.__vector(this.bb_pos+r)+4*i):0}floatsLength(){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__vector_len(this.bb_pos+i):0}floatsArray(){let i=this.bb.__offset(this.bb_pos,20);return i?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}ints(i){let r=this.bb.__offset(this.bb_pos,22);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*i):this.bb.createLong(0,0)}intsLength(){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__vector_len(this.bb_pos+i):0}strings(i,r){let u=this.bb.__offset(this.bb_pos,24);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}stringsLength(){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__vector_len(this.bb_pos+i):0}tensors(i,r){let u=this.bb.__offset(this.bb_pos,26);return u?(r||new l.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}tensorsLength(){let i=this.bb.__offset(this.bb_pos,26);return i?this.bb.__vector_len(this.bb_pos+i):0}graphs(i,r){let u=this.bb.__offset(this.bb_pos,28);return u?(r||new l.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}graphsLength(){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__vector_len(this.bb_pos+i):0}static startAttribute(i){i.startObject(13)}static addName(i,r){i.addFieldOffset(0,r,0)}static addDocString(i,r){i.addFieldOffset(1,r,0)}static addType(i,r){i.addFieldInt32(2,r,l.experimental.fbs.AttributeType.UNDEFINED)}static addF(i,r){i.addFieldFloat32(3,r,0)}static addI(i,r){i.addFieldInt64(4,r,i.createLong(0,0))}static addS(i,r){i.addFieldOffset(5,r,0)}static addT(i,r){i.addFieldOffset(6,r,0)}static addG(i,r){i.addFieldOffset(7,r,0)}static addFloats(i,r){i.addFieldOffset(8,r,0)}static createFloatsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addFloat32(r[u]);return i.endVector()}static startFloatsVector(i,r){i.startVector(4,r,4)}static addInts(i,r){i.addFieldOffset(9,r,0)}static createIntsVector(i,r){i.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)i.addInt64(r[u]);return i.endVector()}static startIntsVector(i,r){i.startVector(8,r,8)}static addStrings(i,r){i.addFieldOffset(10,r,0)}static createStringsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startStringsVector(i,r){i.startVector(4,r,4)}static addTensors(i,r){i.addFieldOffset(11,r,0)}static createTensorsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startTensorsVector(i,r){i.startVector(4,r,4)}static addGraphs(i,r){i.addFieldOffset(12,r,0)}static createGraphsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startGraphsVector(i,r){i.startVector(4,r,4)}static endAttribute(i){return i.endObject()}static createAttribute(i,r,u,f,g,w,y,x,S,T,E,A,C,I){return d.startAttribute(i),d.addName(i,r),d.addDocString(i,u),d.addType(i,f),d.addF(i,g),d.addI(i,w),d.addS(i,y),d.addT(i,x),d.addG(i,S),d.addFloats(i,T),d.addInts(i,E),d.addStrings(i,A),d.addTensors(i,C),d.addGraphs(i,I),d.endAttribute(i)}}m.Attribute=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsGraph(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsGraph(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}initializers(i,r){let u=this.bb.__offset(this.bb_pos,4);return u?(r||new l.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}initializersLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}nodeArgs(i,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new l.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}nodeArgsLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}nodes(i,r){let u=this.bb.__offset(this.bb_pos,8);return u?(r||new l.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}nodesLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}maxNodeIndex(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readUint32(this.bb_pos+i):0}nodeEdges(i,r){let u=this.bb.__offset(this.bb_pos,12);return u?(r||new l.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}nodeEdgesLength(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.__vector_len(this.bb_pos+i):0}inputs(i,r){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}inputsLength(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__vector_len(this.bb_pos+i):0}outputs(i,r){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*i,r):null}outputsLength(){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.__vector_len(this.bb_pos+i):0}sparseInitializers(i,r){let u=this.bb.__offset(this.bb_pos,18);return u?(r||new l.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}sparseInitializersLength(){let i=this.bb.__offset(this.bb_pos,18);return i?this.bb.__vector_len(this.bb_pos+i):0}static startGraph(i){i.startObject(8)}static addInitializers(i,r){i.addFieldOffset(0,r,0)}static createInitializersVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startInitializersVector(i,r){i.startVector(4,r,4)}static addNodeArgs(i,r){i.addFieldOffset(1,r,0)}static createNodeArgsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startNodeArgsVector(i,r){i.startVector(4,r,4)}static addNodes(i,r){i.addFieldOffset(2,r,0)}static createNodesVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startNodesVector(i,r){i.startVector(4,r,4)}static addMaxNodeIndex(i,r){i.addFieldInt32(3,r,0)}static addNodeEdges(i,r){i.addFieldOffset(4,r,0)}static createNodeEdgesVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startNodeEdgesVector(i,r){i.startVector(4,r,4)}static addInputs(i,r){i.addFieldOffset(5,r,0)}static createInputsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startInputsVector(i,r){i.startVector(4,r,4)}static addOutputs(i,r){i.addFieldOffset(6,r,0)}static createOutputsVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startOutputsVector(i,r){i.startVector(4,r,4)}static addSparseInitializers(i,r){i.addFieldOffset(7,r,0)}static createSparseInitializersVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startSparseInitializersVector(i,r){i.startVector(4,r,4)}static endGraph(i){return i.endObject()}static createGraph(i,r,u,f,g,w,y,x,S){return d.startGraph(i),d.addInitializers(i,r),d.addNodeArgs(i,u),d.addNodes(i,f),d.addMaxNodeIndex(i,g),d.addNodeEdges(i,w),d.addInputs(i,y),d.addOutputs(i,x),d.addSparseInitializers(i,S),d.endGraph(i)}}m.Graph=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsModel(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsModel(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}irVersion(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}opsetImport(i,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new l.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}opsetImportLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}producerName(i){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,i):null}producerVersion(i){let r=this.bb.__offset(this.bb_pos,10);return r?this.bb.__string(this.bb_pos+r,i):null}domain(i){let r=this.bb.__offset(this.bb_pos,12);return r?this.bb.__string(this.bb_pos+r,i):null}modelVersion(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}docString(i){let r=this.bb.__offset(this.bb_pos,16);return r?this.bb.__string(this.bb_pos+r,i):null}graph(i){let r=this.bb.__offset(this.bb_pos,18);return r?(i||new l.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}graphDocString(i){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.__string(this.bb_pos+r,i):null}static startModel(i){i.startObject(9)}static addIrVersion(i,r){i.addFieldInt64(0,r,i.createLong(0,0))}static addOpsetImport(i,r){i.addFieldOffset(1,r,0)}static createOpsetImportVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startOpsetImportVector(i,r){i.startVector(4,r,4)}static addProducerName(i,r){i.addFieldOffset(2,r,0)}static addProducerVersion(i,r){i.addFieldOffset(3,r,0)}static addDomain(i,r){i.addFieldOffset(4,r,0)}static addModelVersion(i,r){i.addFieldInt64(5,r,i.createLong(0,0))}static addDocString(i,r){i.addFieldOffset(6,r,0)}static addGraph(i,r){i.addFieldOffset(7,r,0)}static addGraphDocString(i,r){i.addFieldOffset(8,r,0)}static endModel(i){return i.endObject()}static createModel(i,r,u,f,g,w,y,x,S,T){return d.startModel(i),d.addIrVersion(i,r),d.addOpsetImport(i,u),d.addProducerName(i,f),d.addProducerVersion(i,g),d.addDomain(i,w),d.addModelVersion(i,y),d.addDocString(i,x),d.addGraph(i,S),d.addGraphDocString(i,T),d.endModel(i)}}m.Model=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsKernelCreateInfos(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsKernelCreateInfos(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}nodeIndices(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.readUint32(this.bb.__vector(this.bb_pos+r)+4*i):0}nodeIndicesLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}nodeIndicesArray(){let i=this.bb.__offset(this.bb_pos,4);return i?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}kernelDefHashes(i){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.readUint64(this.bb.__vector(this.bb_pos+r)+8*i):this.bb.createLong(0,0)}kernelDefHashesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}static startKernelCreateInfos(i){i.startObject(2)}static addNodeIndices(i,r){i.addFieldOffset(0,r,0)}static createNodeIndicesVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addInt32(r[u]);return i.endVector()}static startNodeIndicesVector(i,r){i.startVector(4,r,4)}static addKernelDefHashes(i,r){i.addFieldOffset(1,r,0)}static createKernelDefHashesVector(i,r){i.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)i.addInt64(r[u]);return i.endVector()}static startKernelDefHashesVector(i,r){i.startVector(8,r,8)}static endKernelCreateInfos(i){return i.endObject()}static createKernelCreateInfos(i,r,u){return d.startKernelCreateInfos(i),d.addNodeIndices(i,r),d.addKernelDefHashes(i,u),d.endKernelCreateInfos(i)}}m.KernelCreateInfos=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsSubGraphSessionState(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSubGraphSessionState(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}graphId(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}sessionState(i){let r=this.bb.__offset(this.bb_pos,6);return r?(i||new l.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startSubGraphSessionState(i){i.startObject(2)}static addGraphId(i,r){i.addFieldOffset(0,r,0)}static addSessionState(i,r){i.addFieldOffset(1,r,0)}static endSubGraphSessionState(i){let r=i.endObject();return i.requiredField(r,4),r}static createSubGraphSessionState(i,r,u){return d.startSubGraphSessionState(i),d.addGraphId(i,r),d.addSessionState(i,u),d.endSubGraphSessionState(i)}}m.SubGraphSessionState=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsSessionState(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSessionState(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}kernels(i){let r=this.bb.__offset(this.bb_pos,4);return r?(i||new l.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}subGraphSessionStates(i,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new l.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*i),this.bb):null}subGraphSessionStatesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}static startSessionState(i){i.startObject(2)}static addKernels(i,r){i.addFieldOffset(0,r,0)}static addSubGraphSessionStates(i,r){i.addFieldOffset(1,r,0)}static createSubGraphSessionStatesVector(i,r){i.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)i.addOffset(r[u]);return i.endVector()}static startSubGraphSessionStatesVector(i,r){i.startVector(4,r,4)}static endSessionState(i){return i.endObject()}static createSessionState(i,r,u){return d.startSessionState(i),d.addKernels(i,r),d.addSubGraphSessionStates(i,u),d.endSessionState(i)}}m.SessionState=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={})),(function(l){(function(_){(function(m){class d{constructor(){this.bb=null,this.bb_pos=0}__init(i,r){return this.bb_pos=i,this.bb=r,this}static getRootAsInferenceSession(i,r){return(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsInferenceSession(i,r){return i.setPosition(i.position()+s.flatbuffers.SIZE_PREFIX_LENGTH),(r||new d).__init(i.readInt32(i.position())+i.position(),i)}static bufferHasIdentifier(i){return i.__has_identifier("ORTM")}ortVersion(i){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,i):null}model(i){let r=this.bb.__offset(this.bb_pos,6);return r?(i||new l.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}sessionState(i){let r=this.bb.__offset(this.bb_pos,8);return r?(i||new l.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startInferenceSession(i){i.startObject(3)}static addOrtVersion(i,r){i.addFieldOffset(0,r,0)}static addModel(i,r){i.addFieldOffset(1,r,0)}static addSessionState(i,r){i.addFieldOffset(2,r,0)}static endInferenceSession(i){return i.endObject()}static finishInferenceSessionBuffer(i,r){i.finish(r,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(i,r){i.finish(r,"ORTM",!0)}static createInferenceSession(i,r,u,f){return d.startInferenceSession(i),d.addOrtVersion(i,r),d.addModel(i,u),d.addSessionState(i,f),d.endInferenceSession(i)}}m.InferenceSession=d})(_.fbs||(_.fbs={}))})(l.experimental||(l.experimental={}))})(e.onnxruntime||(e.onnxruntime={}))},7448:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxjsSessionHandler=void 0;const s=t(1670),a=t(9162);e.OnnxjsSessionHandler=class{constructor(c){this.session=c,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(c,l,_){const m=new Map;for(const i in c)if(Object.hasOwnProperty.call(c,i)){const r=c[i];m.set(i,new a.Tensor(r.dims,r.type,void 0,void 0,r.data))}const d=await this.session.run(m),h={};return d.forEach(((i,r)=>{h[r]=new s.Tensor(i.type,i.data,i.dims)})),h}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Session=void 0;const s=t(7067),a=t(1296),c=t(7091),l=t(1036),_=t(6231),m=t(2644);e.Session=class{constructor(d={}){this._initialized=!1,this.backendHint=d.backendHint,this.profiler=_.Profiler.create(d.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(d,h,i){await this.profiler.event("session","Session.loadModel",(async()=>{const r=await(0,c.resolveBackend)(this.backendHint);if(this.sessionHandler=r.createSessionHandler(this.context),this._model=new m.Model,typeof d=="string"){const u=d.endsWith(".ort");if(typeof fetch>"u"){const f=await(0,a.promisify)(s.readFile)(d);this.initialize(f,u)}else{const f=await fetch(d),g=await f.arrayBuffer();this.initialize(new Uint8Array(g),u)}}else if(ArrayBuffer.isView(d))this.initialize(d);else{const u=new Uint8Array(d,h||0,i||d.byteLength);this.initialize(u)}}))}initialize(d,h){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(d,i,h),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new l.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(d){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const h=this.normalizeAndValidateInputs(d),i=await this._executionPlan.execute(this.sessionHandler,h);return this.createOutput(i)}))}normalizeAndValidateInputs(d){const h=this._model.graph.getInputNames();if(Array.isArray(d)){if(d.length!==h.length)throw new Error(`incorrect input array length: expected ${h.length} but got ${d.length}`)}else{if(d.size!==h.length)throw new Error(`incorrect input map size: expected ${h.length} but got ${d.size}`);const i=new Array(d.size);let r=0;for(let u=0;u<h.length;++u){const f=d.get(h[u]);if(!f)throw new Error(`missing input tensor for: '${name}'`);i[r++]=f}d=i}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,d,!1);else{const i=this._model.graph.getInputIndices(),r=this._model.graph.getValues(),u=new Array(i.length);for(let f=0;f<i.length;++f){const g=r[i[f]];u[f]=g.type.shape.dims,this.context.graphInputTypes.push(g.type.tensorType),this.context.graphInputDims.push(d[f].dims)}this.validateInputTensorDims(u,d,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,d),d}validateInputTensorTypes(d,h){for(let i=0;i<h.length;i++){const r=d[i],u=h[i].type;if(r!==u)throw new Error(`input tensor[${i}] check failed: expected type '${r}' but got ${u}`)}}validateInputTensorDims(d,h,i){for(let r=0;r<h.length;r++){const u=d[r],f=h[r].dims;if(!this.compareTensorDims(u,f,i))throw new Error(`input tensor[${r}] check failed: expected shape '[${u.join(",")}]' but got [${f.join(",")}]`)}}compareTensorDims(d,h,i){if(d.length!==h.length)return!1;for(let r=0;r<d.length;++r)if(d[r]!==h[r]&&(!i||d[r]!==0))return!1;return!0}createOutput(d){const h=this._model.graph.getOutputNames();if(d.length!==h.length)throw new Error("expected number of outputs do not match number of generated outputs");const i=new Map;for(let r=0;r<h.length;++r)i.set(h[r],d[r]);return i}initializeOps(d){const h=d.getNodes();this._ops=new Array(h.length);for(let i=0;i<h.length;i++)this._ops[i]=this.sessionHandler.resolve(h[i],this._model.opsets,d)}}},9162:function(n,e,t){var s=this&&this.__importDefault||function(g){return g&&g.__esModule?g:{default:g}};Object.defineProperty(e,"__esModule",{value:!0}),e.Tensor=void 0;const a=t(3442),c=s(t(3720)),l=t(1446),_=t(9395),m=t(2517);var d=_.onnxruntime.experimental.fbs;class h{get data(){if(this.cache===void 0){const w=this.dataProvider(this.dataId);if(w.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=w}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(w){return this.data[m.ShapeUtil.indicesToOffset(w,this.strides)]}set(w,y){this.data[m.ShapeUtil.indicesToOffset(w,this.strides)]=y}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=m.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(w,y,x,S,T,E=a.Guid.create()){this.dims=w,this.type=y,this.dataProvider=x,this.asyncDataProvider=S,this.cache=T,this.dataId=E,this.size=m.ShapeUtil.validateDimsAndCalcSize(w);const A=this.size,C=x===void 0&&S===void 0&&T===void 0;if(T!==void 0&&T.length!==A)throw new RangeError("Input dims doesn't match data length.");if(y==="string"){if(!(T===void 0||Array.isArray(T)&&T.every((I=>typeof I=="string"))))throw new TypeError("cache should be a string array");C&&(this.cache=new Array(A))}else{if(T!==void 0){const I=r(y);if(!(T instanceof I))throw new TypeError(`cache should be type ${I.name}`)}if(C){const I=new ArrayBuffer(A*(function(D){switch(D){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${D}`)}})(y));this.cache=(function(D,R){return new(r(R))(D)})(I,y)}}}static fromProto(w){if(!w)throw new Error("cannot construct Value from an empty tensor");const y=m.ProtoUtil.tensorDataTypeFromProto(w.dataType),x=m.ProtoUtil.tensorDimsFromProto(w.dims),S=new h(x,y);if(y==="string")w.stringData.forEach(((T,E)=>{S.data[E]=(0,m.decodeUtf8String)(T)}));else if(w.rawData&&typeof w.rawData.byteLength=="number"&&w.rawData.byteLength>0){const T=S.data,E=new DataView(w.rawData.buffer,w.rawData.byteOffset,w.rawData.byteLength),A=i(w.dataType),C=w.rawData.byteLength/A;if(w.rawData.byteLength%A!=0)throw new Error("invalid buffer length");if(T.length!==C)throw new Error("buffer length mismatch");for(let I=0;I<C;I++){const D=f(E,w.dataType,I*A);T[I]=D}}else{let T;switch(w.dataType){case l.onnx.TensorProto.DataType.FLOAT:T=w.floatData;break;case l.onnx.TensorProto.DataType.INT32:case l.onnx.TensorProto.DataType.INT16:case l.onnx.TensorProto.DataType.UINT16:case l.onnx.TensorProto.DataType.INT8:case l.onnx.TensorProto.DataType.UINT8:case l.onnx.TensorProto.DataType.BOOL:T=w.int32Data;break;case l.onnx.TensorProto.DataType.INT64:T=w.int64Data;break;case l.onnx.TensorProto.DataType.DOUBLE:T=w.doubleData;break;case l.onnx.TensorProto.DataType.UINT32:case l.onnx.TensorProto.DataType.UINT64:T=w.uint64Data;break;default:throw new Error("unspecific error")}if(T==null)throw new Error("failed to populate data from a tensorproto value");const E=S.data;if(E.length!==T.length)throw new Error("array length mismatch");for(let A=0;A<T.length;A++){const C=T[A];c.default.isLong(C)?E[A]=u(C,w.dataType):E[A]=C}}return S}static fromData(w,y,x){return new h(y,x,void 0,void 0,w)}static fromOrtTensor(w){if(!w)throw new Error("cannot construct Value from an empty tensor");const y=m.ProtoUtil.tensorDimsFromORTFormat(w),x=m.ProtoUtil.tensorDataTypeFromProto(w.dataType()),S=new h(y,x);if(x==="string")for(let T=0;T<w.stringDataLength();T++)S.data[T]=w.stringData(T);else if(w.rawDataArray()&&typeof w.rawDataLength()=="number"&&w.rawDataLength()>0){const T=S.data,E=new DataView(w.rawDataArray().buffer,w.rawDataArray().byteOffset,w.rawDataLength()),A=i(w.dataType()),C=w.rawDataLength()/A;if(w.rawDataLength()%A!=0)throw new Error("invalid buffer length");if(T.length!==C)throw new Error("buffer length mismatch");for(let I=0;I<C;I++){const D=f(E,w.dataType(),I*A);T[I]=D}}return S}}function i(g){switch(g){case l.onnx.TensorProto.DataType.UINT8:case l.onnx.TensorProto.DataType.INT8:case l.onnx.TensorProto.DataType.BOOL:return 1;case l.onnx.TensorProto.DataType.UINT16:case l.onnx.TensorProto.DataType.INT16:return 2;case l.onnx.TensorProto.DataType.FLOAT:case l.onnx.TensorProto.DataType.INT32:case l.onnx.TensorProto.DataType.UINT32:return 4;case l.onnx.TensorProto.DataType.INT64:case l.onnx.TensorProto.DataType.DOUBLE:case l.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${l.onnx.TensorProto.DataType[g]}`)}}function r(g){switch(g){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function u(g,w){if(w===l.onnx.TensorProto.DataType.INT64||w===d.TensorDataType.INT64){if(g.greaterThanOrEqual(2147483648)||g.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(w!==l.onnx.TensorProto.DataType.UINT32&&w!==d.TensorDataType.UINT32&&w!==l.onnx.TensorProto.DataType.UINT64&&w!==d.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${l.onnx.TensorProto.DataType[w]}`);if(g.greaterThanOrEqual(4294967296)||g.lessThan(0))throw new TypeError("uint64 is not supported")}return g.toNumber()}function f(g,w,y){switch(w){case l.onnx.TensorProto.DataType.BOOL:case l.onnx.TensorProto.DataType.UINT8:return g.getUint8(y);case l.onnx.TensorProto.DataType.INT8:return g.getInt8(y);case l.onnx.TensorProto.DataType.UINT16:return g.getUint16(y,!0);case l.onnx.TensorProto.DataType.INT16:return g.getInt16(y,!0);case l.onnx.TensorProto.DataType.FLOAT:return g.getFloat32(y,!0);case l.onnx.TensorProto.DataType.INT32:return g.getInt32(y,!0);case l.onnx.TensorProto.DataType.UINT32:return g.getUint32(y,!0);case l.onnx.TensorProto.DataType.INT64:return u(c.default.fromBits(g.getUint32(y,!0),g.getUint32(y+4,!0),!1),w);case l.onnx.TensorProto.DataType.DOUBLE:return g.getFloat64(y,!0);case l.onnx.TensorProto.DataType.UINT64:return u(c.default.fromBits(g.getUint32(y,!0),g.getUint32(y+4,!0),!0),w);default:throw new Error(`cannot read from DataView for type ${l.onnx.TensorProto.DataType[w]}`)}}e.Tensor=h},2517:function(n,e,t){var s=this&&this.__importDefault||function(w){return w&&w.__esModule?w:{default:w}};Object.defineProperty(e,"__esModule",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const a=t(5686),c=s(t(3720)),l=t(1446),_=t(9162);e.checkInputsShape=function(w,...y){if(!w||w.length!==y.length)return!1;for(let x=0;x<w.length;x++)if(!w[x].dims||w[x].dims.length!==y[x])return!1;return!0},e.assert=function(w,y){if(!w)throw new Error(typeof y=="string"?y:y())},e.ArrayUtil=class{static arraysEqual(w,y){if(w.length!==y.length)return!1;for(let x=0;x<w.length;x++)if(w[x]!==y[x])return!1;return!0}};class m{static preprocessInputShapes(y,x){return[y.length===1?[1,y[0]]:y,x.length===1?[x[0],1]:x]}static postprocessOutputShape(y,x,S){x===1&&y.splice(y.length-2,1),S===1&&y.pop()}static calcMatMulShape(y,x){return y[1]!==x[0]?void 0:[y[0],x[1]]}}e.MatMulUtil=m;class d{static calcShape(y,x,S=!1){const T=y.length,E=x.length;if(T===0)return x;if(E===0)return y;const A=Math.max(y.length,x.length),C=new Array(A);if(S){if(T<2||E<2)return;const I=m.calcMatMulShape([y[T-2],y[T-1]],[x[E-2],x[E-1]]);if(I===void 0)return;[C[A-2],C[A-1]]=I}for(let I=S?3:1;I<=A;I++){const D=T-I<0?1:y[T-I],R=E-I<0?1:x[E-I];if(D!==R&&D>1&&R>1)return;C[A-I]=Math.max(D,R)}return C}static index(y,x){const S=new Array(x.length);return d.fillIndex(y,x,S),S}static fillIndex(y,x,S){const T=y.length-x.length;for(let E=0;E<x.length;E++)S[E]=y[T+E]%x[E]}static calc(y,x,S,T,E){const A=d.calcShape(y.dims,x.dims);if(A){if(T&&!r.areEqual(A,y.dims))return;const C=r.size(A),I=T?y:new _.Tensor(A,E||y.type);if(A.length===0)I.set([],S(y.get([]),x.get([])));else{const D=new Array(A.length),R=new Array(y.dims.length),Y=new Array(x.dims.length);let re,G=0,te=0,q=!1,z=!1;y.dims.length===0&&(G=y.get([]),q=!0),x.dims.length===0&&(te=x.get([]),z=!0);for(let H=0;H<C;H++){re=H;for(let he=A.length-1;he>=0;he--)D[he]=re%A[he],re=Math.floor(re/A[he]);q||(d.fillIndex(D,y.dims,R),G=y.get(R)),z||(d.fillIndex(D,x.dims,Y),te=x.get(Y)),I.set(D,S(G,te))}}return I}}static isValidBroadcast(y,x){const S=y.length,T=x.length;if(S>T)return!1;for(let E=1;E<=S;E++)if(y[S-E]!==1&&y[S-E]!==x[T-E])return!1;return!0}static getBroadcastDims(y,x){const S=y.length,T=[];for(let E=0;E<S;E++){const A=S-1-E,C=y[A]||1;(x[x.length-1-E]||1)>1&&C===1&&T.unshift(A)}return T}}e.BroadcastUtil=d,e.arrayCopyHelper=function(w,y,x,S,T){if(S<0||S>=y.length)throw new Error("sourceIndex out of bounds");if(x<0||x>=w.length)throw new Error("targetIndex out of bounds");if(S+T>y.length)throw new Error("source indices to be copied are outside bounds");if(x+T>w.length)throw new Error("target array is too small to hold result");for(let E=0;E<T;E++)w[x+E]=y[S+E]},e.GemmUtil=class{static getShapeOfGemmResult(w,y,x,S,T){if(w.length!==2||x.length!==2)throw new Error("shape need to be of size 2");let E,A,C;y?(E=w[1],A=w[0]):(E=w[0],A=w[1]);let I=-1;if(S?(C=x[0],I=1):(C=x[1],I=0),x[I]!==A)throw new Error("dimension mismatch");if(E<=0||C<=0||A<=0)throw new Error("invalid shape specified");if(T&&!d.isValidBroadcast(T,[E,C]))throw new Error("gemm: invalid bias shape for broadcast");return[E,C,A]}};class h{static tensorDataTypeFromProto(y){switch(y){case l.onnx.TensorProto.DataType.INT8:return"int8";case l.onnx.TensorProto.DataType.UINT8:return"uint8";case l.onnx.TensorProto.DataType.BOOL:return"bool";case l.onnx.TensorProto.DataType.INT16:return"int16";case l.onnx.TensorProto.DataType.UINT16:return"uint16";case l.onnx.TensorProto.DataType.INT32:return"int32";case l.onnx.TensorProto.DataType.UINT32:return"uint32";case l.onnx.TensorProto.DataType.FLOAT:return"float32";case l.onnx.TensorProto.DataType.DOUBLE:return"float64";case l.onnx.TensorProto.DataType.STRING:return"string";case l.onnx.TensorProto.DataType.INT64:return"int32";case l.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${l.onnx.TensorProto.DataType[y]}`)}}static tensorDataTypeStringToEnum(y){switch(y){case"int8":return l.onnx.TensorProto.DataType.INT8;case"uint8":return l.onnx.TensorProto.DataType.UINT8;case"bool":return l.onnx.TensorProto.DataType.BOOL;case"int16":return l.onnx.TensorProto.DataType.INT16;case"uint16":return l.onnx.TensorProto.DataType.UINT16;case"int32":return l.onnx.TensorProto.DataType.INT32;case"uint32":return l.onnx.TensorProto.DataType.UINT32;case"float32":return l.onnx.TensorProto.DataType.FLOAT;case"float64":return l.onnx.TensorProto.DataType.DOUBLE;case"string":return l.onnx.TensorProto.DataType.STRING;case"int64":return l.onnx.TensorProto.DataType.INT64;case"uint64":return l.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${y}`)}}static tensorDimsFromProto(y){return y.map((x=>c.default.isLong(x)?x.toNumber():x))}static tensorValueTypeFromProto(y){return{tensorType:h.tensorDataTypeFromProto(y.elemType),shape:{dims:h.tensorDimsFromProto(y.shape.dim.map((x=>x.dimValue)))}}}static tensorDimsFromORTFormat(y){const x=[];for(let S=0;S<y.dimsLength();S++)x.push(i.longToNumber(y.dims(S)));return x}static tensorAttributesFromORTFormat(y){const x=[];for(let S=0;S<y.attributesLength();S++)x.push(y.attributes(S));return x}}e.ProtoUtil=h;class i{static longToNumber(y,x){return c.default.isLong(y)?y.toNumber():y instanceof a.flatbuffers.Long?c.default.fromValue({low:y.low,high:y.high,unsigned:x!=null&&x}).toNumber():y}static isLong(y){return c.default.isLong(y)||y instanceof a.flatbuffers.Long}}e.LongUtil=i;class r{static size(y){return r.getSizeFromDimensionRange(y,0,y.length)}static sizeFromDimension(y,x){if(x<0||x>y.length)throw new Error(`invalid dimension of ${x} for sizeFromDimension as Tensor has ${y.length} dimensions.`);return r.getSizeFromDimensionRange(y,x,y.length)}static sizeToDimension(y,x){if(x<0||x>y.length)throw new Error(`invalid dimension of ${x} for sizeToDimension as Tensor has ${y.length} dimensions.`);return r.getSizeFromDimensionRange(y,0,x)}static getSizeFromDimensionRange(y,x,S){let T=1;for(let E=x;E<S;E++){if(y[E]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");T*=y[E]}return T}static computeStrides(y){const x=y.length;if(x===0)return[];if(x===1)return[1];const S=new Array(x);S[x-1]=1,S[x-2]=y[x-1];for(let T=x-3;T>=0;--T)S[T]=S[T+1]*y[T+1];return S}static transpose(y){return y.slice().reverse()}static indicesToOffset(y,x,S){S===void 0&&(S=y.length);let T=0;for(let E=0;E<S;++E)T+=x[E]*y[E];return T}static offsetToIndices(y,x){const S=x.length;if(S===0)return[];if(S===1)return[y*x[0]];const T=new Array(x.length);for(let E=0;E<T.length-1;++E)T[E]=Math.floor(y/x[E]),y-=T[E]*x[E];return T[T.length-1]=y,T}static normalizeAxis(y,x){if(y<-x&&y>=x)throw new Error("unsupported axis for this operation.");return y<0?y+x:y}static normalizeAxes(y,x){return y.map((S=>this.normalizeAxis(S,x)))}static incrementIndex(y,x,S){if(x.length===0||y.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(S===void 0)S=x.length;else if(S<=0||S>x.length)throw new Error("Incorrect axis to increment on");for(let T=S-1;T>=0&&(y[T]++,!(y[T]<x[T]));--T)y[T]=0}static calculateReshapedDims(y,x){if(x.length===0){if(y.length===0||r.size(y)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const S=x.length,T=new Array(S);let E=-1,A=1;for(let I=0;I<S;I++){if(x[I]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(x[I]===-1){if(E!==-1)throw new Error("at most one dimension in shape hints can be -1");E=I}else{if(x[I]===0){if(I>=y.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");T[I]=y[I]}else T[I]=x[I];A*=T[I]}}const C=r.size(y);if(E!==-1){if(C%A!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${y}] Output shape: [${x}]`);T[E]=C/A}else if(A!==C)throw new Error("reshapedDims and originalDims don't have matching sizes");return T}static sortBasedOnPerm(y,x){return x?x.map((S=>y[S])):y.slice().reverse()}static padShape(y,x){const S=y.length;return y.map(((T,E)=>T+x[E]+x[E+S]))}static areEqual(y,x){return y.length===x.length&&y.every(((S,T)=>S===x[T]))}static validateDimsAndCalcSize(y){if(y.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let x=1;for(const S of y){if(!Number.isInteger(S))throw new TypeError(`Invalid shape: ${S} is not an integer`);if(S<0||S>2147483647)throw new TypeError(`Invalid shape: length ${S} is not allowed`);x*=S}return x}static flattenShape(y,x){x<0&&(x+=y.length);const S=y.reduce(((E,A)=>E*A),1),T=y.slice(x).reduce(((E,A)=>E*A),1);return[S/T,T]}static squeezeShape(y,x){const S=new Array;x=r.normalizeAxes(x,y.length);for(let T=0;T<y.length;T++){const E=x.indexOf(T)>=0;if(E&&y[T]!==1)throw new Error("squeeze an axis of size different than 1");(x.length===0&&y[T]>1||x.length>0&&!E)&&S.push(y[T])}return S}static unsqueezeShape(y,x){const S=new Array(y.length+x.length);S.fill(0);for(let E=0;E<x.length;E++){const A=r.normalizeAxis(x[E],S.length);if(A>=S.length)throw new Error("'axes' has an out of range axis");if(S[A]!==0)throw new Error("'axes' has a duplicate axis");S[A]=1}let T=0;for(let E=0;E<S.length;E++)S[E]===0&&(S[E]=y[T++]);if(T!==y.length)throw new Error("the unsqueezed dimension could not be established");return S}}e.ShapeUtil=r,e.MathUtil=class{static sqr(w,y,x,S,T){if(S<0||S>=y.length)throw new Error("sourceIndex out of bounds");if(x<0||x>=w.length)throw new Error("targetIndex out of bounds");if(S+T>y.length)throw new Error("source indices to be copied are outside bounds");if(x+T>w.length)throw new Error("target array is too small to hold result");for(let E=0;E<T;E++)w[x+E]+=Math.pow(y[S+E],2)}static axpy(w,y,x,S,T,E){if(S<0||S>=y.length)throw new Error("sourceIndex out of bounds");if(x<0||x>=w.length)throw new Error("targetIndex out of bounds");if(S+T>y.length)throw new Error("source indices to be copied are outside bounds");if(x+T>w.length)throw new Error("target array is too small to hold result");for(let A=0;A<T;A++)w[x+A]+=E*y[S+A]}static powx(w,y,x,S,T,E){if(S<0||S>=y.length)throw new Error("sourceIndex out of bounds");if(x<0||x>=w.length)throw new Error("targetIndex out of bounds");if(S+T>y.length)throw new Error("source indices to be copied are outside bounds");if(x+T>w.length)throw new Error("target array is too small to hold result");for(let A=0;A<T;A++)w[x+A]=Math.pow(y[S+A],E)}static mul(w,y,x,S,T){if(S<0||S>=y.length)throw new Error("sourceIndex out of bounds");if(x<0||x>=w.length)throw new Error("targetIndex out of bounds");if(S+T>y.length)throw new Error("source indices to be copied are outside bounds");if(x+T>w.length)throw new Error("target array is too small to hold result");for(let E=0;E<T;E++)w[x+E]=y[S+E]*w[x+E]}};class u{static splitShape(y,x,S,T){if(S.length===0){if(!T)throw new Error("need to know number of outputs when the 'split' attribute is not specified");u.determineSplit(y[x],T,S)}const E=[],A=[0];for(let C=0;C<S.length;++C){C!==0&&A.push(A[C-1]+S[C-1]);const I=y.slice();I[x]=S[C],E.push(I)}return[E,A]}static determineSplit(y,x,S){if(y%x!=0)throw new Error("cannot split tensor to equal sized parts");for(let T=0;T<x;++T)S.push(y/x)}}e.SplitUtil=u;class f{static calcReduce(y,x,S,T,E){const A=y.dims.slice(0);x.length===0&&A.forEach(((G,te)=>x.push(te)));const C=f.calcReduceShape(A,x,!0),I=r.size(C),D=new _.Tensor(C,y.type),R=r.computeStrides(C),Y=r.computeStrides(A),re=new Array(A.length);for(let G=0;G<I;G++){const te=r.offsetToIndices(G,R);d.fillIndex(te,A,re),D.set(te,f.calcReduceByAxis(y.numberData,x,A,0,r.indicesToOffset(re,Y),T,E))}return S?D:new _.Tensor(f.calcReduceShape(A,x,S),D.type,void 0,void 0,D.data,D.dataId)}static calcReduceByAxis(y,x,S,T,E,A,C){let I=0;if(T>=x.length)return A(y[E]);const D=x[T],R=D>=S.length?1:r.size(S.slice(D+1));for(let Y=0;Y<S[D];Y++)I=Y===0?f.calcReduceByAxis(y,x,S,T+1,E,A,C):C(I,f.calcReduceByAxis(y,x,S,T+1,E,A,C)),E+=R;return I}static calcReduceShape(y,x,S){const T=y.slice();for(let E=0;E<x.length;E++)T[x[E]]=S?1:0;return T.filter((E=>E!==0))}}e.ReduceUtil=f;class g{static adjustPoolAttributes(y,x,S,T,E,A){if(!y&&S.length!==x.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(y)for(let C=0;C<x.length-2;C++)C>=S.length?S.push(x[C+2]):S[C]=x[C+2];for(let C=0;C<S.length;C++)if(C<T.length){if(T[C]<0)throw new Error("strides should be greater than or equal to 1")}else T.push(1);for(let C=0;C<S.length;C++)if(C<E.length){if(E[C]<0)throw new Error("dilations should be greater than or equal to 1")}else E.push(1);for(let C=0;C<2*S.length;C++)if(C<A.length){if(A[C]<0)throw new Error("pad should be greater than or equal to 1")}else A.push(0);for(let C=0;C<S.length;C++){if(S[C]<=0)throw new Error("kernel shapes need to be greater than 0");if(A[C]>=S[C]||A[C+S.length]>=S[C])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(y,x,S,T,E,A){if(A){if(E.length!==2*(y.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(x.length!==y.length-2)throw new Error("length of strides should be the length of data dimensions");if(T.length!==y.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let C=0;C<y.length-2;C++)g.adjustPadAndReturnShape(y[C+2],x[C],S[C],T[C],E,C,C+y.length-2,A)}}static computePoolOutputShape(y,x,S,T,E,A,C){if(x.length<=0)throw new Error("input shape must be of size greater than 0");const I=[x[0],x[1]];return g.computeShapeHelper(y,x,I,S,T,E,A,C),I}static computeConvOutputShape(y,x,S,T,E,A,C){if(y.length<=0||x.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const I=[y[0],x[0]];return g.computeShapeHelper(!1,y,I,S,T,E,A,C),I}static computeShapeHelper(y,x,S,T,E,A,C,I){if(y)for(let D=0;D<x.length-2;D++)S.push(1);else for(let D=0;D<x.length-2;D++)S.push(g.adjustPadAndReturnShape(x[D+2],T[D],E[D],A[D],C,D,D+x.length-2,I))}static adjustPadAndReturnShape(y,x,S,T,E,A,C,I){const D=S*(T-1)+1;if(!I||I==="NOTSET")return Math.floor((y+E[A]+E[C]-D)/x+1);switch(I){case"VALID":return E[A]=0,E[C]=0,Math.floor((y-D)/x+1);case"SAME_LOWER":case"SAME_UPPER":if(S!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const R=((y+x-1)/x-1)*x+T-y;return E[A]=Math.floor(I==="SAME_LOWER"?(R+1)/2:R/2),E[C]=R-E[A],Math.floor((y+R-T)/x+1)}default:throw new Error("Unsupported AutoPad type")}}}e.PoolConvUtil=g,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(w){return new TextDecoder().decode(w)}},7967:(n,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,s,a,c)=>{if(typeof t=="object"&&t!==null){if(a.has(t))throw new Error("Circular reference in options");a.add(t)}Object.entries(t).forEach((([l,_])=>{const m=s?s+l:l;if(typeof _=="object")(0,e.iterateExtraOptions)(_,m+".",a,c);else if(typeof _=="string"||typeof _=="number")c(m,_.toString());else{if(typeof _!="boolean")throw new Error("Can't handle extra config type: "+typeof _);c(m,_?"1":"0")}}))}},2157:function(n,e,t){var s,a=this&&this.__createBinding||(Object.create?function(R,Y,re,G){G===void 0&&(G=re);var te=Object.getOwnPropertyDescriptor(Y,re);te&&!("get"in te?!Y.__esModule:te.writable||te.configurable)||(te={enumerable:!0,get:function(){return Y[re]}}),Object.defineProperty(R,G,te)}:function(R,Y,re,G){G===void 0&&(G=re),R[G]=Y[re]}),c=this&&this.__setModuleDefault||(Object.create?function(R,Y){Object.defineProperty(R,"default",{enumerable:!0,value:Y})}:function(R,Y){R.default=Y}),l=this&&this.__importStar||function(R){if(R&&R.__esModule)return R;var Y={};if(R!=null)for(var re in R)re!=="default"&&Object.prototype.hasOwnProperty.call(R,re)&&a(Y,R,re);return c(Y,R),Y};Object.defineProperty(e,"__esModule",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const _=t(1670),m=l(t(349)),d=t(6361),h=()=>!!_.env.wasm.proxy&&typeof document<"u";let i,r,u,f=!1,g=!1,w=!1;const y=[],x=[],S=[],T=[],E=[],A=[],C=()=>{if(f||!g||w||!i)throw new Error("worker not ready")},I=R=>{switch(R.data.type){case"init-wasm":f=!1,R.data.err?(w=!0,r[1](R.data.err)):(g=!0,r[0]());break;case"init-ort":R.data.err?u[1](R.data.err):u[0]();break;case"create_allocate":R.data.err?y.shift()[1](R.data.err):y.shift()[0](R.data.out);break;case"create_finalize":R.data.err?x.shift()[1](R.data.err):x.shift()[0](R.data.out);break;case"create":R.data.err?S.shift()[1](R.data.err):S.shift()[0](R.data.out);break;case"release":R.data.err?T.shift()[1](R.data.err):T.shift()[0]();break;case"run":R.data.err?E.shift()[1](R.data.err):E.shift()[0](R.data.out);break;case"end-profiling":R.data.err?A.shift()[1](R.data.err):A.shift()[0]()}},D=typeof document<"u"?(s=document?.currentScript)===null||s===void 0?void 0:s.src:void 0;e.initWasm=async()=>{if(h()){if(g)return;if(f)throw new Error("multiple calls to 'initWasm()' detected.");if(w)throw new Error("previous call to 'initWasm()' failed.");return f=!0,_.env.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(_.env.wasm.wasmPaths=D.substr(0,+D.lastIndexOf("/")+1)),new Promise(((R,Y)=>{i?.terminate(),i=t(9710).Z(),i.onmessage=I,r=[R,Y];const re={type:"init-wasm",in:_.env.wasm};i.postMessage(re)}))}return(0,d.initializeWebAssembly)(_.env.wasm)},e.initOrt=async(R,Y)=>{if(h())return C(),new Promise(((re,G)=>{u=[re,G];const te={type:"init-ort",in:{numThreads:R,loggingLevel:Y}};i.postMessage(te)}));m.initOrt(R,Y)},e.createSessionAllocate=async R=>h()?(C(),new Promise(((Y,re)=>{y.push([Y,re]);const G={type:"create_allocate",in:{model:R}};i.postMessage(G,[R.buffer])}))):m.createSessionAllocate(R),e.createSessionFinalize=async(R,Y)=>h()?(C(),new Promise(((re,G)=>{x.push([re,G]);const te={type:"create_finalize",in:{modeldata:R,options:Y}};i.postMessage(te)}))):m.createSessionFinalize(R,Y),e.createSession=async(R,Y)=>h()?(C(),new Promise(((re,G)=>{S.push([re,G]);const te={type:"create",in:{model:R,options:Y}};i.postMessage(te,[R.buffer])}))):m.createSession(R,Y),e.releaseSession=async R=>{if(h())return C(),new Promise(((Y,re)=>{T.push([Y,re]);const G={type:"release",in:R};i.postMessage(G)}));m.releaseSession(R)},e.run=async(R,Y,re,G,te)=>h()?(C(),new Promise(((q,z)=>{E.push([q,z]);const H={type:"run",in:{sessionId:R,inputIndices:Y,inputs:re,outputIndices:G,options:te}};i.postMessage(H,m.extractTransferableBuffers(re))}))):m.run(R,Y,re,G,te),e.endProfiling=async R=>{if(h())return C(),new Promise(((Y,re)=>{A.push([Y,re]);const G={type:"end-profiling",in:R};i.postMessage(G)}));m.endProfiling(R)}},586:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const s=t(7967),a=t(4983),c=t(6361);e.setRunOptions=l=>{const _=(0,c.getInstance)();let m=0;const d=[],h=l||{};try{if(l?.logSeverityLevel===void 0)h.logSeverityLevel=2;else if(typeof l.logSeverityLevel!="number"||!Number.isInteger(l.logSeverityLevel)||l.logSeverityLevel<0||l.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${l.logSeverityLevel}`);if(l?.logVerbosityLevel===void 0)h.logVerbosityLevel=0;else if(typeof l.logVerbosityLevel!="number"||!Number.isInteger(l.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${l.logVerbosityLevel}`);l?.terminate===void 0&&(h.terminate=!1);let i=0;if(l?.tag!==void 0&&(i=(0,a.allocWasmString)(l.tag,d)),m=_._OrtCreateRunOptions(h.logSeverityLevel,h.logVerbosityLevel,!!h.terminate,i),m===0)throw new Error("Can't create run options");return l?.extra!==void 0&&(0,s.iterateExtraOptions)(l.extra,"",new WeakSet,((r,u)=>{const f=(0,a.allocWasmString)(r,d),g=(0,a.allocWasmString)(u,d);if(_._OrtAddRunConfigEntry(m,f,g)!==0)throw new Error(`Can't set a run config entry: ${r} - ${u}`)})),[m,d]}catch(i){throw m!==0&&_._OrtReleaseRunOptions(m),d.forEach(_._free),i}}},2306:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const s=t(2806),a=t(1670),c=t(2850),l=t(2157);let _;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(m){const d=await fetch(m),h=await d.arrayBuffer();return(0,l.createSessionAllocate)(new Uint8Array(h))}async loadModel(m,d){if(_||(await(0,l.initOrt)(a.env.wasm.numThreads,(h=>{switch(h){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${h}`)}})(a.env.logLevel)),_=!0),typeof m=="string")if(typeof fetch>"u"){const h=await(0,c.promisify)(s.readFile)(m);[this.sessionId,this.inputNames,this.outputNames]=await(0,l.createSession)(h,d)}else{const h=await this.createSessionAllocate(m);[this.sessionId,this.inputNames,this.outputNames]=await(0,l.createSessionFinalize)(h,d)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,l.createSession)(m,d)}async dispose(){return(0,l.releaseSession)(this.sessionId)}async run(m,d,h){const i=[],r=[];Object.entries(m).forEach((w=>{const y=w[0],x=w[1],S=this.inputNames.indexOf(y);if(S===-1)throw new Error(`invalid input '${y}'`);i.push(x),r.push(S)}));const u=[];Object.entries(d).forEach((w=>{const y=w[0],x=this.outputNames.indexOf(y);if(x===-1)throw new Error(`invalid output '${y}'`);u.push(x)}));const f=await(0,l.run)(this.sessionId,r,i.map((w=>[w.type,w.dims,w.data])),u,h),g={};for(let w=0;w<f.length;w++)g[this.outputNames[u[w]]]=new a.Tensor(f[w][0],f[w][2],f[w][1]);return g}startProfiling(){}endProfiling(){(0,l.endProfiling)(this.sessionId)}}},4919:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const s=t(7967),a=t(4983),c=t(6361);e.setSessionOptions=l=>{const _=(0,c.getInstance)();let m=0;const d=[],h=l||{};(i=>{i.extra||(i.extra={}),i.extra.session||(i.extra.session={});const r=i.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1")})(h);try{l?.graphOptimizationLevel===void 0&&(h.graphOptimizationLevel="all");const i=(f=>{switch(f){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${f}`)}})(h.graphOptimizationLevel);l?.enableCpuMemArena===void 0&&(h.enableCpuMemArena=!0),l?.enableMemPattern===void 0&&(h.enableMemPattern=!0),l?.executionMode===void 0&&(h.executionMode="sequential");const r=(f=>{switch(f){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${f}`)}})(h.executionMode);let u=0;if(l?.logId!==void 0&&(u=(0,a.allocWasmString)(l.logId,d)),l?.logSeverityLevel===void 0)h.logSeverityLevel=2;else if(typeof l.logSeverityLevel!="number"||!Number.isInteger(l.logSeverityLevel)||l.logSeverityLevel<0||l.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${l.logSeverityLevel}`);if(l?.logVerbosityLevel===void 0)h.logVerbosityLevel=0;else if(typeof l.logVerbosityLevel!="number"||!Number.isInteger(l.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${l.logVerbosityLevel}`);if(l?.enableProfiling===void 0&&(h.enableProfiling=!1),m=_._OrtCreateSessionOptions(i,!!h.enableCpuMemArena,!!h.enableMemPattern,r,!!h.enableProfiling,0,u,h.logSeverityLevel,h.logVerbosityLevel),m===0)throw new Error("Can't create session options");return l?.executionProviders&&((f,g,w)=>{for(const y of g){let x=typeof y=="string"?y:y.name;switch(x){case"xnnpack":x="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${x}`)}const S=(0,a.allocWasmString)(x,w);if((0,c.getInstance)()._OrtAppendExecutionProvider(f,S)!==0)throw new Error(`Can't append execution provider: ${x}`)}})(m,l.executionProviders,d),l?.extra!==void 0&&(0,s.iterateExtraOptions)(l.extra,"",new WeakSet,((f,g)=>{const w=(0,a.allocWasmString)(f,d),y=(0,a.allocWasmString)(g,d);if(_._OrtAddSessionConfigEntry(m,w,y)!==0)throw new Error(`Can't set a session config entry: ${f} - ${g}`)})),[m,d]}catch(i){throw m!==0&&_._OrtReleaseSessionOptions(m),d.forEach(_._free),i}}},4983:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const s=t(6361);e.allocWasmString=(a,c)=>{const l=(0,s.getInstance)(),_=l.lengthBytesUTF8(a)+1,m=l._malloc(_);return l.stringToUTF8(a,m,_),c.push(m),m}},349:(n,e,t)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const s=t(586),a=t(4919),c=t(4983),l=t(6361);e.initOrt=(i,r)=>{const u=(0,l.getInstance)()._OrtInit(i,r);if(u!==0)throw new Error(`Can't initialize onnxruntime. error code = ${u}`)};const _=new Map;e.createSessionAllocate=i=>{const r=(0,l.getInstance)(),u=r._malloc(i.byteLength);return r.HEAPU8.set(i,u),[u,i.byteLength]},e.createSessionFinalize=(i,r)=>{const u=(0,l.getInstance)();let f=0,g=0,w=[];try{if([g,w]=(0,a.setSessionOptions)(r),f=u._OrtCreateSession(i[0],i[1],g),f===0)throw new Error("Can't create a session")}finally{u._free(i[0]),u._OrtReleaseSessionOptions(g),w.forEach(u._free)}const y=u._OrtGetInputCount(f),x=u._OrtGetOutputCount(f),S=[],T=[],E=[],A=[];for(let C=0;C<y;C++){const I=u._OrtGetInputName(f,C);if(I===0)throw new Error("Can't get an input name");T.push(I),S.push(u.UTF8ToString(I))}for(let C=0;C<x;C++){const I=u._OrtGetOutputName(f,C);if(I===0)throw new Error("Can't get an output name");A.push(I),E.push(u.UTF8ToString(I))}return _.set(f,[f,T,A]),[f,S,E]},e.createSession=(i,r)=>{const u=(0,e.createSessionAllocate)(i);return(0,e.createSessionFinalize)(u,r)},e.releaseSession=i=>{const r=(0,l.getInstance)(),u=_.get(i);if(!u)throw new Error("invalid session id");const f=u[0],g=u[1],w=u[2];g.forEach(r._OrtFree),w.forEach(r._OrtFree),r._OrtReleaseSession(f),_.delete(i)};const m=i=>{switch(i){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${i}`)}},d=i=>{switch(i){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${i}`)}},h=i=>{switch(i){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${i}`)}};e.run=(i,r,u,f,g)=>{const w=(0,l.getInstance)(),y=_.get(i);if(!y)throw new Error("invalid session id");const x=y[0],S=y[1],T=y[2],E=r.length,A=f.length;let C=0,I=[];const D=[],R=[];try{[C,I]=(0,s.setRunOptions)(g);for(let z=0;z<E;z++){const H=u[z][0],he=u[z][1],Ce=u[z][2];let oe,K;if(Array.isArray(Ce)){K=4*Ce.length,oe=w._malloc(K),R.push(oe);let ue=oe/4;for(let Ze=0;Ze<Ce.length;Ze++){if(typeof Ce[Ze]!="string")throw new TypeError(`tensor data at index ${Ze} is not a string`);w.HEAPU32[ue++]=(0,c.allocWasmString)(Ce[Ze],R)}}else K=Ce.byteLength,oe=w._malloc(K),R.push(oe),w.HEAPU8.set(new Uint8Array(Ce.buffer,Ce.byteOffset,K),oe);const Q=w.stackSave(),de=w.stackAlloc(4*he.length);try{let ue=de/4;he.forEach((Pt=>w.HEAP32[ue++]=Pt));const Ze=w._OrtCreateTensor(m(H),oe,K,de,he.length);if(Ze===0)throw new Error("Can't create a tensor");D.push(Ze)}finally{w.stackRestore(Q)}}const Y=w.stackSave(),re=w.stackAlloc(4*E),G=w.stackAlloc(4*E),te=w.stackAlloc(4*A),q=w.stackAlloc(4*A);try{let z=re/4,H=G/4,he=te/4,Ce=q/4;for(let Q=0;Q<E;Q++)w.HEAPU32[z++]=D[Q],w.HEAPU32[H++]=S[r[Q]];for(let Q=0;Q<A;Q++)w.HEAPU32[he++]=0,w.HEAPU32[Ce++]=T[f[Q]];let oe=w._OrtRun(x,G,re,E,q,A,te,C);const K=[];if(oe===0)for(let Q=0;Q<A;Q++){const de=w.HEAPU32[te/4+Q],ue=w.stackSave(),Ze=w.stackAlloc(16);let Pt,Gt=0;try{if(oe=w._OrtGetTensorData(de,Ze,Ze+4,Ze+8,Ze+12),oe!==0)throw new Error(`Can't access output tensor data. error code = ${oe}`);let bn=Ze/4;const ri=w.HEAPU32[bn++];Gt=w.HEAPU32[bn++];const hn=w.HEAPU32[bn++],ze=w.HEAPU32[bn++],wt=[];for(let Bt=0;Bt<ze;Bt++)wt.push(w.HEAPU32[hn/4+Bt]);w._OrtFree(hn);const ke=wt.length===0?1:wt.reduce(((Bt,In)=>Bt*In));if(Pt=d(ri),Pt==="string"){const Bt=[];let In=Gt/4;for(let Tn=0;Tn<ke;Tn++){const cn=w.HEAPU32[In++],kn=Tn===ke-1?void 0:w.HEAPU32[In]-cn;Bt.push(w.UTF8ToString(cn,kn))}K.push([Pt,wt,Bt])}else{const Bt=new(h(Pt))(ke);new Uint8Array(Bt.buffer,Bt.byteOffset,Bt.byteLength).set(w.HEAPU8.subarray(Gt,Gt+Bt.byteLength)),K.push([Pt,wt,Bt])}}finally{w.stackRestore(ue),Pt==="string"&&Gt&&w._free(Gt),w._OrtReleaseTensor(de)}}if(oe===0)return K;throw new Error(`failed to call OrtRun(). error code = ${oe}.`)}finally{w.stackRestore(Y)}}finally{D.forEach(w._OrtReleaseTensor),R.forEach(w._free),w._OrtReleaseRunOptions(C),I.forEach(w._free)}},e.endProfiling=i=>{const r=(0,l.getInstance)(),u=_.get(i);if(!u)throw new Error("invalid session id");const f=u[0],g=r._OrtEndProfiling(f);if(g===0)throw new Error("Can't get an profile file name");r._OrtFree(g)},e.extractTransferableBuffers=i=>{const r=[];for(const u of i){const f=u[2];!Array.isArray(f)&&f.buffer&&r.push(f.buffer)}return r}},6361:function(n,e,t){var s=this&&this.__createBinding||(Object.create?function(g,w,y,x){x===void 0&&(x=y);var S=Object.getOwnPropertyDescriptor(w,y);S&&!("get"in S?!w.__esModule:S.writable||S.configurable)||(S={enumerable:!0,get:function(){return w[y]}}),Object.defineProperty(g,x,S)}:function(g,w,y,x){x===void 0&&(x=y),g[x]=w[y]}),a=this&&this.__setModuleDefault||(Object.create?function(g,w){Object.defineProperty(g,"default",{enumerable:!0,value:w})}:function(g,w){g.default=w}),c=this&&this.__importStar||function(g){if(g&&g.__esModule)return g;var w={};if(g!=null)for(var y in g)y!=="default"&&Object.prototype.hasOwnProperty.call(g,y)&&s(w,g,y);return a(w,g),w},l=this&&this.__importDefault||function(g){return g&&g.__esModule?g:{default:g}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const _=c(t(6449)),m=l(t(932)),d=t(3474);let h,i=!1,r=!1,u=!1;const f=(g,w)=>w?g?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":g?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async g=>{if(i)return Promise.resolve();if(r)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(u)throw new Error("previous call to 'initializeWebAssembly()' failed.");r=!0;const w=g.initTimeout,y=g.numThreads,x=g.simd,S=y>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),T=x&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),E=typeof g.wasmPaths=="string"?g.wasmPaths:void 0,A=f(!1,S),C=f(T,S),I=typeof g.wasmPaths=="object"?g.wasmPaths[C]:void 0;let D=!1;const R=[];if(w>0&&R.push(new Promise((Y=>{setTimeout((()=>{D=!0,Y()}),w)}))),R.push(new Promise(((Y,re)=>{const G=S?d:m.default,te={locateFile:(q,z)=>S&&q.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([t(4154)],{type:"text/javascript"})):q===A?I??(E??z)+C:z+q};if(S)if(typeof Blob>"u")te.mainScriptUrlOrBlob=_.join("/","ort-wasm-threaded.js");else{const q=`var ortWasmThreaded=(function(){var _scriptDir;return ${G.toString()}})();`;te.mainScriptUrlOrBlob=new Blob([q],{type:"text/javascript"})}G(te).then((q=>{r=!1,i=!0,h=q,Y()}),(q=>{r=!1,u=!0,re(q)}))}))),await Promise.race(R),D)throw new Error(`WebAssembly backend initializing failed due to timeout: ${w}ms`)},e.getInstance=()=>{if(i&&h)return h;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var g;!i||r||u||(r=!0,(g=h.PThread)===null||g===void 0||g.terminateAllThreads(),h=void 0,r=!1,i=!1,u=!0)}},9710:(n,e,t)=>{t.d(e,{Z:()=>c});var s=t(477),a=t.n(s);function c(){return a()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:n=>{n.exports=function(e,t,s,a){var c=self||window;try{try{var l;try{l=new c.Blob([e])}catch{(l=new(c.BlobBuilder||c.WebKitBlobBuilder||c.MozBlobBuilder||c.MSBlobBuilder)).append(e),l=l.getBlob()}var _=c.URL||c.webkitURL,m=_.createObjectURL(l),d=new c[t](m,s);return _.revokeObjectURL(m),d}catch{return new c[t]("data:application/javascript,".concat(encodeURIComponent(e)),s)}}catch{if(!a)throw Error("Inline worker is not supported");return new c[t](a,s)}}},4154:n=>{n.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},1670:n=>{n.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(n,e,t)=>{t.r(e),t.d(e,{flatbuffers:()=>s});var s={};s.Offset,s.Table,s.SIZEOF_SHORT=2,s.SIZEOF_INT=4,s.FILE_IDENTIFIER_LENGTH=4,s.SIZE_PREFIX_LENGTH=4,s.Encoding={UTF8_BYTES:1,UTF16_STRING:2},s.int32=new Int32Array(2),s.float32=new Float32Array(s.int32.buffer),s.float64=new Float64Array(s.int32.buffer),s.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,s.Long=function(a,c){this.low=0|a,this.high=0|c},s.Long.create=function(a,c){return a==0&&c==0?s.Long.ZERO:new s.Long(a,c)},s.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},s.Long.prototype.equals=function(a){return this.low==a.low&&this.high==a.high},s.Long.ZERO=new s.Long(0,0),s.Builder=function(a){if(a)c=a;else var c=1024;this.bb=s.ByteBuffer.allocate(c),this.space=c,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},s.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},s.Builder.prototype.forceDefaults=function(a){this.force_defaults=a},s.Builder.prototype.dataBuffer=function(){return this.bb},s.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},s.Builder.prototype.prep=function(a,c){a>this.minalign&&(this.minalign=a);for(var l=1+~(this.bb.capacity()-this.space+c)&a-1;this.space<l+a+c;){var _=this.bb.capacity();this.bb=s.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-_}this.pad(l)},s.Builder.prototype.pad=function(a){for(var c=0;c<a;c++)this.bb.writeInt8(--this.space,0)},s.Builder.prototype.writeInt8=function(a){this.bb.writeInt8(this.space-=1,a)},s.Builder.prototype.writeInt16=function(a){this.bb.writeInt16(this.space-=2,a)},s.Builder.prototype.writeInt32=function(a){this.bb.writeInt32(this.space-=4,a)},s.Builder.prototype.writeInt64=function(a){this.bb.writeInt64(this.space-=8,a)},s.Builder.prototype.writeFloat32=function(a){this.bb.writeFloat32(this.space-=4,a)},s.Builder.prototype.writeFloat64=function(a){this.bb.writeFloat64(this.space-=8,a)},s.Builder.prototype.addInt8=function(a){this.prep(1,0),this.writeInt8(a)},s.Builder.prototype.addInt16=function(a){this.prep(2,0),this.writeInt16(a)},s.Builder.prototype.addInt32=function(a){this.prep(4,0),this.writeInt32(a)},s.Builder.prototype.addInt64=function(a){this.prep(8,0),this.writeInt64(a)},s.Builder.prototype.addFloat32=function(a){this.prep(4,0),this.writeFloat32(a)},s.Builder.prototype.addFloat64=function(a){this.prep(8,0),this.writeFloat64(a)},s.Builder.prototype.addFieldInt8=function(a,c,l){(this.force_defaults||c!=l)&&(this.addInt8(c),this.slot(a))},s.Builder.prototype.addFieldInt16=function(a,c,l){(this.force_defaults||c!=l)&&(this.addInt16(c),this.slot(a))},s.Builder.prototype.addFieldInt32=function(a,c,l){(this.force_defaults||c!=l)&&(this.addInt32(c),this.slot(a))},s.Builder.prototype.addFieldInt64=function(a,c,l){!this.force_defaults&&c.equals(l)||(this.addInt64(c),this.slot(a))},s.Builder.prototype.addFieldFloat32=function(a,c,l){(this.force_defaults||c!=l)&&(this.addFloat32(c),this.slot(a))},s.Builder.prototype.addFieldFloat64=function(a,c,l){(this.force_defaults||c!=l)&&(this.addFloat64(c),this.slot(a))},s.Builder.prototype.addFieldOffset=function(a,c,l){(this.force_defaults||c!=l)&&(this.addOffset(c),this.slot(a))},s.Builder.prototype.addFieldStruct=function(a,c,l){c!=l&&(this.nested(c),this.slot(a))},s.Builder.prototype.nested=function(a){if(a!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},s.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},s.Builder.prototype.slot=function(a){this.vtable[a]=this.offset()},s.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},s.Builder.growByteBuffer=function(a){var c=a.capacity();if(3221225472&c)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var l=c<<1,_=s.ByteBuffer.allocate(l);return _.setPosition(l-c),_.bytes().set(a.bytes(),l-c),_},s.Builder.prototype.addOffset=function(a){this.prep(s.SIZEOF_INT,0),this.writeInt32(this.offset()-a+s.SIZEOF_INT)},s.Builder.prototype.startObject=function(a){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=a;for(var c=0;c<a;c++)this.vtable[c]=0;this.isNested=!0,this.object_start=this.offset()},s.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var a=this.offset(),c=this.vtable_in_use-1;c>=0&&this.vtable[c]==0;c--);for(var l=c+1;c>=0;c--)this.addInt16(this.vtable[c]!=0?a-this.vtable[c]:0);this.addInt16(a-this.object_start);var _=(l+2)*s.SIZEOF_SHORT;this.addInt16(_);var m=0,d=this.space;e:for(c=0;c<this.vtables.length;c++){var h=this.bb.capacity()-this.vtables[c];if(_==this.bb.readInt16(h)){for(var i=s.SIZEOF_SHORT;i<_;i+=s.SIZEOF_SHORT)if(this.bb.readInt16(d+i)!=this.bb.readInt16(h+i))continue e;m=this.vtables[c];break}}return m?(this.space=this.bb.capacity()-a,this.bb.writeInt32(this.space,m-a)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-a,this.offset()-a)),this.isNested=!1,a},s.Builder.prototype.finish=function(a,c,l){var _=l?s.SIZE_PREFIX_LENGTH:0;if(c){var m=c;if(this.prep(this.minalign,s.SIZEOF_INT+s.FILE_IDENTIFIER_LENGTH+_),m.length!=s.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+s.FILE_IDENTIFIER_LENGTH);for(var d=s.FILE_IDENTIFIER_LENGTH-1;d>=0;d--)this.writeInt8(m.charCodeAt(d))}this.prep(this.minalign,s.SIZEOF_INT+_),this.addOffset(a),_&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},s.Builder.prototype.finishSizePrefixed=function(a,c){this.finish(a,c,!0)},s.Builder.prototype.requiredField=function(a,c){var l=this.bb.capacity()-a,_=l-this.bb.readInt32(l);if(this.bb.readInt16(_+c)==0)throw new Error("FlatBuffers: field "+c+" must be set")},s.Builder.prototype.startVector=function(a,c,l){this.notNested(),this.vector_num_elems=c,this.prep(s.SIZEOF_INT,a*c),this.prep(l,a*c)},s.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},s.Builder.prototype.createString=function(a){if(a instanceof Uint8Array)var c=a;else{c=[];for(var l=0;l<a.length;){var _,m=a.charCodeAt(l++);(_=m<55296||m>=56320?m:(m<<10)+a.charCodeAt(l++)+-56613888)<128?c.push(_):(_<2048?c.push(_>>6&31|192):(_<65536?c.push(_>>12&15|224):c.push(_>>18&7|240,_>>12&63|128),c.push(_>>6&63|128)),c.push(63&_|128))}}this.addInt8(0),this.startVector(1,c.length,1),this.bb.setPosition(this.space-=c.length),l=0;for(var d=this.space,h=this.bb.bytes();l<c.length;l++)h[d++]=c[l];return this.endVector()},s.Builder.prototype.createLong=function(a,c){return s.Long.create(a,c)},s.ByteBuffer=function(a){this.bytes_=a,this.position_=0},s.ByteBuffer.allocate=function(a){return new s.ByteBuffer(new Uint8Array(a))},s.ByteBuffer.prototype.clear=function(){this.position_=0},s.ByteBuffer.prototype.bytes=function(){return this.bytes_},s.ByteBuffer.prototype.position=function(){return this.position_},s.ByteBuffer.prototype.setPosition=function(a){this.position_=a},s.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},s.ByteBuffer.prototype.readInt8=function(a){return this.readUint8(a)<<24>>24},s.ByteBuffer.prototype.readUint8=function(a){return this.bytes_[a]},s.ByteBuffer.prototype.readInt16=function(a){return this.readUint16(a)<<16>>16},s.ByteBuffer.prototype.readUint16=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8},s.ByteBuffer.prototype.readInt32=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8|this.bytes_[a+2]<<16|this.bytes_[a+3]<<24},s.ByteBuffer.prototype.readUint32=function(a){return this.readInt32(a)>>>0},s.ByteBuffer.prototype.readInt64=function(a){return new s.Long(this.readInt32(a),this.readInt32(a+4))},s.ByteBuffer.prototype.readUint64=function(a){return new s.Long(this.readUint32(a),this.readUint32(a+4))},s.ByteBuffer.prototype.readFloat32=function(a){return s.int32[0]=this.readInt32(a),s.float32[0]},s.ByteBuffer.prototype.readFloat64=function(a){return s.int32[s.isLittleEndian?0:1]=this.readInt32(a),s.int32[s.isLittleEndian?1:0]=this.readInt32(a+4),s.float64[0]},s.ByteBuffer.prototype.writeInt8=function(a,c){this.bytes_[a]=c},s.ByteBuffer.prototype.writeUint8=function(a,c){this.bytes_[a]=c},s.ByteBuffer.prototype.writeInt16=function(a,c){this.bytes_[a]=c,this.bytes_[a+1]=c>>8},s.ByteBuffer.prototype.writeUint16=function(a,c){this.bytes_[a]=c,this.bytes_[a+1]=c>>8},s.ByteBuffer.prototype.writeInt32=function(a,c){this.bytes_[a]=c,this.bytes_[a+1]=c>>8,this.bytes_[a+2]=c>>16,this.bytes_[a+3]=c>>24},s.ByteBuffer.prototype.writeUint32=function(a,c){this.bytes_[a]=c,this.bytes_[a+1]=c>>8,this.bytes_[a+2]=c>>16,this.bytes_[a+3]=c>>24},s.ByteBuffer.prototype.writeInt64=function(a,c){this.writeInt32(a,c.low),this.writeInt32(a+4,c.high)},s.ByteBuffer.prototype.writeUint64=function(a,c){this.writeUint32(a,c.low),this.writeUint32(a+4,c.high)},s.ByteBuffer.prototype.writeFloat32=function(a,c){s.float32[0]=c,this.writeInt32(a,s.int32[0])},s.ByteBuffer.prototype.writeFloat64=function(a,c){s.float64[0]=c,this.writeInt32(a,s.int32[s.isLittleEndian?0:1]),this.writeInt32(a+4,s.int32[s.isLittleEndian?1:0])},s.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+s.SIZEOF_INT+s.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var a="",c=0;c<s.FILE_IDENTIFIER_LENGTH;c++)a+=String.fromCharCode(this.readInt8(this.position_+s.SIZEOF_INT+c));return a},s.ByteBuffer.prototype.__offset=function(a,c){var l=a-this.readInt32(a);return c<this.readInt16(l)?this.readInt16(l+c):0},s.ByteBuffer.prototype.__union=function(a,c){return a.bb_pos=c+this.readInt32(c),a.bb=this,a},s.ByteBuffer.prototype.__string=function(a,c){a+=this.readInt32(a);var l=this.readInt32(a),_="",m=0;if(a+=s.SIZEOF_INT,c===s.Encoding.UTF8_BYTES)return this.bytes_.subarray(a,a+l);for(;m<l;){var d,h=this.readUint8(a+m++);if(h<192)d=h;else{var i=this.readUint8(a+m++);if(h<224)d=(31&h)<<6|63&i;else{var r=this.readUint8(a+m++);d=h<240?(15&h)<<12|(63&i)<<6|63&r:(7&h)<<18|(63&i)<<12|(63&r)<<6|63&this.readUint8(a+m++)}}d<65536?_+=String.fromCharCode(d):(d-=65536,_+=String.fromCharCode(55296+(d>>10),56320+(1023&d)))}return _},s.ByteBuffer.prototype.__indirect=function(a){return a+this.readInt32(a)},s.ByteBuffer.prototype.__vector=function(a){return a+this.readInt32(a)+s.SIZEOF_INT},s.ByteBuffer.prototype.__vector_len=function(a){return this.readInt32(a+this.readInt32(a))},s.ByteBuffer.prototype.__has_identifier=function(a){if(a.length!=s.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+s.FILE_IDENTIFIER_LENGTH);for(var c=0;c<s.FILE_IDENTIFIER_LENGTH;c++)if(a.charCodeAt(c)!=this.readInt8(this.position_+s.SIZEOF_INT+c))return!1;return!0},s.ByteBuffer.prototype.createLong=function(a,c){return s.Long.create(a,c)}}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(e!==void 0)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(e,{a:e}),e},__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.g=(function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}})(),__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),__webpack_require__.r=n=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})()))})(ortWeb_min$1)),ortWeb_min$1.exports}var ortWeb_minExports=requireOrtWeb_min();const ortWeb_min=getDefaultExportFromCjs(ortWeb_minExports),ONNX_WEB=_mergeNamespaces({__proto__:null,default:ortWeb_min},[ortWeb_minExports]);let ONNX;const executionProviders=["wasm"];typeof process<"u"&&process?.release?.name==="node"?(ONNX=sharp??ONNX_NODE,executionProviders.unshift("cpu")):(ONNX=ortWeb_min??ONNX_WEB,typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(ONNX.env.wasm.simd=!1));const{env:onnx_env}=ONNX,VERSION="2.17.2",WEB_CACHE_AVAILABLE=typeof self<"u"&&"caches"in self,FS_AVAILABLE=!isEmpty(sharp),PATH_AVAILABLE=!isEmpty(sharp),RUNNING_LOCALLY=FS_AVAILABLE&&PATH_AVAILABLE,__dirname$1=RUNNING_LOCALLY?sharp.dirname(sharp.dirname(sharp.fileURLToPath(import.meta.url))):"./",DEFAULT_CACHE_DIR=RUNNING_LOCALLY?sharp.join(__dirname$1,"/.cache/"):null,DEFAULT_LOCAL_MODEL_PATH="/models/",localModelPath=RUNNING_LOCALLY?sharp.join(__dirname$1,DEFAULT_LOCAL_MODEL_PATH):DEFAULT_LOCAL_MODEL_PATH;onnx_env?.wasm&&(onnx_env.wasm.wasmPaths=RUNNING_LOCALLY?sharp.join(__dirname$1,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`);const env$1={version:VERSION,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",localModelPath,useFS:FS_AVAILABLE,useBrowserCache:WEB_CACHE_AVAILABLE,useFSCache:FS_AVAILABLE,cacheDir:DEFAULT_CACHE_DIR};function isEmpty(n){return Object.keys(n).length===0}var define_process_env_default={};class FileResponse{_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=sharp.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=sharp.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();let s=this;this.body=new ReadableStream({start(a){s.arrayBuffer().then(c=>{a.enqueue(new Uint8Array(c)),a.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[e]??"application/octet-stream")}clone(){let e=new FileResponse(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await sharp.promises.readFile(this.filePath)).buffer}async blob(){const e=await sharp.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await sharp.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function isValidUrl(n,e=null,t=null){let s;try{s=new URL(n)}catch{return!1}return!(e&&!e.includes(s.protocol)||t&&!t.includes(s.hostname))}async function getFile(n){if(env$1.useFS&&!isValidUrl(n,["http:","https:","blob:"]))return new FileResponse(n);if(typeof process<"u"&&process?.release?.name==="node"){const e=!!define_process_env_default?.TESTING_REMOTELY,t=env$1.version,s=new Headers;if(s.set("User-Agent",`transformers.js/${t}; is_ci/${e};`),isValidUrl(n,["http:","https:"],["huggingface.co","hf.co"])){const c=define_process_env_default?.HF_TOKEN??define_process_env_default?.HF_ACCESS_TOKEN;c&&s.set("Authorization",`Bearer ${c}`)}return fetch(n,{headers:s})}else return fetch(n)}const ERROR_MAPPING={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function handleError(n,e,t){if(!t)return null;const s=ERROR_MAPPING[n]??`Error (${n}) occurred while trying to load file`;throw Error(`${s}: "${e}".`)}class FileCache{constructor(e){this.path=e}async match(e){let t=sharp.join(this.path,e),s=new FileResponse(t);if(s.exists)return s}async put(e,t){const s=Buffer.from(await t.arrayBuffer());let a=sharp.join(this.path,e);try{await sharp.promises.mkdir(sharp.dirname(a),{recursive:!0}),await sharp.promises.writeFile(a,s)}catch(c){console.warn("An error occurred while writing the file to cache:",c)}}}async function tryCache(n,...e){for(let t of e)try{let s=await n.match(t);if(s)return s}catch{continue}}async function getModelFile(n,e,t=!0,s={}){dispatchCallback(s.progress_callback,{status:"initiate",name:n,file:e});let a;if(!a&&env$1.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{a=await caches.open("transformers-cache")}catch(y){console.warn("An error occurred while opening the browser cache:",y)}}!a&&env$1.useFSCache&&(a=new FileCache(s.cache_dir??env$1.cacheDir));const c=s.revision??"main";let l=pathJoin(n,e),_=pathJoin(env$1.localModelPath,l),m=pathJoin(env$1.remoteHost,env$1.remotePathTemplate.replaceAll("{model}",n).replaceAll("{revision}",encodeURIComponent(c)),e),d=c==="main"?l:pathJoin(n,c,e),h,i=a instanceof FileCache?d:m,r=!1,u;a&&(u=await tryCache(a,_,i));const f=u!==void 0;if(u===void 0){if(isValidUrl(l,["http:","https:"])){if(s.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${l}.`)}else try{u=await getFile(_),h=_}catch(x){console.warn(`Unable to load from local path "${_}": "${x}"`)}if(u===void 0||u.status===404){if(s.local_files_only){if(t)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${_}".`);return null}if(u=await getFile(m),u.status!==200)return handleError(u.status,m,t);h=i}r=a&&typeof Response<"u"&&u instanceof Response&&u.status===200}dispatchCallback(s.progress_callback,{status:"download",name:n,file:e});const g={status:"progress",name:n,file:e};let w;return s.progress_callback?f&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(w=new Uint8Array(await u.arrayBuffer()),dispatchCallback(s.progress_callback,{...g,progress:100,loaded:w.length,total:w.length})):w=await readResponse(u,y=>{dispatchCallback(s.progress_callback,{...g,...y})}):w=new Uint8Array(await u.arrayBuffer()),r&&h&&await a.match(h)===void 0&&await a.put(h,new Response(w,{headers:u.headers})).catch(y=>{console.warn(`Unable to add response to browser cache: ${y}.`)}),dispatchCallback(s.progress_callback,{status:"done",name:n,file:e}),w}async function getModelJSON(n,e,t=!0,s={}){let a=await getModelFile(n,e,t,s);if(a===null)return{};let l=new TextDecoder("utf-8").decode(a);return JSON.parse(l)}async function readResponse(n,e){const t=n.headers.get("Content-Length");t===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let s=parseInt(t??"0"),a=new Uint8Array(s),c=0;const l=n.body.getReader();async function _(){const{done:m,value:d}=await l.read();if(m)return;let h=c+d.length;if(h>s){s=h;let r=new Uint8Array(s);r.set(a),a=r}a.set(d,c),c=h;const i=c/s*100;return e({progress:i,loaded:c,total:s}),_()}return await _(),a}function pathJoin(...n){return n=n.map((e,t)=>(t&&(e=e.replace(new RegExp("^/"),"")),t!==n.length-1&&(e=e.replace(new RegExp("/$"),"")),e)),n.join("/")}function interpolate_data(n,[e,t,s],[a,c],l="bilinear",_=!1){const m=c/s,d=a/t,h=new n.constructor(a*c*e),i=t*s,r=a*c;for(let u=0;u<a;++u)for(let f=0;f<c;++f){const g=u*c+f,w=(f+.5)/m-.5,y=(u+.5)/d-.5;let x=Math.floor(w),S=Math.floor(y);const T=Math.min(x+1,s-1),E=Math.min(S+1,t-1);x=Math.max(x,0),S=Math.max(S,0);const A=w-x,C=y-S,I=(1-A)*(1-C),D=A*(1-C),R=(1-A)*C,Y=A*C,re=S*s,G=E*s,te=re+x,q=re+T,z=G+x,H=G+T;for(let he=0;he<e;++he){const Ce=he*i;h[he*r+g]=I*n[Ce+te]+D*n[Ce+q]+R*n[Ce+z]+Y*n[Ce+H]}}return h}function permute_data(n,e,t){const s=new Array(t.length),a=new Array(t.length);for(let _=t.length-1,m=1;_>=0;--_)a[_]=m,s[_]=e[t[_]],m*=s[_];const c=t.map((_,m)=>a[t.indexOf(m)]),l=new n.constructor(n.length);for(let _=0;_<n.length;++_){let m=0;for(let d=e.length-1,h=_;d>=0;--d)m+=h%e[d]*c[d],h=Math.floor(h/e[d]);l[m]=n[_]}return[l,s]}function softmax(n){const e=max(n)[0],t=n.map(c=>Math.exp(c-e)),s=t.reduce((c,l)=>c+l,0);return t.map(c=>c/s)}function log_softmax(n){return softmax(n).map(s=>Math.log(s))}function getTopItems(n,e=0){return n=Array.from(n).map((t,s)=>[s,t]).sort((t,s)=>s[1]-t[1]),e!==null&&e>0&&(n=n.slice(0,e)),n}function min(n){if(n.length===0)throw Error("Array must not be empty");let e=n[0],t=0;for(let s=1;s<n.length;++s)n[s]<e&&(e=n[s],t=s);return[e,t]}function max(n){if(n.length===0)throw Error("Array must not be empty");let e=n[0],t=0;for(let s=1;s<n.length;++s)n[s]>e&&(e=n[s],t=s);return[Number(e),t]}function isPowerOfTwo(n){return n>0&&(n&n-1)===0}class P2FFT{constructor(e){if(this.size=e|0,this.size<=1||!isPowerOfTwo(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(this.size*2);for(let s=0;s<this.table.length;s+=2){const a=Math.PI*s/this.size;this.table[s]=Math.cos(a),this.table[s+1]=-Math.sin(a)}let t=0;for(let s=1;this.size>s;s<<=1)++t;this._width=t%2===0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let s=0;s<this._bitrev.length;++s){this._bitrev[s]=0;for(let a=0;a<this._width;a+=2){const c=this._width-a-2;this._bitrev[s]|=(s>>>a&3)<<c}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const s=t||new Array(e.length>>>1);for(let a=0;a<e.length;a+=2)s[a>>>1]=e[a];return s}toComplexArray(e,t){const s=t||this.createComplexArray();for(let a=0;a<s.length;a+=2)s[a]=e[a>>>1],s[a+1]=0;return s}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let s=0;s<e.length;++s)e[s]/=this.size}_transform4(e,t,s){const a=this._csize;let l=1<<this._width,_=a/l<<1,m,d;const h=this._bitrev;if(_===4)for(m=0,d=0;m<a;m+=_,++d){const r=h[d];this._singleTransform2(t,e,m,r,l)}else for(m=0,d=0;m<a;m+=_,++d){const r=h[d];this._singleTransform4(t,e,m,r,l,s)}const i=this.table;for(l>>=2;l>=2;l>>=2){_=a/l<<1;const r=_>>>2;for(m=0;m<a;m+=_){const u=m+r-1;for(let f=m,g=0;f<u;f+=2,g+=l){const w=f,y=w+r,x=y+r,S=x+r,T=e[w],E=e[w+1],A=e[y],C=e[y+1],I=e[x],D=e[x+1],R=e[S],Y=e[S+1],re=i[g],G=s*i[g+1],te=A*re-C*G,q=A*G+C*re,z=i[2*g],H=s*i[2*g+1],he=I*z-D*H,Ce=I*H+D*z,oe=i[3*g],K=s*i[3*g+1],Q=R*oe-Y*K,de=R*K+Y*oe,ue=T+he,Ze=E+Ce,Pt=T-he,Gt=E-Ce,bn=te+Q,ri=q+de,hn=s*(te-Q),ze=s*(q-de);e[w]=ue+bn,e[w+1]=Ze+ri,e[y]=Pt+ze,e[y+1]=Gt-hn,e[x]=ue-bn,e[x+1]=Ze-ri,e[S]=Pt-ze,e[S+1]=Gt+hn}}}}_singleTransform2(e,t,s,a,c){const l=e[a],_=e[a+1],m=e[a+c],d=e[a+c+1];t[s]=l+m,t[s+1]=_+d,t[s+2]=l-m,t[s+3]=_-d}_singleTransform4(e,t,s,a,c,l){const _=c*2,m=c*3,d=e[a],h=e[a+1],i=e[a+c],r=e[a+c+1],u=e[a+_],f=e[a+_+1],g=e[a+m],w=e[a+m+1],y=d+u,x=h+f,S=d-u,T=h-f,E=i+g,A=r+w,C=l*(i-g),I=l*(r-w);t[s]=y+E,t[s+1]=x+A,t[s+2]=S+I,t[s+3]=T-C,t[s+4]=y-E,t[s+5]=x-A,t[s+6]=S-I,t[s+7]=T+C}_realTransform4(e,t,s){const a=this._csize;let l=1<<this._width,_=a/l<<1,m,d;const h=this._bitrev;if(_===4)for(m=0,d=0;m<a;m+=_,++d){const u=h[d];this._singleRealTransform2(t,e,m,u>>>1,l>>>1)}else for(m=0,d=0;m<a;m+=_,++d){const u=h[d];this._singleRealTransform4(t,e,m,u>>>1,l>>>1,s)}const i=this.table;for(l>>=2;l>=2;l>>=2){_=a/l<<1;const u=_>>>1,f=u>>>1,g=f>>>1;for(m=0;m<a;m+=_)for(let w=0,y=0;w<=g;w+=2,y+=l){const x=m+w,S=x+f,T=S+f,E=T+f,A=e[x],C=e[x+1],I=e[S],D=e[S+1],R=e[T],Y=e[T+1],re=e[E],G=e[E+1],te=A,q=C,z=i[y],H=s*i[y+1],he=I*z-D*H,Ce=I*H+D*z,oe=i[2*y],K=s*i[2*y+1],Q=R*oe-Y*K,de=R*K+Y*oe,ue=i[3*y],Ze=s*i[3*y+1],Pt=re*ue-G*Ze,Gt=re*Ze+G*ue,bn=te+Q,ri=q+de,hn=te-Q,ze=q-de,wt=he+Pt,ke=Ce+Gt,Bt=s*(he-Pt),In=s*(Ce-Gt);if(e[x]=bn+wt,e[x+1]=ri+ke,e[S]=hn+In,e[S+1]=ze-Bt,w===0){e[T]=bn-wt,e[T+1]=ri-ke;continue}if(w===g)continue;const Tn=m+f-w,cn=m+u-w;e[Tn]=hn-s*In,e[Tn+1]=-ze-s*Bt,e[cn]=bn-s*wt,e[cn+1]=-ri+s*ke}}const r=a>>>1;for(let u=2;u<r;u+=2)e[a-u]=e[u],e[a-u+1]=-e[u+1]}_singleRealTransform2(e,t,s,a,c){const l=e[a],_=e[a+c];t[s]=l+_,t[s+1]=0,t[s+2]=l-_,t[s+3]=0}_singleRealTransform4(e,t,s,a,c,l){const _=c*2,m=c*3,d=e[a],h=e[a+c],i=e[a+_],r=e[a+m],u=d+i,f=d-i,g=h+r,w=l*(h-r);t[s]=u+g,t[s+1]=0,t[s+2]=f,t[s+3]=-w,t[s+4]=u-g,t[s+5]=0,t[s+6]=f,t[s+7]=w}}class NP2FFT{constructor(e){const t=2*(e-1),s=2*(2*e-1),a=2**Math.ceil(Math.log2(s));this.bufferSize=a,this._a=t;const c=new Float64Array(s),l=new Float64Array(a);this._chirpBuffer=new Float64Array(a),this._buffer1=new Float64Array(a),this._buffer2=new Float64Array(a),this._outBuffer1=new Float64Array(a),this._outBuffer2=new Float64Array(a);const _=-2*Math.PI/e,m=Math.cos(_),d=Math.sin(_);for(let h=0;h<s>>1;++h){const i=(h+1-e)**2/2,r=Math.sqrt(m**2+d**2)**i,u=i*Math.atan2(d,m),f=2*h;c[f]=r*Math.cos(u),c[f+1]=r*Math.sin(u),l[f]=c[f],l[f+1]=-c[f+1]}this._slicedChirpBuffer=c.subarray(t,s),this._f=new P2FFT(a>>1),this._f.transform(this._chirpBuffer,l)}_transform(e,t,s){const a=this._buffer1,c=this._buffer2,l=this._outBuffer1,_=this._outBuffer2,m=this._chirpBuffer,d=this._slicedChirpBuffer,h=this._a;if(s)for(let i=0;i<d.length;i+=2){const r=i+1,u=i>>1,f=t[u];a[i]=f*d[i],a[r]=f*d[r]}else for(let i=0;i<d.length;i+=2){const r=i+1;a[i]=t[i]*d[i]-t[r]*d[r],a[r]=t[i]*d[r]+t[r]*d[i]}this._f.transform(l,a);for(let i=0;i<m.length;i+=2){const r=i+1;c[i]=l[i]*m[i]-l[r]*m[r],c[r]=l[i]*m[r]+l[r]*m[i]}this._f.inverseTransform(_,c);for(let i=0;i<_.length;i+=2){const r=_[i+h],u=_[i+h+1],f=d[i],g=d[i+1];e[i]=r*f-u*g,e[i+1]=r*g+u*f}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class FFT{constructor(e){this.fft_length=e,this.isPowerOfTwo=isPowerOfTwo(e),this.isPowerOfTwo?(this.fft=new P2FFT(e),this.outputBufferSize=2*e):(this.fft=new NP2FFT(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function medianFilter(n,e){if(e%2===0||e<=0)throw new Error("Window size must be a positive odd number");const t=new n.constructor(n.length),s=new n.constructor(e),a=Math.floor(e/2);for(let c=0;c<n.length;++c){let l=0;for(let _=-a;_<=a;++_){let m=c+_;m<0?m=Math.abs(m):m>=n.length&&(m=2*(n.length-1)-m),s[l++]=n[m]}s.sort(),t[c]=s[a]}return t}function round(n,e){const t=Math.pow(10,e);return Math.round(n*t)/t}function bankers_round(n){const e=Math.round(n);return Math.abs(n)%1===.5?e%2===0?e:e-1:e}const DataTypeMap=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),ONNXTensor$1=ONNX.Tensor;class Tensor{dims;type;data;size;constructor(...e){return e[0]instanceof ONNXTensor$1?Object.assign(this,e[0]):Object.assign(this,new ONNXTensor$1(e[0],e[1],e[2])),new Proxy(this,{get:(t,s)=>{if(typeof s=="string"){let a=Number(s);if(Number.isInteger(a))return t._getitem(a)}return t[s]},set:(t,s,a)=>t[s]=a})}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const s=t.reduce((a,c)=>a*c);for(let a=0;a<e;++a)yield this._subarray(a,s,t)}else yield*this.data}_getitem(e){const[t,...s]=this.dims;if(e=safeIndex(e,t),s.length>0){const a=s.reduce((c,l)=>c*l);return this._subarray(e,a,s)}else return new Tensor(this.type,[this.data[e]],s)}indexOf(e){for(let t=0;t<this.data.length;++t)if(this.data[t]==e)return t;return-1}_subarray(e,t,s){const a=e*t,c=(e+1)*t,l="subarray"in this.data?this.data.subarray(a,c):this.data.slice(a,c);return new Tensor(this.type,l,s)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return reshape(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let e=0;e<this.data.length;++e)this.data[e]=1/(1+Math.exp(-this.data[e]));return this}mul(e){return this.clone().mul_(e)}mul_(e){for(let t=0;t<this.data.length;++t)this.data[t]*=e;return this}add(e){return this.clone().add_(e)}add_(e){for(let t=0;t<this.data.length;++t)this.data[t]+=e;return this}clone(){return new Tensor(this.type,this.data.slice(),this.dims.slice())}slice(...e){let t=[],s=[];for(let m=0;m<this.dims.length;++m){let d=e[m];if(d==null)s.push([0,this.dims[m]]),t.push(this.dims[m]);else if(typeof d=="number")d=safeIndex(d,this.dims[m],m),s.push([d,d+1]);else if(Array.isArray(d)&&d.length===2){if(d[0]>d[1])throw new Error(`Invalid slice: ${d}`);let h=[Math.max(d[0],0),Math.min(d[1],this.dims[m])];s.push(h),t.push(h[1]-h[0])}else throw new Error(`Invalid slice: ${d}`)}let a=s.map(([m,d])=>d-m),c=a.reduce((m,d)=>m*d),l=new this.data.constructor(c);const _=this.stride();for(let m=0;m<c;++m){let d=0;for(let h=a.length-1,i=m;h>=0;--h){const r=a[h];d+=(i%r+s[h][0])*_[h],i=Math.floor(i/r)}l[m]=this.data[d]}return new Tensor(this.type,l,t)}permute(...e){return permute(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,s=!1){if(e==="fro")e=2;else if(typeof e=="string")throw Error(`Unsupported norm: ${e}`);if(t===null){let l=this.data.reduce((_,m)=>_+m**e,0)**(1/e);return new Tensor(this.type,[l],[])}t=safeIndex(t,this.dims.length);const a=this.dims.slice();a[t]=1;const c=new this.data.constructor(this.data.length/this.dims[t]);for(let l=0;l<this.data.length;++l){let _=0;for(let m=this.dims.length-1,d=l,h=1;m>=0;--m){const i=this.dims[m];if(m!==t){const r=d%i;_+=r*h,h*=a[m]}d=Math.floor(d/i)}c[_]+=this.data[l]**e}if(e!==1)for(let l=0;l<c.length;++l)c[l]=c[l]**(1/e);return s||a.splice(t,1),new Tensor(this.type,c,a)}normalize_(e=2,t=1){t=safeIndex(t,this.dims.length);const s=this.norm(e,t,!0);for(let a=0;a<this.data.length;++a){let c=0;for(let l=this.dims.length-1,_=a,m=1;l>=0;--l){const d=this.dims[l];if(l!==t){const h=_%d;c+=h*m,m*=this.dims[l]}_=Math.floor(_/d)}this.data[a]/=s.data[c]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return dimsToStride(this.dims)}squeeze(e=null){return new Tensor(this.type,this.data,calc_squeeze_dims(this.dims,e))}squeeze_(e=null){return this.dims=calc_squeeze_dims(this.dims,e),this}unsqueeze(e=null){return new Tensor(this.type,this.data,calc_unsqueeze_dims(this.dims,e))}unsqueeze_(e=null){return this.dims=calc_unsqueeze_dims(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let s=this.dims.slice(0,e),a=this.dims.slice(e,t+1),c=this.dims.slice(t+1);return this.dims=[...s,a.reduce((l,_)=>l*_,1),...c],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let s=0;s<e.length;++s)if(e[s]===-1){if(t!==-1)throw new Error("Only one dimension can be inferred");t=s}if(t!==-1){const s=e.reduce((a,c,l)=>l!==t?a*c:a,1);e[t]=this.data.length/s}return new Tensor(this.type,this.data,e)}neg_(){for(let e=0;e<this.data.length;++e)this.data[e]=-this.data[e];return this}neg(){return this.clone().neg_()}clamp_(e,t){for(let s=0;s<this.data.length;++s)this.data[s]=Math.min(Math.max(this.data[s],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){for(let e=0;e<this.data.length;++e)this.data[e]=Math.round(this.data[e]);return this}round(){return this.clone().round_()}to(e){if(this.type===e)return this;if(!DataTypeMap.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);return new Tensor(e,DataTypeMap[e].from(this.data),this.dims)}}function reshape(n,e){const t=n.length,s=e.reduce((c,l)=>c*l);if(t!==s)throw Error(`cannot reshape array of size ${t} into shape (${e})`);let a=n;for(let c=e.length-1;c>=0;c--)a=a.reduce((l,_)=>{let m=l[l.length-1];return m.length<e[c]?m.push(_):l.push([_]),l},[[]]);return a[0]}function permute(n,e){const[t,s]=permute_data(n.data,n.dims,e);return new Tensor(n.type,t,s)}function interpolate(n,[e,t],s="bilinear",a=!1){const c=n.dims.at(-3)??1,l=n.dims.at(-2),_=n.dims.at(-1);let m=interpolate_data(n.data,[c,l,_],[e,t],s,a);return new Tensor(n.type,m,[c,e,t])}function mean_pooling(n,e){let t=[n.dims[0],n.dims[2]],s=new n.data.constructor(t[0]*t[1]),[a,c,l]=n.dims,_=0;for(let m=0;m<a;++m){let d=m*l*c;for(let h=0;h<l;++h){let i=0,r=0,u=m*c,f=d+h;for(let w=0;w<c;++w){let y=Number(e.data[u+w]);r+=y,i+=n.data[f+w*l]*y}let g=i/r;s[_++]=g}}return new Tensor(n.type,s,t)}function calc_squeeze_dims(n,e){return n=n.slice(),e===null?n=n.filter(t=>t!==1):typeof e=="number"?n[e]===1&&n.splice(e,1):Array.isArray(e)&&(n=n.filter((t,s)=>t!==1||!e.includes(s))),n}function calc_unsqueeze_dims(n,e){return e=safeIndex(e,n.length+1),n=n.slice(),n.splice(e,0,1),n}function safeIndex(n,e,t=null){if(n<-e||n>=e)throw new Error(`IndexError: index ${n} is out of bounds for dimension${t===null?"":" "+t} with size ${e}`);return n<0&&(n=(n%e+e)%e),n}function cat(n,e=0){e=safeIndex(e,n[0].dims.length);const t=n[0].dims.slice();t[e]=n.reduce((l,_)=>l+_.dims[e],0);const s=t.reduce((l,_)=>l*_,1),a=new n[0].data.constructor(s),c=n[0].type;if(e===0){let l=0;for(let _ of n)a.set(_.data,l),l+=_.data.length}else{let l=0;for(let _=0;_<n.length;++_){let m=n[_];for(let d=0;d<m.data.length;++d){let h=0;for(let i=m.dims.length-1,r=d,u=1;i>=0;--i){const f=m.dims[i];let g=r%f;i===e&&(g+=l),h+=g*u,u*=t[i],r=Math.floor(r/f)}a[h]=m.data[d]}l+=m.dims[e]}}return new Tensor(c,a,t)}function stack(n,e=0){return cat(n.map(t=>t.unsqueeze(e)),e)}function std_mean(n,e=null,t=1,s=!1){if(e===null){const d=n.data.reduce((u,f)=>u+f,0)/n.data.length,h=Math.sqrt(n.data.reduce((u,f)=>u+(f-d)**2,0)/(n.data.length-t)),i=new Tensor(n.type,[d],[]);return[new Tensor(n.type,[h],[]),i]}e=safeIndex(e,n.dims.length);const a=mean(n,e,s),c=n.dims.slice();c[e]=1;const l=new n.data.constructor(n.data.length/n.dims[e]);for(let m=0;m<n.data.length;++m){let d=0;for(let h=n.dims.length-1,i=m,r=1;h>=0;--h){const u=n.dims[h];if(h!==e){const f=i%u;d+=f*r,r*=c[h]}i=Math.floor(i/u)}l[d]+=(n.data[m]-a.data[d])**2}for(let m=0;m<l.length;++m)l[m]=Math.sqrt(l[m]/(n.dims[e]-t));return s||c.splice(e,1),[new Tensor(n.type,l,c),a]}function mean(n,e=null,t=!1){if(e===null){let c=n.data.reduce((l,_)=>l+_,0);return new Tensor(n.type,[c/n.data.length],[])}e=safeIndex(e,n.dims.length);const s=n.dims.slice();s[e]=1;const a=new n.data.constructor(n.data.length/n.dims[e]);for(let c=0;c<n.data.length;++c){let l=0;for(let _=n.dims.length-1,m=c,d=1;_>=0;--_){const h=n.dims[_];if(_!==e){const i=m%h;l+=i*d,d*=s[_]}m=Math.floor(m/h)}a[l]+=n.data[c]}if(n.dims[e]!==1)for(let c=0;c<a.length;++c)a[c]=a[c]/n.dims[e];return t||s.splice(e,1),new Tensor(n.type,a,s)}function dynamicTimeWarping(n){const[e,t]=n.dims,s=[e+1,t+1],a=new Tensor("float32",new Float32Array(s[0]*s[1]).fill(1/0),s),c=new Tensor("float32",new Float32Array(s[0]*s[1]).fill(-1),s);a[0].data[0]=0;for(let h=1;h<t+1;++h)for(let i=1;i<e+1;++i){const r=a[i-1][h-1].item(),u=a[i-1][h].item(),f=a[i][h-1].item();let g,w;r<u&&r<f?(g=r,w=0):u<r&&u<f?(g=u,w=1):(g=f,w=2),a[i].data[h]=n[i-1][h-1].item()+g,c[i].data[h]=w}let l=e,_=t;c.data.fill(2,0,s[1]);for(let h=0;h<s[0];++h)c[h].data[0]=1;let m=[],d=[];for(;l>0||_>0;)switch(m.push(l-1),d.push(_-1),c[l][_].item()){case 0:--l,--_;break;case 1:--l;break;case 2:--_;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${l}, ${_}]. Please file a bug report.`)}return m.reverse(),d.reverse(),[m,d]}function dimsToStride(n){const e=new Array(n.length);for(let t=n.length-1,s=1;t>=0;--t)e[t]=s,s*=n[t];return e}function ones(n){const e=n.reduce((t,s)=>t*s,1);return new Tensor("int64",new BigInt64Array(e).fill(1n),n)}function ones_like(n){return ones(n.dims)}function quantize_embeddings(n,e){if(n.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(n.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(e))throw new Error("The precision must be either 'binary' or 'ubinary'");const t=e==="binary",s=t?"int8":"uint8",a=t?Int8Array:Uint8Array,c=n.data,l=new a(c.length/8);for(let _=0;_<c.length;++_){const m=c[_]>0?1:0,d=Math.floor(_/8),h=_%8;l[d]|=m<<7-h,t&&h===0&&(l[d]-=128)}return new Tensor(s,l,[n.dims[0],n.dims[1]/8])}class PriorityQueue{constructor(e=(t,s)=>t>s){this._heap=[],this._comparator=e}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)this._heap.push(t),this._siftUp();return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return(e<<1)+1}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const s=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=s}_siftUp(){let e=this.size-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}}class CharTrie{constructor(){this.root=CharTrieNode.default()}extend(e){for(let t of e)this.push(t)}push(e){let t=this.root;for(let s of e){let a=t.children.get(s);a===void 0&&(a=CharTrieNode.default(),t.children.set(s,a)),t=a}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root,s="";for(let a=0;a<e.length&&t!==void 0;++a){const c=e[a];s+=c,t=t.children.get(c),t!==void 0&&t.isLeaf&&(yield s)}}}class CharTrieNode{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new CharTrieNode(!1,new Map)}}class TokenLattice{constructor(e,t,s){this.sentence=e,this.len=e.length,this.bosTokenId=t,this.eosTokenId=s,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const a=new TokenLatticeNode(this.bosTokenId,0,0,0,0),c=new TokenLatticeNode(this.eosTokenId,1,this.len,0,0);this.nodes.push(a.clone()),this.nodes.push(c.clone()),this.beginNodes[this.len].push(c),this.endNodes[0].push(a)}insert(e,t,s,a){const c=this.nodes.length,l=new TokenLatticeNode(a,c,e,t,s);this.beginNodes[e].push(l),this.endNodes[e+t].push(l),this.nodes.push(l)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(this.beginNodes[t].length==0)return[];for(let _ of this.beginNodes[t]){_.prev=null;let m=0,d=null;for(let h of this.endNodes[t]){const i=h.backtraceScore+_.score;(d===null||i>m)&&(d=h.clone(),m=i)}if(d!==null)_.prev=d,_.backtraceScore=m;else return[]}++t}const s=[],c=this.beginNodes[e][0].prev;if(c===null)return[];let l=c.clone();for(;l.prev!==null;)s.push(l.clone()),l=l.clone().prev.clone();return s.reverse(),s}piece(e){return this.sentence.slice(e.pos,e.pos+e.length)}tokens(){return this.viterbi().map(t=>this.piece(t))}tokenIds(){return this.viterbi().map(t=>t.tokenId)}}class TokenLatticeNode{constructor(e,t,s,a,c){this.tokenId=e,this.nodeId=t,this.pos=s,this.length=a,this.score=c,this.prev=null,this.backtraceScore=0}clone(){const e=new TokenLatticeNode(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var TOKEN_TYPES=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),KEYWORDS=Object.freeze({set:TOKEN_TYPES.Set,for:TOKEN_TYPES.For,in:TOKEN_TYPES.In,is:TOKEN_TYPES.Is,if:TOKEN_TYPES.If,else:TOKEN_TYPES.Else,endif:TOKEN_TYPES.EndIf,elif:TOKEN_TYPES.ElseIf,endfor:TOKEN_TYPES.EndFor,and:TOKEN_TYPES.And,or:TOKEN_TYPES.Or,not:TOKEN_TYPES.Not,"not in":TOKEN_TYPES.NotIn,true:TOKEN_TYPES.BooleanLiteral,false:TOKEN_TYPES.BooleanLiteral}),Token=class{constructor(n,e){this.value=n,this.type=e}};function isWord(n){return/\w/.test(n)}function isInteger(n){return/[0-9]/.test(n)}var ORDERED_MAPPING_TABLE=[["{%",TOKEN_TYPES.OpenStatement],["%}",TOKEN_TYPES.CloseStatement],["{{",TOKEN_TYPES.OpenExpression],["}}",TOKEN_TYPES.CloseExpression],["(",TOKEN_TYPES.OpenParen],[")",TOKEN_TYPES.CloseParen],["{",TOKEN_TYPES.OpenCurlyBracket],["}",TOKEN_TYPES.CloseCurlyBracket],["[",TOKEN_TYPES.OpenSquareBracket],["]",TOKEN_TYPES.CloseSquareBracket],[",",TOKEN_TYPES.Comma],[".",TOKEN_TYPES.Dot],[":",TOKEN_TYPES.Colon],["|",TOKEN_TYPES.Pipe],["<=",TOKEN_TYPES.ComparisonBinaryOperator],[">=",TOKEN_TYPES.ComparisonBinaryOperator],["==",TOKEN_TYPES.ComparisonBinaryOperator],["!=",TOKEN_TYPES.ComparisonBinaryOperator],["<",TOKEN_TYPES.ComparisonBinaryOperator],[">",TOKEN_TYPES.ComparisonBinaryOperator],["+",TOKEN_TYPES.AdditiveBinaryOperator],["-",TOKEN_TYPES.AdditiveBinaryOperator],["*",TOKEN_TYPES.MultiplicativeBinaryOperator],["/",TOKEN_TYPES.MultiplicativeBinaryOperator],["%",TOKEN_TYPES.MultiplicativeBinaryOperator],["=",TOKEN_TYPES.Equals]],ESCAPE_CHARACTERS=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function preprocess(n,e={}){return n.endsWith(`
`)&&(n=n.slice(0,-1)),n=n.replace(/{#.*?#}/gs,"{##}"),e.lstrip_blocks&&(n=n.replace(/^[ \t]*({[#%])/gm,"$1")),e.trim_blocks&&(n=n.replace(/([#%]})\n/g,"$1")),n.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function tokenize(n,e={}){const t=[],s=preprocess(n,e);let a=0;const c=l=>{let _="";for(;l(s[a]);){if(s[a]==="\\"){if(++a,a>=s.length)throw new SyntaxError("Unexpected end of input");const m=s[a++],d=ESCAPE_CHARACTERS.get(m);if(d===void 0)throw new SyntaxError(`Unexpected escaped character: ${m}`);_+=d;continue}if(_+=s[a++],a>=s.length)throw new SyntaxError("Unexpected end of input")}return _};e:for(;a<s.length;){const l=t.at(-1)?.type;if(l===void 0||l===TOKEN_TYPES.CloseStatement||l===TOKEN_TYPES.CloseExpression){let m="";for(;a<s.length&&!(s[a]==="{"&&(s[a+1]==="%"||s[a+1]==="{"));)m+=s[a++];if(m.length>0){t.push(new Token(m,TOKEN_TYPES.Text));continue}}c(m=>/\s/.test(m));const _=s[a];if(_==="-"||_==="+"){const m=t.at(-1)?.type;if(m===TOKEN_TYPES.Text||m===void 0)throw new SyntaxError(`Unexpected character: ${_}`);switch(m){case TOKEN_TYPES.Identifier:case TOKEN_TYPES.NumericLiteral:case TOKEN_TYPES.BooleanLiteral:case TOKEN_TYPES.StringLiteral:case TOKEN_TYPES.CloseParen:case TOKEN_TYPES.CloseSquareBracket:break;default:{++a;const d=c(isInteger);t.push(new Token(`${_}${d}`,d.length>0?TOKEN_TYPES.NumericLiteral:TOKEN_TYPES.UnaryOperator));continue}}}for(const[m,d]of ORDERED_MAPPING_TABLE)if(s.slice(a,a+m.length)===m){t.push(new Token(m,d)),a+=m.length;continue e}if(_==="'"||_==='"'){++a;const m=c(d=>d!==_);t.push(new Token(m,TOKEN_TYPES.StringLiteral)),++a;continue}if(isInteger(_)){const m=c(isInteger);t.push(new Token(m,TOKEN_TYPES.NumericLiteral));continue}if(isWord(_)){const m=c(isWord),d=Object.hasOwn(KEYWORDS,m)?KEYWORDS[m]:TOKEN_TYPES.Identifier;d===TOKEN_TYPES.In&&t.at(-1)?.type===TOKEN_TYPES.Not?(t.pop(),t.push(new Token("not in",TOKEN_TYPES.NotIn))):t.push(new Token(m,d));continue}throw new SyntaxError(`Unexpected character: ${_}`)}return t}var Statement=class{type="Statement"},Program=class extends Statement{constructor(n){super(),this.body=n}type="Program"},If=class extends Statement{constructor(n,e,t){super(),this.test=n,this.body=e,this.alternate=t}type="If"},For=class extends Statement{constructor(n,e,t){super(),this.loopvar=n,this.iterable=e,this.body=t}type="For"},SetStatement=class extends Statement{constructor(n,e){super(),this.assignee=n,this.value=e}type="Set"},Expression=class extends Statement{type="Expression"},MemberExpression=class extends Expression{constructor(n,e,t){super(),this.object=n,this.property=e,this.computed=t}type="MemberExpression"},CallExpression=class extends Expression{constructor(n,e){super(),this.callee=n,this.args=e}type="CallExpression"},Identifier=class extends Expression{constructor(n){super(),this.value=n}type="Identifier"},Literal=class extends Expression{constructor(n){super(),this.value=n}type="Literal"},NumericLiteral=class extends Literal{type="NumericLiteral"},StringLiteral=class extends Literal{type="StringLiteral"},BooleanLiteral=class extends Literal{type="BooleanLiteral"},ArrayLiteral=class extends Literal{type="ArrayLiteral"},TupleLiteral=class extends Literal{type="TupleLiteral"},ObjectLiteral=class extends Literal{type="ObjectLiteral"},BinaryExpression=class extends Expression{constructor(n,e,t){super(),this.operator=n,this.left=e,this.right=t}type="BinaryExpression"},FilterExpression=class extends Expression{constructor(n,e){super(),this.operand=n,this.filter=e}type="FilterExpression"},TestExpression=class extends Expression{constructor(n,e,t){super(),this.operand=n,this.negate=e,this.test=t}type="TestExpression"},UnaryExpression=class extends Expression{constructor(n,e){super(),this.operator=n,this.argument=e}type="UnaryExpression"},SliceExpression=class extends Expression{constructor(n=void 0,e=void 0,t=void 0){super(),this.start=n,this.stop=e,this.step=t}type="SliceExpression"},KeywordArgumentExpression=class extends Expression{constructor(n,e){super(),this.key=n,this.value=e}type="KeywordArgumentExpression"};function parse(n){const e=new Program([]);let t=0;function s(q,z){const H=n[t++];if(!H||H.type!==q)throw new Error(`Parser Error: ${z}. ${H.type} !== ${q}.`);return H}function a(){switch(n[t].type){case TOKEN_TYPES.Text:return _();case TOKEN_TYPES.OpenStatement:return m();case TOKEN_TYPES.OpenExpression:return d();default:throw new SyntaxError(`Unexpected token type: ${n[t].type}`)}}function c(...q){return t+q.length<=n.length&&q.some((z,H)=>z!==n[t+H].type)}function l(...q){return t+q.length<=n.length&&q.every((z,H)=>z===n[t+H].type)}function _(){return new StringLiteral(s(TOKEN_TYPES.Text,"Expected text token").value)}function m(){s(TOKEN_TYPES.OpenStatement,"Expected opening statement token");let q;switch(n[t].type){case TOKEN_TYPES.Set:++t,q=h(),s(TOKEN_TYPES.CloseStatement,"Expected closing statement token");break;case TOKEN_TYPES.If:++t,q=i(),s(TOKEN_TYPES.OpenStatement,"Expected {% token"),s(TOKEN_TYPES.EndIf,"Expected endif token"),s(TOKEN_TYPES.CloseStatement,"Expected %} token");break;case TOKEN_TYPES.For:++t,q=u(),s(TOKEN_TYPES.OpenStatement,"Expected {% token"),s(TOKEN_TYPES.EndFor,"Expected endfor token"),s(TOKEN_TYPES.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${n[t].type}`)}return q}function d(){s(TOKEN_TYPES.OpenExpression,"Expected opening expression token");const q=f();return s(TOKEN_TYPES.CloseExpression,"Expected closing expression token"),q}function h(){const q=f();if(l(TOKEN_TYPES.Equals)){++t;const z=h();return new SetStatement(q,z)}return q}function i(){const q=f();s(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const z=[],H=[];for(;!(n[t]?.type===TOKEN_TYPES.OpenStatement&&(n[t+1]?.type===TOKEN_TYPES.ElseIf||n[t+1]?.type===TOKEN_TYPES.Else||n[t+1]?.type===TOKEN_TYPES.EndIf));)z.push(a());if(n[t]?.type===TOKEN_TYPES.OpenStatement&&n[t+1]?.type!==TOKEN_TYPES.EndIf)if(++t,l(TOKEN_TYPES.ElseIf))s(TOKEN_TYPES.ElseIf,"Expected elseif token"),H.push(i());else for(s(TOKEN_TYPES.Else,"Expected else token"),s(TOKEN_TYPES.CloseStatement,"Expected closing statement token");!(n[t]?.type===TOKEN_TYPES.OpenStatement&&n[t+1]?.type===TOKEN_TYPES.EndIf);)H.push(a());return new If(q,z,H)}function r(q=!1){const z=q?te:f,H=[z()],he=l(TOKEN_TYPES.Comma);for(;he&&(++t,H.push(z()),!!l(TOKEN_TYPES.Comma)););return he?new TupleLiteral(H):H[0]}function u(){const q=r(!0);if(!(q instanceof Identifier||q instanceof TupleLiteral))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${q.type} instead`);s(TOKEN_TYPES.In,"Expected `in` keyword following loop variable");const z=f();s(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const H=[];for(;c(TOKEN_TYPES.OpenStatement,TOKEN_TYPES.EndFor);)H.push(a());return new For(q,z,H)}function f(){return g()}function g(){const q=w();if(l(TOKEN_TYPES.If)){++t;const z=w();s(TOKEN_TYPES.Else,"Expected else token");const H=w();return new If(z,[q],[H])}return q}function w(){let q=y();for(;l(TOKEN_TYPES.Or);){const z=n[t];++t;const H=y();q=new BinaryExpression(z,q,H)}return q}function y(){let q=x();for(;l(TOKEN_TYPES.And);){const z=n[t];++t;const H=x();q=new BinaryExpression(z,q,H)}return q}function x(){let q;for(;l(TOKEN_TYPES.Not);){const z=n[t];++t;const H=x();q=new UnaryExpression(z,H)}return q??S()}function S(){let q=T();for(;l(TOKEN_TYPES.ComparisonBinaryOperator)||l(TOKEN_TYPES.In)||l(TOKEN_TYPES.NotIn);){const z=n[t];++t;const H=T();q=new BinaryExpression(z,q,H)}return q}function T(){let q=Y();for(;l(TOKEN_TYPES.AdditiveBinaryOperator);){const z=n[t];++t;const H=Y();q=new BinaryExpression(z,q,H)}return q}function E(){const q=R();return l(TOKEN_TYPES.OpenParen)?A(q):q}function A(q){let z=new CallExpression(q,C());return l(TOKEN_TYPES.OpenParen)&&(z=A(z)),z}function C(){s(TOKEN_TYPES.OpenParen,"Expected opening parenthesis for arguments list");const q=I();return s(TOKEN_TYPES.CloseParen,"Expected closing parenthesis for arguments list"),q}function I(){const q=[];for(;!l(TOKEN_TYPES.CloseParen);){let z=f();if(l(TOKEN_TYPES.Equals)){if(++t,!(z instanceof Identifier))throw new SyntaxError("Expected identifier for keyword argument");const H=f();z=new KeywordArgumentExpression(z,H)}q.push(z),l(TOKEN_TYPES.Comma)&&++t}return q}function D(){const q=[];let z=!1;for(;!l(TOKEN_TYPES.CloseSquareBracket);)l(TOKEN_TYPES.Colon)?(q.push(void 0),++t,z=!0):(q.push(f()),l(TOKEN_TYPES.Colon)&&(++t,z=!0));if(q.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(z){if(q.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new SliceExpression(...q)}return q[0]}function R(){let q=te();for(;l(TOKEN_TYPES.Dot)||l(TOKEN_TYPES.OpenSquareBracket);){const z=n[t];++t;let H;const he=z.type!==TOKEN_TYPES.Dot;if(he)H=D(),s(TOKEN_TYPES.CloseSquareBracket,"Expected closing square bracket");else if(H=te(),H.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");q=new MemberExpression(q,H,he)}return q}function Y(){let q=re();for(;l(TOKEN_TYPES.MultiplicativeBinaryOperator);){const z=n[t];++t;const H=re();q=new BinaryExpression(z,q,H)}return q}function re(){let q=G();for(;l(TOKEN_TYPES.Is);){++t;const z=l(TOKEN_TYPES.Not);z&&++t;let H=te();if(H instanceof BooleanLiteral&&(H=new Identifier(H.value.toString())),!(H instanceof Identifier))throw new SyntaxError("Expected identifier for the test");q=new TestExpression(q,z,H)}return q}function G(){let q=E();for(;l(TOKEN_TYPES.Pipe);){++t;let z=te();if(!(z instanceof Identifier))throw new SyntaxError("Expected identifier for the filter");l(TOKEN_TYPES.OpenParen)&&(z=A(z)),q=new FilterExpression(q,z)}return q}function te(){const q=n[t];switch(q.type){case TOKEN_TYPES.NumericLiteral:return++t,new NumericLiteral(Number(q.value));case TOKEN_TYPES.StringLiteral:return++t,new StringLiteral(q.value);case TOKEN_TYPES.BooleanLiteral:return++t,new BooleanLiteral(q.value==="true");case TOKEN_TYPES.Identifier:return++t,new Identifier(q.value);case TOKEN_TYPES.OpenParen:{++t;const z=r();if(n[t].type!==TOKEN_TYPES.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${n[t].type} instead`);return++t,z}case TOKEN_TYPES.OpenSquareBracket:{++t;const z=[];for(;!l(TOKEN_TYPES.CloseSquareBracket);)z.push(f()),l(TOKEN_TYPES.Comma)&&++t;return++t,new ArrayLiteral(z)}case TOKEN_TYPES.OpenCurlyBracket:{++t;const z=new Map;for(;!l(TOKEN_TYPES.CloseCurlyBracket);){const H=f();s(TOKEN_TYPES.Colon,"Expected colon between key and value in object literal");const he=f();z.set(H,he),l(TOKEN_TYPES.Comma)&&++t}return++t,new ObjectLiteral(z)}default:throw new SyntaxError(`Unexpected token: ${q.type}`)}}for(;t<n.length;)e.body.push(a());return e}function range(n,e,t=1){e===void 0&&(e=n,n=0);const s=[];for(let a=n;a<e;a+=t)s.push(a);return s}function slice(n,e,t,s=1){const a=Math.sign(s);a>=0?(e=(e??=0)<0?Math.max(n.length+e,0):Math.min(e,n.length),t=(t??=n.length)<0?Math.max(n.length+t,0):Math.min(t,n.length)):(e=(e??=n.length-1)<0?Math.max(n.length+e,-1):Math.min(e,n.length-1),t=(t??=-1)<-1?Math.max(n.length+t,-1):Math.min(t,n.length-1));const c=[];for(let l=e;a*l<a*t;l+=s)c.push(n[l]);return c}function titleCase(n){return n.replace(/\b\w/g,e=>e.toUpperCase())}var RuntimeValue=class{type="RuntimeValue";value;builtins=new Map;constructor(n=void 0){this.value=n}__bool__(){return new BooleanValue(!!this.value)}},NumericValue=class extends RuntimeValue{type="NumericValue"},StringValue=class extends RuntimeValue{type="StringValue";builtins=new Map([["upper",new FunctionValue(()=>new StringValue(this.value.toUpperCase()))],["lower",new FunctionValue(()=>new StringValue(this.value.toLowerCase()))],["strip",new FunctionValue(()=>new StringValue(this.value.trim()))],["title",new FunctionValue(()=>new StringValue(titleCase(this.value)))],["length",new NumericValue(this.value.length)]])},BooleanValue=class extends RuntimeValue{type="BooleanValue"},ObjectValue=class extends RuntimeValue{type="ObjectValue";__bool__(){return new BooleanValue(this.value.size>0)}builtins=new Map([["get",new FunctionValue(([n,e])=>{if(!(n instanceof StringValue))throw new Error(`Object key must be a string: got ${n.type}`);return this.value.get(n.value)??e??new NullValue})],["items",new FunctionValue(()=>new ArrayValue(Array.from(this.value.entries()).map(([n,e])=>new ArrayValue([new StringValue(n),e]))))]])},ArrayValue=class extends RuntimeValue{type="ArrayValue";builtins=new Map([["length",new NumericValue(this.value.length)]]);__bool__(){return new BooleanValue(this.value.length>0)}},TupleValue=class extends ArrayValue{type="TupleValue"},FunctionValue=class extends RuntimeValue{type="FunctionValue"},NullValue=class extends RuntimeValue{type="NullValue"},UndefinedValue=class extends RuntimeValue{type="UndefinedValue"},Environment=class{constructor(n){this.parent=n}variables=new Map([["namespace",new FunctionValue(n=>{if(n.length===0)return new ObjectValue(new Map);if(n.length!==1||!(n[0]instanceof ObjectValue))throw new Error("`namespace` expects either zero arguments or a single object argument");return n[0]})]]);tests=new Map([["boolean",n=>n.type==="BooleanValue"],["callable",n=>n instanceof FunctionValue],["odd",n=>{if(n.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${n.type}`);return n.value%2!==0}],["even",n=>{if(n.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${n.type}`);return n.value%2===0}],["false",n=>n.type==="BooleanValue"&&!n.value],["true",n=>n.type==="BooleanValue"&&n.value],["number",n=>n.type==="NumericValue"],["integer",n=>n.type==="NumericValue"&&Number.isInteger(n.value)],["iterable",n=>n instanceof ArrayValue||n instanceof StringValue],["lower",n=>{const e=n.value;return n.type==="StringValue"&&e===e.toLowerCase()}],["upper",n=>{const e=n.value;return n.type==="StringValue"&&e===e.toUpperCase()}],["none",n=>n.type==="NullValue"],["defined",n=>n.type!=="UndefinedValue"],["undefined",n=>n.type==="UndefinedValue"],["equalto",(n,e)=>n.value===e.value]]);set(n,e){return this.declareVariable(n,convertToRuntimeValues(e))}declareVariable(n,e){if(this.variables.has(n))throw new SyntaxError(`Variable already declared: ${n}`);return this.variables.set(n,e),e}setVariable(n,e){return this.variables.set(n,e),e}resolve(n){if(this.variables.has(n))return this;if(this.parent)return this.parent.resolve(n);throw new Error(`Unknown variable: ${n}`)}lookupVariable(n){try{return this.resolve(n).variables.get(n)??new UndefinedValue}catch{return new UndefinedValue}}},Interpreter=class{global;constructor(n){this.global=n??new Environment}run(n){return this.evaluate(n,this.global)}evaluateBinaryExpression(n,e){const t=this.evaluate(n.left,e);switch(n.operator.value){case"and":return t.__bool__().value?this.evaluate(n.right,e):t;case"or":return t.__bool__().value?t:this.evaluate(n.right,e)}const s=this.evaluate(n.right,e);switch(n.operator.value){case"==":return new BooleanValue(t.value==s.value);case"!=":return new BooleanValue(t.value!=s.value)}if(t instanceof UndefinedValue||s instanceof UndefinedValue)throw new Error("Cannot perform operation on undefined values");if(t instanceof NullValue||s instanceof NullValue)throw new Error("Cannot perform operation on null values");if(t instanceof NumericValue&&s instanceof NumericValue)switch(n.operator.value){case"+":return new NumericValue(t.value+s.value);case"-":return new NumericValue(t.value-s.value);case"*":return new NumericValue(t.value*s.value);case"/":return new NumericValue(t.value/s.value);case"%":return new NumericValue(t.value%s.value);case"<":return new BooleanValue(t.value<s.value);case">":return new BooleanValue(t.value>s.value);case">=":return new BooleanValue(t.value>=s.value);case"<=":return new BooleanValue(t.value<=s.value)}else if(t instanceof ArrayValue&&s instanceof ArrayValue)switch(n.operator.value){case"+":return new ArrayValue(t.value.concat(s.value))}else if(s instanceof ArrayValue){const a=s.value.find(c=>c.value===t.value)!==void 0;switch(n.operator.value){case"in":return new BooleanValue(a);case"not in":return new BooleanValue(!a)}}if(t instanceof StringValue||s instanceof StringValue)switch(n.operator.value){case"+":return new StringValue(t.value.toString()+s.value.toString())}if(t instanceof StringValue&&s instanceof StringValue)switch(n.operator.value){case"in":return new BooleanValue(s.value.includes(t.value));case"not in":return new BooleanValue(!s.value.includes(t.value))}if(t instanceof StringValue&&s instanceof ObjectValue)switch(n.operator.value){case"in":return new BooleanValue(s.value.has(t.value));case"not in":return new BooleanValue(!s.value.has(t.value))}throw new SyntaxError(`Unknown operator "${n.operator.value}" between ${t.type} and ${s.type}`)}evaluateFilterExpression(n,e){const t=this.evaluate(n.operand,e);if(n.filter.type==="Identifier"){const s=n.filter;if(t instanceof ArrayValue)switch(s.value){case"list":return t;case"first":return t.value[0];case"last":return t.value[t.value.length-1];case"length":return new NumericValue(t.value.length);case"reverse":return new ArrayValue(t.value.reverse());case"sort":return new ArrayValue(t.value.sort((a,c)=>{if(a.type!==c.type)throw new Error(`Cannot compare different types: ${a.type} and ${c.type}`);switch(a.type){case"NumericValue":return a.value-c.value;case"StringValue":return a.value.localeCompare(c.value);default:throw new Error(`Cannot compare type: ${a.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${s.value}`)}else if(t instanceof StringValue)switch(s.value){case"length":return new NumericValue(t.value.length);case"upper":return new StringValue(t.value.toUpperCase());case"lower":return new StringValue(t.value.toLowerCase());case"title":return new StringValue(titleCase(t.value));case"capitalize":return new StringValue(t.value.charAt(0).toUpperCase()+t.value.slice(1));case"trim":return new StringValue(t.value.trim());default:throw new Error(`Unknown StringValue filter: ${s.value}`)}else if(t instanceof NumericValue)switch(s.value){case"abs":return new NumericValue(Math.abs(t.value));default:throw new Error(`Unknown NumericValue filter: ${s.value}`)}else if(t instanceof ObjectValue)switch(s.value){case"items":return new ArrayValue(Array.from(t.value.entries()).map(([a,c])=>new ArrayValue([new StringValue(a),c])));case"length":return new NumericValue(t.value.size);default:throw new Error(`Unknown ObjectValue filter: ${s.value}`)}throw new Error(`Cannot apply filter "${s.value}" to type: ${t.type}`)}else if(n.filter.type==="CallExpression"){const s=n.filter;if(s.callee.type!=="Identifier")throw new Error(`Unknown filter: ${s.callee.type}`);const a=s.callee.value;if(t instanceof ArrayValue){switch(a){case"selectattr":{if(t.value.some(h=>!(h instanceof ObjectValue)))throw new Error("`selectattr` can only be applied to array of objects");if(s.args.some(h=>h.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[c,l,_]=s.args.map(h=>this.evaluate(h,e));let m;if(l){const h=e.tests.get(l.value);if(!h)throw new Error(`Unknown test: ${l.value}`);m=h}else m=(...h)=>h[0].__bool__().value;const d=t.value.filter(h=>{const i=h.value.get(c.value);return i?m(i,_):!1});return new ArrayValue(d)}}throw new Error(`Unknown ArrayValue filter: ${a}`)}else throw new Error(`Cannot apply filter "${a}" to type: ${t.type}`)}throw new Error(`Unknown filter: ${n.filter.type}`)}evaluateTestExpression(n,e){const t=this.evaluate(n.operand,e),s=e.tests.get(n.test.value);if(!s)throw new Error(`Unknown test: ${n.test.value}`);const a=s(t);return new BooleanValue(n.negate?!a:a)}evaluateUnaryExpression(n,e){const t=this.evaluate(n.argument,e);switch(n.operator.value){case"not":return new BooleanValue(!t.value);default:throw new SyntaxError(`Unknown operator: ${n.operator.value}`)}}evalProgram(n,e){return this.evaluateBlock(n.body,e)}evaluateBlock(n,e){let t="";for(const s of n){const a=this.evaluate(s,e);a.type!=="NullValue"&&a.type!=="UndefinedValue"&&(t+=a.value)}return new StringValue(t)}evaluateIdentifier(n,e){return e.lookupVariable(n.value)}evaluateCallExpression(n,e){const t=[],s=new Map;for(const c of n.args)if(c.type==="KeywordArgumentExpression"){const l=c;s.set(l.key.value,this.evaluate(l.value,e))}else t.push(this.evaluate(c,e));s.size>0&&t.push(new ObjectValue(s));const a=this.evaluate(n.callee,e);if(a.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${a.type}`);return a.value(t,e)}evaluateSliceExpression(n,e,t){if(!(n instanceof ArrayValue||n instanceof StringValue))throw new Error("Slice object must be an array or string");const s=this.evaluate(e.start,t),a=this.evaluate(e.stop,t),c=this.evaluate(e.step,t);if(!(s instanceof NumericValue||s instanceof UndefinedValue))throw new Error("Slice start must be numeric or undefined");if(!(a instanceof NumericValue||a instanceof UndefinedValue))throw new Error("Slice stop must be numeric or undefined");if(!(c instanceof NumericValue||c instanceof UndefinedValue))throw new Error("Slice step must be numeric or undefined");return n instanceof ArrayValue?new ArrayValue(slice(n.value,s.value,a.value,c.value)):new StringValue(slice(Array.from(n.value),s.value,a.value,c.value).join(""))}evaluateMemberExpression(n,e){const t=this.evaluate(n.object,e);let s;if(n.computed){if(n.property.type==="SliceExpression")return this.evaluateSliceExpression(t,n.property,e);s=this.evaluate(n.property,e)}else s=new StringValue(n.property.value);let a;if(t instanceof ObjectValue){if(!(s instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${s.type}`);a=t.value.get(s.value)??t.builtins.get(s.value)}else if(t instanceof ArrayValue||t instanceof StringValue)if(s instanceof NumericValue)a=t.value.at(s.value),t instanceof StringValue&&(a=new StringValue(t.value.at(s.value)));else if(s instanceof StringValue)a=t.builtins.get(s.value);else throw new Error(`Cannot access property with non-string/non-number: got ${s.type}`);else{if(!(s instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${s.type}`);a=t.builtins.get(s.value)}return a instanceof RuntimeValue?a:new UndefinedValue}evaluateSet(n,e){const t=this.evaluate(n.value,e);if(n.assignee.type==="Identifier"){const s=n.assignee.value;e.setVariable(s,t)}else if(n.assignee.type==="MemberExpression"){const s=n.assignee,a=this.evaluate(s.object,e);if(!(a instanceof ObjectValue))throw new Error("Cannot assign to member of non-object");if(s.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");a.value.set(s.property.value,t)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(n.assignee)}`);return new NullValue}evaluateIf(n,e){const t=this.evaluate(n.test,e);return this.evaluateBlock(t.__bool__().value?n.body:n.alternate,e)}evaluateFor(n,e){const t=new Environment(e),s=this.evaluate(n.iterable,t);if(!(s instanceof ArrayValue))throw new Error(`Expected iterable type in for loop: got ${s.type}`);let a="";for(let c=0;c<s.value.length;++c){const l=new Map([["index",new NumericValue(c+1)],["index0",new NumericValue(c)],["revindex",new NumericValue(s.value.length-c)],["revindex0",new NumericValue(s.value.length-c-1)],["first",new BooleanValue(c===0)],["last",new BooleanValue(c===s.value.length-1)],["length",new NumericValue(s.value.length)],["previtem",c>0?s.value[c-1]:new UndefinedValue],["nextitem",c<s.value.length-1?s.value[c+1]:new UndefinedValue]]);t.setVariable("loop",new ObjectValue(l));const _=s.value[c];if(n.loopvar.type==="Identifier")t.setVariable(n.loopvar.value,_);else if(n.loopvar.type==="TupleLiteral"){const d=n.loopvar;if(_.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${_.type}`);const h=_;if(d.value.length!==h.value.length)throw new Error(`Too ${d.value.length>h.value.length?"few":"many"} items to unpack`);for(let i=0;i<d.value.length;++i){if(d.value[i].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${d.value[i].type}`);t.setVariable(d.value[i].value,h.value[i])}}const m=this.evaluateBlock(n.body,t);a+=m.value}return new StringValue(a)}evaluate(n,e){if(n===void 0)return new UndefinedValue;switch(n.type){case"Program":return this.evalProgram(n,e);case"Set":return this.evaluateSet(n,e);case"If":return this.evaluateIf(n,e);case"For":return this.evaluateFor(n,e);case"NumericLiteral":return new NumericValue(Number(n.value));case"StringLiteral":return new StringValue(n.value);case"BooleanLiteral":return new BooleanValue(n.value);case"ArrayLiteral":return new ArrayValue(n.value.map(t=>this.evaluate(t,e)));case"TupleLiteral":return new TupleValue(n.value.map(t=>this.evaluate(t,e)));case"ObjectLiteral":{const t=new Map;for(const[s,a]of n.value){const c=this.evaluate(s,e);if(!(c instanceof StringValue))throw new Error(`Object keys must be strings: got ${c.type}`);t.set(c.value,this.evaluate(a,e))}return new ObjectValue(t)}case"Identifier":return this.evaluateIdentifier(n,e);case"CallExpression":return this.evaluateCallExpression(n,e);case"MemberExpression":return this.evaluateMemberExpression(n,e);case"UnaryExpression":return this.evaluateUnaryExpression(n,e);case"BinaryExpression":return this.evaluateBinaryExpression(n,e);case"FilterExpression":return this.evaluateFilterExpression(n,e);case"TestExpression":return this.evaluateTestExpression(n,e);default:throw new SyntaxError(`Unknown node type: ${n.type}`)}}};function convertToRuntimeValues(n){switch(typeof n){case"number":return new NumericValue(n);case"string":return new StringValue(n);case"boolean":return new BooleanValue(n);case"object":return n===null?new NullValue:Array.isArray(n)?new ArrayValue(n.map(convertToRuntimeValues)):new ObjectValue(new Map(Object.entries(n).map(([e,t])=>[e,convertToRuntimeValues(t)])));case"function":return new FunctionValue((e,t)=>{const s=n(...e.map(a=>a.value))??null;return convertToRuntimeValues(s)});default:throw new Error(`Cannot convert to runtime value: ${n}`)}}var Template=class{parsed;constructor(n){const e=tokenize(n,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=parse(e)}render(n){const e=new Environment;e.set("false",!1),e.set("true",!0),e.set("raise_exception",a=>{throw new Error(a)}),e.set("range",range);for(const[a,c]of Object.entries(n))e.set(a,c);return new Interpreter(e).run(this.parsed).value}};async function loadTokenizer(n,e){const t=await Promise.all([getModelJSON(n,"tokenizer.json",!0,e),getModelJSON(n,"tokenizer_config.json",!0,e)]);return e.legacy!==null&&(t[1].legacy=e.legacy),t}function regexSplit(n,e){const t=[];let s=0;for(const a of n.matchAll(e)){const c=a[0];s<a.index&&t.push(n.slice(s,a.index)),c.length>0&&t.push(c),s=a.index+c.length}return s<n.length&&t.push(n.slice(s)),t}function createPattern(n,e=!0){if(n.Regex!==void 0){let t=n.Regex.replace(/\\([#&~])/g,"$1");for(const[s,a]of PROBLEMATIC_REGEX_MAP)t=t.replaceAll(s,a);return new RegExp(t,"gu")}else if(n.String!==void 0){const t=escapeRegExp(n.String);return new RegExp(e?t:`(${t})`,"gu")}else return console.warn("Unknown pattern type:",n),null}function objectToMap(n){return new Map(Object.entries(n))}function prepareTensorForDecode(n){const e=n.dims;switch(e.length){case 1:return n.tolist();case 2:if(e[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return n.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${e.length}.`)}}function clean_up_tokenization(n){return n.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function remove_accents(n){return n.replace(/[\u0300-\u036f]/g,"")}function lowercase_and_remove_accent(n){return remove_accents(n.toLowerCase())}function fuse(n,e,t){const s=[];let a=0;for(;a<n.length;){if(s.push(n[a]),(t.get(n[a])??e)!==e){++a;continue}for(;a<n.length&&(t.get(n[a])??e)===e;)++a}return s}function whitespace_split(n){return n.match(/\S+/g)||[]}const PUNCTUATION_REGEX="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",PROBLEMATIC_REGEX_MAP=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class AddedToken{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class TokenizerModel extends Callable{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new WordPieceTokenizer(e);case"Unigram":return new Unigram(e,...t);case"BPE":return new BPE(e);default:if(e.vocab)return new LegacyTokenizerModel(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){let t=this.encode(e);return this.fuse_unk&&(t=fuse(t,this.unk_token_id,this.tokens_to_ids)),t}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map(t=>this.tokens_to_ids.get(t)??this.unk_token_id)}convert_ids_to_tokens(e){return e.map(t=>this.vocab[t]??this.unk_token)}}class WordPieceTokenizer extends TokenizerModel{constructor(e){super(e),this.tokens_to_ids=objectToMap(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[t,s]of this.tokens_to_ids)this.vocab[s]=t}encode(e){const t=[];for(const s of e){const a=[...s];if(a.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let c=!1,l=0;const _=[];for(;l<a.length;){let m=a.length,d=null;for(;l<m;){let h=a.slice(l,m).join("");if(l>0&&(h=this.config.continuing_subword_prefix+h),this.tokens_to_ids.has(h)){d=h;break}--m}if(d===null){c=!0;break}_.push(d),l=m}c?t.push(this.unk_token):t.push(..._)}return t}}class Unigram extends TokenizerModel{constructor(e,t){super(e);const s=e.vocab.length;this.vocab=new Array(s),this.scores=new Array(s);for(let a=0;a<s;++a){const c=e.vocab[a];this.vocab[a]=c[0],this.scores[a]=c[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map((a,c)=>[a,c])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=t.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=min(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.sentence,s=t.length;let a=0;for(;a<s;){let l=!1;for(let _ of this.trie.commonPrefixSearch(t.slice(a))){const m=this.tokens_to_ids.get(_),d=this.scores[m],h=_.length;e.insert(a,h,d,m),!l&&h===1&&(l=!0)}l||e.insert(a,1,this.unkScore,this.unk_token_id),a+=1}}tokenize(e){const t=new TokenLattice(e,this.bosTokenId,this.eosTokenId);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const s of e){const a=this.tokenize(s);t.push(...a)}return t}}const BYTES_TO_UNICODE=(()=>{const n=[...Array.from({length:94},(a,c)=>c+33),...Array.from({length:12},(a,c)=>c+161),...Array.from({length:82},(a,c)=>c+174)],e=n.slice();let t=0;for(let a=0;a<256;++a)n.includes(a)||(n.push(a),e.push(256+t),t+=1);const s=e.map(a=>String.fromCharCode(a));return Object.fromEntries(n.map((a,c)=>[a,s[c]]))})(),UNICODE_TO_BYTES=reverseDictionary(BYTES_TO_UNICODE);class BPE extends TokenizerModel{constructor(e){super(e),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=objectToMap(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[t,s]of this.tokens_to_ids)this.vocab[s]=t;this.bpe_ranks=new Map(e.merges.map((t,s)=>[t,s])),this.merges=e.merges.map(t=>t.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(e.length===0)return[];const t=this.cache.get(e);if(t!==void 0)return t;const s=Array.from(e);this.end_of_word_suffix&&(s[s.length-1]+=this.end_of_word_suffix);let a=[];if(s.length>1){const c=new PriorityQueue((m,d)=>m.score<d.score);let l={token:s[0],bias:0,prev:null,next:null},_=l;for(let m=1;m<s.length;++m){const d={bias:m/s.length,token:s[m],prev:_,next:null};_.next=d,this._add_node(c,_),_=d}for(;!c.isEmpty();){const m=c.pop();if(m.deleted||!m.next||m.next.deleted)continue;if(m.deleted=!0,m.next.deleted=!0,m.prev){const h={...m.prev};m.prev.deleted=!0,m.prev=h,h.prev?h.prev.next=h:l=h}const d={token:m.token+m.next.token,bias:m.bias,prev:m.prev,next:m.next.next};d.prev?(d.prev.next=d,this._add_node(c,d.prev)):l=d,d.next&&(d.next.prev=d,this._add_node(c,d))}for(let m=l;m!==null;m=m.next)a.push(m.token)}else a=s;if(this.continuing_subword_suffix)for(let c=0;c<a.length-1;++c)a[c]+=this.continuing_subword_suffix;return this.cache.set(e,a),a}_add_node(e,t){const s=this.bpe_ranks.get(t.token+this.BPE_SPLIT_TOKEN+t.next.token);s!==void 0&&(t.score=s+t.bias,e.push(t))}encode(e){const t=[];for(const s of e){if(this.ignore_merges&&this.tokens_to_ids.has(s)){t.push(s);continue}const a=this.bpe(s);for(const c of a)this.tokens_to_ids.has(c)?t.push(c):this.byte_fallback?t.push(...Array.from(this.text_encoder.encode(c)).map(l=>`<0x${l.toString(16).toUpperCase().padStart(2,"0")}>`)):t.push(this.unk_token)}return t}}class LegacyTokenizerModel extends TokenizerModel{constructor(e,t){super(e),this.tokens_to_ids=objectToMap(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[s,a]of this.tokens_to_ids)this.vocab[a]=s}encode(e){return e}}class Normalizer extends Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"BertNormalizer":return new BertNormalizer(e);case"Precompiled":return new Precompiled(e);case"Sequence":return new NormalizerSequence(e);case"Replace":return new Replace(e);case"NFC":return new NFC(e);case"NFKC":return new NFKC(e);case"NFKD":return new NFKD(e);case"Strip":return new StripNormalizer(e);case"StripAccents":return new StripAccents(e);case"Lowercase":return new Lowercase(e);case"Prepend":return new Prepend(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class Replace extends Normalizer{normalize(e){const t=createPattern(this.config.pattern);return t===null?e:e.replaceAll(t,this.config.content)}}class NFC extends Normalizer{normalize(e){return e=e.normalize("NFC"),e}}class NFKC extends Normalizer{normalize(e){return e=e.normalize("NFKC"),e}}class NFKD extends Normalizer{normalize(e){return e=e.normalize("NFKD"),e}}class StripNormalizer extends Normalizer{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class StripAccents extends Normalizer{normalize(e){return e=remove_accents(e),e}}class Lowercase extends Normalizer{normalize(e){return e=e.toLowerCase(),e}}class Prepend extends Normalizer{normalize(e){return e=this.config.prepend+e,e}}class NormalizerSequence extends Normalizer{constructor(e){super(e),this.normalizers=e.normalizers.map(t=>Normalizer.fromConfig(t))}normalize(e){return this.normalizers.reduce((t,s)=>s.normalize(t),e)}}class BertNormalizer extends Normalizer{_tokenize_chinese_chars(e){const t=[];for(let s=0;s<e.length;++s){const a=e[s],c=a.charCodeAt(0);this._is_chinese_char(c)?(t.push(" "),t.push(a),t.push(" ")):t.push(a)}return t.join("")}_is_chinese_char(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}stripAccents(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(e){switch(e){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(e)}}_clean_text(e){const t=[];for(const s of e){const a=s.charCodeAt(0);a===0||a===65533||this._is_control(s)||(/^\s$/.test(s)?t.push(" "):t.push(s))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),this.config.strip_accents!==!1&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class PreTokenizer extends Callable{static fromConfig(e){if(e===null)return null;switch(e.type){case"BertPreTokenizer":return new BertPreTokenizer(e);case"Sequence":return new PreTokenizerSequence(e);case"Whitespace":return new WhitespacePreTokenizer(e);case"WhitespaceSplit":return new WhitespaceSplit(e);case"Metaspace":return new MetaspacePreTokenizer(e);case"ByteLevel":return new ByteLevelPreTokenizer(e);case"Split":return new SplitPreTokenizer(e);case"Punctuation":return new PunctuationPreTokenizer(e);case"Digits":return new DigitsPreTokenizer(e);case"Replace":return new ReplacePreTokenizer(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map(s=>this.pre_tokenize_text(s,t)):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class BertPreTokenizer extends PreTokenizer{constructor(e){super(),this.pattern=new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class ByteLevelPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=BYTES_TO_UNICODE,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){return this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),(this.use_regex?e.match(this.pattern)||[]:[e]).map(a=>Array.from(this.text_encoder.encode(a),c=>this.byte_encoder[c]).join(""))}}class SplitPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=createPattern(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return this.pattern===null?[]:this.config.invert?e.match(this.pattern)||[]:regexSplit(e,this.pattern)}}class PunctuationPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class DigitsPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e;const t=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class PostProcessor extends Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"TemplateProcessing":return new TemplateProcessing(e);case"ByteLevel":return new ByteLevelPostProcessor(e);case"RobertaProcessing":return new RobertaProcessing(e);case"BertProcessing":return new BertProcessing(e);case"Sequence":return new PostProcessorSequence(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class BertProcessing extends PostProcessor{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:s=!0}={}){s&&(e=mergeArrays([this.cls],e,[this.sep]));let a=new Array(e.length).fill(0);if(t!==null){const c=s&&this instanceof RobertaProcessing?[this.sep]:[],l=s?[this.sep]:[];e=mergeArrays(e,c,t,l),a=mergeArrays(a,new Array(t.length+c.length+l.length).fill(1))}return{tokens:e,token_type_ids:a}}}class RobertaProcessing extends BertProcessing{}class TemplateProcessing extends PostProcessor{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:s=!0}={}){const a=t===null?this.single:this.pair;let c=[],l=[];for(const _ of a)"SpecialToken"in _?s&&(c.push(_.SpecialToken.id),l.push(_.SpecialToken.type_id)):"Sequence"in _&&(_.Sequence.id==="A"?(c=mergeArrays(c,e),l=mergeArrays(l,new Array(e.length).fill(_.Sequence.type_id))):_.Sequence.id==="B"&&(c=mergeArrays(c,t),l=mergeArrays(l,new Array(t.length).fill(_.Sequence.type_id))));return{tokens:c,token_type_ids:l}}}class ByteLevelPostProcessor extends PostProcessor{post_process(e,t=null){return t&&(e=mergeArrays(e,t)),{tokens:e}}}class PostProcessorSequence extends PostProcessor{constructor(e){super(e),this.processors=e.processors.map(t=>PostProcessor.fromConfig(t))}post_process(e,t=null,s={}){let a;for(const c of this.processors)if(c instanceof ByteLevelPostProcessor)e=c.post_process(e).tokens,t&&(t=c.post_process(t).tokens);else{const l=c.post_process(e,t,s);e=l.tokens,a=l.token_type_ids}return{tokens:e,token_type_ids:a}}}class Decoder extends Callable{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(e===null)return null;switch(e.type){case"WordPiece":return new WordPieceDecoder(e);case"Metaspace":return new MetaspaceDecoder(e);case"ByteLevel":return new ByteLevelDecoder(e);case"Replace":return new ReplaceDecoder(e);case"ByteFallback":return new ByteFallback(e);case"Fuse":return new FuseDecoder(e);case"Strip":return new StripDecoder(e);case"Sequence":return new DecoderSequence(e);case"CTC":return new CTCDecoder(e);case"BPEDecoder":return new BPEDecoder(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class ReplaceDecoder extends Decoder{decode_chain(e){const t=createPattern(this.config.pattern);return t===null?e:e.map(s=>s.replaceAll(t,this.config.content))}}class ByteFallback extends Decoder{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let s=[];for(const a of e){let c=null;if(a.length===6&&a.startsWith("<0x")&&a.endsWith(">")){const l=parseInt(a.slice(3,5),16);isNaN(l)||(c=l)}if(c!==null)s.push(c);else{if(s.length>0){const l=this.text_decoder.decode(Uint8Array.from(s));t.push(l),s=[]}t.push(a)}}if(s.length>0){const a=this.text_decoder.decode(Uint8Array.from(s));t.push(a),s=[]}return t}}class FuseDecoder extends Decoder{decode_chain(e){return[e.join("")]}}class StripDecoder extends Decoder{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map(t=>{let s=0;for(let c=0;c<this.start&&t[c]===this.content;++c){s=c+1;continue}let a=t.length;for(let c=0;c<this.stop;++c){const l=t.length-c-1;if(t[l]===this.content){a=l;continue}else break}return t.slice(s,a)})}}class WordPieceDecoder extends Decoder{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map((t,s)=>(s!==0&&(t.startsWith(this.config.prefix)?t=t.replace(this.config.prefix,""):t=" "+t),this.cleanup&&(t=clean_up_tokenization(t)),t))}}class ByteLevelDecoder extends Decoder{constructor(e){super(e),this.byte_decoder=UNICODE_TO_BYTES,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),s=new Uint8Array([...t].map(c=>this.byte_decoder[c]));return this.text_decoder.decode(s)}decode_chain(e){const t=[];let s=[];for(const a of e)this.added_tokens.find(c=>c.content===a)!==void 0?(s.length>0&&(t.push(this.convert_tokens_to_string(s)),s=[]),t.push(a)):s.push(a);return s.length>0&&t.push(this.convert_tokens_to_string(s)),t}}class CTCDecoder extends Decoder{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(e.length===0)return"";const t=[e[0]];for(let c=1;c<e.length;++c)e[c]!==t.at(-1)&&t.push(e[c]);let a=t.filter(c=>c!==this.pad_token).join("");return this.cleanup&&(a=clean_up_tokenization(a).replaceAll(this.word_delimiter_token," ").trim()),a}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class DecoderSequence extends Decoder{constructor(e){super(e),this.decoders=e.decoders.map(t=>Decoder.fromConfig(t))}decode_chain(e){return this.decoders.reduce((t,s)=>s.decode_chain(t),e)}}class BPEDecoder extends Decoder{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map((t,s)=>t.replaceAll(this.suffix,s===e.length-1?"":" "))}}class VitsDecoder extends Decoder{decode_chain(e){let t="";for(let s=1;s<e.length;s+=2)t+=e[s];return[t]}}class MetaspacePreTokenizer extends PreTokenizer{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t=void 0}={}){let s=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!s.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&t===0)&&(s=this.strRep+s),[s]}}class MetaspaceDecoder extends Decoder{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let s=0;s<e.length;++s){let a=e[s].replaceAll(this.replacement," ");this.addPrefixSpace&&s==0&&a.startsWith(" ")&&(a=a.substring(1)),t.push(a)}return t}}class Precompiled extends Normalizer{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){return e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),e=e.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),e.includes("～")?e=e.split("～").map(s=>s.normalize("NFKC")).join("～"):e=e.normalize("NFKC"),e}}class PreTokenizerSequence extends PreTokenizer{constructor(e){super(),this.tokenizers=e.pretokenizers.map(t=>PreTokenizer.fromConfig(t))}pre_tokenize_text(e,t){return this.tokenizers.reduce((s,a)=>a.pre_tokenize(s,t),[e])}}class WhitespacePreTokenizer extends PreTokenizer{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\w+|[^\w\s]+/g)||[]}}class WhitespaceSplit extends PreTokenizer{constructor(e){super()}pre_tokenize_text(e,t){return whitespace_split(e)}}class ReplacePreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=createPattern(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return this.pattern===null?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const SPECIAL_TOKEN_ATTRIBUTES=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function padHelper(n,e,t,s){for(const a of Object.keys(n)){const c=e-n[a].length,l=t(a),_=new Array(c).fill(l);n[a]=s==="right"?mergeArrays(n[a],_):mergeArrays(_,n[a])}}function truncateHelper(n,e){for(const t of Object.keys(n))n[t].length=e}class PreTrainedTokenizer extends Callable{return_token_type_ids=!1;_default_chat_template=`{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`;constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=Normalizer.fromConfig(e.normalizer),this.pre_tokenizer=PreTokenizer.fromConfig(e.pre_tokenizer),this.model=TokenizerModel.fromConfig(e.model,t),this.post_processor=PostProcessor.fromConfig(e.post_processor),this.decoder=Decoder.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const s of e.added_tokens){const a=new AddedToken(s);this.added_tokens.push(a),this.model.tokens_to_ids.set(a.content,a.id),this.model.vocab[a.id]=a.content,a.special&&(this.special_tokens.push(a.content),this.all_special_ids.push(a.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map(s=>`${s.lstrip?"\\s*":""}(${escapeRegExp(s.content)})${s.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const s=Object.create(null);for(const{name:a,template:c}of this.chat_template){if(typeof a!="string"||typeof c!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');s[a]=c}this.chat_template=s}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const s=this._tokenizer_config[t];if(s)if(typeof s=="object"){if(s.__type==="AddedToken")return s.content;throw Error(`Unknown token: ${s}`)}else return s}return null}static async from_pretrained(e,{progress_callback:t=null,config:s=null,cache_dir:a=null,local_files_only:c=!1,revision:l="main",legacy:_=null}={}){const m=await loadTokenizer(e,{progress_callback:t,cache_dir:a,local_files_only:c,revision:l,legacy:_});return new this(...m)}_call(e,{text_pair:t=null,add_special_tokens:s=!0,padding:a=!1,truncation:c=null,max_length:l=null,return_tensor:_=!0,return_token_type_ids:m=null}={}){const d=Array.isArray(e);let h;if(d){if(e.length===0)throw Error("text array must be non-empty");if(t!==null){if(Array.isArray(t)){if(e.length!==t.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");h=e.map((r,u)=>this._encode_plus(r,t[u],{add_special_tokens:s,return_token_type_ids:m}))}else h=e.map(r=>this._encode_plus(r,null,{add_special_tokens:s,return_token_type_ids:m}))}else{if(e==null)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");h=[this._encode_plus(e,t,{add_special_tokens:s,return_token_type_ids:m})]}if(l===null?a==="max_length"?l=this.model_max_length:l=max(h.map(r=>r.input_ids.length))[0]:c||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),l=Math.min(l,this.model_max_length),a||c)for(let r=0;r<h.length;++r)h[r].input_ids.length!==l&&(h[r].input_ids.length>l?c&&truncateHelper(h[r],l):a&&padHelper(h[r],l,u=>u==="input_ids"?this.pad_token_id:0,this.padding_side));const i={};if(_){if(!(a&&c)&&h.some(u=>{for(const f of Object.keys(u))if(u[f].length!==h[0][f]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const r=[h.length,h[0].input_ids.length];for(const u of Object.keys(h[0]))i[u]=new Tensor("int64",BigInt64Array.from(h.flatMap(f=>f[u]).map(BigInt)),r)}else{for(const r of Object.keys(h[0]))i[r]=h.map(u=>u[r]);if(!d)for(const r of Object.keys(i))i[r]=i[r][0]}return i}_encode_text(e){return e===null?null:(this.added_tokens_regex?e.split(this.added_tokens_regex).filter(a=>a):[e]).map((a,c)=>{if(this.added_tokens.find(_=>_.content===a)!==void 0)return a;{if(this.remove_space===!0&&(a=a.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(a=lowercase_and_remove_accent(a)),this.normalizer!==null&&(a=this.normalizer(a)),a.length===0)return[];const _=this.pre_tokenizer!==null?this.pre_tokenizer(a,{section_index:c}):[a];return this.model(_)}}).flat()}_encode_plus(e,t=null,{add_special_tokens:s=!0,return_token_type_ids:a=null}={}){const c=this._encode_text(e),l=this._encode_text(t),_=this.post_processor?this.post_processor(c,l,{add_special_tokens:s}):{tokens:mergeArrays(c??[],l??[])},m=this.model.convert_tokens_to_ids(_.tokens),d={input_ids:m,attention_mask:new Array(m.length).fill(1)};return(a??this.return_token_type_ids)&&_.token_type_ids&&(d.token_type_ids=_.token_type_ids),d}encode(e,t=null,{add_special_tokens:s=!0,return_token_type_ids:a=null}={}){const{input_ids:c}=this._encode_plus(e,t,{add_special_tokens:s,return_token_type_ids:a});return c}batch_decode(e,t={}){return e instanceof Tensor&&(e=e.tolist()),e.map(s=>this.decode(s,t))}decode(e,t={}){if(e instanceof Tensor&&(e=prepareTensorForDecode(e)),!Array.isArray(e)||e.length===0||!isIntegralNumber(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:s=null}){let a=this.model.convert_ids_to_tokens(e);t&&(a=a.filter(l=>!this.special_tokens.includes(l)));let c=this.decoder?this.decoder(a):a.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(c=c.replaceAll(this.decoder.end_of_word_suffix," "),t&&(c=c.trim())),(s??this.clean_up_tokenization_spaces)&&(c=clean_up_tokenization(c)),c}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(e,{chat_template:t=null,add_generation_prompt:s=!1,tokenize:a=!0,padding:c=!1,truncation:l=!1,max_length:_=null,return_tensor:m=!0,tokenizer_kwargs:d={},...h}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null&&this.default_chat_template&&typeof this.default_chat_template=="object"){const f=this.chat_template??this.default_chat_template;if(t!==null&&Object.hasOwn(f,t))t=f[t];else if(t===null&&"default"in f)t=f.default;else if(t===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(f).sort()}.`)}else t??=this.chat_template??this.default_chat_template;if(typeof t!="string")throw Error(`chat_template must be a string, but got ${typeof t}`);let i=this._compiled_template_cache.get(t);i===void 0&&(i=new Template(t),this._compiled_template_cache.set(t,i));const r=Object.create(null);for(const f of SPECIAL_TOKEN_ATTRIBUTES){const g=this.getToken(f);g&&(r[f]=g)}const u=i.render({messages:e,add_generation_prompt:s,...r,...h});return a?this._call(u,{add_special_tokens:!1,padding:c,truncation:l,max_length:_,return_tensor:m,...d}).input_ids:u}}class BertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class AlbertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class MobileBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class SqueezeBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DebertaTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DebertaV2Tokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class HerbertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class ConvBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class RoFormerTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DistilBertTokenizer extends PreTrainedTokenizer{}class CamembertTokenizer extends PreTrainedTokenizer{}class XLMTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class ElectraTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class T5Tokenizer extends PreTrainedTokenizer{}class GPT2Tokenizer extends PreTrainedTokenizer{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}'}class BartTokenizer extends PreTrainedTokenizer{}class MBartTokenizer extends PreTrainedTokenizer{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(s=>this.languageRegex.test(s)),this.lang_to_token=s=>s}_build_translation_inputs(e,t,s){return _build_translation_inputs(this,e,t,s)}}class MBart50Tokenizer extends MBartTokenizer{}class RobertaTokenizer extends PreTrainedTokenizer{}class BloomTokenizer extends GPT2Tokenizer{constructor(e,t){const s=".,!?…。，、।۔،",a=e.pre_tokenizer?.pretokenizers[0]?.pattern;a&&a.Regex===` ?[^(\\s|[${s}])]+`&&(a.Regex=` ?[^\\s${s}]+`),super(e,t)}}const SPIECE_UNDERLINE="▁";class LlamaTokenizer extends PreTrainedTokenizer{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`;DEFAULT_SYSTEM_PROMPT=`You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`;constructor(e,t){super(e,t),this.use_default_system_prompt=t.use_default_system_prompt??!1,this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new MetaspacePreTokenizer({replacement:SPIECE_UNDERLINE,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(e===null)return null;if(this.legacy||e.length===0)return super._encode_text(e);let t=super._encode_text(SPIECE_UNDERLINE+e.replaceAll(SPIECE_UNDERLINE," "));return t.length>1&&t[0]===SPIECE_UNDERLINE&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll(`
`,"\\n").replaceAll("'","\\'"))}}class CodeLlamaTokenizer extends LlamaTokenizer{}class XLMRobertaTokenizer extends PreTrainedTokenizer{}class MPNetTokenizer extends PreTrainedTokenizer{}class FalconTokenizer extends PreTrainedTokenizer{}class GPTNeoXTokenizer extends PreTrainedTokenizer{}class EsmTokenizer extends PreTrainedTokenizer{}class Qwen2Tokenizer extends PreTrainedTokenizer{}class GemmaTokenizer extends PreTrainedTokenizer{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`}class Grok1Tokenizer extends PreTrainedTokenizer{}function _build_translation_inputs(n,e,t,s){if(!("language_codes"in n)||!Array.isArray(n.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in n)||!(n.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in n)||typeof n.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const a=s.src_lang,c=s.tgt_lang;if(!n.language_codes.includes(c))throw new Error(`Target language code "${c}" is not valid. Must be one of: {${n.language_codes.join(", ")}}`);if(a!==void 0){if(!n.language_codes.includes(a))throw new Error(`Source language code "${a}" is not valid. Must be one of: {${n.language_codes.join(", ")}}`);for(const l of n.post_processor.config.single)if("SpecialToken"in l&&n.languageRegex.test(l.SpecialToken.id)){l.SpecialToken.id=n.lang_to_token(a);break}}return s.forced_bos_token_id=n.model.convert_tokens_to_ids([n.lang_to_token(c)])[0],n._call(e,t)}class NllbTokenizer extends PreTrainedTokenizer{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(s=>this.languageRegex.test(s)),this.lang_to_token=s=>s}_build_translation_inputs(e,t,s){return _build_translation_inputs(this,e,t,s)}}class M2M100Tokenizer extends PreTrainedTokenizer{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(s=>this.languageRegex.test(s)).map(s=>s.slice(2,-2)),this.lang_to_token=s=>`__${s}__`}_build_translation_inputs(e,t,s){return _build_translation_inputs(this,e,t,s)}}const WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],WHISPER_LANGUAGE_MAPPING=new Map(WHISPER_LANGUAGES),WHISPER_TO_LANGUAGE_CODE_MAPPING=new Map([...WHISPER_LANGUAGES.map(([n,e])=>[e,n]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class WhisperTokenizer extends PreTrainedTokenizer{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';_decode_asr(e,{return_timestamps:t=!1,return_language:s=!1,time_precision:a=null,force_full_sequences:c=!0}={}){if(a===null)throw Error("Must specify time_precision");let l=null;const _=t==="word";function m(){return{language:l,timestamp:[null,null],text:""}}const d=[];let h=m(),i=0;const r=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let u=[],f=[],g=!1,w=null;const y=new Set(this.all_special_ids);for(const T of e){const E=T.tokens,A=_?T.token_timestamps:null;let C=null,I=r;if("stride"in T){const[Y,re,G]=T.stride;if(i-=re,w=Y-G,re&&(I=re/a+r),G)for(let te=E.length-1;te>=0;--te){const q=E[te];if(q>=r){if(C!==null&&(q-r)*a<w)break;C=q}}}let D=[],R=[];for(let Y=0;Y<E.length;++Y){const re=E[Y];if(y.has(re)){const G=this.decode([re]),te=WHISPER_LANGUAGE_MAPPING.get(G.slice(2,-2));if(te!==void 0){if(l!==null&&te!==l&&!t){u.push(D);const q=this.findLongestCommonSequence(u)[0],z=this.decode(q);h.text=z,d.push(h),u=[],D=[],h=m()}l=h.language=te}}else if(re>=r){const G=(re-r)*a+i,te=round(G,2);if(C!==null&&re>=C)g=!0;else if(g||u.length>0&&re<I)g=!1;else if(h.timestamp[0]===null)h.timestamp[0]=te;else if(te!==h.timestamp[0]){h.timestamp[1]=te,u.push(D),_&&f.push(R);const[q,z]=this.findLongestCommonSequence(u,f),H=this.decode(q);h.text=H,_&&(h.words=this.collateWordTimestamps(q,z,l)),d.push(h),u=[],D=[],f=[],R=[],h=m()}}else if(D.push(re),_){let G=round(A[Y]+i,2),te;Y+1<A.length?te=round(A[Y+1]+i,2):te=null,R.push([G,te])}}if("stride"in T){const[Y,re,G]=T.stride;i+=Y-G}D.length>0?(u.push(D),_&&f.push(R)):u.every(Y=>Y.length===0)&&(h=m(),u=[],D=[],f=[],R=[])}if(u.length>0){if(c&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[T,E]=this.findLongestCommonSequence(u,f),A=this.decode(T);h.text=A,_&&(h.words=this.collateWordTimestamps(T,E,l)),d.push(h)}let x=Object.create(null);const S=d.map(T=>T.text).join("");if(t||s){for(let T=0;T<d.length;++T){const E=d[T];t||delete E.timestamp,s||delete E.language}if(_){const T=[];for(const E of d)for(const A of E.words)T.push(A);x={chunks:T}}else x={chunks:d}}return[S,x]}findLongestCommonSequence(e,t=null){let s=e[0],a=s.length,c=[];const l=Array.isArray(t)&&t.length>0;let _=l?[]:null,m=l?t[0]:null;for(let d=1;d<e.length;++d){const h=e[d];let i=0,r=[a,a,0,0];const u=h.length;for(let T=1;T<a+u;++T){const E=T/1e4,A=Math.max(0,a-T),C=Math.min(a,a+u-T),I=s.slice(A,C),D=Math.max(0,T-a),R=Math.min(u,T),Y=h.slice(D,R);if(I.length!==Y.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const re=I.filter((te,q)=>te===Y[q]).length,G=re/T+E;re>1&&G>i&&(i=G,r=[A,C,D,R])}const[f,g,w,y]=r,x=Math.floor((g+f)/2),S=Math.floor((y+w)/2);c.push(...s.slice(0,x)),s=h.slice(S),a=s.length,l&&(_.push(...m.slice(0,x)),m=t[d].slice(S))}return c.push(...s),l?(_.push(...m),[c,_]):[c,[]]}collateWordTimestamps(e,t,s){const[a,c,l]=this.combineTokensIntoWords(e,s),_=[];for(let m=0;m<a.length;++m){const d=l[m];_.push({text:a[m],timestamp:[t[d.at(0)][0],t[d.at(-1)][1]]})}return _}combineTokensIntoWords(e,t,s=`"'“¡¿([{-`,a=`"'.。,，!！?？:：”)]}、`){t=t??"english";let c,l,_;return["chinese","japanese","thai","lao","myanmar"].includes(t)?[c,l,_]=this.splitTokensOnUnicode(e):[c,l,_]=this.splitTokensOnSpaces(e),this.mergePunctuations(c,l,_,s,a)}decode(e,t){let s;return t&&t.decode_with_timestamps?(e instanceof Tensor&&(e=prepareTensorForDecode(e)),s=this.decodeWithTimestamps(e,t)):s=super.decode(e,t),s}decodeWithTimestamps(e,t){const s=t?.time_precision??.02,a=Array.from(this.all_special_ids).at(-1)+1;let c=[[]];for(const l of e)if(l>=a){const _=round((l-a)*s,2);c.push(`<|${_}|>`),c.push([])}else c[c.length-1].push(l);return c=c.map(l=>typeof l=="string"?l:super.decode(l,t)),c.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),s="�",a=[],c=[],l=[];let _=[],m=[],d=0;for(let h=0;h<e.length;++h){const i=e[h];_.push(i),m.push(h);const r=this.decode(_,{decode_with_timestamps:!0});(!r.includes(s)||t[d+r.indexOf(s)]===s)&&(a.push(r),c.push(_),l.push(m),_=[],m=[],d+=r.length)}return[a,c,l]}splitTokensOnSpaces(e){const[t,s,a]=this.splitTokensOnUnicode(e),c=[],l=[],_=[],m=new RegExp(`^[${PUNCTUATION_REGEX}]$`,"gu");for(let d=0;d<t.length;++d){const h=t[d],i=s[d],r=a[d],u=i[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),f=h.startsWith(" "),g=h.trim(),w=m.test(g);if(u||f||w||c.length===0)c.push(h),l.push(i),_.push(r);else{const y=c.length-1;c[y]+=h,l[y].push(...i),_[y].push(...r)}}return[c,l,_]}mergePunctuations(e,t,s,a,c){const l=structuredClone(e),_=structuredClone(t),m=structuredClone(s);let d=l.length-2,h=l.length-1;for(;d>=0;)l[d].startsWith(" ")&&a.includes(l[d].trim())?(l[h]=l[d]+l[h],_[h]=mergeArrays(_[d],_[h]),m[h]=mergeArrays(m[d],m[h]),l[d]="",_[d]=[],m[d]=[]):h=d,--d;for(d=0,h=1;h<l.length;)!l[d].endsWith(" ")&&c.includes(l[h])?(l[d]+=l[h],_[d]=mergeArrays(_[d],_[h]),m[d]=mergeArrays(m[d],m[h]),l[h]="",_[h]=[],m[h]=[]):d=h,++h;return[l.filter(i=>i),_.filter(i=>i.length>0),m.filter(i=>i.length>0)]}get_decoder_prompt_ids({language:e=null,task:t=null,no_timestamps:s=!0}={}){const a=[];if(e){e=e.toLowerCase();let c=WHISPER_TO_LANGUAGE_CODE_MAPPING.get(e);if(c===void 0)if(WHISPER_LANGUAGE_MAPPING.has(e))c=e;else{const m=e.length===2?WHISPER_LANGUAGE_MAPPING.keys():WHISPER_LANGUAGE_MAPPING.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(m)}`)}const l=this.model.tokens_to_ids.get(`<|${c}|>`);if(l===void 0)throw new Error(`Unable to find language "${c}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);a.push(l)}else a.push(null);if(t){if(t=t.toLowerCase(),t!=="transcribe"&&t!=="translate")throw new Error(`Task "${t}" is not supported. Must be one of: ["transcribe", "translate"]`);const c=this.model.tokens_to_ids.get(`<|${t}|>`);if(c===void 0)throw new Error(`Unable to find task "${t}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);a.push(c)}else a.push(null);if(s){const c=this.model.tokens_to_ids.get("<|notimestamps|>");if(c===void 0)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');a.push(c)}return a.map((c,l)=>[l+1,c]).filter(c=>c[1]!==null)}}class CodeGenTokenizer extends PreTrainedTokenizer{}class CLIPTokenizer extends PreTrainedTokenizer{}class SiglipTokenizer extends PreTrainedTokenizer{}class MarianTokenizer extends PreTrainedTokenizer{constructor(e,t){super(e,t),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(s=>this.languageRegex.test(s)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(e===null)return null;const[t,...s]=e.trim().split(this.languageRegex);if(s.length===0)return super._encode_text(t);if(s.length===2){const[a,c]=s;return this.supported_language_codes.includes(a)||console.warn(`Unsupported language code "${a}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),mergeArrays([a],super._encode_text(c))}}}class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer{}class BlenderbotTokenizer extends PreTrainedTokenizer{_default_chat_template="{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}"}class BlenderbotSmallTokenizer extends BlenderbotTokenizer{}class SpeechT5Tokenizer extends PreTrainedTokenizer{}class NougatTokenizer extends PreTrainedTokenizer{}class VitsTokenizer extends PreTrainedTokenizer{constructor(e,t){super(e,t),this.decoder=new VitsDecoder({})}}class CohereTokenizer extends PreTrainedTokenizer{}class AutoTokenizer{static TOKENIZER_CLASS_MAPPING={T5Tokenizer,DistilBertTokenizer,CamembertTokenizer,DebertaTokenizer,DebertaV2Tokenizer,BertTokenizer,HerbertTokenizer,ConvBertTokenizer,RoFormerTokenizer,XLMTokenizer,ElectraTokenizer,MobileBertTokenizer,SqueezeBertTokenizer,AlbertTokenizer,GPT2Tokenizer,BartTokenizer,MBartTokenizer,MBart50Tokenizer,RobertaTokenizer,WhisperTokenizer,CodeGenTokenizer,CLIPTokenizer,SiglipTokenizer,MarianTokenizer,BloomTokenizer,NllbTokenizer,M2M100Tokenizer,LlamaTokenizer,CodeLlamaTokenizer,XLMRobertaTokenizer,MPNetTokenizer,FalconTokenizer,GPTNeoXTokenizer,EsmTokenizer,Wav2Vec2CTCTokenizer,BlenderbotTokenizer,BlenderbotSmallTokenizer,SpeechT5Tokenizer,NougatTokenizer,VitsTokenizer,Qwen2Tokenizer,GemmaTokenizer,Grok1Tokenizer,CohereTokenizer,PreTrainedTokenizer};static async from_pretrained(e,{quantized:t=!0,progress_callback:s=null,config:a=null,cache_dir:c=null,local_files_only:l=!1,revision:_="main",legacy:m=null}={}){const[d,h]=await loadTokenizer(e,{progress_callback:s,cache_dir:c,local_files_only:l,revision:_,legacy:m}),i=h.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let r=this.TOKENIZER_CLASS_MAPPING[i];return r||(console.warn(`Unknown tokenizer class "${i}", attempting to construct from base class.`),r=PreTrainedTokenizer),new r(d,h)}}async function loadConfig(n,e){return await getModelJSON(n,"config.json",!0,e)}class PretrainedConfig{constructor(e){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,e)}static async from_pretrained(e,{progress_callback:t=null,config:s=null,cache_dir:a=null,local_files_only:c=!1,revision:l="main"}={}){let _=s??await loadConfig(e,{progress_callback:t,cache_dir:a,local_files_only:c,revision:l});return new this(_)}}class AutoConfig{static async from_pretrained(...e){return PretrainedConfig.from_pretrained(...e)}}class LogitsProcessorList extends Callable{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){for(let s of t)this.processors.forEach(a=>a(e,s))}[Symbol.iterator](){return this.processors.values()}}class LogitsProcessor extends Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class ForceTokensLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.force_token_map=Object.fromEntries(e??[])}_call(e,t){let s=this.force_token_map[e.length];return exists(s)&&(t.data.fill(-1/0),t.data[s]=0),t}}class ForcedBOSTokenLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.bos_token_id=e}_call(e,t){return e.length===1&&(t.data.fill(-1/0),t.data[this.bos_token_id]=0),t}}class ForcedEOSTokenLogitsProcessor extends LogitsProcessor{constructor(e,t){super(),this.max_length=e,this.forced_eos_token_id=t}_call(e,t){}}class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){if(e.length===this.begin_index)for(let s of this.begin_suppress_tokens)t.data[s]=-1/0;return t}}class WhisperTimeStampLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.eos_token_id=e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(e.forced_decoder_ids||[]).length+2,e.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){const s=t.data;if(s[this.no_timestamps_token_id]=-1/0,e.length===this.begin_index-1)return s.fill(-1/0),s[this.timestamp_begin]=0,t;const a=e.slice(this.begin_index),c=a.length>=1&&a[a.length-1]>=this.timestamp_begin,l=a.length<2||a[a.length-2]>=this.timestamp_begin;if(c&&(l?s.subarray(this.timestamp_begin).fill(-1/0):s.subarray(0,this.eos_token_id).fill(-1/0)),e.length===this.begin_index&&this.max_initial_timestamp_index!==null){const h=this.timestamp_begin+this.max_initial_timestamp_index;s.subarray(h+1).fill(-1/0)}const _=log_softmax(s),m=Math.log(_.subarray(this.timestamp_begin).map(Math.exp).reduce((h,i)=>h+i)),d=max(_.subarray(0,this.timestamp_begin))[0];return m>d&&s.subarray(0,this.timestamp_begin).fill(-1/0),t}}class NoRepeatNGramLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,s=[];for(let c=0;c<t+1-this.no_repeat_ngram_size;++c){const l=[];for(let _=0;_<this.no_repeat_ngram_size;++_)l.push(e[c+_]);s.push(l)}const a=new Map;for(const c of s){const l=c.slice(0,c.length-1),_=JSON.stringify(l),m=a.get(_)??[];m.push(c[c.length-1]),a.set(_,m)}return a}getGeneratedNgrams(e,t){const s=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(s))??[]}calcBannedNgramTokens(e){const t=[];if(e.length+1<this.no_repeat_ngram_size)return t;{const s=this.getNgrams(e);return this.getGeneratedNgrams(s,e)}}_call(e,t){const s=this.calcBannedNgramTokens(e);for(const a of s)t.data[a]=-1/0;return t}}class RepetitionPenaltyLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.penalty=e}_call(e,t){for(const s of e)t.data[s]<0?t.data[s]*=this.penalty:t.data[s]/=this.penalty;return t}}class MinLengthLogitsProcessor extends LogitsProcessor{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){if(e.length<this.min_length)for(const s of this.eos_token_id)t.data[s]=-1/0;return t}}class MinNewTokensLengthLogitsProcessor extends LogitsProcessor{constructor(e,t,s){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(s)?s:[s]}_call(e,t){if(e.length-this.prompt_length_to_skip<this.min_new_tokens)for(const a of this.eos_token_id)t.data[a]=-1/0;return t}}class NoBadWordsLogitsProcessor extends LogitsProcessor{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(const s of this.bad_words_ids){let a=!0;for(let c=1;c<=s.length-1&&s.length<e.length;++c)if(s.at(-c-1)!==e.at(-c)){a=!1;break}a&&(t.data[s.at(-1)]=-1/0)}return t}}const GenerationConfig=class{constructor(n={}){this.max_length=n.max_length??20,this.max_new_tokens=n.max_new_tokens??null,this.min_length=n.min_length??0,this.min_new_tokens=n.min_new_tokens??null,this.early_stopping=n.early_stopping??!1,this.max_time=n.max_time??null,this.do_sample=n.do_sample??!1,this.num_beams=n.num_beams??1,this.num_beam_groups=n.num_beam_groups??1,this.penalty_alpha=n.penalty_alpha??null,this.use_cache=n.use_cache??!0,this.temperature=n.temperature??1,this.top_k=n.top_k??50,this.top_p=n.top_p??1,this.typical_p=n.typical_p??1,this.epsilon_cutoff=n.epsilon_cutoff??0,this.eta_cutoff=n.eta_cutoff??0,this.diversity_penalty=n.diversity_penalty??0,this.repetition_penalty=n.repetition_penalty??1,this.encoder_repetition_penalty=n.encoder_repetition_penalty??1,this.length_penalty=n.length_penalty??1,this.no_repeat_ngram_size=n.no_repeat_ngram_size??0,this.bad_words_ids=n.bad_words_ids??null,this.force_words_ids=n.force_words_ids??null,this.renormalize_logits=n.renormalize_logits??!1,this.constraints=n.constraints??null,this.forced_bos_token_id=n.forced_bos_token_id??null,this.forced_eos_token_id=n.forced_eos_token_id??null,this.remove_invalid_values=n.remove_invalid_values??!1,this.exponential_decay_length_penalty=n.exponential_decay_length_penalty??null,this.suppress_tokens=n.suppress_tokens??null,this.begin_suppress_tokens=n.begin_suppress_tokens??null,this.forced_decoder_ids=n.forced_decoder_ids??null,this.num_return_sequences=n.num_return_sequences??1,this.output_attentions=n.output_attentions??!1,this.output_hidden_states=n.output_hidden_states??!1,this.output_scores=n.output_scores??!1,this.return_dict_in_generate=n.return_dict_in_generate??!1,this.pad_token_id=n.pad_token_id??null,this.bos_token_id=n.bos_token_id??null,this.eos_token_id=n.eos_token_id??null,this.encoder_no_repeat_ngram_size=n.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=n.decoder_start_token_id??null,this.generation_kwargs=n.generation_kwargs??{}}};class Sampler extends Callable{constructor(e){super(),this.generation_config=e}_call(e,t=-1){return this.sample(e,t)}sample(e,t){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let s=e.dims.at(-1),a=e.data;if(t===-1)a=a.slice(-s);else{let c=t*s;a=a.slice(c,c+s)}return this.generation_config.temperature>0&&(a=a.map(c=>c/this.generation_config.temperature)),a}randomSelect(e){let t=e.reduce((a,c)=>a+c,0),s=Math.random()*t;for(let a=0;a<e.length;++a)if(s-=e[a],s<=0)return a;return 0}static getSampler(e){if(e.do_sample)return new MultinomialSampler(e);if(e.num_beams>1)return new BeamSearchSampler(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new GreedySampler(e)}}class GreedySampler extends Sampler{sample(e,t=-1){let s=this.getLogits(e,t);return[[max(s)[1],0]]}}class MultinomialSampler extends Sampler{sample(e,t=-1){let s=e.dims.at(-1);this.generation_config.top_k>0&&(s=Math.min(this.generation_config.top_k,s));const a=this.getLogits(e,t),c=getTopItems(a,s),l=softmax(c.map(_=>_[1]));return Array.from({length:this.generation_config.num_beams},()=>{const _=this.randomSelect(l);return[c[_][0],Math.log(l[_])]})}}class BeamSearchSampler extends Sampler{sample(e,t=-1){let s=e.dims.at(-1);this.generation_config.top_k>0&&(s=Math.min(this.generation_config.top_k,s));const a=this.getLogits(e,t),c=getTopItems(a,s),l=softmax(c.map(_=>_[1]));return Array.from({length:this.generation_config.num_beams},(_,m)=>[c[m][0],Math.log(l[m])])}}const{InferenceSession,Tensor:ONNXTensor,env}=ONNX,MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5},MODEL_TYPE_MAPPING=new Map,MODEL_NAME_TO_CLASS_MAPPING=new Map,MODEL_CLASS_TO_NAME_MAPPING=new Map;async function constructSession(n,e,t){let s=`onnx/${e}${t.quantized?"_quantized":""}.onnx`,a=await getModelFile(n,s,!0,t);try{return await InferenceSession.create(a,{executionProviders})}catch(c){if(executionProviders.length===1&&executionProviders[0]==="wasm")throw c;return console.warn(c),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await InferenceSession.create(a,{executionProviders:["wasm"]})}}function validateInputs(n,e){const t=Object.create(null),s=[];for(const l of n.inputNames){const _=e[l];if(!(_ instanceof Tensor)){s.push(l);continue}t[l]=env.wasm.proxy?_.clone():_}if(s.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${s.join(", ")}.`);const a=Object.keys(e).length,c=n.inputNames.length;if(a>c){let l=Object.keys(e).filter(_=>!n.inputNames.includes(_));console.warn(`WARNING: Too many inputs were provided (${a} > ${c}). The following inputs will be ignored: "${l.join(", ")}".`)}return t}async function sessionRun(n,e){const t=validateInputs(n,e);try{let s=await n.run(t);return s=replaceTensors(s),s}catch(s){throw console.error(`An error occurred during model execution: "${s}".`),console.error("Inputs given to model:",t),s}}function replaceTensors(n){for(let e in n)n[e]instanceof ONNXTensor?n[e]=new Tensor(n[e]):typeof n[e]=="object"&&replaceTensors(n[e]);return n}function toI64Tensor(n){if(n instanceof Tensor)return n;if(n.length===0)throw Error("items must be non-empty");if(Array.isArray(n[0])){if(n.some(e=>e.length!==n[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Tensor("int64",BigInt64Array.from(n.flat().map(e=>BigInt(e))),[n.length,n[0].length])}else return new Tensor("int64",BigInt64Array.from(n.map(e=>BigInt(e))),[1,n.length])}function prepareAttentionMask(n,e){let t=n.config.pad_token_id??null,s=n.config.eos_token_id??null;isIntegralNumber(s)&&(s=[s]);let a=e.indexOf(t)!==-1,c=s===null||!s.includes(t);if(a&&c){let l=BigInt64Array.from(e.data.map(_=>_!=t));return new Tensor("int64",l,e.dims)}else return ones_like(e)}function preparePositionIds(n,e,t){if(!n.inputNames.includes("position_ids"))return;const s=new BigInt64Array(e.attention_mask.data.length);for(let a=0;a<e.attention_mask.dims[0];++a){let c=a*e.attention_mask.dims[1],l=BigInt(0);for(let _=0;_<e.attention_mask.dims[1];++_){const m=c+_;e.attention_mask.data[m]===0n?s[m]=BigInt(1):(s[m]=l,l+=e.attention_mask.data[m])}}e.position_ids=new Tensor("int64",s,e.attention_mask.dims),t&&(e.position_ids=e.position_ids.slice(null,-1).unsqueeze_(-1))}function boolTensor(n){return new Tensor("bool",[n],[1])}async function seq2seqForward(n,e){let{encoder_outputs:t,past_key_values:s}=e;t||(t=(await encoderForward(n,e)).last_hidden_state);let a={input_ids:e.decoder_input_ids,encoder_hidden_states:t};const c=!!s;n.decoder_merged_session.inputNames.includes("use_cache_branch")&&(a.use_cache_branch=boolTensor(c)),n.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(a.encoder_attention_mask=e.attention_mask),preparePositionIds(n.decoder_merged_session,a,c),n.addPastKeyValues(a,s);const l=await sessionRun(n.decoder_merged_session,a);let _=l.logits;s=n.getPastKeyValues(l,s);const m=n.getAttentions(l);return new Seq2SeqLMOutput({logits:_,past_key_values:s,encoder_outputs:t,...m})}function seq2seqStartBeams(n,e,t,s){let a=[],c=0;const l=n.requires_attention_mask??!0;let _=t.decoder_input_ids??t.decoder_start_token_id??t.bos_token_id??t.eos_token_id;_ instanceof Tensor?_=_.tolist().flat():Array.isArray(_)||(_=[_]);for(let m of e){m.dims=[1,...m.dims];let d={inputs:m,encoder_outputs:null,prev_model_outputs:null,output_token_ids:_,done:!1,score:0,id:c++};l&&(d.attention_mask=prepareAttentionMask(n,m)),a.push(d)}return a}async function seq2seqRunBeam(n,e){const t=n.main_input_name;let s=e.output_token_ids;e.prev_model_outputs&&(s=s.slice(-1));let a={[t]:e.inputs,decoder_input_ids:toI64Tensor(s),encoder_outputs:e.encoder_outputs,past_key_values:e.prev_model_outputs?.past_key_values};e.attention_mask&&(a.attention_mask=e.attention_mask);let c=await n.forward(a);return e.prev_model_outputs=c,e.encoder_outputs=c.encoder_outputs,c}function seq2seqUpdatebeam(n,e){n.output_token_ids=[...n.output_token_ids,e]}async function encoderForward(n,e){const t=Object.create(null);for(const s of n.session.inputNames)t[s]=e[s];return n.session.inputNames.includes("token_type_ids")&&!t.token_type_ids&&(t.token_type_ids=new Tensor("int64",new BigInt64Array(t.input_ids.data.length),t.input_ids.dims)),await sessionRun(n.session,t)}async function decoderForward(n,e){let{input_ids:t,past_key_values:s,attention_mask:a}=e,c={input_ids:t,attention_mask:a??prepareAttentionMask(n,t)};const l=!!s;n.session.inputNames.includes("use_cache_branch")&&(c.use_cache_branch=boolTensor(l)),preparePositionIds(n.session,c,l),n.addPastKeyValues(c,s);let _=await sessionRun(n.session,c),m=_.logits;return s=n.getPastKeyValues(_,s),{logits:m,past_key_values:s}}function decoderStartBeams(n,e,t,s,a){let c=[],l=0;for(let _ of e){let m=_.tolist().map(Number);_.dims=[1,..._.dims];let d;a?(d=a[l],d.dims=[1,...d.dims]):d=prepareAttentionMask(n,_);let h={input:_,model_input_ids:_,attention_mask:d,prev_model_outputs:null,output_token_ids:m,num_output_tokens:s,done:!1,score:0,id:l++};c.push(h)}return c}async function decoderRunBeam(n,e){let t=new BigInt64Array(e.output_token_ids.length).fill(1n),s={input_ids:e.model_input_ids,attention_mask:new Tensor("int64",t,[1,t.length]),past_key_values:e.prev_model_outputs?.past_key_values},a=await n.forward(s);return e.prev_model_outputs=a,a}function decoderUpdatebeam(n,e){n.output_token_ids=[...n.output_token_ids,e],n.model_input_ids=new Tensor("int64",[BigInt(e)],[1,1])}class PreTrainedModel extends Callable{main_input_name="input_ids";constructor(e,t){super(),this.config=e,this.session=t;const s=MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),a=MODEL_TYPE_MAPPING.get(s);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,a===MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=decoderRunBeam,this._getStartBeams=decoderStartBeams,this._updateBeam=decoderUpdatebeam,this._forward=decoderForward):a===MODEL_TYPES.Seq2Seq||a===MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=seq2seqRunBeam,this._getStartBeams=seq2seqStartBeams,this._updateBeam=seq2seqUpdatebeam,this._forward=seq2seqForward):a===MODEL_TYPES.EncoderDecoder?this._forward=encoderForward:this._forward=encoderForward}async dispose(){const e=[];for(let t of Object.keys(this)){const s=this[t];s instanceof InferenceSession&&e.push(s.handler.dispose())}return await Promise.all(e)}static async from_pretrained(e,{quantized:t=!0,progress_callback:s=null,config:a=null,cache_dir:c=null,local_files_only:l=!1,revision:_="main",model_file_name:m=null}={}){let d={quantized:t,progress_callback:s,config:a,cache_dir:c,local_files_only:l,revision:_,model_file_name:m};const h=MODEL_CLASS_TO_NAME_MAPPING.get(this),i=MODEL_TYPE_MAPPING.get(h);let r;return i===MODEL_TYPES.DecoderOnly?r=await Promise.all([AutoConfig.from_pretrained(e,d),constructSession(e,d.model_file_name??"decoder_model_merged",d),getModelJSON(e,"generation_config.json",!1,d)]):i===MODEL_TYPES.Seq2Seq||i===MODEL_TYPES.Vision2Seq?r=await Promise.all([AutoConfig.from_pretrained(e,d),constructSession(e,"encoder_model",d),constructSession(e,"decoder_model_merged",d),getModelJSON(e,"generation_config.json",!1,d)]):i===MODEL_TYPES.MaskGeneration?r=await Promise.all([AutoConfig.from_pretrained(e,d),constructSession(e,"vision_encoder",d),constructSession(e,"prompt_encoder_mask_decoder",d)]):i===MODEL_TYPES.EncoderDecoder?r=await Promise.all([AutoConfig.from_pretrained(e,d),constructSession(e,"encoder_model",d),constructSession(e,"decoder_model_merged",d)]):(i!==MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${h??a?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),r=await Promise.all([AutoConfig.from_pretrained(e,d),constructSession(e,d.model_file_name??"model",d)])),new this(...r)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}_get_logits_processor(e,t,s=null){const a=new LogitsProcessorList;if(e.repetition_penalty!==null&&e.repetition_penalty!==1&&a.push(new RepetitionPenaltyLogitsProcessor(e.repetition_penalty)),e.no_repeat_ngram_size!==null&&e.no_repeat_ngram_size>0&&a.push(new NoRepeatNGramLogitsProcessor(e.no_repeat_ngram_size)),e.bad_words_ids!==null&&a.push(new NoBadWordsLogitsProcessor(e.bad_words_ids,e.eos_token_id)),e.min_length!==null&&e.eos_token_id!==null&&e.min_length>0&&a.push(new MinLengthLogitsProcessor(e.min_length,e.eos_token_id)),e.min_new_tokens!==null&&e.eos_token_id!==null&&e.min_new_tokens>0&&a.push(new MinNewTokensLengthLogitsProcessor(t,e.min_new_tokens,e.eos_token_id)),e.forced_bos_token_id!==null&&a.push(new ForcedBOSTokenLogitsProcessor(e.forced_bos_token_id)),e.forced_eos_token_id!==null&&a.push(new ForcedEOSTokenLogitsProcessor(e.max_length,e.forced_eos_token_id)),e.begin_suppress_tokens!==null){let c=t>1||e.forced_bos_token_id===null?t:t+1;e.forced_decoder_ids!==null&&(c+=e.forced_decoder_ids[e.forced_decoder_ids.length-1][0]),a.push(new SuppressTokensAtBeginLogitsProcessor(e.begin_suppress_tokens,c))}return e.forced_decoder_ids!==null&&a.push(new ForceTokensLogitsProcessor(e.forced_decoder_ids)),s!==null&&a.extend(s),a}_get_generation_config(e){let t=new GenerationConfig(this.config);return"generation_config"in this&&Object.assign(t,this.generation_config),e!==null&&Object.assign(t,e),t}async generate(e,t=null,s=null,{inputs_attention_mask:a=null}={}){if(!this.can_generate){let w=`The current model class (${MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const y=this.config.model_type,x=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(y)??MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(y)??MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(y)??MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(y);throw x&&(w+=` Please use the following class instead: '${x[0]}'`),Error(w)}if(!(e instanceof Tensor)&&!isTypedArray(e)&&!Array.isArray(e))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${e.constructor.name}".`);let c;if(this.config.is_encoder_decoder)c=0;else if(c=e instanceof Tensor?e.dims.at(-1):e.length,c===0)throw Error("Must supply a non-empty array of input token ids.");t=this._get_generation_config(t),s=s??new LogitsProcessorList,s=this._get_logits_processor(t,c,s);let l=t.eos_token_id;l!==null&&!Array.isArray(l)&&(l=[l]);let _=1;const m=_+(t.max_new_tokens??1/0),d=Number.isInteger(t.max_length)&&(t.max_new_tokens??null)===null;let h=Sampler.getSampler(t),i=this.getStartBeams(e,t,_,a);for(;i.some(g=>!g.done)&&_<m;){let g=[];for(let w of i){if(w.done){g.push(w);continue}if(d&&w.output_token_ids.length>=t.max_length){w.done=!0,g.push(w);continue}let y=await this.runBeam(w);t.output_attentions&&this.addAttentionsToBeam(w,y),t.output_scores;let x=y.logits.slice(null,-1,null);s(w.output_token_ids,x);let S=h(x);for(let[T,E]of S){let A={...w};this.updateBeam(A,T),A.score+=E,l&&l.includes(T)&&(A.done=!0),g.push(A)}}++_,g=this.groupBeams(g).map(w=>w.sort((y,x)=>x.score-y.score).slice(0,t.num_beams)),i=g.flat(),t.callback_function&&t.callback_function(i)}const r=this.groupBeams(i),u=g=>r.map(w=>t.num_return_sequences>1?w.slice(0,t.num_return_sequences).map(y=>y[g]):[w[0][g]]).flat(),f=u("output_token_ids");if(t.return_dict_in_generate){const g=u("decoder_attentions"),w=u("cross_attentions");return{sequences:f,decoder_attentions:g,cross_attentions:w}}else return f}addAttentionsToBeam(e,t){if(this.config.is_encoder_decoder){if(!t.cross_attentions||t.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.cross_attentions||(e.cross_attentions=[]),e.cross_attentions.push(t.cross_attentions)}if(!t.decoder_attentions||t.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.decoder_attentions||(e.decoder_attentions=[]),e.decoder_attentions.push(t.decoder_attentions)}groupBeams(e){const t=Object.create(null);for(const s of e)t[s.id]===void 0?t[s.id]=[s]:t[s.id].push(s);return Object.values(t)}getPastKeyValues(e,t){const s=Object.create(null);for(const a in e)if(a.startsWith("present")){let c=a.replace("present","past_key_values");t&&a.includes("encoder")?s[c]=t[c]:s[c]=e[a]}return s}getAttentions(e){const t=Object.create(null);for(const s of["cross_attentions","decoder_attentions"]){const a=[];for(const c in e)if(c.startsWith(s)){const l=c.split(".").pop();a[l]=e[c]}t[s]=a}return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let a=[1,this.num_encoder_heads,0,this.encoder_dim_kv],c=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let l=0;l<this.num_decoder_layers;++l)e[`past_key_values.${l}.encoder.key`]=new Tensor("float32",[],a),e[`past_key_values.${l}.encoder.value`]=new Tensor("float32",[],a),e[`past_key_values.${l}.decoder.key`]=new Tensor("float32",[],c),e[`past_key_values.${l}.decoder.value`]=new Tensor("float32",[],c)}else if(this.config.model_type==="falcon"){let a=[1*this.num_heads,0,this.dim_kv];for(let c=0;c<this.num_layers;++c)e[`past_key_values.${c}.key`]=new Tensor("float32",[],a),e[`past_key_values.${c}.value`]=new Tensor("float32",[],a)}else if(this.config.multi_query){let a=[1*this.num_heads,0,2*this.dim_kv];for(let c=0;c<this.num_layers;++c)e[`past_key_values.${c}.key_value`]=new Tensor("float32",[],a)}else if(this.config.model_type==="bloom"){let a=[1*this.num_heads,this.dim_kv,0],c=[1*this.num_heads,0,this.dim_kv];for(let l=0;l<this.num_layers;++l)e[`past_key_values.${l}.key`]=new Tensor("float32",[],a),e[`past_key_values.${l}.value`]=new Tensor("float32",[],c)}else{let a=[1,this.num_heads,0,this.dim_kv];for(let c=0;c<this.num_layers;++c)e[`past_key_values.${c}.key`]=new Tensor("float32",[],a),e[`past_key_values.${c}.value`]=new Tensor("float32",[],a)}}getStartBeams(e,t,s,a){return this._getStartBeams(this,e,t,s,a)}async runBeam(e){return await this._runBeam(this,e)}updateBeam(e,t){return this._updateBeam(e,t)}}class ModelOutput{}class BertPreTrainedModel extends PreTrainedModel{}class BertModel extends BertPreTrainedModel{}class BertForMaskedLM extends BertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class BertForSequenceClassification extends BertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class BertForTokenClassification extends BertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class BertForQuestionAnswering extends BertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class NomicBertPreTrainedModel extends PreTrainedModel{}class NomicBertModel extends NomicBertPreTrainedModel{}class RoFormerPreTrainedModel extends PreTrainedModel{}class RoFormerModel extends RoFormerPreTrainedModel{}class RoFormerForMaskedLM extends RoFormerPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class RoFormerForSequenceClassification extends RoFormerPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class RoFormerForTokenClassification extends RoFormerPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ConvBertPreTrainedModel extends PreTrainedModel{}class ConvBertModel extends ConvBertPreTrainedModel{}class ConvBertForMaskedLM extends ConvBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class ConvBertForSequenceClassification extends ConvBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ConvBertForTokenClassification extends ConvBertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ElectraPreTrainedModel extends PreTrainedModel{}class ElectraModel extends ElectraPreTrainedModel{}class ElectraForMaskedLM extends ElectraPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class ElectraForSequenceClassification extends ElectraPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ElectraForTokenClassification extends ElectraPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class ElectraForQuestionAnswering extends ElectraPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class CamembertPreTrainedModel extends PreTrainedModel{}class CamembertModel extends CamembertPreTrainedModel{}class CamembertForMaskedLM extends CamembertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class CamembertForSequenceClassification extends CamembertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class CamembertForTokenClassification extends CamembertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class CamembertForQuestionAnswering extends CamembertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DebertaPreTrainedModel extends PreTrainedModel{}class DebertaModel extends DebertaPreTrainedModel{}class DebertaForMaskedLM extends DebertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class DebertaForSequenceClassification extends DebertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DebertaForTokenClassification extends DebertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DebertaForQuestionAnswering extends DebertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DebertaV2PreTrainedModel extends PreTrainedModel{}class DebertaV2Model extends DebertaV2PreTrainedModel{}class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DistilBertPreTrainedModel extends PreTrainedModel{}class DistilBertModel extends DistilBertPreTrainedModel{}class DistilBertForSequenceClassification extends DistilBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DistilBertForTokenClassification extends DistilBertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DistilBertForMaskedLM extends DistilBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class EsmPreTrainedModel extends PreTrainedModel{}class EsmModel extends EsmPreTrainedModel{}class EsmForMaskedLM extends EsmPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class EsmForSequenceClassification extends EsmPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class EsmForTokenClassification extends EsmPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class MobileBertPreTrainedModel extends PreTrainedModel{}class MobileBertModel extends MobileBertPreTrainedModel{}class MobileBertForMaskedLM extends MobileBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class MobileBertForSequenceClassification extends MobileBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class MPNetPreTrainedModel extends PreTrainedModel{}class MPNetModel extends MPNetPreTrainedModel{}class MPNetForMaskedLM extends MPNetPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class MPNetForSequenceClassification extends MPNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MPNetForTokenClassification extends MPNetPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class MPNetForQuestionAnswering extends MPNetPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class SqueezeBertPreTrainedModel extends PreTrainedModel{}class SqueezeBertModel extends SqueezeBertPreTrainedModel{}class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class AlbertPreTrainedModel extends PreTrainedModel{}class AlbertModel extends AlbertPreTrainedModel{}class AlbertForSequenceClassification extends AlbertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class AlbertForQuestionAnswering extends AlbertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class AlbertForMaskedLM extends AlbertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class T5PreTrainedModel extends PreTrainedModel{}class T5Model extends T5PreTrainedModel{}class T5ForConditionalGeneration extends T5PreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class LongT5PreTrainedModel extends PreTrainedModel{}class LongT5Model extends LongT5PreTrainedModel{}class LongT5ForConditionalGeneration extends LongT5PreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class MT5PreTrainedModel extends PreTrainedModel{}class MT5Model extends MT5PreTrainedModel{}class MT5ForConditionalGeneration extends MT5PreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class BartPretrainedModel extends PreTrainedModel{}class BartModel extends BartPretrainedModel{}class BartForConditionalGeneration extends BartPretrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BartForSequenceClassification extends BartPretrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MBartPreTrainedModel extends PreTrainedModel{}class MBartModel extends MBartPreTrainedModel{}class MBartForConditionalGeneration extends MBartPreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class MBartForSequenceClassification extends MBartPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MBartForCausalLM extends MBartPreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotPreTrainedModel extends PreTrainedModel{}class BlenderbotModel extends BlenderbotPreTrainedModel{}class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotSmallPreTrainedModel extends PreTrainedModel{}class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel{}class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class RobertaPreTrainedModel extends PreTrainedModel{}class RobertaModel extends RobertaPreTrainedModel{}class RobertaForMaskedLM extends RobertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class RobertaForSequenceClassification extends RobertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class RobertaForTokenClassification extends RobertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class RobertaForQuestionAnswering extends RobertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class XLMPreTrainedModel extends PreTrainedModel{}class XLMModel extends XLMPreTrainedModel{}class XLMWithLMHeadModel extends XLMPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class XLMForSequenceClassification extends XLMPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class XLMForTokenClassification extends XLMPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class XLMForQuestionAnswering extends XLMPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class XLMRobertaPreTrainedModel extends PreTrainedModel{}class XLMRobertaModel extends XLMRobertaPreTrainedModel{}class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ASTPreTrainedModel extends PreTrainedModel{}class ASTModel extends ASTPreTrainedModel{}class ASTForAudioClassification extends ASTPreTrainedModel{}class WhisperPreTrainedModel extends PreTrainedModel{}class WhisperModel extends WhisperPreTrainedModel{}class WhisperForConditionalGeneration extends WhisperPreTrainedModel{requires_attention_mask=!1;main_input_name="input_features";constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(e,t=null,s=null){if(t=this._get_generation_config(t),t.return_timestamps??=!1,t.return_timestamps&&(s=[new WhisperTimeStampLogitsProcessor(t)]),t.return_token_timestamps&&(t.output_attentions=!0,t.return_dict_in_generate=!0,t.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!t.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const a=await super.generate(e,t,s);return t.return_token_timestamps&&t.alignment_heads&&(a.token_timestamps=this._extract_token_timestamps(a,t.alignment_heads,t.num_frames)),a}_extract_token_timestamps(e,t,s=null,a=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let c=this.config.median_filter_width;c===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),c=7);const l=e.cross_attentions.map(d=>{let h=Array.from({length:this.config.decoder_layers},(w,y)=>cat(d.map(x=>x[y]),2)),i=stack(t.map(([w,y])=>s?h[w].slice(null,y,null,[0,s]):h[w].slice(null,y)));i=i.transpose(1,0,2,3);let[r,u]=std_mean(i,-2,0,!0),f=i.clone();for(let w=0;w<f.dims[0];++w){let y=f[w];for(let x=0;x<y.dims[0];++x){let S=y[x];const T=r[w][x][0],E=u[w][x][0];for(let A=0;A<S.dims[0];++A){let C=S[A];for(let I=0;I<C.data.length;++I)C.data[I]=(C.data[I]-E.data[I])/T.data[I];C.data.set(medianFilter(C.data,c))}}}return mean(f,1)}),_=[e.sequences.length,e.sequences[0].length],m=new Tensor("float32",new Float32Array(_[0]*_[1]),_);for(let d=0;d<_[0];++d){const h=l[d].neg().squeeze_(0);let[i,r]=dynamicTimeWarping(h),u=Array.from({length:i.length-1},(w,y)=>i[y+1]-i[y]),f=mergeArrays([1],u).map(w=>!!w),g=[];for(let w=0;w<f.length;++w)f[w]&&g.push(r[w]*a);m[d].data.set(g,1)}return m}}class VisionEncoderDecoderModel extends PreTrainedModel{main_input_name="pixel_values";constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a;const c=this.config.encoder,l=this.config.decoder,_=c.model_type;(MODEL_MAPPING_NAMES_ENCODER_ONLY.get(_)??MODEL_MAPPING_NAMES_ENCODER_DECODER.get(_))||console.warn(`Model type for encoder '${_}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const d=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(l.model_type);if(!d)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const h=d[1],i=new h(l,s,a);this.add_encoder_pkv="num_decoder_layers"in i,this.add_encoder_pkv?(this.num_decoder_layers=i.num_decoder_layers,this.num_decoder_heads=i.num_decoder_heads,this.decoder_dim_kv=i.decoder_dim_kv,this.num_encoder_layers=i.num_encoder_layers,this.num_encoder_heads=i.num_encoder_heads,this.encoder_dim_kv=i.encoder_dim_kv):(this.num_layers=i.num_layers,this.num_heads=i.num_heads,this.dim_kv=i.dim_kv)}}class CLIPPreTrainedModel extends PreTrainedModel{}class CLIPModel extends CLIPPreTrainedModel{}class CLIPTextModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(e,t={}){return t.model_file_name??="text_model",super.from_pretrained(e,t)}}class CLIPVisionModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(e,t={}){return t.model_file_name??="vision_model",super.from_pretrained(e,t)}}class SiglipPreTrainedModel extends PreTrainedModel{}class SiglipModel extends SiglipPreTrainedModel{}class SiglipTextModel extends SiglipPreTrainedModel{static async from_pretrained(e,t={}){return t.model_file_name??="text_model",super.from_pretrained(e,t)}}class SiglipVisionModel extends CLIPPreTrainedModel{static async from_pretrained(e,t={}){return t.model_file_name??="vision_model",super.from_pretrained(e,t)}}class ChineseCLIPPreTrainedModel extends PreTrainedModel{}class ChineseCLIPModel extends ChineseCLIPPreTrainedModel{}class CLIPSegPreTrainedModel extends PreTrainedModel{}class CLIPSegModel extends CLIPSegPreTrainedModel{}class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel{}class GPT2PreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPT2Model extends GPT2PreTrainedModel{}class GPT2LMHeadModel extends GPT2PreTrainedModel{}class GPTNeoPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoModel extends GPTNeoPreTrainedModel{}class GPTNeoForCausalLM extends GPTNeoPreTrainedModel{}class GPTNeoXPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoXModel extends GPTNeoXPreTrainedModel{}class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel{}class GPTJPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTJModel extends GPTJPreTrainedModel{}class GPTJForCausalLM extends GPTJPreTrainedModel{}class GPTBigCodePreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTBigCodeModel extends GPTBigCodePreTrainedModel{}class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel{}class CodeGenPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class CodeGenModel extends CodeGenPreTrainedModel{}class CodeGenForCausalLM extends CodeGenPreTrainedModel{}class LlamaPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class LlamaModel extends LlamaPreTrainedModel{}class LlamaForCausalLM extends LlamaPreTrainedModel{}class Qwen2PreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Qwen2Model extends Qwen2PreTrainedModel{}class Qwen2ForCausalLM extends Qwen2PreTrainedModel{}class PhiPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class PhiModel extends PhiPreTrainedModel{}class PhiForCausalLM extends PhiPreTrainedModel{}class BloomPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class BloomModel extends BloomPreTrainedModel{}class BloomForCausalLM extends BloomPreTrainedModel{}class MptPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class MptModel extends MptPreTrainedModel{}class MptForCausalLM extends MptPreTrainedModel{}class OPTPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class OPTModel extends OPTPreTrainedModel{}class OPTForCausalLM extends OPTPreTrainedModel{}class ViTPreTrainedModel extends PreTrainedModel{}class ViTModel extends ViTPreTrainedModel{}class ViTForImageClassification extends ViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class FastViTPreTrainedModel extends PreTrainedModel{}class FastViTModel extends FastViTPreTrainedModel{}class FastViTForImageClassification extends FastViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class VitMattePreTrainedModel extends PreTrainedModel{}class VitMatteForImageMatting extends VitMattePreTrainedModel{async _call(e){return new ImageMattingOutput(await super._call(e))}}class MobileViTPreTrainedModel extends PreTrainedModel{}class MobileViTModel extends MobileViTPreTrainedModel{}class MobileViTForImageClassification extends MobileViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MobileViTV2PreTrainedModel extends PreTrainedModel{}class MobileViTV2Model extends MobileViTV2PreTrainedModel{}class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class OwlViTPreTrainedModel extends PreTrainedModel{}class OwlViTModel extends OwlViTPreTrainedModel{}class OwlViTForObjectDetection extends OwlViTPreTrainedModel{}class Owlv2PreTrainedModel extends PreTrainedModel{}class Owlv2Model extends Owlv2PreTrainedModel{}class Owlv2ForObjectDetection extends Owlv2PreTrainedModel{}class BeitPreTrainedModel extends PreTrainedModel{}class BeitModel extends BeitPreTrainedModel{}class BeitForImageClassification extends BeitPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DetrPreTrainedModel extends PreTrainedModel{}class DetrModel extends DetrPreTrainedModel{}class DetrForObjectDetection extends DetrPreTrainedModel{async _call(e){return new DetrObjectDetectionOutput(await super._call(e))}}class DetrForSegmentation extends DetrPreTrainedModel{async _call(e){return new DetrSegmentationOutput(await super._call(e))}}class DetrObjectDetectionOutput extends ModelOutput{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class DetrSegmentationOutput extends ModelOutput{constructor({logits:e,pred_boxes:t,pred_masks:s}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=s}}class TableTransformerPreTrainedModel extends PreTrainedModel{}class TableTransformerModel extends TableTransformerPreTrainedModel{}class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel{async _call(e){return new TableTransformerObjectDetectionOutput(await super._call(e))}}class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput{}class DeiTPreTrainedModel extends PreTrainedModel{}class DeiTModel extends DeiTPreTrainedModel{}class DeiTForImageClassification extends DeiTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ResNetPreTrainedModel extends PreTrainedModel{}class ResNetModel extends ResNetPreTrainedModel{}class ResNetForImageClassification extends ResNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class SwinPreTrainedModel extends PreTrainedModel{}class SwinModel extends SwinPreTrainedModel{}class SwinForImageClassification extends SwinPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Swin2SRPreTrainedModel extends PreTrainedModel{}class Swin2SRModel extends Swin2SRPreTrainedModel{}class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel{}class DPTPreTrainedModel extends PreTrainedModel{}class DPTModel extends DPTPreTrainedModel{}class DPTForDepthEstimation extends DPTPreTrainedModel{}class DepthAnythingPreTrainedModel extends PreTrainedModel{}class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel{}class GLPNPreTrainedModel extends PreTrainedModel{}class GLPNModel extends GLPNPreTrainedModel{}class GLPNForDepthEstimation extends GLPNPreTrainedModel{}class DonutSwinPreTrainedModel extends PreTrainedModel{}class DonutSwinModel extends DonutSwinPreTrainedModel{}class ConvNextPreTrainedModel extends PreTrainedModel{}class ConvNextModel extends ConvNextPreTrainedModel{}class ConvNextForImageClassification extends ConvNextPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ConvNextV2PreTrainedModel extends PreTrainedModel{}class ConvNextV2Model extends ConvNextV2PreTrainedModel{}class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Dinov2PreTrainedModel extends PreTrainedModel{}class Dinov2Model extends Dinov2PreTrainedModel{}class Dinov2ForImageClassification extends Dinov2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class YolosPreTrainedModel extends PreTrainedModel{}class YolosModel extends YolosPreTrainedModel{}class YolosForObjectDetection extends YolosPreTrainedModel{async _call(e){return new YolosObjectDetectionOutput(await super._call(e))}}class YolosObjectDetectionOutput extends ModelOutput{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class SamPreTrainedModel extends PreTrainedModel{}class SamModel extends SamPreTrainedModel{constructor(e,t,s){super(e,t),this.prompt_encoder_mask_decoder=s}async get_image_embeddings({pixel_values:e}){return await encoderForward(this,{pixel_values:e})}async forward(e){if((!e.image_embeddings||!e.image_positional_embeddings)&&(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels){const t=e.input_points.dims.slice(0,-1),s=t.reduce((a,c)=>a*c,1);e.input_labels=new Tensor("int64",new BigInt64Array(s).fill(1n),t)}return await sessionRun(this.prompt_encoder_mask_decoder,{input_points:e.input_points,input_labels:e.input_labels,image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings})}async _call(e){return new SamImageSegmentationOutput(await super._call(e))}}class SamImageSegmentationOutput extends ModelOutput{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class MarianPreTrainedModel extends PreTrainedModel{}class MarianModel extends MarianPreTrainedModel{}class MarianMTModel extends MarianPreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class M2M100PreTrainedModel extends PreTrainedModel{}class M2M100Model extends M2M100PreTrainedModel{}class M2M100ForConditionalGeneration extends M2M100PreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wav2Vec2PreTrainedModel extends PreTrainedModel{}class Wav2Vec2Model extends Wav2Vec2PreTrainedModel{}class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class UniSpeechPreTrainedModel extends PreTrainedModel{}class UniSpeechModel extends UniSpeechPreTrainedModel{}class UniSpeechForCTC extends UniSpeechPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class UniSpeechSatPreTrainedModel extends PreTrainedModel{}class UniSpeechSatModel extends UniSpeechSatPreTrainedModel{}class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class Wav2Vec2BertPreTrainedModel extends PreTrainedModel{}class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel{}class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class HubertModel extends Wav2Vec2PreTrainedModel{}class HubertForCTC extends Wav2Vec2PreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class WavLMPreTrainedModel extends PreTrainedModel{}class WavLMModel extends WavLMPreTrainedModel{}class WavLMForCTC extends WavLMPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class WavLMForSequenceClassification extends WavLMPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class WavLMForXVector extends WavLMPreTrainedModel{async _call(e){return new XVectorOutput(await super._call(e))}}class WavLMForAudioFrameClassification extends WavLMPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class SpeechT5PreTrainedModel extends PreTrainedModel{}class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel{}class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel{constructor(e,t,s,a){super(e,t),this.decoder_merged_session=s,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(e,t,{threshold:s=.5,minlenratio:a=0,maxlenratio:c=20,vocoder:l=null}={}){const _={input_ids:e},{encoder_outputs:m,encoder_attention_mask:d}=await encoderForward(this,_),h=m.dims[1]/this.config.reduction_factor,i=Math.floor(h*c),r=Math.floor(h*a),u=this.config.num_mel_bins;let f=[],g=null,w=null,y=0;for(;;){++y;const T=boolTensor(!!w);let E;w?E=w.output_sequence_out:E=new Tensor("float32",new Float32Array(u),[1,1,u]);let A={use_cache_branch:T,output_sequence:E,encoder_attention_mask:d,speaker_embeddings:t,encoder_hidden_states:m};this.addPastKeyValues(A,g),w=await sessionRun(this.decoder_merged_session,A),g=this.getPastKeyValues(w,g);const{prob:C,spectrum:I}=w;if(f.push(I),y>=r&&(Array.from(C.data).filter(D=>D>=s).length>0||y>=i))break}const x=cat(f),{waveform:S}=await sessionRun(l.session,{spectrogram:x});return{spectrogram:x,waveform:S}}}class SpeechT5HifiGan extends PreTrainedModel{main_input_name="spectrogram"}class TrOCRPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class TrOCRForCausalLM extends TrOCRPreTrainedModel{}class MistralPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class MistralModel extends MistralPreTrainedModel{}class MistralForCausalLM extends MistralPreTrainedModel{}class Starcoder2PreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Starcoder2Model extends Starcoder2PreTrainedModel{}class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel{}class FalconPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class FalconModel extends FalconPreTrainedModel{}class FalconForCausalLM extends FalconPreTrainedModel{}class ClapPreTrainedModel extends PreTrainedModel{}class ClapModel extends ClapPreTrainedModel{}class ClapTextModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(e,t={}){return t.model_file_name??="text_model",super.from_pretrained(e,t)}}class ClapAudioModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(e,t={}){return t.model_file_name??="audio_model",super.from_pretrained(e,t)}}class VitsPreTrainedModel extends PreTrainedModel{}class VitsModel extends VitsPreTrainedModel{async _call(e){return new VitsModelOutput(await super._call(e))}}class SegformerPreTrainedModel extends PreTrainedModel{}class SegformerForImageClassification extends SegformerPreTrainedModel{}class SegformerForSemanticSegmentation extends SegformerPreTrainedModel{}class StableLmPreTrainedModel extends PreTrainedModel{constructor(e,t,s){super(e,t),this.generation_config=s,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class StableLmForCausalLM extends StableLmPreTrainedModel{}class EfficientNetPreTrainedModel extends PreTrainedModel{}class EfficientNetModel extends EfficientNetPreTrainedModel{}class EfficientNetForImageClassification extends EfficientNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class PretrainedMixin{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{quantized:t=!0,progress_callback:s=null,config:a=null,cache_dir:c=null,local_files_only:l=!1,revision:_="main",model_file_name:m=null}={}){let d={quantized:t,progress_callback:s,config:a,cache_dir:c,local_files_only:l,revision:_,model_file_name:m};if(a=await AutoConfig.from_pretrained(e,d),d.config||(d.config=a),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let h of this.MODEL_CLASS_MAPPINGS){const i=h.get(a.model_type);if(i)return await i[1].from_pretrained(e,d)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${a.model_type}", attempting to construct from base class.`),await PreTrainedModel.from_pretrained(e,d);throw Error(`Unsupported model type: ${a.model_type}`)}}const MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",BertModel]],["nomic_bert",["NomicBertModel",NomicBertModel]],["roformer",["RoFormerModel",RoFormerModel]],["electra",["ElectraModel",ElectraModel]],["esm",["EsmModel",EsmModel]],["convbert",["ConvBertModel",ConvBertModel]],["camembert",["CamembertModel",CamembertModel]],["deberta",["DebertaModel",DebertaModel]],["deberta-v2",["DebertaV2Model",DebertaV2Model]],["mpnet",["MPNetModel",MPNetModel]],["albert",["AlbertModel",AlbertModel]],["distilbert",["DistilBertModel",DistilBertModel]],["roberta",["RobertaModel",RobertaModel]],["xlm",["XLMModel",XLMModel]],["xlm-roberta",["XLMRobertaModel",XLMRobertaModel]],["clap",["ClapModel",ClapModel]],["clip",["CLIPModel",CLIPModel]],["clipseg",["CLIPSegModel",CLIPSegModel]],["chinese_clip",["ChineseCLIPModel",ChineseCLIPModel]],["siglip",["SiglipModel",SiglipModel]],["mobilebert",["MobileBertModel",MobileBertModel]],["squeezebert",["SqueezeBertModel",SqueezeBertModel]],["wav2vec2",["Wav2Vec2Model",Wav2Vec2Model]],["wav2vec2-bert",["Wav2Vec2BertModel",Wav2Vec2BertModel]],["unispeech",["UniSpeechModel",UniSpeechModel]],["unispeech-sat",["UniSpeechSatModel",UniSpeechSatModel]],["hubert",["HubertModel",HubertModel]],["wavlm",["WavLMModel",WavLMModel]],["audio-spectrogram-transformer",["ASTModel",ASTModel]],["vits",["VitsModel",VitsModel]],["detr",["DetrModel",DetrModel]],["table-transformer",["TableTransformerModel",TableTransformerModel]],["vit",["ViTModel",ViTModel]],["fastvit",["FastViTModel",FastViTModel]],["mobilevit",["MobileViTModel",MobileViTModel]],["mobilevitv2",["MobileViTV2Model",MobileViTV2Model]],["owlvit",["OwlViTModel",OwlViTModel]],["owlv2",["Owlv2Model",Owlv2Model]],["beit",["BeitModel",BeitModel]],["deit",["DeiTModel",DeiTModel]],["convnext",["ConvNextModel",ConvNextModel]],["convnextv2",["ConvNextV2Model",ConvNextV2Model]],["dinov2",["Dinov2Model",Dinov2Model]],["resnet",["ResNetModel",ResNetModel]],["swin",["SwinModel",SwinModel]],["swin2sr",["Swin2SRModel",Swin2SRModel]],["donut-swin",["DonutSwinModel",DonutSwinModel]],["yolos",["YolosModel",YolosModel]],["dpt",["DPTModel",DPTModel]],["glpn",["GLPNModel",GLPNModel]],["hifigan",["SpeechT5HifiGan",SpeechT5HifiGan]],["efficientnet",["EfficientNetModel",EfficientNetModel]]]),MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",T5Model]],["longt5",["LongT5Model",LongT5Model]],["mt5",["MT5Model",MT5Model]],["bart",["BartModel",BartModel]],["mbart",["MBartModel",MBartModel]],["marian",["MarianModel",MarianModel]],["whisper",["WhisperModel",WhisperModel]],["m2m_100",["M2M100Model",M2M100Model]],["blenderbot",["BlenderbotModel",BlenderbotModel]],["blenderbot-small",["BlenderbotSmallModel",BlenderbotSmallModel]]]),MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",BloomModel]],["gpt2",["GPT2Model",GPT2Model]],["gptj",["GPTJModel",GPTJModel]],["gpt_bigcode",["GPTBigCodeModel",GPTBigCodeModel]],["gpt_neo",["GPTNeoModel",GPTNeoModel]],["gpt_neox",["GPTNeoXModel",GPTNeoXModel]],["codegen",["CodeGenModel",CodeGenModel]],["llama",["LlamaModel",LlamaModel]],["qwen2",["Qwen2Model",Qwen2Model]],["phi",["PhiModel",PhiModel]],["mpt",["MptModel",MptModel]],["opt",["OPTModel",OPTModel]],["mistral",["MistralModel",MistralModel]],["starcoder2",["Starcoder2Model",Starcoder2Model]],["falcon",["FalconModel",FalconModel]]]),MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForSpeechToText",SpeechT5ForSpeechToText]],["whisper",["WhisperForConditionalGeneration",WhisperForConditionalGeneration]]]),MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForTextToSpeech",SpeechT5ForTextToSpeech]]]),MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES=new Map([["vits",["VitsModel",VitsModel]]]),MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",BertForSequenceClassification]],["roformer",["RoFormerForSequenceClassification",RoFormerForSequenceClassification]],["electra",["ElectraForSequenceClassification",ElectraForSequenceClassification]],["esm",["EsmForSequenceClassification",EsmForSequenceClassification]],["convbert",["ConvBertForSequenceClassification",ConvBertForSequenceClassification]],["camembert",["CamembertForSequenceClassification",CamembertForSequenceClassification]],["deberta",["DebertaForSequenceClassification",DebertaForSequenceClassification]],["deberta-v2",["DebertaV2ForSequenceClassification",DebertaV2ForSequenceClassification]],["mpnet",["MPNetForSequenceClassification",MPNetForSequenceClassification]],["albert",["AlbertForSequenceClassification",AlbertForSequenceClassification]],["distilbert",["DistilBertForSequenceClassification",DistilBertForSequenceClassification]],["roberta",["RobertaForSequenceClassification",RobertaForSequenceClassification]],["xlm",["XLMForSequenceClassification",XLMForSequenceClassification]],["xlm-roberta",["XLMRobertaForSequenceClassification",XLMRobertaForSequenceClassification]],["bart",["BartForSequenceClassification",BartForSequenceClassification]],["mbart",["MBartForSequenceClassification",MBartForSequenceClassification]],["mobilebert",["MobileBertForSequenceClassification",MobileBertForSequenceClassification]],["squeezebert",["SqueezeBertForSequenceClassification",SqueezeBertForSequenceClassification]]]),MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",BertForTokenClassification]],["roformer",["RoFormerForTokenClassification",RoFormerForTokenClassification]],["electra",["ElectraForTokenClassification",ElectraForTokenClassification]],["esm",["EsmForTokenClassification",EsmForTokenClassification]],["convbert",["ConvBertForTokenClassification",ConvBertForTokenClassification]],["camembert",["CamembertForTokenClassification",CamembertForTokenClassification]],["deberta",["DebertaForTokenClassification",DebertaForTokenClassification]],["deberta-v2",["DebertaV2ForTokenClassification",DebertaV2ForTokenClassification]],["mpnet",["MPNetForTokenClassification",MPNetForTokenClassification]],["distilbert",["DistilBertForTokenClassification",DistilBertForTokenClassification]],["roberta",["RobertaForTokenClassification",RobertaForTokenClassification]],["xlm",["XLMForTokenClassification",XLMForTokenClassification]],["xlm-roberta",["XLMRobertaForTokenClassification",XLMRobertaForTokenClassification]]]),MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",T5ForConditionalGeneration]],["longt5",["LongT5ForConditionalGeneration",LongT5ForConditionalGeneration]],["mt5",["MT5ForConditionalGeneration",MT5ForConditionalGeneration]],["bart",["BartForConditionalGeneration",BartForConditionalGeneration]],["mbart",["MBartForConditionalGeneration",MBartForConditionalGeneration]],["marian",["MarianMTModel",MarianMTModel]],["m2m_100",["M2M100ForConditionalGeneration",M2M100ForConditionalGeneration]],["blenderbot",["BlenderbotForConditionalGeneration",BlenderbotForConditionalGeneration]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",BlenderbotSmallForConditionalGeneration]]]),MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",BloomForCausalLM]],["gpt2",["GPT2LMHeadModel",GPT2LMHeadModel]],["gptj",["GPTJForCausalLM",GPTJForCausalLM]],["gpt_bigcode",["GPTBigCodeForCausalLM",GPTBigCodeForCausalLM]],["gpt_neo",["GPTNeoForCausalLM",GPTNeoForCausalLM]],["gpt_neox",["GPTNeoXForCausalLM",GPTNeoXForCausalLM]],["codegen",["CodeGenForCausalLM",CodeGenForCausalLM]],["llama",["LlamaForCausalLM",LlamaForCausalLM]],["qwen2",["Qwen2ForCausalLM",Qwen2ForCausalLM]],["phi",["PhiForCausalLM",PhiForCausalLM]],["mpt",["MptForCausalLM",MptForCausalLM]],["opt",["OPTForCausalLM",OPTForCausalLM]],["mbart",["MBartForCausalLM",MBartForCausalLM]],["mistral",["MistralForCausalLM",MistralForCausalLM]],["starcoder2",["Starcoder2ForCausalLM",Starcoder2ForCausalLM]],["falcon",["FalconForCausalLM",FalconForCausalLM]],["trocr",["TrOCRForCausalLM",TrOCRForCausalLM]],["stablelm",["StableLmForCausalLM",StableLmForCausalLM]]]),MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",BertForMaskedLM]],["roformer",["RoFormerForMaskedLM",RoFormerForMaskedLM]],["electra",["ElectraForMaskedLM",ElectraForMaskedLM]],["esm",["EsmForMaskedLM",EsmForMaskedLM]],["convbert",["ConvBertForMaskedLM",ConvBertForMaskedLM]],["camembert",["CamembertForMaskedLM",CamembertForMaskedLM]],["deberta",["DebertaForMaskedLM",DebertaForMaskedLM]],["deberta-v2",["DebertaV2ForMaskedLM",DebertaV2ForMaskedLM]],["mpnet",["MPNetForMaskedLM",MPNetForMaskedLM]],["albert",["AlbertForMaskedLM",AlbertForMaskedLM]],["distilbert",["DistilBertForMaskedLM",DistilBertForMaskedLM]],["roberta",["RobertaForMaskedLM",RobertaForMaskedLM]],["xlm",["XLMWithLMHeadModel",XLMWithLMHeadModel]],["xlm-roberta",["XLMRobertaForMaskedLM",XLMRobertaForMaskedLM]],["mobilebert",["MobileBertForMaskedLM",MobileBertForMaskedLM]],["squeezebert",["SqueezeBertForMaskedLM",SqueezeBertForMaskedLM]]]),MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",BertForQuestionAnswering]],["roformer",["RoFormerForQuestionAnswering",RoFormerForQuestionAnswering]],["electra",["ElectraForQuestionAnswering",ElectraForQuestionAnswering]],["convbert",["ConvBertForQuestionAnswering",ConvBertForQuestionAnswering]],["camembert",["CamembertForQuestionAnswering",CamembertForQuestionAnswering]],["deberta",["DebertaForQuestionAnswering",DebertaForQuestionAnswering]],["deberta-v2",["DebertaV2ForQuestionAnswering",DebertaV2ForQuestionAnswering]],["mpnet",["MPNetForQuestionAnswering",MPNetForQuestionAnswering]],["albert",["AlbertForQuestionAnswering",AlbertForQuestionAnswering]],["distilbert",["DistilBertForQuestionAnswering",DistilBertForQuestionAnswering]],["roberta",["RobertaForQuestionAnswering",RobertaForQuestionAnswering]],["xlm",["XLMForQuestionAnswering",XLMForQuestionAnswering]],["xlm-roberta",["XLMRobertaForQuestionAnswering",XLMRobertaForQuestionAnswering]],["mobilebert",["MobileBertForQuestionAnswering",MobileBertForQuestionAnswering]],["squeezebert",["SqueezeBertForQuestionAnswering",SqueezeBertForQuestionAnswering]]]),MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",ViTForImageClassification]],["fastvit",["FastViTForImageClassification",FastViTForImageClassification]],["mobilevit",["MobileViTForImageClassification",MobileViTForImageClassification]],["mobilevitv2",["MobileViTV2ForImageClassification",MobileViTV2ForImageClassification]],["beit",["BeitForImageClassification",BeitForImageClassification]],["deit",["DeiTForImageClassification",DeiTForImageClassification]],["convnext",["ConvNextForImageClassification",ConvNextForImageClassification]],["convnextv2",["ConvNextV2ForImageClassification",ConvNextV2ForImageClassification]],["dinov2",["Dinov2ForImageClassification",Dinov2ForImageClassification]],["resnet",["ResNetForImageClassification",ResNetForImageClassification]],["swin",["SwinForImageClassification",SwinForImageClassification]],["segformer",["SegformerForImageClassification",SegformerForImageClassification]],["efficientnet",["EfficientNetForImageClassification",EfficientNetForImageClassification]]]),MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",DetrForObjectDetection]],["table-transformer",["TableTransformerForObjectDetection",TableTransformerForObjectDetection]],["yolos",["YolosForObjectDetection",YolosForObjectDetection]]]),MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES=new Map([["owlvit",["OwlViTForObjectDetection",OwlViTForObjectDetection]],["owlv2",["Owlv2ForObjectDetection",Owlv2ForObjectDetection]]]),MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",DetrForSegmentation]],["clipseg",["CLIPSegForImageSegmentation",CLIPSegForImageSegmentation]]]),MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES=new Map([["segformer",["SegformerForSemanticSegmentation",SegformerForSemanticSegmentation]]]),MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",SamModel]]]),MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",Wav2Vec2ForCTC]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Wav2Vec2BertForCTC]],["unispeech",["UniSpeechForCTC",UniSpeechForCTC]],["unispeech-sat",["UniSpeechSatForCTC",UniSpeechSatForCTC]],["wavlm",["WavLMForCTC",WavLMForCTC]],["hubert",["HubertForCTC",HubertForCTC]]]),MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Wav2Vec2ForSequenceClassification]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Wav2Vec2BertForSequenceClassification]],["unispeech",["UniSpeechForSequenceClassification",UniSpeechForSequenceClassification]],["unispeech-sat",["UniSpeechSatForSequenceClassification",UniSpeechSatForSequenceClassification]],["wavlm",["WavLMForSequenceClassification",WavLMForSequenceClassification]],["hubert",["HubertForSequenceClassification",HubertForSequenceClassification]],["audio-spectrogram-transformer",["ASTForAudioClassification",ASTForAudioClassification]]]),MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES=new Map([["wavlm",["WavLMForXVector",WavLMForXVector]]]),MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",UniSpeechSatForAudioFrameClassification]],["wavlm",["WavLMForAudioFrameClassification",WavLMForAudioFrameClassification]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Wav2Vec2ForAudioFrameClassification]]]),MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES=new Map([["vitmatte",["VitMatteForImageMatting",VitMatteForImageMatting]]]),MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Swin2SRForImageSuperResolution]]]),MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES=new Map([["dpt",["DPTForDepthEstimation",DPTForDepthEstimation]],["depth_anything",["DepthAnythingForDepthEstimation",DepthAnythingForDepthEstimation]],["glpn",["GLPNForDepthEstimation",GLPNForDepthEstimation]]]),MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES=new Map([["clip",["CLIPVisionModelWithProjection",CLIPVisionModelWithProjection]],["siglip",["SiglipVisionModel",SiglipVisionModel]]]),MODEL_CLASS_TYPE_MAPPING=[[MODEL_MAPPING_NAMES_ENCODER_ONLY,MODEL_TYPES.EncoderOnly],[MODEL_MAPPING_NAMES_ENCODER_DECODER,MODEL_TYPES.EncoderDecoder],[MODEL_MAPPING_NAMES_DECODER_ONLY,MODEL_TYPES.DecoderOnly],[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_WITH_LM_HEAD_MAPPING_NAMES,MODEL_TYPES.DecoderOnly],[MODEL_FOR_MASKED_LM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Vision2Seq],[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,MODEL_TYPES.MaskGeneration],[MODEL_FOR_CTC_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly]];for(const[n,e]of MODEL_CLASS_TYPE_MAPPING)for(const[t,s]of n.values())MODEL_TYPE_MAPPING.set(t,e),MODEL_CLASS_TO_NAME_MAPPING.set(s,t),MODEL_NAME_TO_CLASS_MAPPING.set(t,s);const CUSTOM_MAPPING=[["CLIPTextModelWithProjection",CLIPTextModelWithProjection,MODEL_TYPES.EncoderOnly],["SiglipTextModel",SiglipTextModel,MODEL_TYPES.EncoderOnly],["ClapTextModelWithProjection",ClapTextModelWithProjection,MODEL_TYPES.EncoderOnly],["ClapAudioModelWithProjection",ClapAudioModelWithProjection,MODEL_TYPES.EncoderOnly]];for(const[n,e,t]of CUSTOM_MAPPING)MODEL_TYPE_MAPPING.set(n,t),MODEL_CLASS_TO_NAME_MAPPING.set(e,n),MODEL_NAME_TO_CLASS_MAPPING.set(n,e);class AutoModel extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=MODEL_CLASS_TYPE_MAPPING.map(e=>e[0]);static BASE_IF_FAIL=!0}class AutoModelForSequenceClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForTokenClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForSeq2SeqLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES]}class AutoModelForSpeechSeq2Seq extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES]}class AutoModelForTextToSpectrogram extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES]}class AutoModelForTextToWaveform extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES]}class AutoModelForCausalLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_WITH_LM_HEAD_MAPPING_NAMES]}class AutoModelForMaskedLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_MASKED_LM_MAPPING_NAMES]}class AutoModelForQuestionAnswering extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES]}class AutoModelForVision2Seq extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES]}class AutoModelForImageClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForImageSegmentation extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES]}class AutoModelForSemanticSegmentation extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES]}class AutoModelForObjectDetection extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES]}class AutoModelForZeroShotObjectDetection extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES]}class AutoModelForCTC extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_CTC_MAPPING_NAMES]}class AutoModelForAudioClassification extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES]}class AutoModelForDocumentQuestionAnswering extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES]}class AutoModelForImageToImage extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES]}class AutoModelForDepthEstimation extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES]}class AutoModelForImageFeatureExtraction extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES]}class Seq2SeqLMOutput extends ModelOutput{constructor({logits:e,past_key_values:t,encoder_outputs:s,decoder_attentions:a=null,cross_attentions:c=null}){super(),this.logits=e,this.past_key_values=t,this.encoder_outputs=s,this.decoder_attentions=a,this.cross_attentions=c}}class SequenceClassifierOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class XVectorOutput extends ModelOutput{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class TokenClassifierOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class MaskedLMOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class QuestionAnsweringModelOutput extends ModelOutput{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class CausalLMOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class ImageMattingOutput extends ModelOutput{constructor({alphas:e}){super(),this.alphas=e}}class VitsModelOutput extends ModelOutput{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}const BROWSER_ENV=typeof self<"u",WEBWORKER_ENV=BROWSER_ENV&&self.constructor.name==="DedicatedWorkerGlobalScope";let createCanvasFunction,ImageDataClass,loadImageFunction;if(BROWSER_ENV)createCanvasFunction=(n,e)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(n,e)},loadImageFunction=self.createImageBitmap,ImageDataClass=self.ImageData;else if(sharp)loadImageFunction=async n=>{const t=(await n.metadata()).channels;let{data:s,info:a}=await n.rotate().raw().toBuffer({resolveWithObject:!0});const c=new RawImage(new Uint8ClampedArray(s),a.width,a.height,a.channels);return t!==void 0&&t!==a.channels&&c.convert(t),c};else throw new Error("Unable to load image processing library.");const RESAMPLING_MAPPING={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},CONTENT_TYPE_MAP=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class RawImage{constructor(e,t,s,a){this.data=e,this.width=t,this.height=s,this.channels=a}get size(){return[this.width,this.height]}static async read(e){if(e instanceof RawImage)return e;if(typeof e=="string"||e instanceof URL)return await this.fromURL(e);throw new Error(`Unsupported input type: ${typeof e}`)}static async fromURL(e){let t=await getFile(e);if(t.status!==200)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);let s=await t.blob();return this.fromBlob(s)}static async fromBlob(e){if(BROWSER_ENV){let t=await loadImageFunction(e);const s=createCanvasFunction(t.width,t.height).getContext("2d");return s.drawImage(t,0,0),new this(s.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}else{let t=sharp(await e.arrayBuffer());return await loadImageFunction(t)}}static fromTensor(e,t="CHW"){if(e.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if(t==="CHW")e=e.transpose(1,2,0);else if(t!=="HWC")throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new RawImage(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(this.channels===1)return this;let e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,s=0;t<this.data.length;t+=this.channels){const a=this.data[t],c=this.data[t+1],l=this.data[t+2];e[s++]=Math.round(.2989*a+.587*c+.114*l)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(this.channels===3)return this;let e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,s=0;t<this.data.length;++t)e[s++]=this.data[t],e[s++]=this.data[t],e[s++]=this.data[t];break;case 4:for(let t=0,s=0;t<this.data.length;t+=4)e[s++]=this.data[t],e[s++]=this.data[t+1],e[s++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(this.channels===4)return this;let e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,s=0;t<this.data.length;++t)e[s++]=this.data[t],e[s++]=this.data[t],e[s++]=this.data[t],e[s++]=255;break;case 3:for(let t=0,s=0;t<this.data.length;t+=3)e[s++]=this.data[t],e[s++]=this.data[t+1],e[s++]=this.data[t+2],e[s++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}async resize(e,t,{resample:s=2}={}){let a=RESAMPLING_MAPPING[s]??s;if(BROWSER_ENV){let c=this.channels,l=this.toCanvas();const _=createCanvasFunction(e,t).getContext("2d");return _.drawImage(l,0,0,e,t),new RawImage(_.getImageData(0,0,e,t).data,e,t,4).convert(c)}else{let c=this.toSharp();switch(a){case"box":case"hamming":(a==="box"||a==="hamming")&&(console.warn(`Resampling method ${a} is not yet supported. Using bilinear instead.`),a="bilinear");case"nearest":case"bilinear":case"bicubic":c=c.affine([e/this.width,0,0,t/this.height],{interpolator:a});break;case"lanczos":c=c.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${a} is not supported.`)}return await loadImageFunction(c)}}async pad([e,t,s,a]){if(e=Math.max(e,0),t=Math.max(t,0),s=Math.max(s,0),a=Math.max(a,0),e===0&&t===0&&s===0&&a===0)return this;if(BROWSER_ENV){let c=this.channels,l=this.toCanvas(),_=this.width+e+t,m=this.height+s+a;const d=createCanvasFunction(_,m).getContext("2d");return d.drawImage(l,0,0,this.width,this.height,e,s,_,m),new RawImage(d.getImageData(0,0,_,m).data,_,m,4).convert(c)}else{let c=this.toSharp().extend({left:e,right:t,top:s,bottom:a});return await loadImageFunction(c)}}async crop([e,t,s,a]){if(e=Math.max(e,0),t=Math.max(t,0),s=Math.min(s,this.width-1),a=Math.min(a,this.height-1),e===0&&t===0&&s===this.width-1&&a===this.height-1)return this;const c=s-e+1,l=a-t+1;if(BROWSER_ENV){const _=this.channels,m=this.toCanvas(),d=createCanvasFunction(c,l).getContext("2d");return d.drawImage(m,e,t,c,l,0,0,c,l),new RawImage(d.getImageData(0,0,c,l).data,c,l,4).convert(_)}else{const _=this.toSharp().extract({left:e,top:t,width:c,height:l});return await loadImageFunction(_)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;let s=(this.width-e)/2,a=(this.height-t)/2;if(BROWSER_ENV){let c=this.channels,l=this.toCanvas();const _=createCanvasFunction(e,t).getContext("2d");let m=0,d=0,h=0,i=0;return s>=0?m=s:h=-s,a>=0?d=a:i=-a,_.drawImage(l,m,d,e,t,h,i,e,t),new RawImage(_.getImageData(0,0,e,t).data,e,t,4).convert(c)}else{let c=this.toSharp();if(s>=0&&a>=0)c=c.extract({left:Math.floor(s),top:Math.floor(a),width:e,height:t});else if(s<=0&&a<=0){let l=Math.floor(-a),_=Math.floor(-s);c=c.extend({top:l,left:_,right:e-this.width-_,bottom:t-this.height-l})}else{let l=[0,0],_=0;a<0?(l[0]=Math.floor(-a),l[1]=t-this.height-l[0]):_=Math.floor(a);let m=[0,0],d=0;s<0?(m[0]=Math.floor(-s),m[1]=e-this.width-m[0]):d=Math.floor(s),c=c.extend({top:l[0],bottom:l[1],left:m[0],right:m[1]}).extract({left:d,top:_,width:e,height:t})}return await loadImageFunction(c)}}async toBlob(e="image/png",t=1){if(!BROWSER_ENV)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(e!=="HWC")if(e==="CHW")t=t.permute(2,0,1);else throw new Error(`Unsupported channel format: ${e}`);return t}toCanvas(){if(!BROWSER_ENV)throw new Error("toCanvas() is only supported in browser environments.");let e=this.clone().rgba(),t=createCanvasFunction(e.width,e.height),s=new ImageDataClass(e.data,e.width,e.height);return t.getContext("2d").putImageData(s,0,0),t}_update(e,t,s,a=null){return this.data=e,this.width=t,this.height=s,a!==null&&(this.channels=a),this}clone(){return new RawImage(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(BROWSER_ENV){if(WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),s=CONTENT_TYPE_MAP.get(t)??"image/png",a=await this.toBlob(s),c=URL.createObjectURL(a),l=document.createElement("a");l.href=c,l.download=e,l.click(),l.remove()}else{if(env$1.useFS)return await this.toSharp().toFile(e);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(BROWSER_ENV)throw new Error("toSharp() is only supported in server-side environments.");return sharp(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}async function read_audio(n,e){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const t=await(await getFile(n)).arrayBuffer(),s=new AudioContext({sampleRate:e});typeof e>"u"&&console.warn(`No sampling rate provided, using default of ${s.sampleRate}Hz.`);const a=await s.decodeAudioData(t);let c;if(a.numberOfChannels===2){const l=Math.sqrt(2),_=a.getChannelData(0),m=a.getChannelData(1);c=new Float32Array(_.length);for(let d=0;d<a.length;++d)c[d]=l*(_[d]+m[d])/2}else c=a.getChannelData(0);return c}function hanning(n){if(n<1)return new Float64Array;if(n===1)return new Float64Array([1]);const e=n-1,t=Math.PI/e,s=new Float64Array(n);for(let a=0;a<n;++a){const c=2*a-e;s[a]=.5+.5*Math.cos(t*c)}return s}const HERTZ_TO_MEL_MAPPING={htk:n=>2595*Math.log10(1+n/700),kaldi:n=>1127*Math.log(1+n/700),slaney:(n,e=1e3,t=15,s=27/Math.log(6.4))=>n>=e?t+Math.log(n/e)*s:3*n/200};function hertz_to_mel(n,e="htk"){const t=HERTZ_TO_MEL_MAPPING[e];if(!t)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof n=="number"?t(n):n.map(s=>t(s))}const MEL_TO_HERTZ_MAPPING={htk:n=>700*(10**(n/2595)-1),kaldi:n=>700*(Math.exp(n/1127)-1),slaney:(n,e=1e3,t=15,s=Math.log(6.4)/27)=>n>=t?e*Math.exp(s*(n-t)):200*n/3};function mel_to_hertz(n,e="htk"){const t=MEL_TO_HERTZ_MAPPING[e];if(!t)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof n=="number"?t(n):n.map(s=>t(s))}function _create_triangular_filter_bank(n,e){const t=Float64Array.from({length:e.length-1},(l,_)=>e[_+1]-e[_]),s=Array.from({length:n.length},()=>new Array(e.length));for(let l=0;l<n.length;++l){const _=s[l];for(let m=0;m<e.length;++m)_[m]=e[m]-n[l]}const a=e.length-2,c=Array.from({length:a},()=>new Array(n.length));for(let l=0;l<n.length;++l){const _=s[l];for(let m=0;m<a;++m){const d=-_[m]/t[m],h=_[m+2]/t[m+1];c[m][l]=Math.max(0,Math.min(d,h))}}return c}function linspace(n,e,t){const s=(e-n)/(t-1);return Float64Array.from({length:t},(a,c)=>n+s*c)}function mel_filter_bank(n,e,t,s,a,c=null,l="htk",_=!1){if(c!==null&&c!=="slaney")throw new Error('norm must be one of null or "slaney"');const m=hertz_to_mel(t,l),d=hertz_to_mel(s,l),h=linspace(m,d,e+2);let i=mel_to_hertz(h,l),r;if(_){const f=a/(n*2);r=hertz_to_mel(Float64Array.from({length:n},(g,w)=>w*f),l),i=h}else r=linspace(0,Math.floor(a/2),n);const u=_create_triangular_filter_bank(r,i);if(c!==null&&c==="slaney")for(let f=0;f<e;++f){const g=u[f],w=2/(i[f+2]-i[f]);for(let y=0;y<n;++y)g[y]*=w}return u}function padReflect(n,e,t){const s=new n.constructor(n.length+e+t),a=n.length-1;for(let c=0;c<n.length;++c)s[e+c]=n[c];for(let c=1;c<=e;++c)s[e-c]=n[calculateReflectOffset(c,a)];for(let c=1;c<=t;++c)s[a+e+c]=n[calculateReflectOffset(a-c,a)];return s}function _db_conversion_helper(n,e,t,s,a){if(t<=0)throw new Error("reference must be greater than zero");if(s<=0)throw new Error("min_value must be greater than zero");t=Math.max(s,t);const c=Math.log10(t);for(let l=0;l<n.length;++l)n[l]=e*Math.log10(Math.max(s,n[l])-c);if(a!==null){if(a<=0)throw new Error("db_range must be greater than zero");const l=max(n)[0]-a;for(let _=0;_<n.length;++_)n[_]=Math.max(n[_],l)}return n}function amplitude_to_db(n,e=1,t=1e-5,s=null){return _db_conversion_helper(n,20,e,t,s)}function power_to_db(n,e=1,t=1e-10,s=null){return _db_conversion_helper(n,10,e,t,s)}function spectrogram(n,e,t,s,{fft_length:a=null,power:c=1,center:l=!0,pad_mode:_="reflect",onesided:m=!0,preemphasis:d=null,mel_filters:h=null,mel_floor:i=1e-10,log_mel:r=null,reference:u=1,min_value:f=1e-10,db_range:g=null,remove_dc_offset:w=null,max_num_frames:y=null,do_pad:x=!0,transpose:S=!1}={}){const T=e.length;if(a===null&&(a=t),t>a)throw Error(`frame_length (${t}) may not be larger than fft_length (${a})`);if(T!==t)throw new Error(`Length of the window (${T}) must equal frame_length (${t})`);if(s<=0)throw new Error("hop_length must be greater than zero");if(c===null&&h!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(l){if(_!=="reflect")throw new Error(`pad_mode="${_}" not implemented yet.`);const z=Math.floor((a-1)/2)+1;n=padReflect(n,z,z)}const E=Math.floor(1+Math.floor((n.length-t)/s)),A=m?Math.floor(a/2)+1:a;let C=E,I=E;y!==null&&(y>E?x&&(I=y):I=C=y);const D=new FFT(a),R=new Float64Array(a),Y=new Float64Array(D.outputBufferSize),re=new Array(C);for(let z=0;z<C;++z){const H=z*s;for(let Ce=0;Ce<t;++Ce)R[Ce]=n[H+Ce];if(w){let Ce=0;for(let K=0;K<t;++K)Ce+=R[K];const oe=Ce/t;for(let K=0;K<t;++K)R[K]-=oe}if(d!==null){for(let Ce=t-1;Ce>=1;--Ce)R[Ce]-=d*R[Ce-1];R[0]*=1-d}for(let Ce=0;Ce<e.length;++Ce)R[Ce]*=e[Ce];D.realTransform(Y,R);const he=new Array(A);for(let Ce=0;Ce<he.length;++Ce){const oe=Ce<<1;he[Ce]=Y[oe]**2+Y[oe+1]**2}re[z]=he}if(c!==null&&c!==2){const z=2/c;for(let H=0;H<re.length;++H){const he=re[H];for(let Ce=0;Ce<he.length;++Ce)he[Ce]**=z}}const G=h.length,te=new Float32Array(G*I),q=S?[I,G]:[G,I];for(let z=0;z<G;++z){const H=h[z];for(let he=0;he<C;++he){const Ce=re[he];let oe=0;for(let K=0;K<A;++K)oe+=H[K]*Ce[K];te[S?he*G+z:z*C+he]=Math.max(i,oe)}}if(c!==null&&r!==null){const z=Math.min(te.length,C*G);switch(r){case"log":for(let H=0;H<z;++H)te[H]=Math.log(te[H]);break;case"log10":for(let H=0;H<z;++H)te[H]=Math.log10(te[H]);break;case"dB":if(c===1)amplitude_to_db(te,u,f,g);else if(c===2)power_to_db(te,u,f,g);else throw new Error(`Cannot use log_mel option '${r}' with power ${c}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${r}'`)}}return{data:te,dims:q}}function window_function(n,e,{periodic:t=!0,frame_length:s=null,center:a=!0}={}){const c=t?n+1:n;let l;switch(e){case"boxcar":l=new Float64Array(c).fill(1);break;case"hann":case"hann_window":l=hanning(c);break;case"povey":l=hanning(c).map(_=>Math.pow(_,.85));break;default:throw new Error(`Unknown window type ${e}.`)}if(t&&(l=l.subarray(0,n)),s===null)return l;if(n>s)throw new Error(`Length of the window (${n}) may not be larger than frame_length (${s})`);return l}function center_to_corners_format([n,e,t,s]){return[n-t/2,e-s/2,n+t/2,e+s/2]}function post_process_object_detection(n,e=.5,t=null,s=!1){const a=n.logits,c=n.pred_boxes,[l,_,m]=a.dims;if(t!==null&&t.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let d=[];for(let h=0;h<l;++h){let i=t!==null?t[h]:null,r={boxes:[],classes:[],scores:[]},u=a[h],f=c[h];for(let g=0;g<_;++g){let w=u[g],y=[],x;if(s){x=w.sigmoid().data;for(let S=0;S<x.length;++S)x[S]>e&&y.push(S)}else{let S=max(w.data)[1];if(S===m-1)continue;y.push(S),x=softmax(w.data)}for(const S of y){let T=f[g].data;T=center_to_corners_format(T),i!==null&&(T=T.map((E,A)=>E*i[(A+1)%2])),r.boxes.push(T),r.classes.push(S),r.scores.push(x[S])}}d.push(r)}return d}function validate_audio_inputs(n,e){if(!(n instanceof Float32Array||n instanceof Float64Array))throw new Error(`${e} expects input to be a Float32Array or a Float64Array, but got ${n?.constructor?.name??typeof n} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function constraint_to_multiple_of(n,e,t=0,s=null){const a=n/e;let c=bankers_round(a)*e;return s!==null&&c>s&&(c=Math.floor(a)*e),c<t&&(c=Math.ceil(a)*e),c}function enforce_size_divisibility([n,e],t){return[Math.max(Math.floor(n/t),1)*t,Math.max(Math.floor(e/t),1)*t]}class FeatureExtractor extends Callable{constructor(e){super(),this.config=e}}class ImageFeatureExtractor extends FeatureExtractor{constructor(e){super(e),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(e,t,s=2){const a=e.height,c=e.width,l=t.height,_=t.width;let m=Math.min(a,l),d=Math.min(c,_);return m===a&&d===c?e:(a>c?d=Math.floor(c*m/a):c>a&&(m=Math.floor(a*d/c)),await e.resize(d,m,{resample:s}))}async crop_margin(e,t=200){const s=e.clone().grayscale(),a=min(s.data)[0],l=max(s.data)[0]-a;if(l===0)return e;const _=t/255;let m=s.width,d=s.height,h=0,i=0;for(let r=0;r<s.height;++r){const u=r*s.width;for(let f=0;f<s.width;++f)(s.data[u+f]-a)/l<_&&(m=Math.min(m,f),d=Math.min(d,r),h=Math.max(h,f),i=Math.max(i,r))}return e=await e.crop([m,d,h,i]),e}pad_image(e,t,s,{mode:a="constant",center:c=!1,constant_values:l=0}={}){const[_,m,d]=t;let h,i;if(typeof s=="number"?(h=s,i=s):(h=s.width,i=s.height),h!==m||i!==_){const r=new Float32Array(h*i*d);if(Array.isArray(l))for(let g=0;g<r.length;++g)r[g]=l[g%d];else l!==0&&r.fill(l);const[u,f]=c?[Math.floor((h-m)/2),Math.floor((i-_)/2)]:[0,0];for(let g=0;g<_;++g){const w=(g+f)*h,y=g*m;for(let x=0;x<m;++x){const S=(w+x+u)*d,T=(y+x)*d;for(let E=0;E<d;++E)r[S+E]=e[T+E]}}if(a==="symmetric"){if(c)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const g=_-1,w=m-1;for(let y=0;y<i;++y){const x=y*h,S=calculateReflectOffset(y,g)*m;for(let T=0;T<h;++T){if(y<_&&T<m)continue;const E=(x+T)*d,A=(S+calculateReflectOffset(T,w))*d;for(let C=0;C<d;++C)r[E+C]=e[A+C]}}}e=r,t=[i,h,d]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[s,a]=e.size;let c,l;if(this.do_thumbnail){const{height:_,width:m}=t;c=Math.min(_,m)}else Number.isInteger(t)?(c=t,l=this.config.max_size??c):t!==void 0&&(c=t.shortest_edge,l=t.longest_edge);if(c!==void 0||l!==void 0){const _=c===void 0?1:Math.max(c/s,c/a),m=s*_,d=a*_,h=l===void 0?1:Math.min(l/m,l/d);let i=Math.floor(Number((m*h).toFixed(2))),r=Math.floor(Number((d*h).toFixed(2)));return this.size_divisibility!==void 0&&([i,r]=enforce_size_divisibility([i,r],this.size_divisibility)),[i,r]}else if(t!==void 0&&t.width!==void 0&&t.height!==void 0){let _=t.width,m=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let d=m/a,h=_/s;Math.abs(1-h)<Math.abs(1-d)?d=h:h=d,m=constraint_to_multiple_of(d*a,this.config.ensure_multiple_of),_=constraint_to_multiple_of(h*s,this.config.ensure_multiple_of)}return[_,m]}else{if(this.size_divisibility!==void 0)return enforce_size_divisibility([s,a],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(t)}`)}}async resize(e){const[t,s]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,s,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:s=null,do_convert_rgb:a=null,do_convert_grayscale:c=null,do_flip_channel_order:l=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[_,m]=e.size;if(a??this.do_convert_rgb?e=e.rgb():c&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let u,f;Number.isInteger(this.crop_size)?(u=this.crop_size,f=this.crop_size):(u=this.crop_size.width,f=this.crop_size.height),e=await e.center_crop(u,f)}const d=[e.height,e.width];let h=Float32Array.from(e.data),i=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(h),t??this.do_normalize){let u=this.image_mean;Array.isArray(this.image_mean)||(u=new Array(e.channels).fill(u));let f=this.image_std;if(Array.isArray(this.image_std)||(f=new Array(e.channels).fill(u)),u.length!==e.channels||f.length!==e.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${u.length}) and \`image_std\` (${f.length}) must match the number of channels in the image (${e.channels}).`);for(let g=0;g<h.length;g+=e.channels)for(let w=0;w<e.channels;++w)h[g+w]=(h[g+w]-u[w])/f[w]}if(s??this.do_pad){if(this.pad_size)[h,i]=this.pad_image(h,[e.height,e.width,e.channels],this.pad_size);else if(this.size_divisibility){const[u,f]=enforce_size_divisibility([i[1],i[0]],this.size_divisibility);[h,i]=this.pad_image(h,i,{width:u,height:f})}}if(l??this.do_flip_channel_order){if(i[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let u=0;u<h.length;u+=3){const f=h[u];h[u]=h[u+2],h[u+2]=f}}const r=new Tensor("float32",h,i).permute(2,0,1);return{original_size:[m,_],reshaped_input_size:d,pixel_values:r}}async _call(e,...t){Array.isArray(e)||(e=[e]);const s=await Promise.all(e.map(c=>this.preprocess(c)));return{pixel_values:stack(s.map(c=>c.pixel_values),0),original_sizes:s.map(c=>c.original_size),reshaped_input_sizes:s.map(c=>c.reshaped_input_size)}}}class SegformerFeatureExtractor extends ImageFeatureExtractor{post_process_semantic_segmentation(e,t=null){const s=e.logits,a=s.dims[0];if(t!==null&&t.length!==a)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const c=[];for(let l=0;l<a;++l){const _=t!==null?t[l]:null;let m=s[l];_!==null&&(m=interpolate(m,_,"bilinear",!1));const[d,h]=_??m.dims.slice(-2),i=new Tensor("int32",new Int32Array(d*h),[d,h]),r=m[0].data;for(let w=1;w<m.dims[0];++w){const y=m[w].data;for(let x=0;x<y.length;++x)y[x]>r[x]&&(r[x]=y[x],i.data[x]=w)}const u=new Array(m.dims[0]),f=i.data;for(let w=0;w<f.length;++w){const y=f[w];u[y]=y}const g=u.filter(w=>w!==void 0);c.push({segmentation:i,labels:g})}return c}}class DPTFeatureExtractor extends ImageFeatureExtractor{}class DPTImageProcessor extends DPTFeatureExtractor{}class BitImageProcessor extends ImageFeatureExtractor{}class GLPNFeatureExtractor extends ImageFeatureExtractor{}class CLIPFeatureExtractor extends ImageFeatureExtractor{}class ChineseCLIPFeatureExtractor extends ImageFeatureExtractor{}class SiglipImageProcessor extends ImageFeatureExtractor{}class ConvNextFeatureExtractor extends ImageFeatureExtractor{constructor(e){super(e),this.crop_pct=this.config.crop_pct??224/256}async resize(e){const t=this.size?.shortest_edge;if(t===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(t<384){const s=Math.floor(t/this.crop_pct),[a,c]=this.get_resize_output_image_size(e,{shortest_edge:s});e=await e.resize(a,c,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class ConvNextImageProcessor extends ConvNextFeatureExtractor{}class ViTFeatureExtractor extends ImageFeatureExtractor{}class ViTImageProcessor extends ImageFeatureExtractor{}class EfficientNetImageProcessor extends ImageFeatureExtractor{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(t=>t*t))}}class MobileViTFeatureExtractor extends ImageFeatureExtractor{}class MobileViTImageProcessor extends MobileViTFeatureExtractor{}class OwlViTFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(...e){return post_process_object_detection(...e)}}class Owlv2ImageProcessor extends OwlViTFeatureExtractor{}class DeiTFeatureExtractor extends ImageFeatureExtractor{}class BeitFeatureExtractor extends ImageFeatureExtractor{}class DonutFeatureExtractor extends ImageFeatureExtractor{pad_image(e,t,s,a={}){const[c,l,_]=t;let m=this.image_mean;Array.isArray(this.image_mean)||(m=new Array(_).fill(m));let d=this.image_std;Array.isArray(d)||(d=new Array(_).fill(m));const h=m.map((i,r)=>-i/d[r]);return super.pad_image(e,t,s,{center:!0,constant_values:h,...a})}}class NougatImageProcessor extends DonutFeatureExtractor{}class DetrFeatureExtractor extends ImageFeatureExtractor{async _call(e){const t=await super._call(e),s=[t.pixel_values.dims[0],64,64],a=new Tensor("int64",new BigInt64Array(s.reduce((c,l)=>c*l)).fill(1n),s);return{...t,pixel_mask:a}}post_process_object_detection(...e){return post_process_object_detection(...e)}remove_low_and_no_objects(e,t,s,a){let c=[],l=[],_=[];for(let m=0;m<e.dims[0];++m){let d=e[m],h=t[m],i=max(d.data)[1];if(i===a)continue;let u=softmax(d.data)[i];u>s&&(c.push(h),l.push(u),_.push(i))}return[c,l,_]}check_segment_validity(e,t,s,a=.5,c=.8){let l=[],_=0,m=0;for(let h=0;h<e.length;++h)e[h]===s&&(l.push(h),++_),t[s].data[h]>=a&&++m;let d=_>0&&m>0;return d&&(d=_/m>c),[d,l]}compute_segments(e,t,s,a,c,l=null,_=null){let[m,d]=_??e[0].dims,h=new Tensor("int32",new Int32Array(m*d),[m,d]),i=[];if(_!==null)for(let g=0;g<e.length;++g)e[g]=interpolate(e[g],_,"bilinear",!1);let r=new Int32Array(e[0].data.length),u=new Float32Array(e[0].data.length);for(let g=0;g<e.length;++g){let w=t[g];for(let y=0;y<e[g].data.length;++y)e[g].data[y]*=w,e[g].data[y]>u[y]&&(r[y]=g,u[y]=e[g].data[y])}let f=0;for(let g=0;g<s.length;++g){let w=s[g],[y,x]=this.check_segment_validity(r,e,g,a,c);if(y){++f;for(let S of x)h.data[S]=f;i.push({id:f,label_id:w,score:t[g]})}}return[h,i]}post_process_panoptic_segmentation(e,t=.5,s=.5,a=.8,c=null,l=null){c===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),c=new Set);const _=e.logits,d=e.pred_masks.sigmoid();let[h,i,r]=_.dims;if(r-=1,l!==null&&l.length!==h)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let f=0;f<h;++f){let g=l!==null?l[f]:null,w=_[f],y=d[f],[x,S,T]=this.remove_low_and_no_objects(w,y,t,r);if(T.length===0){let[C,I]=g??y.dims.slice(-2),D=new Tensor("int32",new Int32Array(C*I).fill(-1),[C,I]);u.push({segmentation:D,segments_info:[]});continue}let[E,A]=this.compute_segments(x,S,T,s,a,c,g);u.push({segmentation:E,segments_info:A})}return u}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class YolosFeatureExtractor extends ImageFeatureExtractor{post_process_object_detection(...e){return post_process_object_detection(...e)}}class SamImageProcessor extends ImageFeatureExtractor{reshape_input_points(e,t,s){e=structuredClone(e);let a=calculateDimensions(e);if(a.length===3)a=[1,...a],e=[e];else if(a.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let c=0;c<e.length;++c){let l=t[c],_=s[c],m=[_[0]/l[0],_[1]/l[1]];for(let d=0;d<e[c].length;++d)for(let h=0;h<e[c][d].length;++h)for(let i=0;i<e[c][d][h].length;++i)e[c][d][h][i]*=m[i]}return new Tensor("float32",Float32Array.from(e.flat(1/0)),a)}add_input_labels(e,t){let s=calculateDimensions(e);if(s.length===2)s=[1,...s],e=[e];else if(s.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(s.some((a,c)=>a!==t.dims[c]))throw Error(`The first ${s.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new Tensor("int64",e.flat(1/0).map(BigInt),s)}async _call(e,t=null,s=null){const a=await super._call(e);if(t&&(a.input_points=this.reshape_input_points(t,a.original_sizes,a.reshaped_input_sizes)),s){if(!a.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");a.input_labels=this.add_input_labels(s,a.input_points)}return a}post_process_masks(e,t,s,{mask_threshold:a=0,binarize:c=!0,pad_size:l=null}={}){const _=[];l=l??this.pad_size;const m=[l.height,l.width];for(let d=0;d<t.length;++d){const h=t[d],i=s[d],r=e[d],u=[];for(let f=0;f<r.dims[0];++f){const g=r[f];let w=interpolate(g,m,"bilinear",!1);if(w=w.slice(null,[0,i[0]],[0,i[1]]),w=interpolate(w,h,"bilinear",!1),c){const y=new Uint8Array(w.data.length);for(let x=0;x<w.data.length;++x)w.data[x]>a&&(y[x]=1);w=new Tensor("bool",y,w.dims)}u.push(w)}_.push(stack(u))}return _}}class Swin2SRImageProcessor extends ImageFeatureExtractor{pad_image(e,t,s,a={}){const[c,l,_]=t;return super.pad_image(e,t,{width:l+(s-l%s)%s,height:c+(s-c%s)%s},{mode:"symmetric",center:!1,constant_values:-1,...a})}}class VitMatteImageProcessor extends ImageFeatureExtractor{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const s=await Promise.all(e.map(l=>this.preprocess(l))),a=await Promise.all(t.map(l=>this.preprocess(l,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:stack(s.map((l,_)=>cat([l.pixel_values,a[_].pixel_values],0)),0),original_sizes:s.map(l=>l.original_size),reshaped_input_sizes:s.map(l=>l.reshaped_input_size)}}}class WhisperFeatureExtractor extends FeatureExtractor{constructor(e){super(e),this.config.mel_filters??=mel_filter_bank(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=window_function(this.config.n_fft,"hann")}_extract_fbank_features(e){const{data:t,dims:s}=spectrogram(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),a=max(t)[0];for(let c=0;c<t.length;++c)t[c]=(Math.max(t[c],a-8)+4)/4;return{data:t,dims:s}}async _call(e){validate_audio_inputs(e,"WhisperFeatureExtractor");let t;e.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),t=e.slice(0,this.config.n_samples)):(t=new Float32Array(this.config.n_samples),t.set(e));const{data:s,dims:a}=this._extract_fbank_features(t);return{input_features:new Tensor("float32",s,[1,...a])}}}class Wav2Vec2FeatureExtractor extends FeatureExtractor{_zero_mean_unit_var_norm(e){const s=e.reduce((c,l)=>c+l,0)/e.length,a=e.reduce((c,l)=>c+(l-s)**2,0)/e.length;return e.map(c=>(c-s)/Math.sqrt(a+1e-7))}async _call(e){validate_audio_inputs(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const s=[1,t.length];return{input_values:new Tensor("float32",t,s),attention_mask:new Tensor("int64",new BigInt64Array(t.length).fill(1n),s)}}}class SeamlessM4TFeatureExtractor extends FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,s=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let a=0;a<s.length;++a)s[a].push(0);this.mel_filters=s,this.window=window_function(400,"povey",{periodic:!1})}_extract_fbank_features(e,t){return e=e.map(s=>s*32768),spectrogram(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:s=2,do_normalize_per_mel_bins:a=!0,return_attention_mask:c=!0}={}){validate_audio_inputs(e,"SeamlessM4TFeatureExtractor");let l=this._extract_fbank_features(e,this.config.max_length);if(a){const[f,g]=l.dims;for(let w=0;w<g;++w){let y=0;for(let E=0;E<f;++E)y+=l.data[E*g+w];const x=y/f;let S=0;for(let E=0;E<f;++E)S+=(l.data[E*g+w]-x)**2;S/=f-1;const T=Math.sqrt(S+1e-7);for(let E=0;E<f;++E){const A=E*g+w;l.data[A]=(l.data[A]-x)/T}}}let _;if(t){const[f,g]=l.dims,w=f%s;if(w>0){const y=new Float32Array(g*(f+w));y.set(l.data),y.fill(this.config.padding_value,l.data.length);const x=f+w;l={data:y,dims:[x,g]},c&&(_=new Tensor("int64",new BigInt64Array(x),[1,x]),_.data.fill(1n,0,f))}}const[m,d]=l.dims,h=this.config.stride;if(m%h!==0)throw new Error(`The number of frames (${m}) must be a multiple of the stride (${h}).`);const r=new Tensor("float32",l.data,l.dims).view(1,Math.floor(m/h),d*h),u={input_features:r};if(c){const f=r.dims[1],g=new Tensor("int64",new BigInt64Array(f),[1,f]);if(_)for(let w=1,y=0;w<m;w+=h,++y)g.data[y]=_.data[w];else g.data.fill(1n);u.attention_mask=g}return u}}class ASTFeatureExtractor extends FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,s=mel_filter_bank(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let a=0;a<s.length;++a)s[a].push(0);this.mel_filters=s,this.window=window_function(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}_extract_fbank_features(e,t){return spectrogram(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){validate_audio_inputs(e,"ASTFeatureExtractor");const t=this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const s=this.std*2;for(let a=0;a<t.data.length;++a)t.data[a]=(t.data[a]-this.mean)/s}return{input_values:new Tensor("float32",t.data,[1,...t.dims])}}}class ClapFeatureExtractor extends FeatureExtractor{constructor(e){super(e),this.mel_filters=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=mel_filter_bank(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=window_function(this.config.fft_window_size,"hann")}_get_input_mel(e,t,s,a){let c,l=!1;const _=e.length-t;if(_>0)if(s==="rand_trunc"){l=!0;const m=Math.floor(Math.random()*(_+1));e=e.subarray(m,m+t),c=this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples),c.dims=[1,...c.dims]}else throw new Error(`Truncation strategy "${s}" not implemented`);else{if(_<0){let m=new Float64Array(t);if(m.set(e),a==="repeat")for(let d=e.length;d<t;d+=e.length)m.set(e.subarray(0,Math.min(e.length,t-d)),d);else if(a==="repeatpad")for(let d=e.length;d<-_;d+=e.length)m.set(e,d);e=m}if(s==="fusion")throw new Error(`Truncation strategy "${s}" not implemented`);c=this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples),c.dims=[1,...c.dims]}return{...c,longer:l}}_extract_fbank_features(e,t,s=null){return spectrogram(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:s,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){validate_audio_inputs(e,"ClapFeatureExtractor");const s=this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding);return{input_features:new Tensor("float32",s.data,[1,...s.dims])}}}class SpeechT5FeatureExtractor extends FeatureExtractor{}class Processor extends Callable{constructor(e){super(),this.feature_extractor=e}async _call(e,...t){return await this.feature_extractor(e,...t)}}class SamProcessor extends Processor{async _call(...e){return await this.feature_extractor(...e)}post_process_masks(...e){return this.feature_extractor.post_process_masks(...e)}reshape_input_points(...e){return this.feature_extractor.reshape_input_points(...e)}}class WhisperProcessor extends Processor{async _call(e){return await this.feature_extractor(e)}}class Wav2Vec2ProcessorWithLM extends Processor{async _call(e){return await this.feature_extractor(e)}}class SpeechT5Processor extends Processor{async _call(e){return await this.feature_extractor(e)}}class OwlViTProcessor extends Processor{}class AutoProcessor{static FEATURE_EXTRACTOR_CLASS_MAPPING={ImageFeatureExtractor,WhisperFeatureExtractor,ViTFeatureExtractor,MobileViTFeatureExtractor,MobileViTImageProcessor,OwlViTFeatureExtractor,Owlv2ImageProcessor,CLIPFeatureExtractor,ChineseCLIPFeatureExtractor,SiglipImageProcessor,ConvNextFeatureExtractor,ConvNextImageProcessor,SegformerFeatureExtractor,BitImageProcessor,DPTImageProcessor,DPTFeatureExtractor,GLPNFeatureExtractor,BeitFeatureExtractor,DeiTFeatureExtractor,DetrFeatureExtractor,YolosFeatureExtractor,DonutFeatureExtractor,NougatImageProcessor,EfficientNetImageProcessor,ViTImageProcessor,VitMatteImageProcessor,SamImageProcessor,Swin2SRImageProcessor,Wav2Vec2FeatureExtractor,SeamlessM4TFeatureExtractor,SpeechT5FeatureExtractor,ASTFeatureExtractor,ClapFeatureExtractor};static PROCESSOR_CLASS_MAPPING={WhisperProcessor,Wav2Vec2ProcessorWithLM,SamProcessor,SpeechT5Processor,OwlViTProcessor};static async from_pretrained(e,{progress_callback:t=null,config:s=null,cache_dir:a=null,local_files_only:c=!1,revision:l="main"}={}){let _=s??await getModelJSON(e,"preprocessor_config.json",!0,{progress_callback:t,cache_dir:a,local_files_only:c,revision:l}),m=_.feature_extractor_type??_.image_processor_type,d=this.FEATURE_EXTRACTOR_CLASS_MAPPING[m];if(!d)if(_.size!==void 0)console.warn(`Feature extractor type "${m}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),d=ImageFeatureExtractor;else throw new Error(`Unknown Feature Extractor type: ${m}`);let h=this.PROCESSOR_CLASS_MAPPING[_.processor_class]??Processor,i=new d(_);return new h(i)}}async function prepareImages(n){return Array.isArray(n)||(n=[n]),await Promise.all(n.map(e=>RawImage.read(e)))}async function prepareAudios(n,e){return Array.isArray(n)||(n=[n]),await Promise.all(n.map(t=>typeof t=="string"||t instanceof URL?read_audio(t,e):t instanceof Float64Array?new Float32Array(t):t))}function get_bounding_box(n,e){e&&(n=n.map(l=>l|0));const[t,s,a,c]=n;return{xmin:t,ymin:s,xmax:a,ymax:c}}class Pipeline extends Callable{constructor({task:e,model:t,tokenizer:s=null,processor:a=null}){super(),this.task=e,this.model=t,this.tokenizer=s,this.processor=a}async dispose(){await this.model.dispose()}}class TextClassificationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{topk:t=1}={}){const s=this.tokenizer(e,{padding:!0,truncation:!0}),a=await this.model(s),c=this.model.config.problem_type==="multi_label_classification"?m=>m.sigmoid().data:m=>softmax(m.data),l=this.model.config.id2label,_=[];for(const m of a.logits){const d=c(m),i=getTopItems(d,t).map(r=>({label:l[r[0]],score:r[1]}));t===1?_.push(...i):_.push(i)}return Array.isArray(e)||t===1?_:_[0]}}class TokenClassificationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const s=Array.isArray(e),a=this.tokenizer(s?e:[e],{padding:!0,truncation:!0}),l=(await this.model(a)).logits,_=this.model.config.id2label,m=[];for(let d=0;d<l.dims[0];++d){const h=a.input_ids[d],i=l[d],r=[];for(let u=0;u<i.dims[0];++u){const f=i[u],g=max(f.data)[1],w=_?_[g]:`LABEL_${g}`;if(t.includes(w))continue;const y=this.tokenizer.decode([h[u].item()],{skip_special_tokens:!0});if(y==="")continue;const x=softmax(f.data);r.push({entity:w,score:x[g],index:u,word:y,start:null,end:null})}m.push(r)}return s?m:m[0]}}class QuestionAnsweringPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t,{topk:s=1}={}){const a=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),c=await this.model(a),l=[];for(let _=0;_<c.start_logits.dims[0];++_){const m=a.input_ids[_],d=m.indexOf(this.tokenizer.sep_token_id),h=Array.from(softmax(c.start_logits[_].data)).map((u,f)=>[u,f]).filter(u=>u[1]>d),i=Array.from(softmax(c.end_logits[_].data)).map((u,f)=>[u,f]).filter(u=>u[1]>d),r=product(h,i).filter(u=>u[0][1]<=u[1][1]).map(u=>[u[0][1],u[1][1],u[0][0]*u[1][0]]).sort((u,f)=>f[2]-u[2]);for(let u=0;u<Math.min(r.length,s);++u){const[f,g,w]=r[u],y=[...m].slice(f,g+1),x=this.tokenizer.decode(y,{skip_special_tokens:!0});l.push({answer:x,score:w})}}return s===1?l[0]:l}}class FillMaskPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{topk:t=5}={}){const s=this.tokenizer(e,{padding:!0,truncation:!0}),a=await this.model(s),c=[];for(let l=0;l<s.input_ids.dims[0];++l){const _=s.input_ids[l],m=_.indexOf(this.tokenizer.mask_token_id);if(m===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const h=a.logits[l][m],i=getTopItems(softmax(h.data),t);c.push(i.map(r=>{const u=[..._];return u[m]=r[0],{score:r[1],token:r[0],token_str:this.tokenizer.model.vocab[r[0]],sequence:this.tokenizer.decode(u,{skip_special_tokens:!0})}}))}return Array.isArray(e)?c:c[0]}}class Text2TextGenerationPipeline extends Pipeline{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map(m=>this.model.config.prefix+m));const s=this.model.config.task_specific_params;s&&s[this.task]&&s[this.task].prefix&&(e=e.map(m=>s[this.task].prefix+m));const a=this.tokenizer,c={padding:!0,truncation:!0};let l;this instanceof TranslationPipeline&&"_build_translation_inputs"in a?l=a._build_translation_inputs(e,c,t).input_ids:l=a(e,c).input_ids;const _=await this.model.generate(l,t);return a.batch_decode(_,{skip_special_tokens:!0}).map(m=>({[this._key]:m}))}}class SummarizationPipeline extends Text2TextGenerationPipeline{_key="summary_text";constructor(e){super(e)}}class TranslationPipeline extends Text2TextGenerationPipeline{_key="translation_text";constructor(e){super(e)}}function isChat(n){return Array.isArray(n)&&n.every(e=>"role"in e&&"content"in e)}class TextGenerationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t={}){let s=!1,a=!1,c;if(typeof e=="string")c=e=[e];else if(Array.isArray(e)&&e.every(f=>typeof f=="string"))s=!0,c=e;else{if(isChat(e))e=[e];else if(Array.isArray(e)&&e.every(isChat))s=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");a=!0,c=e.map(f=>this.tokenizer.apply_chat_template(f,{tokenize:!1,add_generation_prompt:!0}))}const l=t.add_special_tokens??!1,_=a?!1:t.return_full_text??!0;this.tokenizer.padding_side="left";const{input_ids:m,attention_mask:d}=this.tokenizer(c,{add_special_tokens:l,padding:!0,truncation:!0}),h=await this.model.generate(m,t,null,{inputs_attention_mask:d});let i=this.tokenizer.batch_decode(h,{skip_special_tokens:!0}),r;!_&&m.dims.at(-1)>0&&(r=this.tokenizer.batch_decode(m,{skip_special_tokens:!0}).map(f=>f.length));const u=Array.from({length:e.length},f=>[]);for(let f=0;f<i.length;++f){const g=Math.floor(f/h.length*e.length);r&&(i[f]=i[f].slice(r[g])),u[g].push({generated_text:a?[...e[g],{role:"assistant",content:i[f]}]:i[f]})}return!s&&u.length===1?u[0]:u}}class ZeroShotClassificationPipeline extends Pipeline{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([t,s])=>[t.toLowerCase(),s])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:s="This example is {}.",multi_label:a=!1}={}){const c=Array.isArray(e);c||(e=[e]),Array.isArray(t)||(t=[t]);const l=t.map(d=>s.replace("{}",d)),_=a||t.length===1,m=[];for(const d of e){const h=[];for(const u of l){const f=this.tokenizer(d,{text_pair:u,padding:!0,truncation:!0}),g=await this.model(f);_?h.push([g.logits.data[this.contradiction_id],g.logits.data[this.entailment_id]]):h.push(g.logits.data[this.entailment_id])}const r=(_?h.map(u=>softmax(u)[1]):softmax(h)).map((u,f)=>[u,f]).sort((u,f)=>f[0]-u[0]);m.push({sequence:d,labels:r.map(u=>t[u[1]]),scores:r.map(u=>u[0])})}return c?m:m[0]}}class FeatureExtractionPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:s=!1,quantize:a=!1,precision:c="binary"}={}){const l=this.tokenizer(e,{padding:!0,truncation:!0}),_=await this.model(l);let m=_.last_hidden_state??_.logits??_.token_embeddings;if(t!=="none")if(t==="mean")m=mean_pooling(m,l.attention_mask);else if(t==="cls")m=m.slice(null,0);else throw Error(`Pooling method '${t}' not supported.`);return s&&(m=m.normalize(2,-1)),a&&(m=quantize_embeddings(m,c)),m}}class ImageFeatureExtractionPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const s=await prepareImages(e),{pixel_values:a}=await this.processor(s),c=await this.model({pixel_values:a});let l;if(t){if(!("pooler_output"in c))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");l=c.pooler_output}else l=c.last_hidden_state??c.logits??c.image_embeds;return l}}class AudioClassificationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{topk:t=null}={}){const s=!Array.isArray(e),a=this.processor.feature_extractor.config.sampling_rate,c=await prepareAudios(e,a),l=this.model.config.id2label,_=[];for(const m of c){const d=await this.processor(m),i=(await this.model(d)).logits[0],u=getTopItems(softmax(i.data),t).map(f=>({label:l[f[0]],score:f[1]}));t===1?_.push(...u):_.push(u)}return!s||t===1?_:_[0]}}class ZeroShotAudioClassificationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t,{hypothesis_template:s="This is a sound of {}."}={}){const a=!Array.isArray(e);a&&(e=[e]);const c=t.map(h=>s.replace("{}",h)),l=this.tokenizer(c,{padding:!0,truncation:!0}),_=this.processor.feature_extractor.config.sampling_rate,m=await prepareAudios(e,_),d=[];for(const h of m){const i=await this.processor(h),r=await this.model({...l,...i}),u=softmax(r.logits_per_audio.data);d.push([...u].map((f,g)=>({score:f,label:t[g]})))}return a?d[0]:d}}class AutomaticSpeechRecognitionPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(e,t={}){t.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),t.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const s=!Array.isArray(e);s&&(e=[e]);const a=this.processor.feature_extractor.config.sampling_rate,c=await prepareAudios(e,a),l=[];for(const _ of c){const m=await this.processor(_),h=(await this.model(m)).logits[0],i=[];for(const u of h)i.push(max(u.data)[1]);const r=this.tokenizer.decode(i);l.push({text:r})}return s?l[0]:l}async _call_whisper(e,t={}){const s=t.return_timestamps??!1,a=t.chunk_length_s??0,c=t.chunk_callback??null,l=t.force_full_sequences??!1;let _=t.stride_length_s??null;s==="word"&&(t.return_token_timestamps=!0);const m=pop(t,"language",null),d=pop(t,"task",null);if(m||d||s){if(t.forced_decoder_ids)throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");const w=this.tokenizer.get_decoder_prompt_ids({language:m,task:d,no_timestamps:!s});w.length>0&&(t.forced_decoder_ids=w)}const h=!Array.isArray(e);h&&(e=[e]);const i=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,r=this.processor.feature_extractor.config.hop_length,u=this.processor.feature_extractor.config.sampling_rate,f=await prepareAudios(e,u),g=[];for(const w of f){let y=[];if(a>0){if(_===null)_=a/6;else if(a<=_)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const T=u*a,E=u*_,A=T-2*E;let C=0;for(;C<w.length;){const I=w.subarray(C,C+T),D=await this.processor(I),R=C===0,Y=C+A>=w.length;y.push({stride:[I.length,R?0:E,Y?0:E],input_features:D.input_features,is_last:Y}),C+=A}}else y=[{stride:[w.length,0,0],input_features:(await this.processor(w)).input_features,is_last:!0}];for(const T of y){t.num_frames=Math.floor(T.stride[0]/r);const E=await this.model.generate(T.input_features,t);s==="word"?(T.tokens=E.sequences[0],T.token_timestamps=E.token_timestamps.tolist()[0].map(A=>round(A,2))):T.tokens=E[0],T.stride=T.stride.map(A=>A/u),c!==null&&c(T)}const[x,S]=this.tokenizer._decode_asr(y,{time_precision:i,return_timestamps:s,force_full_sequences:l});g.push({text:x,...S})}return h?g[0]:g}}class ImageToTextPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t={}){const s=Array.isArray(e),a=await prepareImages(e),{pixel_values:c}=await this.processor(a),l=[];for(const _ of c){_.dims=[1,..._.dims];const m=await this.model.generate(_,t),d=this.tokenizer.batch_decode(m,{skip_special_tokens:!0}).map(h=>({generated_text:h.trim()}));l.push(d)}return s?l:l[0]}}class ImageClassificationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{topk:t=1}={}){const s=Array.isArray(e),a=await prepareImages(e),{pixel_values:c}=await this.processor(a),l=await this.model({pixel_values:c}),_=this.model.config.id2label,m=[];for(const d of l.logits){const i=getTopItems(softmax(d.data),t).map(r=>({label:_[r[0]],score:r[1]}));t===1?m.push(...i):m.push(i)}return s||t===1?m:m[0]}}class ImageSegmentationPipeline extends Pipeline{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:s=.5,overlap_mask_area_threshold:a=.8,label_ids_to_fuse:c=null,target_sizes:l=null,subtask:_=null}={}){if(Array.isArray(e)&&e.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const d=await prepareImages(e),h=d.map(y=>[y.height,y.width]),{pixel_values:i,pixel_mask:r}=await this.processor(d),u=await this.model({pixel_values:i,pixel_mask:r});let f=null;if(_!==null)f=this.subtasks_mapping[_];else for(let[y,x]of Object.entries(this.subtasks_mapping))if(x in this.processor.feature_extractor){f=this.processor.feature_extractor[x].bind(this.processor.feature_extractor),_=y;break}const g=this.model.config.id2label,w=[];if(_==="panoptic"||_==="instance"){const y=f(u,t,s,a,c,l??h)[0],x=y.segmentation;for(const S of y.segments_info){const T=new Uint8ClampedArray(x.data.length);for(let A=0;A<x.data.length;++A)x.data[A]===S.id&&(T[A]=255);const E=new RawImage(T,x.dims[1],x.dims[0],1);w.push({score:S.score,label:g[S.label_id],mask:E})}}else if(_==="semantic"){const{segmentation:y,labels:x}=f(u,l??h)[0];for(const S of x){const T=new Uint8ClampedArray(y.data.length);for(let A=0;A<y.data.length;++A)y.data[A]===S&&(T[A]=255);const E=new RawImage(T,y.dims[1],y.dims[0],1);w.push({score:null,label:g[S],mask:E})}}else throw Error(`Subtask ${_} not supported.`);return w}}class ZeroShotImageClassificationPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t,{hypothesis_template:s="This is a photo of {}"}={}){const a=Array.isArray(e),c=await prepareImages(e),l=t.map(r=>s.replace("{}",r)),_=this.tokenizer(l,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:m}=await this.processor(c),d=await this.model({..._,pixel_values:m}),h=this.model.config.model_type==="siglip"?r=>r.sigmoid().data:r=>softmax(r.data),i=[];for(const r of d.logits_per_image){const f=[...h(r)].map((g,w)=>({score:g,label:t[w]}));f.sort((g,w)=>w.score-g.score),i.push(f)}return a?i:i[0]}}class ObjectDetectionPipeline extends Pipeline{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:s=!1}={}){const a=Array.isArray(e);if(a&&e.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const c=await prepareImages(e),l=s?null:c.map(u=>[u.height,u.width]),{pixel_values:_,pixel_mask:m}=await this.processor(c),d=await this.model({pixel_values:_,pixel_mask:m}),h=this.processor.feature_extractor.post_process_object_detection(d,t,l),i=this.model.config.id2label,r=h.map(u=>u.boxes.map((f,g)=>({score:u.scores[g],label:i[u.classes[g]],box:get_bounding_box(f,!s)})));return a?r:r[0]}}class ZeroShotObjectDetectionPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t,{threshold:s=.1,topk:a=null,percentage:c=!1}={}){const l=Array.isArray(e),_=await prepareImages(e),m=this.tokenizer(t,{padding:!0,truncation:!0}),d=await this.processor(_),h=[];for(let i=0;i<_.length;++i){const r=_[i],u=c?null:[[r.height,r.width]],f=d.pixel_values[i].unsqueeze_(0),g=await this.model({...m,pixel_values:f}),w=this.processor.feature_extractor.post_process_object_detection(g,s,u,!0)[0];let y=w.boxes.map((x,S)=>({score:w.scores[S],label:t[w.classes[S]],box:get_bounding_box(x,!c)})).sort((x,S)=>S.score-x.score);a!==null&&(y=y.slice(0,a)),h.push(y)}return l?h:h[0]}}class DocumentQuestionAnsweringPipeline extends Pipeline{constructor(e){super(e)}async _call(e,t,s={}){const a=(await prepareImages(e))[0],{pixel_values:c}=await this.processor(a),l=`<s_docvqa><s_question>${t}</s_question><s_answer>`,_=this.tokenizer(l,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,m=await this.model.generate(c,{...s,decoder_input_ids:_,max_length:this.model.config.decoder.max_position_embeddings}),h=this.tokenizer.batch_decode(m)[0].match(/<s_answer>(.*?)<\/s_answer>/);let i=null;return h&&h.length>=2&&(i=h[1].trim()),[{answer:i}]}}class TextToAudioPipeline extends Pipeline{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:s}=await this.model(t),a=this.model.config.sampling_rate;return{audio:s.data,sampling_rate:a}}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{quantized:!1})),(typeof t=="string"||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new Tensor("float32",t,[1,t.length]);else if(!(t instanceof Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:s}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:a}=await this.model.generate_speech(s,t,{vocoder:this.vocoder}),c=this.processor.feature_extractor.config.sampling_rate;return{audio:a.data,sampling_rate:c}}}class ImageToImagePipeline extends Pipeline{constructor(e){super(e)}async _call(e){const t=await prepareImages(e),s=await this.processor(t),a=await this.model(s),c=[];for(const l of a.reconstruction){const _=l.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");c.push(RawImage.fromTensor(_))}return c.length>1?c:c[0]}}class DepthEstimationPipeline extends Pipeline{constructor(e){super(e)}async _call(e){const t=await prepareImages(e),s=await this.processor(t),{predicted_depth:a}=await this.model(s),c=[];for(let l=0;l<t.length;++l){const _=interpolate(a[l],t[l].size.reverse(),"bilinear",!1),m=_.mul_(255/max(_.data)[0]).to("uint8");c.push({predicted_depth:a[l],depth:RawImage.fromTensor(m)})}return c.length>1?c:c[0]}}const SUPPORTED_TASKS=Object.freeze({"text-classification":{tokenizer:AutoTokenizer,pipeline:TextClassificationPipeline,model:AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:AutoTokenizer,pipeline:TokenClassificationPipeline,model:AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:AutoTokenizer,pipeline:QuestionAnsweringPipeline,model:AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:AutoTokenizer,pipeline:FillMaskPipeline,model:AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:AutoTokenizer,pipeline:SummarizationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:AutoTokenizer,pipeline:TranslationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:AutoTokenizer,pipeline:Text2TextGenerationPipeline,model:AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:AutoTokenizer,pipeline:TextGenerationPipeline,model:AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotClassificationPipeline,model:AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:AudioClassificationPipeline,model:AutoModelForAudioClassification,processor:AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotAudioClassificationPipeline,model:AutoModel,processor:AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:AutoTokenizer,pipeline:AutomaticSpeechRecognitionPipeline,model:[AutoModelForSpeechSeq2Seq,AutoModelForCTC],processor:AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:AutoTokenizer,pipeline:TextToAudioPipeline,model:[AutoModelForTextToWaveform,AutoModelForTextToSpectrogram],processor:[AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:AutoTokenizer,pipeline:ImageToTextPipeline,model:AutoModelForVision2Seq,processor:AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:ImageClassificationPipeline,model:AutoModelForImageClassification,processor:AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:ImageSegmentationPipeline,model:[AutoModelForImageSegmentation,AutoModelForSemanticSegmentation],processor:AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:AutoTokenizer,pipeline:ZeroShotImageClassificationPipeline,model:AutoModel,processor:AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:ObjectDetectionPipeline,model:AutoModelForObjectDetection,processor:AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:AutoTokenizer,pipeline:ZeroShotObjectDetectionPipeline,model:AutoModelForZeroShotObjectDetection,processor:AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:AutoTokenizer,pipeline:DocumentQuestionAnsweringPipeline,model:AutoModelForDocumentQuestionAnswering,processor:AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ImageToImagePipeline,model:AutoModelForImageToImage,processor:AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:DepthEstimationPipeline,model:AutoModelForDepthEstimation,processor:AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:AutoTokenizer,pipeline:FeatureExtractionPipeline,model:AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:AutoProcessor,pipeline:ImageFeatureExtractionPipeline,model:[AutoModelForImageFeatureExtraction,AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),TASK_ALIASES=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function pipeline(n,e=null,{quantized:t=!0,progress_callback:s=null,config:a=null,cache_dir:c=null,local_files_only:l=!1,revision:_="main",model_file_name:m=null}={}){n=TASK_ALIASES[n]??n;const d=SUPPORTED_TASKS[n.split("_",1)[0]];if(!d)throw Error(`Unsupported pipeline: ${n}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`);e||(e=d.default.model,console.log(`No model specified. Using default model: "${e}".`));const h={quantized:t,progress_callback:s,config:a,cache_dir:c,local_files_only:l,revision:_,model_file_name:m},i=new Map([["tokenizer",d.tokenizer],["model",d.model],["processor",d.processor]]),r=await loadItems(i,e,h);r.task=n,dispatchCallback(s,{status:"ready",task:n,model:e});const u=d.pipeline;return new u(r)}async function loadItems(n,e,t){const s=Object.create(null),a=[];for(let[c,l]of n.entries()){if(!l)continue;let _;Array.isArray(l)?_=new Promise(async(m,d)=>{let h;for(let i of l){if(i===null){m(null);return}try{m(await i.from_pretrained(e,t));return}catch(r){h=r}}d(h)}):_=l.from_pretrained(e,t),s[c]=_,a.push(_)}await Promise.all(a);for(let[c,l]of Object.entries(s))s[c]=await l;return s}env$1.localModelPath="/huggingface";const defaultModel="Xenova/all-MiniLM-L6-v2",pipePromise=await pipeline("feature-extraction",defaultModel),cosineSimilarity=(n,e)=>{const t=n.reduce((c,l,_)=>c+l*e[_],0),s=Math.sqrt(n.reduce((c,l)=>c+l*l,0)),a=Math.sqrt(e.reduce((c,l)=>c+l*l,0));return t/(s*a)},getEmbeddingFromText=async(n,e=defaultModel)=>{try{console.log("Starting embed");const s=await(await pipePromise)(n,{pooling:"mean",normalize:!0});return Array.from(s.data)}catch(t){console.error(t)}},binarizeVector=(n,e=null)=>{if(e===null){const t=[...n].sort((a,c)=>a-c),s=Math.floor(t.length/2);e=t.length%2===0?(t[s-1]+t[s])/2:t[s]}return n.map(t=>t>=e?1:0)},hammingDistance=(n,e)=>{if(n.length!==e.length)throw new Error("Vectors must be of the same length");n.length;const t=new BigUint64Array(n.buffer),s=new BigUint64Array(e.buffer);let a=0n;for(let c=0;c<t.length;c++){const l=t[c]^s[c];a+=BigInt(l.toString(2).replace(/0/g,"").length)}return Number(a)},wasmBase64="AGFzbQEAAAABDAJgAX8AYAN/f38BfwILAQNlbnYDbG9nAAADAgEBBQMBAAEHHQIGbWVtb3J5AgAQaGFtbWluZ19kaXN0YW5jZQABCoYBAYMBAQF/QQAhAwJAA0AgAkUEQAwCCyAAEAAgAyAA/QAEACAB/QAEAP1R/RsAaSAA/QAEACAB/QAEAP1R/RsBaSAA/QAEACAB/QAEAP1R/RsCaSAA/QAEACAB/QAEAP1R/RsDaWpqamohAyAAQRBqIQAgAUEQaiEBIAJBEGshAgwACwsgAwsAPQRuYW1lARgCAANsb2cBEGhhbW1pbmdfZGlzdGFuY2UCHAIAAAEEAARwdHJBAQRwdHJCAgNsZW4DBGRpc3Q=";function base64ToUint8Array(n){return typeof window<"u"?Uint8Array.from(atob(n),e=>e.charCodeAt(0)):Uint8Array.from(Buffer.from(n,"base64"))}async function loadWasm(){const n=base64ToUint8Array(wasmBase64),e=await WebAssembly.instantiate(n,{env:{memory:new WebAssembly.Memory({initial:1}),log:s=>console.log(`Processing pointer at offset: ${s}`)}}),t=e.instance.exports.memory||e.instance.exports.env.memory;if(!t)throw new Error("WebAssembly module does not export or provide memory.");return{...e.instance.exports,memory:t}}class EntityDB{constructor({vectorPath:e,model:t=defaultModel}){this.vectorPath=e,this.model=t,this.dbPromise=this._initDB()}async _initDB(){return await openDB("EntityDB",1,{upgrade(t){t.objectStoreNames.contains("vectors")||t.createObjectStore("vectors",{keyPath:"id",autoIncrement:!0})}})}async insert(e){try{let t=e[this.vectorPath];e.text&&(console.log("Attempting to embed"),t=await getEmbeddingFromText(e.text,this.model)),console.log("Final embedding",t);const c=(await this.dbPromise).transaction("vectors","readwrite").objectStore("vectors"),l={vector:t,...e};return await c.add(l)}catch(t){throw new Error(`Error inserting data: ${t}`)}}async insertBinary(e){try{let t=e[this.vectorPath];e.text&&(t=await getEmbeddingFromText(e.text,this.model));const s=binarizeVector(t),a=new BigUint64Array(new ArrayBuffer(Math.ceil(s.length/64)*8));for(let h=0;h<s.length;h++){const i=h%64,r=Math.floor(h/64);s[h]===1&&(a[r]|=1n<<BigInt(i))}const _=(await this.dbPromise).transaction("vectors","readwrite").objectStore("vectors"),m={vector:a,...e};return await _.add(m)}catch(t){throw new Error(`Error inserting binary data: ${t}`)}}async insertManualVectors(e){try{const a=(await this.dbPromise).transaction("vectors","readwrite").objectStore("vectors"),c={vector:e[this.vectorPath],...e};return await a.add(c)}catch(t){throw new Error(`Error inserting manual vectors: ${t}`)}}async update(e,t){const c=(await this.dbPromise).transaction("vectors","readwrite").objectStore("vectors"),l=t[this.vectorPath],_={...t,[c.keyPath]:e,vector:l};await c.put(_)}async delete(e){await(await this.dbPromise).transaction("vectors","readwrite").objectStore("vectors").delete(e)}async query(e,{limit:t=10}={}){try{const s=await getEmbeddingFromText(e,this.model),m=(await(await this.dbPromise).transaction("vectors","readonly").objectStore("vectors").getAll()).map(d=>{const h=cosineSimilarity(s,d.vector);return{...d,similarity:h}});return m.sort((d,h)=>h.similarity-d.similarity),m.slice(0,t)}catch(s){throw new Error(`Error querying vectors: ${s}`)}}async queryBinary(e,{limit:t=10}={}){try{const s=await getEmbeddingFromText(e,this.model),a=binarizeVector(s),c=new BigUint64Array(new ArrayBuffer(Math.ceil(a.length/64)*8));for(let i=0;i<a.length;i++){const r=i%64,u=Math.floor(i/64);a[i]===1&&(c[u]|=1n<<BigInt(r))}const h=(await(await this.dbPromise).transaction("vectors","readonly").objectStore("vectors").getAll()).map(i=>{const r=hammingDistance(c,i.vector);return{...i,distance:r}});return h.sort((i,r)=>i.distance-r.distance),h.slice(0,t)}catch(s){throw new Error(`Error querying binary vectors: ${s}`)}}async queryBinarySIMD(e,{limit:t=10}={}){try{const s=await getEmbeddingFromText(e,this.model),a=binarizeVector(s),c=new BigUint64Array(new ArrayBuffer(Math.ceil(a.length/64)*8));for(let g=0;g<a.length;g++){const w=g%64,y=Math.floor(g/64);a[g]===1&&(c[y]|=1n<<BigInt(w))}console.log("Query Vector (binary):",[...c].map(g=>g.toString(2)));const d=await(await this.dbPromise).transaction("vectors","readonly").objectStore("vectors").getAll();d.forEach((g,w)=>{console.log(`DB Vector ${w} (binary):`,[...new BigUint64Array(g.vector.buffer)].map(y=>y.toString(2)))});const h=await loadWasm(),{hamming_distance:i,memory:r}=h;if(!r)throw new Error("WebAssembly memory is undefined.");const u=new Uint8Array(r.buffer);u.set(new Uint8Array(c.buffer),0);const f=d.map(g=>{const w=new Uint8Array(g.vector.buffer);u.set(w,16);const y=i(0,16,c.length*8);return{...g,distance:y}});return f.sort((g,w)=>g.distance-w.distance),f.slice(0,t)}catch(s){throw console.error("Error querying binary vectors:",s),s}}async queryManualVectors(e,{limit:t=10}={}){try{const _=(await(await this.dbPromise).transaction("vectors","readonly").objectStore("vectors").getAll()).map(m=>{const d=cosineSimilarity(e,m.vector);return{...m,similarity:d}});return _.sort((m,d)=>d.similarity-m.similarity),_.slice(0,t)}catch(s){throw new Error(`Error querying manual vectors: ${s}`)}}}function App(){const[n,e]=reactExports.useState("requesting-permission"),[t,s]=reactExports.useState(null),[a,c]=reactExports.useState(!1),l=reactExports.useRef(null),_=new EntityDB({vectorPath:"customDB"}),m=reactExports.useCallback(f=>{s(f),e("welcome")},[]),d=reactExports.useCallback(()=>{e("loading")},[]),h=reactExports.useCallback(()=>{e("captioning")},[]),i=reactExports.useCallback(async f=>{try{await f.play()}catch(g){console.error("Failed to play video:",g)}},[]),r=reactExports.useCallback((f,g)=>{f.srcObject=g;const w=()=>{c(!0),i(f)};return f.addEventListener("canplay",w,{once:!0}),()=>{f.removeEventListener("canplay",w)}},[i]);reactExports.useEffect(()=>{if(t&&l.current){const f=l.current;return f.srcObject=null,f.load(),r(f,t)}},[t,r]);const u=reactExports.useMemo(()=>{switch(n){case"requesting-permission":return"blur(20px) brightness(0.2) saturate(0.5)";case"welcome":return"blur(12px) brightness(0.3) saturate(0.7)";case"loading":return"blur(8px) brightness(0.4) saturate(0.8)";case"captioning":return"none";default:return"blur(20px) brightness(0.2) saturate(0.5)"}},[n]);return jsxRuntimeExports.jsxs("div",{className:"App relative h-screen overflow-hidden",children:[jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gray-900"}),t&&jsxRuntimeExports.jsx("video",{ref:l,autoPlay:!0,muted:!0,playsInline:!0,className:"absolute inset-0 w-full h-full object-cover transition-all duration-1000 ease-out",style:{filter:u,opacity:a?1:0}}),n!=="captioning"&&jsxRuntimeExports.jsx("div",{className:"absolute inset-0 bg-gray-900/80 backdrop-blur-sm"}),n==="requesting-permission"&&jsxRuntimeExports.jsx(WebcamPermissionDialog,{onPermissionGranted:m}),n==="welcome"&&jsxRuntimeExports.jsx(WelcomeScreen,{onStart:d}),n==="loading"&&jsxRuntimeExports.jsx(LoadingScreen,{onComplete:h}),n==="captioning"&&jsxRuntimeExports.jsx(CaptioningView,{videoRef:l,db:_})]})}ReactDOM.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(VLMProvider,{children:jsxRuntimeExports.jsx(App,{})})}));
